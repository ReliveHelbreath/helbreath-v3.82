// Game.cpp: implementation of the CGame class.
//
//////////////////////////////////////////////////////////////////////

#include "Game.h"

class CDebugWindow *DbgWnd;

extern void PutLogList(char * cMsg);
//extern char G_cTxt[512];
extern char G_cTxt[1024];
extern char	G_cData50000[50000];

extern void PutLogFileList(char * cStr);
extern void PutAdminLogFileList(char * cStr);
extern void PutItemLogFileList(char * cStr); // SNOOPY: Corrected calls to this one
extern void PutLogEventFileList(char * cStr);
extern void PutHackLogFileList(char * cStr);
extern void PutPvPLogFileList(char * cStr);
extern void PutPartyLogFileList(char * cStr);
extern void PutSkillLogFileList(char * cStr);

/* // Information above all Logs
PutLogFileList(G_cTxt);		   // GameLogs\Events.log			Log mics events
PutAdminLogFileList(G_cTxt);   // GameLogs\AdminEvents.log		Log Admins orders
PutGServerLogFileList		   // GameLogs\GServer2050131.log	Copy of gserver window messages
PutHackLogFileList(G_cTxt);    // GameLogs\HackEvents.log		Log Hackers
PutPvPLogFileList(G_cTxt);     // GameLogs\PvPEvents.log		Log Player deaths/resurections
PutItemLogFileList(G_cTxt);	   // GameLogs\ItemEvents.log		Log special items actions	
PutLogEventFileList(G_cTxt);   // GameLogs\InGameEvents.log		Log Arenas/Crusade/Heldenian MiscOrganizedEvents related events
PutPartyLogFileList(G_cTxt);   // GameLogs\PartyEvents.log		Log Party related events
PutSkillLogFileList(G_cTxt);   // GameLogs\SkillEvents.log		Log Farming, Manuf, Alchim
PutMonitorLogFileList(G_cTxt); // GameLogs\Monitoring.log       Monitor a character on GM command
*/
// extern void PutDebugMsg(char * cStr);	// 2002-09-09 #2

extern FILE * pLogFile;
extern HWND	G_hWnd;

// 
int _tmp_iMoveLocX[9][37] = {
	 // 0
	{0,0,0,0,0,0,0,0,0,0,
	 0,0,0,0,0,0,0,0,0,0,
	 0,0,0,0,0,0,0,0,0,0,
	 0,0,0,0,0,0,0},
	// 1
	{0,1,2,3,4,5,6,7,8,9,
	 10,11,12,13,14,15,16,17,18,19,
	 20,-1,0,0,0,0,0,0,0,0,
	 0,0,0,0,0,0,0},
	//2
	{0,1,2,3,4,5,6,7,8,9,
	 10,11,12,13,14,15,16,17,18,19,
	 20,20,20,20,20,20,20,20,20,20,
	 20,20,20,20,20,20,-1},
	//3
	{20,20,20,20,20,20,20,20,20,20,
	 20,20,20,20,20,20,-1,0,0,0,
	 0,0,0,0,0,0,0,0,0,0,
	 0,0,0,0,0,0,0},
	//4
	{20,20,20,20,20,20,20,20,20,20,
	 20,20,20,20,20,20,19,18,17,16,
	 15,14,13,12,11,10,9,8,7,6,
	 5,4,3,2,1,0,-1},
	//5
	{0,1,2,3,4,5,6,7,8,9,
	 10,11,12,13,14,15,16,17,18,19,
	 20,-1,0,0,0,0,0,0,0,0,
	 0,0,0,0,0,0,0},
	//6
	{0,0,0,0,0,0,0,0,0,0,
	 0,0,0,0,0,0,1,2,3,4,
	 5,6,7,8,9,10,11,12,13,14,
	 15,16,17,18,19,20,-1},
	//7
	{0,0,0,0,0,0,0,0,0,0,
	 0,0,0,0,0,0,-1,0,0,0,
	 0,0,0,0,0,0,0,0,0,0,
	 0,0,0,0,0,0,0},
	//8
	{0,0,0,0,0,0,0,0,0,0,
	 0,0,0,0,0,0,1,2,3,4,
	 5,6,7,8,9,10,11,12,13,14,
	 15,16,17,18,19,20,-1}
};

int _tmp_iMoveLocY[9][37] = {
	// 0
	{0,0,0,0,0,0,0,0,0,0,
	 0,0,0,0,0,0,0,0,0,0,
	 0,0,0,0,0,0,0,0,0,0,
	 0,0,0,0,0,0,0},
	//1
	{0,0,0,0,0,0,0,0,0,0,
	 0,0,0,0,0,0,0,0,0,0,
	 0,-1,0,0,0,0,0,0,0,0,
	 0,0,0,0,0,0,0},
	//2
	{0,0,0,0,0,0,0,0,0,0,
	 0,0,0,0,0,0,0,0,0,0,
	 0,1,2,3,4,5,6,7,8,9,
	 10,11,12,13,14,15,-1},
	//3
	{0,1,2,3,4,5,6,7,8,9,
	 10,11,12,13,14,15,-1,0,0,0,
	 0,0,0,0,0,0,0,0,0,0,
	 0,0,0,0,0,0,0},
	//4
	{0,1,2,3,4,5,6,7,8,9,
	 10,11,12,13,14,15,15,15,15,15,
	 15,15,15,15,15,15,15,15,15,15,
	 15,15,15,15,15,15,-1},
	//5
	{15,15,15,15,15,15,15,15,15,15,
	 15,15,15,15,15,15,15,15,15,15,
	 15,-1,0,0,0,0,0,0,0,0,
	 0,0,0,0,0,0,0},
	//6
	{0,1,2,3,4,5,6,7,8,9,
	 10,11,12,13,14,15,15,15,15,15,
	 15,15,15,15,15,15,15,15,15,15,
	 15,15,15,15,15,15,-1},
	//7
	{0,1,2,3,4,5,6,7,8,9,
	 10,11,12,13,14,15,-1,0,0,0,
	 0,0,0,0,0,0,0,0,0,0,
	 0,0,0,0,0,0,0},
	// 8
	{15,14,13,12,11,10,9,8,7,6,
	 5,4,3,2,1,0,0,0,0,0,
	 0,0,0,0,0,0,0,0,0,0,
	 0,0,0,0,0,0,-1}
};

char _tmp_cTmpDirX[9] = { 0,0,1,1,1,0,-1,-1,-1 };
char _tmp_cTmpDirY[9] = { 0,-1,-1,0,1,1,1,0,-1 };

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

extern BOOL	G_bIsThread;
//extern void ThreadProc(void *ch); // Fix for bumps
extern unsigned __stdcall  ThreadProc(void *ch);

CGame::CGame(HWND hWnd)
{
 int i, x;
	
	m_bIsGameStarted = FALSE;
	m_hWnd           = hWnd;
	m_pMainLogSock   = NULL;
	m_pGateSock      = NULL;
	m_bIsLogSockAvailable   = FALSE;
	m_bIsGateSockAvailable  = FALSE;
	m_bIsItemAvailable      = FALSE;
	m_bIsBuildItemAvailable = FALSE;
	m_bIsNpcAvailable       = FALSE;
	m_bIsMagicAvailable     = FALSE;
	m_bIsSkillAvailable     = FALSE;
	m_bIsQuestAvailable     = FALSE;
	m_bIsPortionAvailable   = FALSE;

	ZeroMemory(m_cServerName, sizeof(m_cServerName));

	m_iPlayerMaxLevel = DEF_PLAYERMAXLEVEL;
	m_sAbsoluteMaxPlayerLevel = DEF_PLAYERMAXLEVEL;
	m_sEvilMaxPlayerLevel = DEF_PLAYERMAXLEVEL - 10;
	m_dwBuildDate = DEF_BUILDDATE;


	// SNOOPY: Added initialisation here
	m_bManualTime = FALSE;
	
	for (i = 0; i < DEF_MAXCLIENTS; i++)
		m_pClientList[i] = NULL;

	for (i = 0; i < DEF_MAXMAPS; i++)
		m_pMapList[i] = NULL;

	for (i = 0; i < DEF_MAXITEMTYPES; i++)
		m_pItemConfigList[i] = NULL;

	for (i = 0; i < DEF_MAXNPCTYPES; i++)
		m_pNpcConfigList[i] = NULL;

	for (i = 0; i < DEF_MAXNPCS; i++)
		m_pNpcList[i] = NULL;

	for (i = 0; i < DEF_MSGQUENESIZE; i++)
		m_pMsgQuene[i] = NULL;

	for (i = 0; i < DEF_MAXMAGICTYPE; i++)
		m_pMagicConfigList[i] = NULL;

	for (i = 0; i < DEF_MAXSKILLTYPE; i++)
		m_pSkillConfigList[i] = NULL;

	for (i = 0; i < DEF_MAXQUESTTYPE; i++)
		m_pQuestConfigList[i] = NULL;
	
	for (i = 0; i < DEF_MAXDYNAMICOBJECTS; i++)
		m_pDynamicObjectList[i] = NULL;

	for (i = 0; i < DEF_MAXDELAYEVENTS; i++)
		m_pDelayEventList[i] = NULL;

	for (i = 0; i < DEF_MAXNOTIFYMSGS; i++)
		m_pNoticeMsgList[i] = NULL;

	for (i = 0; i < DEF_MAXFISHS; i++)
		m_pFish[i] = NULL;

	for (i = 0; i < DEF_MAXMINERALS; i++)
		m_pMineral[i] = NULL;

	for (i = 0; i < DEF_MAXPORTIONTYPES; i++)
	{	m_pPortionConfigList[i] = NULL;	
		m_pCraftingConfigList[i] = NULL;// Crafting
	}
	for (i = 0; i <  DEF_MAXTELEPORTLIST; i++)
		m_pTeleportConfigList[i] = NULL;

	for (i = 0; i < DEF_MAXSUBLOGSOCK; i++) 
	{	m_pSubLogSock[i] = NULL;
		m_bIsSubLogSockAvailable[i] = FALSE;
		m_bIsSubLogSockInitialPointer[i] = 0;// Snoopy
	}

	for (i = 0; i < DEF_MAXBUILDITEMS; i++) 
		m_pBuildItemList[i] = NULL;

	for (i = 0; i < DEF_MAXDUPITEMID; i++)
		m_pDupItemIDList[i] = NULL;

	// New 06/05/2004
	for (i = 0; i < DEF_MAXCLIENTS; i++) {
		m_stPartyInfo[i].iTotalMembers = 0;
		for(x = 0; x < DEF_MAXPARTYMEMBERS; x++)
			m_stPartyInfo[i].iIndex[x] = 0;
	}

	m_iQueneHead = 0;
	m_iQueneTail = 0;

	m_iTotalClients = 0;
	m_iMaxClients   = 0;
	m_iTotalMaps    = 0;

	m_iTotalGameServerClients    = 0;
	m_iTotalGameServerMaxClients = 0;

	m_MaxUserSysTime.wHour   = 0;
	m_MaxUserSysTime.wMinute = 0;

	m_bIsServerShutdowned = FALSE;
	m_cShutDownCode = 0;

	m_iMiddlelandMapIndex = -1;

	// Avatar
	m_iPLmapIndex= -1;

	m_iAresdenOccupyTiles = 0;
	m_iElvineOccupyTiles  = 0;

	m_iCurMsgs = 0;
	m_iMaxMsgs = 0;

	for (i = 0; i < DEF_MAXSIDES; i++) { // more than 3 sides
		m_stCityStatus[i].iCrimes = 0;
		m_stCityStatus[i].iFunds  = 0;
		m_stCityStatus[i].iWins   = 0;
	}
	m_iAutoRebootingCount	= 0;
	m_bEnemyKillMode		= FALSE; 
	m_iEnemyKillAdjust      = 1; 
	m_bAdminSecurity		= TRUE; 
	m_sRaidTimeMonday		= 0; 
	m_sRaidTimeTuesday      = 0; 
	m_sRaidTimeWednesday	= 0; 
	m_sRaidTimeThursday     = 0; 
	m_sRaidTimeFriday		= 0; 
	m_sRaidTimeSaturday     = 0; 
	m_sRaidTimeSunday		= 0;
	m_sCharPointLimit		= 0;
	m_sSlateSuccessRate		= 0;
	// New settings by SNOOPY: Default to standard HB mode
	m_bMapModeEquilibrium	= FALSE;
	m_bMapModeEquilibriumChanged = FALSE;
	m_bPVPHPMode			= FALSE;
	// Normal settings to show player activity on server window, FALSE will show player nb by cities.
	bShowActivity			= TRUE;
	m_dwHeldenianWarTime	= 15*60*1000;  // 15 minutes before effective War start
	m_dwHeldenianEndTime	= 105*60*1000; // 90 minutes effective battle
	m_cHeldenianSummonMode  = -1;
	
	m_bReceivedItemList = FALSE;
}

CGame::~CGame()
{
	//DbgWnd->Shutdown();
	//delete DbgWnd;
}

BOOL CGame::bAcceptPing(class XSocket * pXSock)
{
	//G_pGame->bAccept(G_pPingSock);
	char  cIPaddress[21];
	ZeroMemory(cIPaddress, sizeof(cIPaddress));
	class XSocket * pTmpSock;
	pTmpSock = new class XSocket(m_hWnd, DEF_SERVERSOCKETBLOCKLIMIT);
	pXSock->bAccept(pTmpSock, NULL); 
	pTmpSock->iGetPeerAddress(cIPaddress);
	wsprintf(G_cTxt,"Ping PatchIP: (%s)", cIPaddress);
	PutLogList(G_cTxt); 

	delete pTmpSock;
	return FALSE;
}

BOOL CGame::bAccept(class XSocket * pXSock)
{register int i;
 class XSocket * pTmpSock;

	if ((m_bIsGateSockAvailable == FALSE)  || (m_bIsLogSockAvailable == FALSE)   || 
		(m_bIsItemAvailable == FALSE)      || (m_bIsNpcAvailable == FALSE)       || 
		(m_bIsMagicAvailable == FALSE)     || (m_bIsSkillAvailable == FALSE)     || 
		(m_bIsPortionAvailable == FALSE)   || (m_bOnExitProcess == TRUE)         || 
		(m_bIsQuestAvailable == FALSE)     || (m_bIsBuildItemAvailable == FALSE) || 
		(m_bIsGameStarted == FALSE))
		goto CLOSE_ANYWAY;

	for (i = 1; i < DEF_MAXCLIENTS; i++)
	if (m_pClientList[i] == NULL) {		
		m_pClientList[i] = new class CClient(m_hWnd);
		bAddClientShortCut(i);
		m_pClientList[i]->m_dwSPTime		= m_pClientList[i]->m_dwMPTime = 
		m_pClientList[i]->m_dwHPTime		= m_pClientList[i]->m_dwAutoSaveTime = 
		m_pClientList[i]->m_dwTime			= m_pClientList[i]->m_dwHungerTime = 
		m_pClientList[i]->m_dwExpStockTime	= m_pClientList[i]->m_dwRecentAttackTime = 
		m_pClientList[i]->m_dwAutoExpTime	= m_pClientList[i]->m_dwXPHackCheckTime = timeGetTime();		
		pXSock->bAccept(m_pClientList[i]->m_pXSock, WM_ONCLIENTSOCKETEVENT + i); 	
		// SNOOPY: That's the reason  for using iGetPeerAddress in some places 
		ZeroMemory(m_pClientList[i]->m_cIPaddress, sizeof(m_pClientList[i]->m_cIPaddress));
		m_pClientList[i]->m_pXSock->iGetPeerAddress(m_pClientList[i]->m_cIPaddress);		
		wsprintf(G_cTxt,"<%d> Client Connected : (%s)", i, m_pClientList[i]->m_cIPaddress);
		PutLogList(G_cTxt);
		m_iTotalClients++;
		if (m_iTotalClients > m_iMaxClients)  
		{	m_iMaxClients = m_iTotalClients;
		}
		return TRUE;
	}

CLOSE_ANYWAY:;	pTmpSock = new class XSocket(m_hWnd, DEF_SERVERSOCKETBLOCKLIMIT);
	pXSock->bAccept(pTmpSock, NULL); 
	delete pTmpSock;
	return FALSE;
}

void CGame::OnClientSocketEvent(UINT message, WPARAM wParam, LPARAM lParam)
{	UINT iTmp;
	register int iClientH, iRet;
	DWORD dwTime = timeGetTime();	
	iTmp = WM_ONCLIENTSOCKETEVENT;
	iClientH = (int) (message - iTmp);
// SNOOPY: Trying to trap 004030B6 error
// 004030D0  |> 8B4D F4        MOV ECX,DWORD PTR SS:[EBP-C]
// 004030D3  |. 8B55 FC        MOV EDX,DWORD PTR SS:[EBP-4]
// 004030D6  |. 837C8A 7C 00   CMP DWORD PTR DS:[EDX+ECX*4+7C],0
// 004030DB  |. 75 05          JNZ SHORT HGserver.004030E2
// 004030DD  |. E9 AB020000    JMP HGserver.0040338D
// 004030E2  |> 8B45 10        MOV EAX,DWORD PTR SS:[EBP+10]
	if (iClientH <= 0) return;	
	if (m_pClientList[iClientH] == NULL) return;
	iRet = m_pClientList[iClientH]->m_pXSock->iOnSocketEvent(wParam, lParam);
	switch (iRet) {
	case DEF_XSOCKEVENT_UNKNOWN:
		wsprintf(G_cTxt,"(???C) <%d> DEF_XSOCKEVENT_UNKNOWN (%s) \tIP(%s)", iClientH, m_pClientList[iClientH]->m_cCharName, m_pClientList[iClientH]->m_cIPaddress);
		PutLogList(G_cTxt);
		break;
	case DEF_XSOCKEVENT_READCOMPLETE:
		m_pClientList[iClientH]->m_dwTime = dwTime;
		OnClientRead(iClientH, dwTime);
		break;	
	case DEF_XSOCKEVENT_BLOCK:
		PutLogList("Socket BLOCKED!");
		break;	
	case DEF_XSOCKEVENT_CONFIRMCODENOTMATCH:
		wsprintf(G_cTxt,"<%d> Confirmcode notmatch!", iClientH);
		PutLogList(G_cTxt);
		DeleteClient(iClientH, FALSE, TRUE);
		break;
// Snoopy: Fixed here, starnge values (1000 & not 10000) and m_dwLastDamageTime was not set  everywhere needed
//         Detailled here...
	case DEF_XSOCKEVENT_MSGSIZETOOLARGE:		
		wsprintf(G_cTxt,"<%d> Client Disconn.  : (%s)  DEF_XSOCKEVENT_MSGSIZETOOLARGE", iClientH, m_pClientList[iClientH]->m_cIPaddress);
		PutLogList(G_cTxt); 
		if (   ((dwTime - m_pClientList[iClientH]->m_dwLastDamageTime) > 800)
			&& ((dwTime - m_pClientList[iClientH]->m_dwLastDamageTime) < 10000)) 
		{	wsprintf(G_cTxt, "Logout hack:       PC(%s) (%4d) - Disconnected within 10 seconds of most recent damage(LARGE). \tIP(%s)"
				, m_pClientList[iClientH]->m_cCharName
				, (dwTime - m_pClientList[iClientH]->m_dwLastDamageTime)
				, m_pClientList[iClientH]->m_cIPaddress);
			PutHackLogFileList(G_cTxt);
		}
		DeleteClient(iClientH, TRUE, TRUE);
		break;
	case DEF_XSOCKEVENT_SOCKETERROR:		
		wsprintf(G_cTxt,"<%d> Client Disconn.  : (%s)  DEF_XSOCKEVENT_SOCKETERROR", iClientH, m_pClientList[iClientH]->m_cIPaddress);
		PutLogList(G_cTxt); 
		if (   ((dwTime - m_pClientList[iClientH]->m_dwLastDamageTime) > 800)
			&& ((dwTime - m_pClientList[iClientH]->m_dwLastDamageTime) < 10000)) 
		{	wsprintf(G_cTxt, "Logout hack:       PC(%s) (%4d) - Disconnected within 10 seconds of most recent damage(ERROR). \tIP(%s)"
				, m_pClientList[iClientH]->m_cCharName
				, (dwTime - m_pClientList[iClientH]->m_dwLastDamageTime)
				, m_pClientList[iClientH]->m_cIPaddress);
			PutHackLogFileList(G_cTxt);
		}
		DeleteClient(iClientH, TRUE, TRUE);
		break;
	case DEF_XSOCKEVENT_SOCKETCLOSED:		
		if (m_pClientList[iClientH]->m_bIsOnWaitingProcess == FALSE) // When client TPs, is not a real deco hack
		{	wsprintf(G_cTxt,"<%d> Client Disconn.  : (%s)", iClientH, m_pClientList[iClientH]->m_cIPaddress);
			PutLogList(G_cTxt); 
			if (   ((dwTime - m_pClientList[iClientH]->m_dwLastDamageTime) > 800)
				&& ((dwTime - m_pClientList[iClientH]->m_dwLastDamageTime) < 10000)) 
			{	wsprintf(G_cTxt, "Logout hack:       PC(%s) (%4d) - Disconnected within 10 seconds of most recent damage(CLOSED) (Delayed). \tIP(%s)"
					, m_pClientList[iClientH]->m_cCharName
					, (dwTime - m_pClientList[iClientH]->m_dwLastDamageTime)
					, m_pClientList[iClientH]->m_cIPaddress);
				PutHackLogFileList(G_cTxt);
				DelayedDeleteClient(iClientH, TRUE, TRUE);
			}else DeleteClient(iClientH, TRUE, TRUE);
		}else
		{	DeleteClient(iClientH, TRUE, TRUE);
		}
		break;
	}													    
}

int ShowExceptionDlg()
{	PutLogList("(!) EXCEPTION...continuing...");		
	return 1;
}
//#include <afx.h>
//#include <afxinet.h>

BOOL CGame::bInit()		   
{
 char * cp, cTxt[120];
 DWORD * dwp;
 WORD * wp;
 int  i;
 SYSTEMTIME SysTime;
 DWORD dwTime = timeGetTime();	//m_Misc.Temp();
	PutLogList("(!) INITIALIZING GAME SERVER...");
	for (i = 0; i < DEF_MAXCLIENTS+1; i++)
		m_iClientShortCut[i] = 0;
	if (m_pMainLogSock != NULL) delete m_pMainLogSock;
	if (m_pGateSock != NULL) delete m_pGateSock;
	
	for (i = 0; i < DEF_MAXSUBLOGSOCK; i++)	
	{	if (m_pSubLogSock[i] != NULL) 
		{	if (m_bIsSubLogSockAvailable[i] == FALSE) // Snoopy			
			{	wsprintf(G_cTxt,"Forgetting Socket(%d) (Not available) (binit) Pointer: %d - %d,", i,(int)m_pSubLogSock[i], m_bIsSubLogSockInitialPointer[i]);
				PutLogList(G_cTxt); 
			}else // Snoopy: test for valid pointer...
			{	if (m_bIsSubLogSockInitialPointer[i] != (int)m_pSubLogSock[i])
				{	wsprintf(G_cTxt,"Forgetting Socket(%d) (Just crashed) (binit) Pointer: %d - %d,", i,(int)m_pSubLogSock[i], m_bIsSubLogSockInitialPointer[i]);
					PutLogList(G_cTxt); 			
				}else
				{	wsprintf(G_cTxt,"Closing Socket(%d) (Was available) (binit) Pointer: %d - %d,", i,(int)m_pSubLogSock[i], m_bIsSubLogSockInitialPointer[i]);
					PutLogList(G_cTxt); 				
					try
					{	delete m_pSubLogSock[i]; // n°5 = EXCEPTION_ACCESS_VIOLATION
					}
					catch(int e) 
					{	wsprintf(G_cTxt,"Closing Socket(%d) CRASHED Exception code: %d ", i, e);
						PutLogList(G_cTxt); 
						Sleep(5000);
			}	}	}
			m_bIsSubLogSockInitialPointer[i] = 0;
			m_bIsSubLogSockAvailable[i] = FALSE;
	}	}
	PutLogList("Closed all Sockets..."); 

	for (i = 0; i < DEF_MAXCLIENTS; i++)
	if (m_pClientList[i] != NULL) delete m_pClientList[i];
	for (i = 0; i < DEF_MAXNPCS; i++)
	if (m_pNpcList[i] != NULL) delete m_pNpcList[i];
	for (i = 0; i < DEF_MAXMAPS; i++)
	if (m_pMapList[i] != NULL) delete m_pMapList[i];
	for (i = 0; i < DEF_MAXITEMTYPES; i++)
	if (m_pItemConfigList[i] != NULL) delete m_pItemConfigList[i];
	for (i = 0; i < DEF_MAXNPCTYPES; i++)
	if (m_pNpcConfigList[i] != NULL) delete m_pNpcConfigList[i];
	for (i = 0; i < DEF_MAXMAGICTYPE; i++)
	if (m_pMagicConfigList[i] != NULL) delete m_pMagicConfigList[i];
	for (i = 0; i < DEF_MAXSKILLTYPE; i++)
	if (m_pSkillConfigList[i] != NULL) delete m_pSkillConfigList[i];
	for (i = 0; i < DEF_MAXQUESTTYPE; i++)
	if (m_pQuestConfigList[i] != NULL) delete m_pQuestConfigList[i];
	for (i = 0; i < DEF_MAXDYNAMICOBJECTS; i++)
	if (m_pDynamicObjectList[i] != NULL) delete m_pDynamicObjectList[i];
	for (i = 0; i < DEF_MAXDELAYEVENTS; i++)
	if (m_pDelayEventList[i] != NULL) delete m_pDelayEventList[i];
	for (i = 0; i < DEF_MAXNOTIFYMSGS; i++)
	if (m_pNoticeMsgList[i] != NULL) delete m_pNoticeMsgList[i];
	for (i = 0; i < DEF_MAXFISHS; i++)
	if (m_pFish[i] != NULL) delete m_pFish[i];
	for (i = 0; i < DEF_MAXMINERALS; i++)
	if (m_pMineral[i] != NULL) delete m_pMineral[i];
	for (i = 0; i < DEF_MAXPORTIONTYPES; i++)
	{	if (m_pPortionConfigList[i] != NULL) delete m_pPortionConfigList[i];
		if (m_pCraftingConfigList[i] != NULL) delete m_pCraftingConfigList[i];	// Crafting
	}
	for (i = 0; i <  DEF_MAXTELEPORTLIST; i++)
	if (m_pTeleportConfigList[i] != NULL) delete m_pTeleportConfigList[i];
	for (i = 0; i < DEF_MAXBUILDITEMS; i++) 
	if (m_pBuildItemList[i] != NULL) delete m_pBuildItemList[i];
	for (i = 0; i < DEF_MAXNPCTYPES; i++)
		m_iNpcConstructionPoint[i] = NULL;
	// Remember erazed clients
	for (i = 0; i < DEF_MAXCLIENTS; i++) {
		m_stOldClientList[i].iClientH = 0;
		ZeroMemory(m_stOldClientList[i].m_cCharName, sizeof(m_stOldClientList[i].m_cCharName));
		ZeroMemory(m_stOldClientList[i].m_cAccountName, sizeof(m_stOldClientList[i].m_cAccountName));
		ZeroMemory(m_stOldClientList[i].m_cAccountPassword, sizeof(m_stOldClientList[i].m_cAccountPassword));
		m_stOldClientList[i].m_dwDeleteTime = 0;
	}
	for (i = 0; i < DEF_MAXSCHEDULE; i++) {
		m_stCrusadeWarSchedule[i].iDay = -1;
		m_stCrusadeWarSchedule[i].iHour = -1;
		m_stCrusadeWarSchedule[i].iMinute = -1;
	}	
	for (i = 0; i < DEF_MAXAPOCALYPSE; i++) {
		m_stApocalypseScheduleStart[i].iDay = -1;
		m_stApocalypseScheduleStart[i].iHour = -1;
		m_stApocalypseScheduleStart[i].iMinute = -1;
	}
	for (i = 0; i < DEF_MAXAPOCALYPSE; i++) {
		m_stApocalypseScheduleEnd[i].iDay = -1;
		m_stApocalypseScheduleEnd[i].iHour = -1;
		m_stApocalypseScheduleEnd[i].iMinute = -1;
	}	
	for (i = 0; i < DEF_MAXHELDENIAN; i++) {
		m_stHeldenianSchedule[i].iDay = -1;
		m_stHeldenianSchedule[i].StartiHour = -1;
		m_stHeldenianSchedule[i].StartiMinute = -1;
		m_stHeldenianSchedule[i].EndiHour = -1;
		m_stHeldenianSchedule[i].EndiMinute = -1;
	}
	m_iNpcConstructionPoint[1]  = 100; // MS
	m_iNpcConstructionPoint[2]  = 100; // MS
	m_iNpcConstructionPoint[3]  = 100; // MS
	m_iNpcConstructionPoint[4]  = 100; // MS
	m_iNpcConstructionPoint[5]  = 100; // MS
	m_iNpcConstructionPoint[6]  = 100; // MS		
	m_iNpcConstructionPoint[43] = 1000; // LWB
	m_iNpcConstructionPoint[44] = 2000; // GHK
	m_iNpcConstructionPoint[45] = 3000; // GHKABS
	m_iNpcConstructionPoint[46] = 2000; // TK
	m_iNpcConstructionPoint[47] = 3000; // BG
	m_iNpcConstructionPoint[51] = 1500; // Catapult
	m_bIsGameStarted = FALSE;
	m_pMainLogSock  = NULL;
	m_pGateSock = NULL;
	m_bIsLogSockAvailable   = FALSE;
	m_bIsGateSockAvailable  = FALSE;
	m_bIsItemAvailable      = FALSE;
	m_bIsBuildItemAvailable = FALSE;
	m_bIsNpcAvailable       = FALSE;
	m_bIsMagicAvailable     = FALSE;
	m_bIsSkillAvailable     = FALSE;
	m_bIsQuestAvailable     = FALSE;
	m_bIsPortionAvailable   = FALSE;
	ZeroMemory(m_cServerName, sizeof(m_cServerName));	
	for (i = 0; i < DEF_MAXCLIENTS; i++)
		m_pClientList[i] = NULL;
	for (i = 0; i < DEF_MAXMAPS; i++)
		m_pMapList[i] = NULL;
	for (i = 0; i < DEF_MAXITEMTYPES; i++)
		m_pItemConfigList[i] = NULL;
	for (i = 0; i < DEF_MAXNPCTYPES; i++)
		m_pNpcConfigList[i] = NULL;
	for (i = 0; i < DEF_MAXNPCS; i++)
		m_pNpcList[i] = NULL;
	for (i = 0; i < DEF_MSGQUENESIZE; i++)
		m_pMsgQuene[i] = NULL;
	for (i = 0; i < DEF_MAXMAGICTYPE; i++)
		m_pMagicConfigList[i] = NULL;
	for (i = 0; i < DEF_MAXSKILLTYPE; i++)
		m_pSkillConfigList[i] = NULL;
	for (i = 0; i < DEF_MAXQUESTTYPE; i++)
		m_pQuestConfigList[i] = NULL;	
	for (i = 0; i < DEF_MAXDYNAMICOBJECTS; i++)
		m_pDynamicObjectList[i] = NULL;
	for (i = 0; i < DEF_MAXDELAYEVENTS; i++)
		m_pDelayEventList[i] = NULL;
	for (i = 0; i < DEF_MAXNOTIFYMSGS; i++)
		m_pNoticeMsgList[i] = NULL;
	for (i = 0; i < DEF_MAXFISHS; i++)
		m_pFish[i] = NULL;
	for (i = 0; i < DEF_MAXMINERALS; i++)
		m_pMineral[i] = NULL;
	for (i = 0; i < DEF_MAXPORTIONTYPES; i++)
	{	m_pPortionConfigList[i] = NULL;
		m_pCraftingConfigList[i] = NULL;	// Crafting
	}
	for (i = 0; i <  DEF_MAXTELEPORTLIST; i++)
		m_pTeleportConfigList[i] = NULL;
	for (i = 0; i < DEF_MAXSUBLOGSOCK; i++) 
	{	m_pSubLogSock[i] = NULL;
		m_bIsSubLogSockAvailable[i] = FALSE;
		m_bIsSubLogSockInitialPointer[i] = 0;
	}
	for (i = 0; i < DEF_MAXBUILDITEMS; i++) 
		m_pBuildItemList[i] = NULL;
	for (i = 0; i < DEF_MAXCRUSADESTRUCTURES; i++) 
	{	ZeroMemory(m_stCrusadeStructures[i].cMapName, sizeof(m_stCrusadeStructures[i].cMapName));
		m_stCrusadeStructures[i].cType = NULL;
		m_stCrusadeStructures[i].dX    = NULL;
		m_stCrusadeStructures[i].dY    = NULL;
		m_stCrusadeStructures[i].bManaStoneValid  = FALSE;
	}
	m_iManaStoneNumber = 3; // Default value
	for (i = 0; i < DEF_MAXADMINS; i++) {
		ZeroMemory(m_stAdminList[i].m_cGMName, sizeof(m_stAdminList[i].m_cGMName));
	}

	for (i = 0; i < DEF_MAXBANNED; i++) {
		ZeroMemory(m_stBannedList[i].m_cBannedIPaddress, sizeof(m_stBannedList[i].m_cBannedIPaddress));
	}	
	for (i = 0; i < DEF_MAXGUILDS; i++)
		m_pGuildTeleportLoc[i].m_iV1 = NULL;
	for (i = 0; i < DEF_MAXCRUSADESTRUCTURES; i++) 
	{	m_stMiddleCrusadeStructureInfo[i].cType = NULL;
		m_stMiddleCrusadeStructureInfo[i].cSide = NULL;
		m_stMiddleCrusadeStructureInfo[i].sX = NULL;
		m_stMiddleCrusadeStructureInfo[i].sY = NULL;	
	}
	m_iTotalMiddleCrusadeStructures = 0;	
	m_pNoticementData = NULL;
	m_iQueneHead = 0;
	m_iQueneTail = 0;
	m_iTotalClients = 0;
	m_iMaxClients   = 0;
	m_iTotalMaps    = 0;
	m_iTotalGameServerClients    = 0;
	m_iTotalGameServerMaxClients = 0;
	m_MaxUserSysTime.wHour   = 0;
	m_MaxUserSysTime.wMinute = 0;
	m_bIsServerShutdowned = FALSE;
	m_cShutDownCode = 0;
	m_iMiddlelandMapIndex = -1;
	m_iAresdenMapIndex    = -1;
	m_iElvineMapIndex     = -1;
	m_iGodHMapIndex	      = -1;
	m_iBTFieldMapIndex    = -1;
	m_iRampartMapIndex	  = -1;

	// Avatar Event
	for (i = 0; i < DEF_MAX_STATUE_LOCATIONS; i++) 
	{	ZeroMemory(m_stAvatarStructures[i].cMapName, sizeof(m_stAvatarStructures[i].cMapName));		
		m_stAvatarStructures[i].cMapIndex	= -1;	// MapIndex or -1 if not on server
		m_stAvatarStructures[i].cType		= NULL;	// DynamicObject type (15..21)
		m_stAvatarStructures[i].dX			= -1;	// 
		m_stAvatarStructures[i].dY			= -1;	// 
		m_stAvatarStructures[i].cMobSide	= -1;	// -1 if statue is absent	
		
		ZeroMemory(m_stAvatarStatues[i].cMapName, sizeof(m_stAvatarStatues[i].cMapName));		
		m_stAvatarStatues[i].cMapIndex		= -1;	// MapIndex or -1 if not on server
		m_stAvatarStatues[i].cType			= NULL;	// DynamicObject type (15..21)
		m_stAvatarStatues[i].dX				= -1;	// 
		m_stAvatarStatues[i].dY				= -1;	// 
		m_stAvatarStatues[i].cStatueRank	= -1;	// -1 if not defined, 0 if mob	
	} 
	m_dwAvatarGUID		= NULL;
	m_dwAvatarStartTime = NULL;
	m_iAvatarWinnerSide = -1;
	m_bIsAvatarMode		= FALSE;
	m_iAvatarMessenger  = -1;
	ZeroMemory(m_cAvatarMessenger, sizeof(m_cAvatarMessenger));	
	m_iStatueCount = 0;		// Rank of next Statue
	m_iStatueIndex = 0;		// Index of next Statue


	m_iPLmapIndex		  = -1; // Avatar
	m_iAresdenOccupyTiles = 0;
	m_iElvineOccupyTiles  = 0;
	m_iSubLogSockInitIndex   = 0;
	m_iCurMsgs = 0;
	m_iMaxMsgs = 0;
	for (i = 0; i < DEF_MAXSIDES; i++)  // more than 3 sides
	{	m_stCityStatus[i].iCrimes = 0;
		m_stCityStatus[i].iFunds  = 0;
		m_stCityStatus[i].iWins   = 0;
	}
	m_iStrategicStatus = 0;
	m_iCollectedMana[0] = 0;
	m_iCollectedMana[1] = 0;
	m_iCollectedMana[2] = 0;
	m_iAresdenMana = 0;
	m_iElvineMana  = 0;	
	m_iLastSentAresdenMana = m_iLastSentElvineMana = 0;
	m_dwSpecialEventTime = m_dwWhetherTime = m_dwGameTime1 =
		m_dwGameTime2 = m_dwGameTime3 = m_dwGameTime4 = m_dwGameTime5 = m_dwGameTime6 = m_dwFishTime = dwTime;
	m_bIsSpecialEventTime = FALSE;
	GetLocalTime(&SysTime);
	m_dwCanFightzoneReserveTime =  dwTime -  ((SysTime.wHour%2)*60*60 + SysTime.wMinute*60) *1000 ;
	for(i =0; i < DEF_MAXFIGHTZONE; i++) 
		m_iFightZoneReserve[i] = 0 ;
	m_iFightzoneNoForceRecall = 0;
	for (i = 1; i < 3500; i++) {
		m_iLevelExpTable[i] = iGetLevelExp(i);
		//testcode
		//wsprintf(G_cTxt, "Level:%d --- Exp:%d", i, m_iLevelExpTable[i]);
		//PutLogFileList(G_cTxt);
	}
	m_iLimitedUserExp = m_iLevelExpTable[DEF_PLRAIDER_LEVELLIMIT]; // Snoopy: to limit a player to lvl 90
	m_iLevelExp20     = m_iLevelExpTable[20]; 

	m_iPrimaryDropRate = 10001;
	// SNOOPY: new variables
	m_iAlchimyItemUpgradeEnabled = FALSE;
	m_iGizonItemUpgradeEnabled = FALSE;
	m_iAdminLevelSetPkMode = 4;
	m_iAdminLevelSetMapType = 4;
	m_iAdminLevelGetServerInfo =4;
	m_iAdminLevelMapMobNum = 4;
	m_iAdminLevelPopoEnabled = 3;
	m_bMapModeEquilibrium = FALSE;
	m_bMapModeEquilibriumChanged = FALSE;
	m_bPVPHPMode = FALSE;
	m_iXPBonusType = 2; // Standard Equilibrium for XP
	m_iPartyLog = FALSE; // Do not log all party events by default
	m_iServerValidationNumber = 0;				// 0 means line absent from settings, or no check
	m_iClientConnectionCheckTime = 8000;		// default client gap is 8000 or 8000+1000 
	m_iClientConnectionCheckTimeRound = 8000;	// default client gap is 8000 or 8000+1000 
	m_iClientConnectionCheckMaxNumber = 33;		// x+2000/300
	m_iCCCNeededForValidation = 12;				// 12 CCC to valid the lower possible one.	
	m_wServerValidationCRC1 = 0;				// Means don't use system
	m_wServerValidationCRC2 = 0;				// CRC1 is always the smaller
	m_dwMSGID_REQUEST_REGISTERGAMESERVER = MSGID_REQUEST_REGISTERGAMESERVER; // Default value
	m_iVariableTimeOut = DEF_CLIENTTIMEOUT; // DEF_CLIENTTIMEOUT =10000
	m_iBugWarning = 0;	

	m_iHourllyXP250 = 250*1000;
	m_iHourllyXP300 = 300*1000;
	m_iHourllyXP400 = 400*1000;
	//m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_iXPRate

	ZeroMemory(m_cBugText, sizeof(m_cBugText));


	m_iGameServerMode = 0;
	if (bReadProgramConfigFile("GServer.cfg") == FALSE) 
	{	PutLogList(" ");
		PutLogList("(!!!) CRITICAL ERROR! Cannot execute server! GServer.cfg file contents error!");
		return FALSE;	
	}
	if (bReadSettingsConfigFile("..\\GameConfigs\\Settings.cfg") == FALSE) 
	{	PutLogList(" ");
		PutLogList("(!!!) CRITICAL ERROR! Cannot execute server! Settings.cfg file contents error!");
		return FALSE;
	}
	if (bReadAdminListConfigFile("..\\GameConfigs\\AdminList.cfg") == FALSE) 
	{	PutLogList(" ");
		PutLogList("(!!!) CRITICAL ERROR! Cannot execute server! AdminList.cfg file contents error!");
		return FALSE;
	}
	if (bReadBannedListConfigFile("..\\GameConfigs\\BannedList.cfg") == FALSE) 
	{	PutLogList(" ");
		PutLogList("(!!!) CRITICAL ERROR! Cannot execute server! BannedList.cfg file contents error!");
		return FALSE;
	}
	if (bReadAdminSetConfigFile("..\\GameConfigs\\AdminSettings.cfg") == FALSE) 
	{	PutLogList(" ");
		PutLogList("(!!!) CRITICAL ERROR! Cannot execute server! AdminSettings.cfg file contents error!");
		return FALSE;
	}
	if (bDecodeTeleportList("..\\GameConfigs\\TeleportList.cfg") == FALSE) 
	{	PutLogList(" ");
		PutLogList("(!!!) CRITICAL ERROR! Cannot execute server! TeleportList.cfg file contents error!");
		return FALSE;
	}	
	PutLogList(" "); // Space at end of settings files reading
	srand( (unsigned)time( NULL ) );   
	// Main Log Socket
	m_pMainLogSock = new class XSocket(m_hWnd, DEF_SERVERSOCKETBLOCKLIMIT);
	if (m_pMainLogSock->bConnect(m_cLogServerAddr, m_iLogServerPort, WM_ONLOGSOCKETEVENT))
	{	m_pMainLogSock->bInitBufferSize(DEF_MSGBUFFERSIZE);
		wsprintf(cTxt, "(...W) Try to connect WorldServer...      Addr:%s  Port:%d", m_cLogServerAddr, m_iLogServerPort);
	}else
	{	wsprintf(cTxt, "(!!!W) Failed trying to connect WorldServer... Addr:%s  Port:%d", m_cLogServerAddr, m_iLogServerPort);
	}
	PutLogList(cTxt);
	//
	Sleep(100);
	m_pGateSock = new class XSocket(m_hWnd, DEF_SERVERSOCKETBLOCKLIMIT);
	if (m_pGateSock->bConnect(m_cGateServerAddr, m_iGateServerPort, WM_ONGATESOCKETEVENT))
	{	m_pGateSock->bInitBufferSize(DEF_MSGBUFFERSIZE);
		m_iGateSockConnRetryTimes = 1;
		wsprintf(cTxt, "(...G) Try to connect GateServer...       Addr:%s  Port:%d", m_cGateServerAddr, m_iGateServerPort);
	}else
	{	wsprintf(cTxt, "(!!!G) Failed trying to connect Gate Server... Addr:%s  Port:%d", m_cGateServerAddr, m_iGateServerPort);
	}
	PutLogList(cTxt);
	m_bF1pressed = m_bF4pressed = m_bF12pressed = m_bF5pressed = FALSE;	
	m_bOnExitProcess = FALSE;
	for (i = 0; i <= 100; i++) 
	{	m_iSkillSSNpoint[i] = _iCalcSkillSSNpoint(i);
	}
	GetLocalTime(&SysTime);
	if (SysTime.wMinute >= DEF_NIGHTTIME) 
		 m_cDayOrNight = (char) 2; // night
	else m_cDayOrNight = (char) 1; // day
	bReadNotifyMsgListFile("notice.txt");
	m_dwNoticeTime = dwTime;
	m_iCurSubLogSockIndex    = 0;
	m_iSubLogSockFailCount   = 0;
	m_iSubLogSockActiveCount = 0;
	m_pNoticementData      = NULL;
	m_dwNoticementDataSize = 0;
	m_dwMapSectorInfoTime = dwTime;
	m_iMapSectorInfoUpdateCount = 0;
	m_iCrusadeCount  = NULL;
	m_bIsCrusadeMode = FALSE;
	m_bIsApocalypseMode = FALSE;
	m_bIsApocalypseGateOpen	= FALSE; // SNOOPY add
	m_wServerID_GSS = iDice(1,65535);
	ZeroMemory(m_cGateServerStockMsg, sizeof(m_cGateServerStockMsg));
	cp = (char *)m_cGateServerStockMsg;
	dwp = (DWORD *)cp;
	*dwp = MSGID_SERVERSTOCKMSG;
	cp += 4;
	wp = (WORD *)cp;
	*wp = DEF_MSGTYPE_CONFIRM;
	cp += 2;
	m_iIndexGSS = 6;
	m_dwCrusadeGUID = NULL;
	m_dwCrusadeStartTime = 0;
	m_iCrusadeWinnerSide = NULL;
	m_iLastCrusadeWinner = 0;
	m_iCrusadeAdvantage  = 0;

	m_iFinalShutdownCount = 0;
	m_bIsCrusadeWarStarter = FALSE;
	m_bEverybodyAdvised		= FALSE;
	m_bIsApocalypseStarter = FALSE;
	m_iLatestCrusadeDayOfWeek = -1;
	// 	Heldenian
	m_bIsHeldenianMode			 = FALSE;
	m_bHeldenianWarInitiated	 = FALSE;
	m_cHeldenianType			 = 0;
	m_sLastHeldenianWinner		 = 0; 
	m_cHeldenianWinner			 = -1;
	m_dwHeldenianGUID			 = NULL;
	m_dwHeldenianWarStartTime	 = 0;
	m_dwHeldenianFinishTime		 = 0;
	m_cHeldenianFirstDestroyedTowerWinner = -1;
	m_iHeldenianAresdenDead		 = 0;
	m_iHeldenianElvineDead		 = 0;
	m_iHeldenianAresdenFlags	 = 0;
	m_iHeldenianElvineFlags		 = 0;
	m_iHeldenianAresdenLeftTower = 0;
	m_iHeldenianElvineLeftTower  = 0;
	return TRUE;
}

void CGame::OnClientRead(int iClientH, DWORD dwTime)
{char  * pData, cKey;
 DWORD  dwMsgSize;	
	if (m_pClientList[iClientH] == NULL) return; 
	pData = m_pClientList[iClientH]->m_pXSock->pGetRcvDataPointer(&dwMsgSize, &cKey); // v1.4	
	if (bPutMsgQuene(DEF_MSGFROM_CLIENT, pData, dwMsgSize, iClientH, cKey, dwTime) == FALSE) {
		PutLogFileList("(@@@C) CRITICAL ERROR in MsgQuene!!! @@@@@@");
		PutLogList("(@@@C) CRITICAL ERROR in MsgQuene!!! @@@@@@");
	}
}

void CGame::DisplayInfo(HDC hdc, HWND G_hWnd)
{
 char cTxt[350],cTitle[350];
 SYSTEMTIME SysTime;
 GetLocalTime(&SysTime);  
 int  i, iLine;
 	wsprintf(cTxt, "Server-Name(%s) Max.Level(%d) Players(%d/%d - %d/%d) Crusade(%d:%d) SLSock(%d:%d) GTSock(%d) RBT(%d)"
		, m_cServerName, m_iPlayerMaxLevel, m_iTotalClients, m_iMaxClients
		, m_iTotalGameServerClients, m_iTotalGameServerMaxClients
		, m_dwCrusadeGUID, (int)m_bIsCrusadeMode, m_iSubLogSockActiveCount, m_iSubLogSockFailCount
		, m_iGateSockConnRetryTimes, m_iAutoRebootingCount);
	TextOut(hdc, 5, 10, cTxt, strlen(cTxt));

	if ((m_bIsCrusadeMode == TRUE) && (DEF_MAXSTRIKEPOINTS >4))
	{	ZeroMemory(cTxt, sizeof(cTxt));
		if (m_iAresdenMapIndex != -1)
		{	wsprintf(cTxt, "HB server by Snoopy81 - Crusade, Aresden: Mana=%d  GMG[%d/%d] - %d %d %d %d "
				, m_iAresdenMana
				, m_iCrusadeGMG, m_iCrusadeGMGMax
				, m_pMapList[m_iAresdenMapIndex]->m_stStrikePoint[1].iHP
				, m_pMapList[m_iAresdenMapIndex]->m_stStrikePoint[2].iHP
				, m_pMapList[m_iAresdenMapIndex]->m_stStrikePoint[3].iHP
				, m_pMapList[m_iAresdenMapIndex]->m_stStrikePoint[4].iHP);
		}else if (m_iElvineMapIndex != -1)
		{	wsprintf(cTxt, "HB server by Snoopy81 - Crusade, Elvine:  Mana=%d  GMG[%d/%d] - %d %d %d %d "
				, m_iElvineMana
				, m_iCrusadeGMG, m_iCrusadeGMGMax
				, m_pMapList[m_iElvineMapIndex]->m_stStrikePoint[1].iHP
				, m_pMapList[m_iElvineMapIndex]->m_stStrikePoint[2].iHP
				, m_pMapList[m_iElvineMapIndex]->m_stStrikePoint[3].iHP
				, m_pMapList[m_iElvineMapIndex]->m_stStrikePoint[4].iHP);		
		}else if (m_iMiddlelandMapIndex != -1)
		{	wsprintf(cTxt, "HB server by Snoopy81 - Crusade: Aresden mana=%d  -  Elvine mana=%d "
				, m_iLastSentAresdenMana, m_iLastSentElvineMana	);		
		}else wsprintf(cTxt, "HB server by Snoopy81 - Crusade in progress...");	
	}else if (m_bIsCrusadeMode == TRUE) // If less than 4 strike points...
	{	ZeroMemory(cTxt, sizeof(cTxt));
		wsprintf(cTxt, "HB server by Snoopy81 - Crusade in progress...");	
	}else if (m_bIsHeldenianMode == TRUE)
	{	ZeroMemory(cTxt, sizeof(cTxt));
		wsprintf(cTxt, "HB server by Snoopy81 - Heldenian in progress...");	
	}else if (m_bIsApocalypseMode == TRUE)
	{	ZeroMemory(cTxt, sizeof(cTxt));
		wsprintf(cTxt, "HB server by Snoopy81 - Apocalypse in progress...");	
	}else
	{	ZeroMemory(cTxt, sizeof(cTxt));
		strcpy(cTxt, "HB server by Snoopy81 - Debugged and improved from HBx v2.24b sources for Equilibrium Project.");
	}	
	SetTextColor(hdc, 0x00FF0000); // blue
	TextOut(hdc, 5, 25, cTxt, strlen(cTxt));
	SetTextColor(hdc, 0x00000000); // black

	if (m_iBugWarning != 0) // Show warning message in Red
	{	SetTextColor(hdc, 0x000000FF); // red
		TextOut(hdc, 5, 40 , m_cBugText, strlen(m_cBugText));
		SetTextColor(hdc, 0x00000000); // black
		wsprintf(cTitle, "Helbreath GameServer v%s.%s %d - Name(%s) Players(%d/%d - %d/%d) - (Executed on %d %d at %dh%d ) ***ERROR DETECTED***"
			, DEF_UPPERVERSION, DEF_LOWERVERSION, (int)m_dwBuildDate
			, m_cServerName, m_iTotalClients, m_iMaxClients, m_iTotalGameServerClients, m_iTotalGameServerMaxClients
			, SysTime.wMonth, SysTime.wDay, SysTime.wHour, SysTime.wMinute);
	}else // replace warning message by player repartition
	{	int tab[4] = {200,380,555,660};
		int a1,a2,a3,a4,e1,e2,e3,e4,x1,x2,n1,n2;
		a1=a2=a3=a4=e1=e2=e3=e4=x1=x2=n1=n2=0;
		for (i = 0; i < DEF_MAXMAPS; i++)
		{	if (m_pMapList[i] != NULL)
			{	a1 += CalcCityStr(1, (char)i, TRUE, TRUE);
				a2 += CalcCityStr(1, (char)i, TRUE, FALSE);
				a3 += CalcCityStr(1, (char)i, FALSE, TRUE);
				a4 += CalcCityStr(1, (char)i, FALSE, FALSE);
				e1 += CalcCityStr(2, (char)i, TRUE, TRUE);
				e2 += CalcCityStr(2, (char)i, TRUE, FALSE);
				e3 += CalcCityStr(2, (char)i, FALSE, TRUE);
				e4 += CalcCityStr(2, (char)i, FALSE, FALSE);
				x1 += CalcCityStr(4, (char)i, TRUE, TRUE);
				x2 += CalcCityStr(4, (char)i, TRUE, FALSE);
				n1 += CalcCityStr(0, (char)i, TRUE, TRUE);
				n2 += CalcCityStr(0, (char)i, TRUE, FALSE);
			}	
		}		
		ZeroMemory(cTxt, sizeof(cTxt));				
		wsprintf(cTxt, "Balance:[nb(act) might(act)]:\tAres[%d(%d) %d(%d)]\tElv[%d(%d) %d(%d)]\tExec[%d(%d)]\tNeut[%d(%d)]" 
			 //, CalcCityStr(int iSide, char cMapIndex, bool bWantNumber, bool bIncludeAFK)
			, a1, a2 , a3, a4 , e1, e2 , e3, e4 , x1, x2 , n1, n2);
		SetTextColor(hdc, 0x000AA20A); // Dark green
		TabbedTextOut(hdc, 5, 40, cTxt, strlen(cTxt), 4, tab, 0);
		SetTextColor(hdc, 0x00000000); // black			
		wsprintf(cTitle, "Helbreath GameServer v%s.%s %d - Name(%s) Players(%d/%d - %d/%d) - (Executed on %d %d at %dh%d )  "
			, DEF_UPPERVERSION, DEF_LOWERVERSION, (int)m_dwBuildDate
			, m_cServerName, m_iTotalClients, m_iMaxClients, m_iTotalGameServerClients, m_iTotalGameServerMaxClients
			, SysTime.wMonth, SysTime.wDay, SysTime.wHour, SysTime.wMinute);
	}
	SetWindowText(G_hWnd, cTitle); // could returns bool
	
	iLine = 0;	
	if (bShowActivity == TRUE)
	{	int tab[8] = {130,200,300,400,500,600,700,800};
		for (i = 0; i < DEF_MAXMAPS; i++)
		{	if (m_pMapList[i] != NULL) 
			{	ZeroMemory(G_cTxt, sizeof(G_cTxt));
				wsprintf(G_cTxt, "Map(%s)\tObj(%d)\tP(%d, %d)\tN(%d, %d)\tA(%d, %d)\tE(%d, %d)\tX(%d, %d)\tM(%d, %d)", 
				     m_pMapList[i]->m_cName, m_pMapList[i]->m_iTotalActiveObject,  m_pMapList[i]->m_iMaxPx*20+10, m_pMapList[i]->m_iMaxPy*20+10, 
					 m_pMapList[i]->m_iMaxNx*20+10, m_pMapList[i]->m_iMaxNy*20+10, m_pMapList[i]->m_iMaxAx*20+10, m_pMapList[i]->m_iMaxAy*20+10, 
					 m_pMapList[i]->m_iMaxEx*20+10, m_pMapList[i]->m_iMaxEy*20+10, m_pMapList[i]->m_iMaxXx*20+10, m_pMapList[i]->m_iMaxXy*20+10,  
					 m_pMapList[i]->m_iMaxMx*20+10, m_pMapList[i]->m_iMaxMy*20+10);				
				TabbedTextOut(hdc, 5, 390 + iLine*15, G_cTxt, strlen(G_cTxt), 7, tab, 0);
				iLine++;
			}	
		}	
	}else
	{	int tab[5] = {130,200,380,555,660};
		for (i = 0; i < DEF_MAXMAPS; i++)
		{	if (m_pMapList[i] != NULL)
			{	ZeroMemory(G_cTxt, sizeof(G_cTxt));
				wsprintf(G_cTxt, "Map(%s)\tObj(%d)\tAres[%d(%d) %d(%d)]\tElv[%d(%d) %d(%d)]\tExec[%d(%d)]\tNeut[%d(%d)]" 
				   , m_pMapList[i]->m_cName, m_pMapList[i]->m_iTotalActiveObject
					 //, CalcCityStr(int iSide, char cMapIndex, bool bWantNumber, bool bIncludeAFK)
					 , CalcCityStr(1, (char)i, TRUE, TRUE),  CalcCityStr(1, (char)i, TRUE, FALSE)
					 , CalcCityStr(1, (char)i, FALSE, TRUE), CalcCityStr(1, (char)i, FALSE, FALSE)
					 , CalcCityStr(2, (char)i, TRUE, TRUE),  CalcCityStr(2, (char)i, TRUE, FALSE)
					 , CalcCityStr(2, (char)i, FALSE, TRUE), CalcCityStr(2, (char)i, FALSE, FALSE)
					 , CalcCityStr(4, (char)i, TRUE, TRUE),  CalcCityStr(4, (char)i, TRUE, FALSE)
					 , CalcCityStr(0, (char)i, TRUE, TRUE),  CalcCityStr(0, (char)i, TRUE, FALSE) );	
				//TextOut(hdc, 5, 400 + iLine*15, G_cTxt, strlen(G_cTxt));
				TabbedTextOut(hdc, 5, 390 + iLine*15, G_cTxt, strlen(G_cTxt), 5, tab, 0);
				iLine++;
			}			
		}
	}
}

void CGame::ClientMotionHandler(int iClientH, char * pData, DWORD dwMsgTime)
{DWORD * dwp, dwClientTime;
 WORD * wp, wCommand, wTargetObjectID = 0;
 short * sp, sX, sY, dX, dY, wType;
 char  * cp, cDir;
 int   iRet, iTemp;	
	if (m_pClientList[iClientH] == NULL) return;
	if (m_pClientList[iClientH]->m_bIsInitComplete == FALSE) return;
	if (m_pClientList[iClientH]->m_bIsKilled == TRUE) return;
	m_pClientList[iClientH]->m_dwLastActionTime = m_pClientList[iClientH]->m_dwAFKCheckTime = timeGetTime();;
	m_pClientList[iClientH]->m_bAntiTPLameEK = FALSE; 
	wp = (WORD *)(pData + DEF_INDEX2_MSGTYPE);
	wCommand = *wp;
	cp = (char *)(pData + DEF_INDEX2_MSGTYPE + 2);
	sp = (short *)cp;
	sX = *sp;
	cp += 2;
	sp = (short *)cp;
	sY = *sp;
	cp += 2;
	cDir = *cp;
	cp++;
	sp = (short *)cp;
	dX = *sp;
	cp += 2;
	sp = (short *)cp;
	dY = *sp;
	cp += 2;
	sp = (short *)cp;
	wType = *sp;
	cp += 2;
	if ((wCommand == DEF_OBJECTATTACK) || (wCommand == DEF_OBJECTATTACKMOVE))  // v1.4
	{	wp = (WORD *)cp;
		wTargetObjectID = *wp;
		cp += 2;
	}	
	// v2.171
	dwp = (DWORD *)cp;
	dwClientTime = *dwp;
	cp += 4;
	CheckDenialServiceAttack(iClientH, dwClientTime, dwMsgTime, 0);
	switch (wCommand) {
	case DEF_OBJECTSTOP: // 0
		bCheckClientMoveFrequency(iClientH, dwClientTime, dwMsgTime, 0); // Here to reset counters
		iRet = iClientMotion_Stop_Handler(iClientH, sX, sY, cDir);
		if (iRet == 1) {
			SendEventToNearClient_TypeA(iClientH, DEF_OWNERTYPE_PLAYER, MSGID_EVENT_MOTION, DEF_OBJECTSTOP, NULL, NULL, NULL);
		}
		else if (iRet == 2) SendObjectMotionRejectMsg(iClientH);
		break;

	case DEF_OBJECTRUN:	// 2 Running	
		iRet = iClientMotion_Move_Handler(iClientH, sX, sY, cDir, 1, bCheckClientMoveFrequency(iClientH, dwClientTime, dwMsgTime, 1));// run
		if (iRet == 1) 
		{	SendEventToNearClient_TypeA(iClientH, DEF_OWNERTYPE_PLAYER, MSGID_EVENT_MOTION, DEF_OBJECTRUN, NULL, NULL, NULL);
		}
		if ((m_pClientList[iClientH] != NULL) && (m_pClientList[iClientH]->m_iHP <= 0)) ClientKilledHandler(iClientH, NULL, NULL, 1); // v1.4
		break;

	case DEF_OBJECTMOVE: // 1 Walking
		iRet = iClientMotion_Move_Handler(iClientH, sX, sY, cDir, 2, bCheckClientMoveFrequency(iClientH, dwClientTime, dwMsgTime, 2));// walk
		if (iRet == 1) 
		{	SendEventToNearClient_TypeA(iClientH, DEF_OWNERTYPE_PLAYER, MSGID_EVENT_MOTION, DEF_OBJECTMOVE, NULL, NULL, NULL);
		}
		if ((m_pClientList[iClientH] != NULL) && (m_pClientList[iClientH]->m_iHP <= 0)) ClientKilledHandler(iClientH, NULL, NULL, 1); // v1.4
		break;

	case DEF_OBJECTDAMAGEMOVE: // 7
		bCheckClientMoveFrequency(iClientH, dwClientTime, dwMsgTime, 7); // Here to reset counters
		iRet = iClientMotion_Move_Handler(iClientH, sX, sY, cDir, 0, FALSE);//Fly
		if (iRet == 1)                                                  
		{	SendEventToNearClient_TypeA((short)iClientH, DEF_OWNERTYPE_PLAYER, MSGID_EVENT_MOTION, DEF_OBJECTDAMAGEMOVE, m_pClientList[iClientH]->m_iLastDamage, NULL, NULL);
		}
		if ((m_pClientList[iClientH] != NULL) && (m_pClientList[iClientH]->m_iHP <= 0)) ClientKilledHandler(iClientH, NULL, NULL, 1); // v1.4
		break;

	case DEF_OBJECTATTACKMOVE: // 8 Dash attack
		iRet = iClientMotion_Move_Handler(iClientH, sX, sY, cDir, 0); // Dash attack
		if ((iRet == 1) && (m_pClientList[iClientH] != NULL)) 
		{	if ( bCheckClientDashFrequency(iClientH, dwClientTime, dwMsgTime))
			{	iRet = 2; //TRUE: Hacked dash attack
			}else
			{	SendEventToNearClient_TypeA((short)iClientH, DEF_OWNERTYPE_PLAYER, MSGID_EVENT_MOTION, DEF_OBJECTATTACKMOVE, NULL, NULL, NULL);
				wType = 1;			
				iClientMotion_Attack_Handler(iClientH, m_pClientList[iClientH]->m_sX, m_pClientList[iClientH]->m_sY, dX, dY, wType, cDir, wTargetObjectID, dwClientTime, dwMsgTime, FALSE, TRUE, FALSE); // v1.4
			}
		}
		if ((m_pClientList[iClientH] != NULL) && (m_pClientList[iClientH]->m_iHP <= 0)) ClientKilledHandler(iClientH, NULL, NULL, 1); // v1.4
		break;

	case DEF_OBJECTATTACK: // 3 Non-Dash attack
		_CheckAttackType(iClientH, &wType);
		if (bCheckClientAttackFrequency(iClientH, dwClientTime, dwMsgTime))
		{	iRet = 2; //TRUE: Hacked attack
		}else
		{	iRet = iClientMotion_Attack_Handler(iClientH, sX, sY, dX, dY, wType, cDir, wTargetObjectID, dwClientTime, dwMsgTime, TRUE, FALSE, FALSE); // v1.4
		}
		if (iRet == 1) 
		{	if (wType >= 20) 
			{	m_pClientList[iClientH]->m_iSuperAttackLeft--;
				if (m_pClientList[iClientH]->m_iSuperAttackLeft < 0) m_pClientList[iClientH]->m_iSuperAttackLeft = 0;
			}
			SendEventToNearClient_TypeA(iClientH, DEF_OWNERTYPE_PLAYER, MSGID_EVENT_MOTION, DEF_OBJECTATTACK, dX, dY, wType);
		}else if (iRet == 2) SendObjectMotionRejectMsg(iClientH);
		break;

	case DEF_OBJECTGETITEM: // 5
		iRet = iClientMotion_GetItem_Handler(iClientH, sX, sY, cDir);
		if (iRet == 1) 
		{	SendEventToNearClient_TypeA(iClientH, DEF_OWNERTYPE_PLAYER, MSGID_EVENT_MOTION, DEF_OBJECTGETITEM, NULL, NULL, NULL);
		}
		else if (iRet == 2) SendObjectMotionRejectMsg(iClientH);
		break;

	case DEF_OBJECTMAGIC: // 4 Precast (character does cast movement)
		iRet = iClientMotion_Magic_Handler(iClientH, sX, sY, cDir, dwClientTime, dwMsgTime, dX); //included hack check here
		if (iRet == 1) // 0= client deleted...
		{	iTemp = 10; // dX is spellID, iTemps seems unused (on v2.20 Client sources...)
			SendEventToNearClient_TypeA(iClientH, DEF_OWNERTYPE_PLAYER, MSGID_EVENT_MOTION, DEF_OBJECTMAGIC, dX, iTemp, NULL);
		}else if (iRet == 2) SendObjectMotionRejectMsg(iClientH);
		break;
	default:
		wsprintf(G_cTxt, "Unknown MSGID_COMMAND_MOTION message received.");
		PutLogList(G_cTxt);
		break;
	}
}
/////////////////////////////////////////////////////////////////////////////////////
//  int CGame::iClientMotion_Move_Handler(int iClientH, short sX, short sY, char cDir, char cMoveType)
//  description			:: Handles how player or npc run, walk, attack, or get flown by attack
//  last updated		:: October 30, 2004; 1:52 AM; Hypnotoad
//	return value		:: int
//  commentary			:: - contains speed hack detection previously unavailable
//						   - changed variable 5 to char, prior BOOL.
//								1 = object run
//								2 = object walk
//								0 = object damage move, object attack move
//								5 = Object run by Server command (Stormbringer) (walk2 + 4)
//						   - fixed bump bug removing aura
/////////////////////////////////////////////////////////////////////////////////////
// Missing 3.51: // Snoopy: DynamicGate......
//			m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->3CA18h
// 			bRet = m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->sub_4C0F20(dX, dY, cTemp, wV1, wV2);
//
/////////////////////////////////////////////////////////////////////////////////////
int CGame::iClientMotion_Move_Handler(int iClientH, short sX, short sY, char cDir, char cMoveType, BOOL bIsBlocked)
{ char  * cp, cData[3000];
 class CTile * pTile;
 DWORD * dwp;
 WORD  * wp, wObjectID;
 short * sp, dX, dY, sDOtype, pTopItem;
 int   * ip, iRet, iSize, iDamage, iTemp, iTemp2;
 BOOL  bRet;
 BOOL bTransparentInvi = FALSE;
	if (m_pClientList[iClientH] == NULL) return 0;
	if ((cDir <= 0) || (cDir > 8))       return 0;
	if (m_pClientList[iClientH]->m_bIsKilled == TRUE) return 0;
	if (m_pClientList[iClientH]->m_bIsInitComplete == FALSE) return 0;	
	if ((sX != m_pClientList[iClientH]->m_sX) || (sY != m_pClientList[iClientH]->m_sY)) return 2;// Reject Move

	// Snoopy: SpeedHack ckeck on server time were disactivated by HBx team. 
	// I introduced it in bCheckClientMoveFrequency along with client side timing checks
	if (cMoveType >3) cMoveType -=4; // Move type 4+ indicates move generated by server, not client !

	int iStX, iStY;
	if (m_pMapList[m_pClientList[iClientH]->m_cMapIndex] != NULL) {
		iStX = m_pClientList[iClientH]->m_sX / 20;
		iStY = m_pClientList[iClientH]->m_sY / 20;
		m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_stTempSectorInfo[iStX][iStY].iPlayerActivity++;
		switch (m_pClientList[iClientH]->m_cSide) {
		case 1: m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_stTempSectorInfo[iStX][iStY].iAresdenActivity++;  break;
		case 2: m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_stTempSectorInfo[iStX][iStY].iElvineActivity++;   break;
		case 4: m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_stTempSectorInfo[iStX][iStY].iExecutorActivity++; break;
		case 0:
		default: m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_stTempSectorInfo[iStX][iStY].iNeutralActivity++; break;
		}
	}	
	ClearSkillUsingStatus(iClientH);	
	dX = m_pClientList[iClientH]->m_sX;
	dY = m_pClientList[iClientH]->m_sY;
	switch (cDir) {
	case 1:	dY--; break;
	case 2:	dX++; dY--;	break;
	case 3:	dX++; break;
	case 4:	dX++; dY++;	break;
	case 5: dY++; break;
	case 6:	dX--; dY++;	break;
	case 7:	dX--; break;
	case 8:	dX--; dY--;	break;
	}
	pTopItem = 0;
	bRet = m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->bGetMoveable(dX, dY, &sDOtype, &pTopItem);	
	if (m_pClientList[iClientH]->m_cMagicEffectStatus[DEF_MAGICTYPE_HOLDOBJECT] != 0)	bRet = FALSE;  
	if ((bRet == TRUE) && (bIsBlocked == FALSE))  // bRet means allowed tile, bIsBlocked means HackCheck prevents moving
	{	if (m_pClientList[iClientH]->m_iQuest != NULL) _bCheckIsQuestCompleted(iClientH);
		m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->ClearOwner(1, iClientH, DEF_OWNERTYPE_PLAYER, m_pClientList[iClientH]->m_sX, m_pClientList[iClientH]->m_sY);
		m_pClientList[iClientH]->m_sX   = dX;
		m_pClientList[iClientH]->m_sY   = dY;
		m_pClientList[iClientH]->m_cDir = cDir;
		m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->SetOwner((short)iClientH, DEF_OWNERTYPE_PLAYER, dX, dY);
		if (sDOtype == DEF_DYNAMICOBJECT_SPIKE) 
		{	if ((m_pClientList[iClientH]->m_bIsNeutral == TRUE) /*&& ((m_pClientList[iClientH]->m_sAppr2 & 0xF000) == 0)*/) 
			{	// No damage for Travellers
			}else  // SNOOPY: Chage from 2d4 to 2d6
			{	iDamage = iDice(2,6);
				if (m_pClientList[iClientH]->m_iAdminUserLevel == 0)
					m_pClientList[iClientH]->m_iHP -= iDamage;		
		}	}		
		if (m_pClientList[iClientH]->m_iHP <= 0) 
			m_pClientList[iClientH]->m_iHP = 0;		
		dwp  = (DWORD *)(cData + DEF_INDEX4_MSGID);
		*dwp = MSGID_RESPONSE_MOTION;
		wp   = (WORD *)(cData + DEF_INDEX2_MSGTYPE);
		*wp  = DEF_OBJECTMOVE_CONFIRM;		
		cp = (char *)(cData + DEF_INDEX2_MSGTYPE+2);		
		sp  = (short *)cp;
		*sp = (short)(dX - 10); 
		cp += 2;		
		sp  = (short *)cp;
		*sp = (short)(dY - 7); 
		cp += 2;		
		*cp = cDir;
		cp++;		
		if (cMoveType == 1) // Running depletes Stamina
		{	if (m_pClientList[iClientH]->m_iSP > 0) 
			{	*cp = 0;
				if (m_pClientList[iClientH]->m_iTimeLeft_FirmStaminar == 0) 
				{	m_pClientList[iClientH]->m_iSP--;
					*cp = 1;
				}
			}else 
			{	*cp = 0;
				if (m_pClientList[iClientH]->m_iTimeLeft_FirmStaminar == 0) 
				{	m_pClientList[iClientH]->m_iSP--;
					*cp = 1;
				}
				if (m_pClientList[iClientH]->m_iSP < -10) 
				{	m_pClientList[iClientH]->m_iSP = 0;
					DeleteClient(iClientH, TRUE, TRUE);
					return 0;
				}
			}
		}else *cp = 0;
		cp++;		
		pTile = (class CTile *)(m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_pTile + dX + dY*m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_sSizeY);
		*cp = (char)pTile->m_iOccupyStatus;
		cp++;		
		ip = (int *)cp;
		*ip = m_pClientList[iClientH]->m_iHP;
		cp += 4;		
		iSize = iComposeMoveMapData((short)(dX - 10), (short)(dY - 7), iClientH, cDir, cp);	
		iRet = m_pClientList[iClientH]->m_pXSock->iSendMsg(cData, iSize + 12 + 1 + 4);
		switch (iRet) {
		case DEF_XSOCKEVENT_QUENEFULL:
		case DEF_XSOCKEVENT_SOCKETERROR:
		case DEF_XSOCKEVENT_CRITICALERROR:
		case DEF_XSOCKEVENT_SOCKETCLOSED:
			DeleteClient(iClientH, TRUE, TRUE);
			return 0;
		}
		/*if (m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->3CA18h == TRUE) {			
			.text:00406037                 mov     [ebp+var_C1C], 0
			.text:0040603E                 xor     edx, edx
			.text:00406040                 mov     [ebp+var_C1B], edx
			.text:00406046                 mov     [ebp+var_C17], edx
			.text:0040604C                 mov     [ebp+var_C13], dx			
			bRet = m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->sub_4C0F20(dX, dY, cTemp, wV1, wV2);
			if (bRet == 1) {
				RequestTeleportHandler(iClientH, "2   ", cTemp, wV1, wV2, TRUE);
			}
		}*/
	}else  // Either para, there is something on the Tile either Anti SpeedHack block moving
	{	m_pClientList[iClientH]->m_bIsMoveBlocked = TRUE;

		dwp  = (DWORD *)(cData + DEF_INDEX4_MSGID);
		*dwp = MSGID_RESPONSE_MOTION;
		wp   = (WORD *)(cData + DEF_INDEX2_MSGTYPE);
		*wp  = DEF_OBJECTMOVE_REJECT;
		wObjectID = (WORD)iClientH;
		cp = (char *)(cData + DEF_INDEX2_MSGTYPE + 2);
		wp  = (WORD *)cp;
		*wp = wObjectID;
		cp += 2;
		sp  = (short *)cp;
		sX  = m_pClientList[wObjectID]->m_sX;
		*sp = sX;
		cp += 2;
		sp  = (short *)cp;
		sY  = m_pClientList[wObjectID]->m_sY;
		*sp = sY;
		cp += 2;
		sp  = (short *)cp;
		*sp = m_pClientList[wObjectID]->m_sType;
		cp += 2;
		*cp = m_pClientList[wObjectID]->m_cDir;
		cp++;
		memcpy(cp, m_pClientList[wObjectID]->m_cCharName, 10);
		cp += 10;
		sp  = (short *)cp;
		*sp = m_pClientList[wObjectID]->m_sAppr1;
		cp += 2;
		sp  = (short *)cp;
		*sp = m_pClientList[wObjectID]->m_sAppr2;
		cp += 2;
		sp  = (short *)cp;
		*sp = m_pClientList[wObjectID]->m_sAppr3;
		cp += 2;
		sp  = (short *)cp;
		*sp = m_pClientList[wObjectID]->m_sAppr4;
		cp += 2;
		ip  = (int *)cp;
		*ip = m_pClientList[wObjectID]->m_iApprColor;
		cp+= 4;
		ip  = (int *)cp;
		iTemp = m_pClientList[wObjectID]->m_iStatus;
		iTemp = 0x0FFBFFFF & iTemp;
		bTransparentInvi = FALSE;
		iTemp2 = iGetPlayerABSStatus(wObjectID, iClientH, bTransparentInvi);
		if (bTransparentInvi == TRUE) iTemp = (iTemp | 0x00040000);
		iTemp  = (iTemp | (iTemp2 << 28));
		*ip = iTemp;
		cp += 4;
		iRet = m_pClientList[iClientH]->m_pXSock->iSendMsg(cData, 42);		
		switch (iRet) {
		case DEF_XSOCKEVENT_QUENEFULL:
		case DEF_XSOCKEVENT_SOCKETERROR:
		case DEF_XSOCKEVENT_CRITICALERROR:
		case DEF_XSOCKEVENT_SOCKETCLOSED:
			DeleteClient(iClientH, TRUE, TRUE);
			return 0;
		}
		return 0;
	}
	return 1;
}

void CGame::RequestInitPlayerHandler(int iClientH, char * pData, char cKey)
{register int i;
 char * cp, cCharName[11], cAccountName[11], cAccountPassword[11], cTxt[120], cTempIP[120], cTempIP2[120];
 BOOL bIsObserverMode;	
	// Snoopy; added trap for faultlly client ID
	if (iClientH <1) return;
	if (m_pClientList[iClientH] == NULL) return;
	if (m_pClientList[iClientH]->m_bIsInitComplete == TRUE) return;

	ZeroMemory(cCharName, sizeof(cCharName));
	ZeroMemory(cAccountName, sizeof(cAccountName));
	ZeroMemory(cAccountPassword, sizeof(cAccountPassword));

	ZeroMemory(m_pClientList[iClientH]->m_cCharName, sizeof(m_pClientList[iClientH]->m_cCharName));
	ZeroMemory(m_pClientList[iClientH]->m_cAccountName, sizeof(m_pClientList[iClientH]->m_cAccountName));
	ZeroMemory(m_pClientList[iClientH]->m_cAccountPassword, sizeof(m_pClientList[iClientH]->m_cAccountPassword));

	cp = (char *)(pData + DEF_INDEX2_MSGTYPE + 2);
	memcpy(cCharName, cp, 10);
	cp += 10;
	ZeroMemory(cTxt, sizeof(cTxt)); // v1.4
	memcpy(cTxt, cCharName, 10);
	m_Misc.bDecode(cKey, cTxt);
	ZeroMemory(cCharName, sizeof(cCharName));
	memcpy(cCharName, cTxt, 10);
	memcpy(cAccountName, cp, 10);
	cp += 10;	
	ZeroMemory(cTxt, sizeof(cTxt)); // v1.4
	memcpy(cTxt, cAccountName, 10);
	m_Misc.bDecode(cKey, cTxt);
	ZeroMemory(cAccountName, sizeof(cAccountName));
	memcpy(cAccountName, cTxt, 10);
	memcpy(cAccountPassword, cp, 10);
	cp += 10;
	ZeroMemory(cTxt, sizeof(cTxt)); // v1.4
	memcpy(cTxt, cAccountPassword, 10);
	m_Misc.bDecode(cKey, cTxt);
	ZeroMemory(cAccountPassword, sizeof(cAccountPassword));
	memcpy(cAccountPassword, cTxt, 10);	
	bIsObserverMode = (BOOL)*cp;
	cp++;
	//Empty PC name
	if (strlen(cCharName) == 0) 
	{	ZeroMemory(cTempIP2, sizeof(cTempIP2));
		m_pClientList[iClientH]->m_pXSock->iGetPeerAddress(cTempIP2);
		wsprintf(G_cTxt, "<%d> Empty PC name.  Account(%s) Pwd(%s) IP(%s)"
			, iClientH
			, cAccountName
			, cAccountPassword
			, cTempIP2);		
		PutLogList(G_cTxt);
		wsprintf(G_cTxt, "Empty PC name:     PC(.......) Account(%s) Pwd(%s). \tIP(%s)"
			, cAccountName
			, cAccountPassword
			, cTempIP2);
		PutHackLogFileList(G_cTxt);
		//PutLogFileList(G_cTxt);	
		DeleteClient(iClientH, FALSE, FALSE);
		return;
	}
	// Prevents logging 2 characters from same account
	for (i = 1; i < DEF_MAXCLIENTS; i++)
	if (   (m_pClientList[i] != NULL) 
		&& (iClientH != i) 
		&& (memcmp(m_pClientList[i]->m_cAccountName, cAccountName, 10) == 0)) 
	{	// Check password
		// If psw is good, delete previous client
		if (memcmp(m_pClientList[i]->m_cAccountPassword, cAccountPassword, 10) == 0)  			
		{	ZeroMemory(cTempIP, sizeof(cTempIP));		
			ZeroMemory(cTempIP2, sizeof(cTempIP2));
			m_pClientList[i]->m_pXSock->iGetPeerAddress(cTempIP);
			m_pClientList[iClientH]->m_pXSock->iGetPeerAddress(cTempIP2);
			wsprintf(G_cTxt, "<%d> Duplicate account player! Deleted with data save : CharName(%s) AccntName(%s) IP(%s)"
				, i
				, m_pClientList[i]->m_cCharName
				, m_pClientList[i]->m_cAccountName
				, cTempIP);
			PutLogList(G_cTxt);
			// SNOOPY Logging this here as well
			wsprintf(G_cTxt, "Same account:      PC(%s) Account(%s) - Disconnected by PC(%s) from same account\tIP(%s) by IP(%s)"
				, m_pClientList[i]->m_cCharName
				, m_pClientList[i]->m_cAccountName
				, m_pClientList[iClientH]->m_cCharName
				, cTempIP
				, cTempIP2);
			PutHackLogFileList(G_cTxt);
			PutLogFileList(G_cTxt);
			DeleteClient(i, TRUE, TRUE, FALSE);	
		}else  // If pwd is wrong, Delete new client (the one with wrong pwd)
		{	wsprintf(G_cTxt, "Same account:      PC(%s) Account(%s) - PC(%s) tryed to disconnect with wrong pwd. \tIP(%s) by (%s)"
				, m_pClientList[i]->m_cCharName
				, m_pClientList[i]->m_cAccountName
				, m_pClientList[iClientH]->m_cCharName
				, cTempIP
				, cTempIP2);
			PutHackLogFileList(G_cTxt);	
			PutLogFileList(G_cTxt);
			memcpy(m_pClientList[iClientH]->m_cCharName, cCharName, 10);
			memcpy(m_pClientList[iClientH]->m_cAccountName, cAccountName, 10);
			memcpy(m_pClientList[iClientH]->m_cAccountPassword, cAccountPassword, 10);			
			DeleteClient(iClientH, FALSE, FALSE, FALSE);
			return;
	}	}		
	// Prevents login twice the same character name (same from same account or duplicated name) 
	//NB: if account is same, either client was deleted above.
	for (i = 1; i < DEF_MAXCLIENTS; i++)
	if (   (m_pClientList[i] != NULL) 
		&& (iClientH != i) 
		&& (memcmp(m_pClientList[i]->m_cCharName, cCharName, 10) == 0)) 
	{	ZeroMemory(cTempIP, sizeof(cTempIP));		
		ZeroMemory(cTempIP2, sizeof(cTempIP2));
		m_pClientList[i]->m_pXSock->iGetPeerAddress(cTempIP);
		m_pClientList[iClientH]->m_pXSock->iGetPeerAddress(cTempIP2);
		if (memcmp(m_pClientList[i]->m_cAccountPassword, cAccountPassword, 10) == 0)  				
		{	wsprintf(G_cTxt, "<%d> Duplicate player name! Deleted with data save : CharName(%s) IP(%s)"
				, i
				, m_pClientList[i]->m_cCharName
				, cTempIP);
			PutLogList(G_cTxt);
			// SNOOPY Logging this here as well
			//printf(G_cTxt, "Same account:      PC(%s) Account(%s) - PC(%s) tryed to disconect with wrong password \tIP(%s) by (%s)"
			wsprintf(G_cTxt, "Duplicate PC name: PC(%s) Account(%s) - Discon. by Account(%s)\tIP(%s) by IP(%s)"
				, m_pClientList[i]->m_cCharName
				, m_pClientList[i]->m_cAccountName
				, m_pClientList[iClientH]->m_cAccountName
				, cTempIP
				, cTempIP2);
			PutHackLogFileList(G_cTxt);
			PutLogFileList(G_cTxt);
			DeleteClient(i, TRUE, TRUE, FALSE);	
		}else  // If pwd is wrong, Delete new client (with wrong pwd)
			// Copy the info to client object
		{	wsprintf(G_cTxt, "Duplicate PC name: PC(%s) Account(%s) - Account(%s) tryed to log PC(%s) with wrong pwd. \tIP(%s) by IP(%s)"
				, m_pClientList[i]->m_cCharName
				, m_pClientList[i]->m_cAccountName
				, m_pClientList[iClientH]->m_cAccountName
				, m_pClientList[iClientH]->m_cCharName
				, cTempIP
				, cTempIP2);
			PutHackLogFileList(G_cTxt);
			PutLogFileList(G_cTxt);			
			memcpy(m_pClientList[iClientH]->m_cCharName, cCharName, 10);
			memcpy(m_pClientList[iClientH]->m_cAccountName, cAccountName, 10);
			memcpy(m_pClientList[iClientH]->m_cAccountPassword, cAccountPassword, 10);
			DeleteClient(iClientH, FALSE, FALSE);
			return;
		}
	}
	// copy log in info
	memcpy(m_pClientList[iClientH]->m_cCharName, cCharName, 10);
	memcpy(m_pClientList[iClientH]->m_cAccountName, cAccountName, 10);
	memcpy(m_pClientList[iClientH]->m_cAccountPassword, cAccountPassword, 10);	
	m_pClientList[iClientH]->m_bIsObserverMode = bIsObserverMode;		
	// Log Server
	bSendMsgToLS(MSGID_REQUEST_PLAYERDATA, iClientH);
	// Snoopy: Prevent sending MSGID_REQUEST_DATA 1st to crash gserver.
	m_pClientList[iClientH]->m_cInitProgress = 1;
}

// 05/22/2004 - Hypnotoad - sends client to proper location after dying
void CGame::RequestInitDataHandler(int iClientH, char * pData, char cKey)
{	char  * pBuffer = NULL;
	short * sp;
	DWORD * dwp;
	WORD  * wp;
	char  * cp, cPlayerName[11], cTxt[120]; 
	short sSummonPoints;
	int   * ip, i, iTotalItemA, iTotalItemB, iSize, iRet, iStats;
	SYSTEMTIME SysTime;
	if (m_pClientList[iClientH] == NULL) return;
	pBuffer = new char [DEF_MSGBUFFERSIZE+1];
	ZeroMemory(pBuffer, DEF_MSGBUFFERSIZE+1);
	cp = (char *)(pData + DEF_INDEX2_MSGTYPE + 2);
	ZeroMemory(cPlayerName, sizeof(cPlayerName));
	memcpy(cPlayerName, cp, 10);
	ZeroMemory(cTxt, sizeof(cTxt)); // v1.4
	memcpy(cTxt, cPlayerName, 10);
	m_Misc.bDecode(cKey, cTxt);
	ZeroMemory(cPlayerName, sizeof(cPlayerName));
	memcpy(cPlayerName, cTxt, 10);
	if (memcmp(m_pClientList[iClientH]->m_cCharName, cPlayerName, 10) != 0) 
	{	DeleteClient(iClientH, FALSE, TRUE);
		return;
	}
	dwp  = (DWORD *)(pBuffer + DEF_INDEX4_MSGID);
	*dwp = MSGID_PLAYERCHARACTERCONTENTS; 
	wp   = (WORD *) (pBuffer + DEF_INDEX2_MSGTYPE);
	*wp  = DEF_MSGTYPE_CONFIRM;
	cp = (char *)(pBuffer + DEF_INDEX2_MSGTYPE + 2);
	ip   = (int *)cp;
	*ip  = m_pClientList[iClientH]->m_iHP;
	cp  += 4;
	ip   = (int *)cp;
	*ip  = m_pClientList[iClientH]->m_iMP;
	cp  += 4;
	ip   = (int *)cp;
	*ip  = m_pClientList[iClientH]->m_iSP;
	cp  += 4;
	ip   = (int *)cp;
	*ip  = m_pClientList[iClientH]->m_iDefenseRatio;
	cp  += 4;
	ip   = (int *)cp;
	*ip  = m_pClientList[iClientH]->m_iHitRatio;
	cp  += 4;
	ip   = (int *)cp;
	*ip  = m_pClientList[iClientH]->m_iLevel;
	cp  += 4;
	ip   = (int *)cp;
	*ip  = m_pClientList[iClientH]->m_iStr;		
	cp  += 4;
	ip   = (int *)cp;
	*ip  = m_pClientList[iClientH]->m_iInt;					
	cp  += 4;
	ip   = (int *)cp;
	*ip  = m_pClientList[iClientH]->m_iVit;								
	cp  += 4;
	ip   = (int *)cp;
	*ip  = m_pClientList[iClientH]->m_iDex;			
	cp  += 4;
	ip   = (int *)cp;
	*ip  = m_pClientList[iClientH]->m_iMag;						
	cp  += 4;
	ip   = (int *)cp;
	*ip  = m_pClientList[iClientH]->m_iCharisma;
	cp  += 4;
	iStats = (m_pClientList[iClientH]->m_iStr + m_pClientList[iClientH]->m_iDex + m_pClientList[iClientH]->m_iVit +  
		m_pClientList[iClientH]->m_iInt + m_pClientList[iClientH]->m_iMag + m_pClientList[iClientH]->m_iCharisma); 
	m_pClientList[iClientH]->m_iLU_Pool =  m_pClientList[iClientH]->m_iLevel*3 - (iStats - 70);
	wp = (WORD *)cp; 
	//*wp = m_pClientList[iClientH]->m_iLevel*3 - (iStats - 70); 
	*wp = m_pClientList[iClientH]->m_iLU_Pool;
	cp += 2;
	if (m_bIsCrusadeMode == TRUE) 	
	{	*cp = (char) 1;
	}else if (m_bIsHeldenianMode == TRUE) 
	{	*cp = (char) 2;
	}else
	{	*cp = (char) 0;//
	}	
	//*cp = m_pClientList[iClientH]->m_cVar; //1: Crusade, 2: Heldenian	
	cp++;
	*cp = 0;
	cp++;
	*cp = 0;
	cp++;
	*cp = 0;
	cp++;
	*cp = 0;
	cp++;
	ip   = (int *)cp;
	*ip  = m_pClientList[iClientH]->m_iExp;
	cp  += 4;
	ip = (int *)cp;
	*ip  = m_pClientList[iClientH]->m_iEnemyKillCount;
	cp  += 4;
	ip = (int *)cp;
	*ip  = m_pClientList[iClientH]->m_iPKCount;
	cp  += 4;
	ip = (int *)cp;
	*ip  = m_pClientList[iClientH]->m_iRewardGold;
	cp  += 4;
	memcpy(cp, m_pClientList[iClientH]->m_cLocation, 10);
	cp  += 10;
	memcpy(cp, m_pClientList[iClientH]->m_cGuildName, 20);
	cp  += 20;
	ip   = (int *)cp;
	*ip  = m_pClientList[iClientH]->m_iGuildRank;
	cp  += 4;
	// v1.4311
	*cp = (char)m_pClientList[iClientH]->m_iSuperAttackLeft;
	cp++;
	ip   = (int *)cp;
	*ip  = m_pClientList[iClientH]->m_iFightzoneNumber;
	cp  += 4;

	//Syntax : ======HP==MP==SP==DRatHRatLVL=STR=INT=VIT=DEX=MAG=CHR=LUstatEXP=EK==PK==RewaLocation==GuildName=RankAF
	//Syntax : 1234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345
	//Syntax : ......145212521152........376.200=200=200=200=200=195=......big.8...17......aresden...NONE......NONE30
	//Debug Event
	//DbgWnd->AddEventMsg(MSG_SEND,pBuffer,180,0);
	iRet = m_pClientList[iClientH]->m_pXSock->iSendMsg(pBuffer, 118);// Original : 115

	switch (iRet) {
	case DEF_XSOCKEVENT_QUENEFULL:
	case DEF_XSOCKEVENT_SOCKETERROR:
	case DEF_XSOCKEVENT_CRITICALERROR:
	case DEF_XSOCKEVENT_SOCKETCLOSED:
		DeleteClient(iClientH, TRUE, TRUE);
		if(pBuffer != NULL) delete pBuffer;
		return;
	}

	dwp  = (DWORD *)(pBuffer + DEF_INDEX4_MSGID);
	*dwp = MSGID_PLAYERITEMLISTCONTENTS;
	wp   = (WORD *) (pBuffer + DEF_INDEX2_MSGTYPE);
	*wp  = DEF_MSGTYPE_CONFIRM;

	iTotalItemA = 0;
	for (i = 0; i < DEF_MAXITEMS; i++)
		if (m_pClientList[iClientH]->m_pItemList[i] != NULL) 
			iTotalItemA++;

	cp = (char *)(pBuffer + DEF_INDEX2_MSGTYPE + 2);
	*cp = iTotalItemA;
	cp++;
	for (i = 0; i < iTotalItemA; i++) 
		// ### ERROR POINT!!!
	{	if (m_pClientList[iClientH]->m_pItemList[i] == NULL) 
		{	wsprintf(G_cTxt, "RequestInitDataHandler error: Client(%s) Item(%d)"
				, m_pClientList[iClientH]->m_cCharName
				, i);
			PutLogList(G_cTxt);
			PutLogFileList(G_cTxt);
			DeleteClient(iClientH, FALSE, TRUE);
			if(pBuffer != NULL) delete pBuffer;
			return;
		}
		memcpy(cp, m_pClientList[iClientH]->m_pItemList[i]->m_cName, 20);
		cp += 20;
		dwp  = (DWORD *)cp;
		*dwp = m_pClientList[iClientH]->m_pItemList[i]->m_dwCount;
		cp += 4;
		*cp = m_pClientList[iClientH]->m_pItemList[i]->m_cItemType;
		cp++;
		*cp = m_pClientList[iClientH]->m_pItemList[i]->m_cEquipPos;
		cp++;
		*cp = (char)m_pClientList[iClientH]->m_bIsItemEquipped[i];
		cp++;
		sp  = (short *)cp;
		*sp = m_pClientList[iClientH]->m_pItemList[i]->m_sLevelLimit;
		cp += 2;
		*cp = m_pClientList[iClientH]->m_pItemList[i]->m_cGenderLimit;
		cp++;
		wp = (WORD *)cp;
		*wp = m_pClientList[iClientH]->m_pItemList[i]->m_wCurLifeSpan;
		cp += 2;
		wp = (WORD *)cp;
		*wp = m_pClientList[iClientH]->m_pItemList[i]->m_wWeight;
		cp += 2;
		sp  = (short *)cp;
		*sp = m_pClientList[iClientH]->m_pItemList[i]->m_sSprite;
		cp += 2;
		sp  = (short *)cp;
		*sp = m_pClientList[iClientH]->m_pItemList[i]->m_sSpriteFrame;
		cp += 2;
		*cp = m_pClientList[iClientH]->m_pItemList[i]->m_cItemColor; // v1.4
		cp++;
		*cp = (char)m_pClientList[iClientH]->m_pItemList[i]->m_sItemSpecEffectValue2; // v1.41 
		cp++;
		dwp =(DWORD *)cp;
		*dwp = m_pClientList[iClientH]->m_pItemList[i]->m_dwAttribute;
		cp += 4;
		/*
		*cp = (char)(m_pClientList[iClientH]->m_pItemList[i]->m_dwAttribute & 0x00000001); 
		// Custom-Item?
		cp++;
		*/
	}

	iTotalItemB = 0;
	for (i = 0; i < DEF_MAXBANKITEMS; i++)
		if (m_pClientList[iClientH]->m_pItemInBankList[i] != NULL) 
			iTotalItemB++;

	*cp = iTotalItemB;
	cp++;
	for (i = 0; i < iTotalItemB; i++) 
	{	if (m_pClientList[iClientH]->m_pItemInBankList[i] == NULL) 
		{	wsprintf(G_cTxt, "RequestInitDataHandler error: Client(%s) Bank-Item(%d)"
				, m_pClientList[iClientH]->m_cCharName
				, i);
			PutLogList(G_cTxt);
			PutLogFileList(G_cTxt);
			DeleteClient(iClientH, FALSE, TRUE);
			if(pBuffer != NULL) delete pBuffer;
			return;
		}
		memcpy(cp, m_pClientList[iClientH]->m_pItemInBankList[i]->m_cName, 20);
		cp += 20;
		dwp  = (DWORD *)cp;
		*dwp = m_pClientList[iClientH]->m_pItemInBankList[i]->m_dwCount;
		cp += 4;
		*cp = m_pClientList[iClientH]->m_pItemInBankList[i]->m_cItemType;
		cp++;
		*cp = m_pClientList[iClientH]->m_pItemInBankList[i]->m_cEquipPos;
		cp++;
		sp  = (short *)cp;
		*sp = m_pClientList[iClientH]->m_pItemInBankList[i]->m_sLevelLimit;
		cp += 2;
		*cp = m_pClientList[iClientH]->m_pItemInBankList[i]->m_cGenderLimit;
		cp++;
		wp = (WORD *)cp;
		*wp = m_pClientList[iClientH]->m_pItemInBankList[i]->m_wCurLifeSpan;
		cp += 2;
		wp = (WORD *)cp;
		*wp = m_pClientList[iClientH]->m_pItemInBankList[i]->m_wWeight;
		cp += 2;
		sp  = (short *)cp;
		*sp = m_pClientList[iClientH]->m_pItemInBankList[i]->m_sSprite;
		cp += 2;
		sp  = (short *)cp;
		*sp = m_pClientList[iClientH]->m_pItemInBankList[i]->m_sSpriteFrame;
		cp += 2;
		*cp = m_pClientList[iClientH]->m_pItemInBankList[i]->m_cItemColor; // v1.4
		cp++;
		*cp = (char)m_pClientList[iClientH]->m_pItemInBankList[i]->m_sItemSpecEffectValue2; // v1.41 
		cp++;
		dwp =(DWORD *)cp;
		*dwp = m_pClientList[iClientH]->m_pItemInBankList[i]->m_dwAttribute;
		cp += 4;
		/*
		*cp = (char)(m_pClientList[iClientH]->m_pItemInBankList[i]->m_dwAttribute & 0x00000001); // Custom-Item?Ã­Å¡â€œÃ­Å¡ÂÃ¬Â²Â ?Ã­Å¡â€° Ã¬Â©â€Ã¬Â§Â¤Ã¬Â¨ËœÃ­Å¡â€œ 
		cp++;
		*/
	}
	for (i = 0; i < DEF_MAXMAGICTYPE; i++) 
	{	*cp = m_pClientList[iClientH]->m_cMagicMastery[i];
		cp++;
	}
	for (i = 0; i < DEF_MAXSKILLTYPE; i++) 
	{	*cp = m_pClientList[iClientH]->m_cSkillMastery[i];
		cp++;
	}

	iRet = m_pClientList[iClientH]->m_pXSock->iSendMsg(pBuffer, 6 + 1 + iTotalItemA*44 + iTotalItemB*43 + DEF_MAXMAGICTYPE + DEF_MAXSKILLTYPE);
	switch (iRet) {
	case DEF_XSOCKEVENT_QUENEFULL:
	case DEF_XSOCKEVENT_SOCKETERROR:
	case DEF_XSOCKEVENT_CRITICALERROR:
	case DEF_XSOCKEVENT_SOCKETCLOSED:
		DeleteClient(iClientH, TRUE, TRUE);
		if(pBuffer != NULL) delete pBuffer;
		return;
	}
	dwp  = (DWORD *)(pBuffer + DEF_INDEX4_MSGID);
	*dwp = MSGID_RESPONSE_INITDATA;
	wp   = (WORD *)(pBuffer + DEF_INDEX2_MSGTYPE);
	*wp  = DEF_MSGTYPE_CONFIRM;
	cp = (char *)(pBuffer + DEF_INDEX2_MSGTYPE + 2);
	if (m_pClientList[iClientH]->m_bIsObserverMode == FALSE)
		bGetEmptyPosition(&m_pClientList[iClientH]->m_sX, &m_pClientList[iClientH]->m_sY, m_pClientList[iClientH]->m_cMapIndex);
	else GetMapInitialPoint(m_pClientList[iClientH]->m_cMapIndex, &m_pClientList[iClientH]->m_sX, &m_pClientList[iClientH]->m_sY);

	// ObjectID
	wp  = (WORD *)cp;
	*wp = iClientH;
	cp += 2;
	// ? (x, y) (x+14, y+12)
	sp  = (short *)cp;
	*sp = m_pClientList[iClientH]->m_sX - 14 - 5;
	cp += 2;
	sp  = (short *)cp;
	*sp = m_pClientList[iClientH]->m_sY - 12 - 5;
	cp += 2;
	sp  = (short *)cp;
	*sp = m_pClientList[iClientH]->m_sType;
	cp += 2;
	sp  = (short *)cp;
	*sp = m_pClientList[iClientH]->m_sAppr1;
	cp += 2;
	sp  = (short *)cp;
	*sp = m_pClientList[iClientH]->m_sAppr2;
	cp += 2;
	sp  = (short *)cp;
	*sp = m_pClientList[iClientH]->m_sAppr3;
	cp += 2;
	sp  = (short *)cp;
	*sp = m_pClientList[iClientH]->m_sAppr4;
	cp += 2;
	ip  = (int *)cp; // v1.4
	*ip = m_pClientList[iClientH]->m_iApprColor;
	cp += 4;
	ip  = (int *)cp;
	*ip = m_pClientList[iClientH]->m_iStatus;
	cp += 4;// Original : 2
	memcpy(cp, m_pClientList[iClientH]->m_cMapName, 10);
	cp += 10;
	memcpy(cp, m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cLocationName, 10);
	cp += 10;
	if (m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_bIsFixedDayMode == TRUE) 
	{	*cp = 1;
		cp++;
		*cp = NULL;
	}else 
	{	*cp = m_cDayOrNight;
		cp++;
		*cp = m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cWhetherStatus;
	}
	cp++;
	ip = (int *)cp;
	*ip = m_pClientList[iClientH]->m_iContribution;
	cp += 4;
	*cp = (char)m_pClientList[iClientH]->m_bIsObserverMode;
	cp++;
	if (m_pClientList[iClientH]->m_bIsObserverMode == FALSE) 
	{	m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->SetOwner(iClientH, 
			DEF_OWNERTYPE_PLAYER, 
			m_pClientList[iClientH]->m_sX, 
			m_pClientList[iClientH]->m_sY);
	}
	ip = (int *)cp;
	*ip = m_pClientList[iClientH]->m_iRating;
	cp += 4;
	ip = (int *)cp;
	*ip = m_pClientList[iClientH]->m_iHP;
	cp += 4;
	*cp = m_pClientList[iClientH]->m_cDiscount;	//m_cDiscount = (char )*cp; // 100=> Price +100%
	cp++;
	iSize = iComposeInitMapData(m_pClientList[iClientH]->m_sX - 10, m_pClientList[iClientH]->m_sY - 7, iClientH, cp );
	iRet = m_pClientList[iClientH]->m_pXSock->iSendMsg(pBuffer, 46 + iSize +4 +4 +1 +4 +4+3); // Zabuza fix
	switch (iRet) {
	case DEF_XSOCKEVENT_QUENEFULL:
	case DEF_XSOCKEVENT_SOCKETERROR:
	case DEF_XSOCKEVENT_CRITICALERROR:
	case DEF_XSOCKEVENT_SOCKETCLOSED:
		DeleteClient(iClientH, TRUE, TRUE);
		if(pBuffer != NULL) delete pBuffer;
		return;
	}
	if(pBuffer != NULL) delete pBuffer;
	SendEventToNearClient_TypeA(iClientH, DEF_OWNERTYPE_PLAYER, MSGID_EVENT_LOG, DEF_MSGTYPE_CONFIRM, NULL, NULL, NULL);

	m_pClientList[iClientH]->m_bIsWarLocation = FALSE;	
	m_pClientList[iClientH]->m_iTimeLeft_ForceRecall = 0;

	// set recall time in ennemy city (if not Equilibrium mode)
	if ( (m_pClientList[iClientH]->m_cSide == 1) 
		&& (memcmp(m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cLocationName, "elvine", 3) == 0)
		&& (m_pClientList[iClientH]->m_iAdminUserLevel == 0) 
		&& (!m_bMapModeEquilibrium)) 		
	{	m_pClientList[iClientH]->m_bIsWarLocation = TRUE;
		SetForceRecallTime(iClientH) ;
	// set recall time in ennemy city  (if not Equilibrium mode)
	}else if ( (m_pClientList[iClientH]->m_cSide == 2) 
			&& (memcmp(m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cLocationName, "aresden", 7) == 0)
			&& (m_pClientList[iClientH]->m_iAdminUserLevel == 0)
			&& (!m_bMapModeEquilibrium)) {		
		m_pClientList[iClientH]->m_bIsWarLocation = TRUE;
		SetForceRecallTime(iClientH) ;
	} // Set recall time if in Jail (5 minutes)
	else if (	(  (memcmp(m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cLocationName, "arejail", 7) == 0) 
				|| (memcmp(m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cLocationName, "elvjail", 7) == 0))
		     && (m_pClientList[iClientH]->m_iAdminUserLevel == 0))  
	{	m_pClientList[iClientH]->m_bIsWarLocation = TRUE;
		if (m_pClientList[iClientH]->m_iTimeLeft_ForceRecall == 0) 
		{	m_pClientList[iClientH]->m_iTimeLeft_ForceRecall = 20*5 ; // 5 minute
		}else if (m_pClientList[iClientH]->m_iTimeLeft_ForceRecall > 20*5) 
		{	m_pClientList[iClientH]->m_iTimeLeft_ForceRecall = 20*5 ; // 5 minute 
		}	 
	// Set recall Time from arenas
	}else if (   (m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_bIsFightZone == TRUE)
			&& (m_iFightzoneNoForceRecall == 0)
			&& (m_pClientList[iClientH]->m_iAdminUserLevel == 0))  				
	{	m_pClientList[iClientH]->m_bIsWarLocation = TRUE;
		GetLocalTime(&SysTime);						//   = 1h58 3h58 5h58 etc...
		m_pClientList[iClientH]->m_iTimeLeft_ForceRecall = 2*60*20 - ((SysTime.wHour%2)*20*60 + SysTime.wMinute*20) - 2*20; 
	}else // No special recall time features...
	{	m_pClientList[iClientH]->m_bIsWarLocation = FALSE;	
		m_pClientList[iClientH]->m_iTimeLeft_ForceRecall = 0;
		SetForceRecallTime(iClientH) ;
	}		
	// Logging in enemy shops => Set a very short recall time if Crusade or Standard Map settings
	if (   ((!m_bMapModeEquilibrium) || (m_bIsCrusadeMode == TRUE))
		&& (m_pClientList[iClientH]->m_cSide == iGetMapLocationForbiddenSide(m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cName)) 
		&& (m_pClientList[iClientH]->m_iAdminUserLevel == 0))  // Not in own town
	{	m_pClientList[iClientH]->m_bIsWarLocation = TRUE;
		m_pClientList[iClientH]->m_iTimeLeft_ForceRecall = 0;
	}
	// Looging in ennemy city at crusade recall the character if it's 1st crusade longon
	if (   (m_bIsCrusadeMode == TRUE) 		
		&& (m_pClientList[iClientH]->m_iAdminUserLevel == 0)
		&& (m_pClientList[iClientH]->m_dwCrusadeGUID != m_dwCrusadeGUID)) 
	{	if ( (m_pClientList[iClientH]->m_cSide == 1) 
			&& (memcmp(m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cLocationName, "elvine", 6) == 0)) 		
		{	m_pClientList[iClientH]->m_bIsWarLocation = TRUE;
			m_pClientList[iClientH]->m_iTimeLeft_ForceRecall = 0;
		}else if ( (m_pClientList[iClientH]->m_cSide == 2) 
			&& (memcmp(m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cLocationName, "aresden", 7) == 0)
			&& (m_pClientList[iClientH]->m_iAdminUserLevel == 0)
			&& (!m_bMapModeEquilibrium)) 
		{	m_pClientList[iClientH]->m_bIsWarLocation = TRUE;
			m_pClientList[iClientH]->m_iTimeLeft_ForceRecall = 0;			
	}	} 
	// Logging an executor in Crusade is not possible in cities or middleland
	if (   (m_bIsCrusadeMode == TRUE) 		
		&& (m_pClientList[iClientH]->m_iAdminUserLevel == 0)
		&& (m_pClientList[iClientH]->m_cSide == 4)) 
	{	if (   (memcmp(m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cLocationName, "aresden", 7) == 0)
			|| (memcmp(m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cLocationName, "elvine", 6) == 0)
			|| (memcmp(m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cLocationName, "middleland", 10) == 0))
		{	m_pClientList[iClientH]->m_bIsWarLocation = TRUE;
			m_pClientList[iClientH]->m_iTimeLeft_ForceRecall = 0;	
	}	}

	SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_SAFEATTACKMODE, NULL, NULL, NULL, NULL);
	SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_DOWNSKILLINDEXSET, m_pClientList[iClientH]->m_iDownSkillIndex, NULL, NULL, NULL);
	SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_ITEMPOSLIST, NULL, NULL, NULL, NULL);
	_SendQuestContents(iClientH);
	_CheckQuestEnvironment(iClientH);
	// v1.432
	if (m_pClientList[iClientH]->m_iSpecialAbilityTime == 0) 
	{	SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_SPECIALABILITYENABLED, NULL, NULL, NULL, NULL);
	}
	// Crusade 
	if (m_bIsCrusadeMode == TRUE) 
	{	if (m_pClientList[iClientH]->m_dwCrusadeGUID == 0) 
		{	m_pClientList[iClientH]->m_iCrusadeDuty = 0;
			m_pClientList[iClientH]->m_iConstructionPoint = 0;
			m_pClientList[iClientH]->m_dwCrusadeGUID = m_dwCrusadeGUID;
		}else if (m_pClientList[iClientH]->m_dwCrusadeGUID != m_dwCrusadeGUID) 
		{	m_pClientList[iClientH]->m_iCrusadeDuty       = 0;
			m_pClientList[iClientH]->m_iConstructionPoint = 0;
			m_pClientList[iClientH]->m_iWarContribution   = 0;
			m_pClientList[iClientH]->m_dwCrusadeGUID = m_dwCrusadeGUID;
			SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_CRUSADE, (DWORD)TRUE, 0, 0, NULL, -1);	//-1: last crusade finished	
		}
		m_pClientList[iClientH]->m_cVar = 1; // character have been informed of crusade starting...
		SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_CONSTRUCTIONPOINT, m_pClientList[iClientH]->m_iConstructionPoint, m_pClientList[iClientH]->m_iWarContribution, 1, NULL); // 1: Don't show to player
		SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_CRUSADE, (DWORD)m_bIsCrusadeMode, m_pClientList[iClientH]->m_iCrusadeDuty, 0, NULL, 0);
	// Heldenian
	}else if (m_bIsHeldenianMode == TRUE) 
	{	sSummonPoints = 10000 + m_pClientList[iClientH]->m_iCharisma*100;
		if (sSummonPoints > DEF_MAXHELDENIANSUMMONPOINT) sSummonPoints = (short)DEF_MAXHELDENIANSUMMONPOINT;
		if (m_pClientList[iClientH]->m_dwHeldenianGUID == NULL) 
		{	m_pClientList[iClientH]->m_dwHeldenianGUID    = m_dwHeldenianGUID;
			m_pClientList[iClientH]->m_iConstructionPoint = sSummonPoints;
			m_pClientList[iClientH]->m_iWarContribution   = 0;
			if (   (m_pMapList[m_pClientList[iClientH]->m_cMapIndex] != NULL) 
				&& (m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_bIsHeldenianMap == 1))
			{	// Player connecting on Heldenian map, and not been advised of Heldenian start will recall
				SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_0BE8, NULL , NULL, NULL, NULL);	
				m_pClientList[iClientH]->m_bIsWarLocation = TRUE;
				m_pClientList[iClientH]->m_iTimeLeft_ForceRecall = 3;
			}
		}else if (m_pClientList[iClientH]->m_dwHeldenianGUID != m_dwHeldenianGUID) 
		{	m_pClientList[iClientH]->m_dwHeldenianGUID    = m_dwHeldenianGUID;
			m_pClientList[iClientH]->m_iConstructionPoint = sSummonPoints;
			m_pClientList[iClientH]->m_iWarContribution   = 0;
			if (   (m_pMapList[m_pClientList[iClientH]->m_cMapIndex] != 0) 
				&& (m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_bIsHeldenianMap == 1))
			{	// Player connecting on Heldenian map, and not been advised of this Heldenian start will recall
				SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_0BE8, NULL , NULL, NULL, NULL);	
				m_pClientList[iClientH]->m_bIsWarLocation = TRUE;
				m_pClientList[iClientH]->m_iTimeLeft_ForceRecall = 3;
		}	}
		//UpdateHeldenianStatus(iClientH);
		if (m_cHeldenianWinner == -1) 
		{	if (m_bHeldenianWarInitiated == TRUE) 
			{	SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_HELDENIANSTART, NULL, NULL, NULL, NULL);
			}else
			{	SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_HELDENIANTELEPORT, NULL, NULL, NULL, NULL);
			}
		}else // Force recall loosers
		{	if (   (m_pClientList[iClientH]->m_cSide != m_cHeldenianWinner)
				&& (m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_bIsHeldenianMap == 1))
			{	m_pClientList[iClientH]->m_bIsWarLocation = TRUE;
				m_pClientList[iClientH]->m_iTimeLeft_ForceRecall = 2;
		}	}
		m_pClientList[iClientH]->m_cVar = 2;// character have been informed of heldenian starting...
		SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_CONSTRUCTIONPOINT, m_pClientList[iClientH]->m_iConstructionPoint, m_pClientList[iClientH]->m_iWarContribution, 1, NULL);
		UpdateHeldenianStatus(iClientH);	
	// The crusade he has participated is over
	}else if ( (m_pClientList[iClientH]->m_dwCrusadeGUID == m_dwCrusadeGUID)
			&& (m_pClientList[iClientH]->m_dwCrusadeGUID != NULL)) 
	{	m_pClientList[iClientH]->m_iCrusadeDuty = 0;
		m_pClientList[iClientH]->m_iConstructionPoint = 0;
		SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_CRUSADE, (DWORD)FALSE, 0, 0, NULL, -1); // crusade was finished
		m_pClientList[iClientH]->m_cVar = 0; // Character is informed of Crusade end... so he'll get XP....
	// The Heldenian he has participated is over...
	}else if ( (m_pClientList[iClientH]->m_dwHeldenianGUID == m_dwHeldenianGUID)
			&& (m_pClientList[iClientH]->m_dwHeldenianGUID != NULL)) 
	{	m_pClientList[iClientH]->m_iConstructionPoint = 0;
		SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_HELDENIANEND, NULL, NULL, NULL, NULL);
		m_pClientList[iClientH]->m_cVar = 0; // Character is informed of Hedenian end... so he'll get XP later
	}
	// The Avatar is running...
	if ( m_bIsAvatarMode == TRUE) 
	{	if (m_pClientList[iClientH]->m_dwAvatarGUID != m_dwAvatarGUID)
		{	m_pClientList[iClientH]->m_dwAvatarGUID = m_dwAvatarGUID;
			m_pClientList[iClientH]->m_iConstructionPoint = 0; // not the messenger!
			m_pClientList[iClientH]->m_iWarContribution   = 0; // reset xp
		}else
		{	m_pClientList[iClientH]->m_iConstructionPoint = 0; // not the messenger!
		}		
		SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_AVATAR, (DWORD)1, 0, 0, NULL, 0);
	}

	if (memcmp(m_pClientList[iClientH]->m_cMapName, "fightzone", 9) == 0) 
	{	wsprintf(G_cTxt, "Char(%s)-Enter(%s) Observer(%d)", m_pClientList[iClientH]->m_cCharName, m_pClientList[iClientH]->m_cMapName, m_pClientList[iClientH]->m_bIsObserverMode);
		PutLogEventFileList(G_cTxt);
	}
	//Fix Sprite Bug
	// SendEventToNearClient_TypeA(iClientH, DEF_OWNERTYPE_PLAYER, MSGID_EVENT_MOTION, DEF_OBJECTNULLACTION, NULL, NULL, NULL);

	//Gizon point left
	SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_GIZONITEMUPGRADELEFT, m_pClientList[iClientH]->m_iGizonItemUpgradeLeft, NULL, NULL, NULL);
	if (   (m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_nIsNotPermanentMap == TRUE)
		&& (m_pClientList[iClientH]->m_iAdminUserLevel == 0))
	{	if (   ( m_pClientList[iClientH]->m_cdwDecoTime == NULL)
			|| ((m_pClientList[iClientH]->m_cdwDecoTime +(60*1000)) < timeGetTime()) ) 
		{	m_pClientList[iClientH]->m_bIsWarLocation = TRUE;
			m_pClientList[iClientH]->m_iTimeLeft_ForceRecall = 0;
			wsprintf(G_cTxt,"<%d> Trying to log in a not-permanent map, recalled.  PC(%s) %d - %d"
				,iClientH 
				, m_pClientList[iClientH]->m_cCharName
				, (int)m_pClientList[iClientH]->m_cdwDecoTime
				, (int)timeGetTime()) ;
			PutLogList(G_cTxt) ;		
			PutLogFileList(G_cTxt);
	}	}
	
	// SNOOPY: Send gate positions if applicable.
	Notify_ApocalypseGateState(iClientH); 
	// Tell to client and log he's been advised
	if ((m_pClientList[iClientH]->m_iTimeLeft_ForceRecall > 0) && (m_pClientList[iClientH]->m_bIsWarLocation == TRUE)) 
	{	SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_FORCERECALLTIME,  m_pClientList[iClientH]->m_iTimeLeft_ForceRecall , NULL, NULL, NULL);
		wsprintf(G_cTxt,"PC(%s) Game Server Force Recall Time  %d (%d min)"
			, m_pClientList[iClientH]->m_cCharName
			, m_pClientList[iClientH]->m_iTimeLeft_ForceRecall
			, m_pClientList[iClientH]->m_iTimeLeft_ForceRecall/20) ;
		PutLogList(G_cTxt) ;
	}
}

CGame::iComposeInitMapData(short sX, short sY, int iClientH, char * pData)
{register int * ip, ix, iy, iSize, iTileExists;
 class CTile * pTileSrc, * pTile;
 unsigned char ucHeader;
 short * sp, * pTotal;
 int     iTemp, iTemp2;
 WORD  * wp;
 char  * cp;
 BOOL bTransparentInvi;

	if (m_pClientList[iClientH] == NULL) return 0;
	pTotal = (short *)pData;
	cp = (char *)(pData + 2);
	iSize = 2;
	iTileExists = 0;
	pTileSrc = (class CTile *)(m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_pTile + 
		                       (sX) + (sY)*m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_sSizeY);	
	for (iy = 0; iy < 16; iy++)
	for (ix = 0; ix < 21; ix++) 
	{	pTile = (class CTile *)(pTileSrc + ix + iy*m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_sSizeY);
		if (   (pTile->m_sOwner != NULL)   || (pTile->m_sDeadOwner != NULL) 
			|| (pTile->m_pItem[0] != NULL) || (pTile->m_sDynamicObjectType != NULL) ) 
		{	iTileExists++;
			sp = (short *)cp;
			*sp = ix;
			cp += 2;
			sp = (short *)cp;
			*sp = iy;
			cp += 2;
			iSize += 4;
			ucHeader = 0;
			if (pTile->m_sOwner != NULL) 
			{	if (pTile->m_cOwnerClass == DEF_OWNERTYPE_PLAYER)  
				{	if (m_pClientList[pTile->m_sOwner] != NULL) 
						ucHeader = ucHeader | 0x01;
					else pTile->m_sOwner = NULL;				
				}			
				if (pTile->m_cOwnerClass == DEF_OWNERTYPE_NPC)  
				{	if (m_pNpcList[pTile->m_sOwner] != NULL ) ucHeader = ucHeader | 0x01;
					else pTile->m_sOwner = NULL;			
			}	}
			if (pTile->m_sDeadOwner != NULL) 
			{	if (pTile->m_cDeadOwnerClass == DEF_OWNERTYPE_PLAYER) 
				{ 	if (m_pClientList[pTile->m_sDeadOwner] != NULL) ucHeader = ucHeader | 0x02;
					else pTile->m_sDeadOwner = NULL;
				}
				if (pTile->m_cDeadOwnerClass == DEF_OWNERTYPE_NPC) 
				{ 	if (m_pNpcList[pTile->m_sDeadOwner] != NULL) ucHeader = ucHeader | 0x02;
				   	else pTile->m_sDeadOwner = NULL;			
			}	}
			if (pTile->m_pItem[0] != NULL)				ucHeader = ucHeader | 0x04;
			if (pTile->m_sDynamicObjectType != NULL)    ucHeader = ucHeader | 0x08;
			*cp = ucHeader;
			cp++;
			iSize++;
			if ((ucHeader & 0x01) != 0)  // alive pc or npc
			{	switch (pTile->m_cOwnerClass) {
				case DEF_OWNERTYPE_PLAYER:	// Object ID number(Player) : 1~10000				
					sp  = (short *)cp;
					*sp	= pTile->m_sOwner;
					cp += 2;
					iSize += 2; 				
					sp  = (short *)cp;
					*sp	= m_pClientList[pTile->m_sOwner]->m_sType;	// object type
					cp += 2;
					iSize += 2;				
					*cp = m_pClientList[pTile->m_sOwner]->m_cDir;	// dir
					cp++;
					iSize++;				
					sp  = (short *)cp;
					*sp	= m_pClientList[pTile->m_sOwner]->m_sAppr1;	// Appearance1
					cp += 2;
					iSize += 2;				
					sp  = (short *)cp;
					*sp	= m_pClientList[pTile->m_sOwner]->m_sAppr2;	// Appearance2
					cp += 2;
					iSize += 2;				
					sp  = (short *)cp;
					*sp	= m_pClientList[pTile->m_sOwner]->m_sAppr3;	// Appearance3
					cp += 2;
					iSize += 2;				
					sp  = (short *)cp;
					*sp	= m_pClientList[pTile->m_sOwner]->m_sAppr4;	// Appearance4
					cp += 2;
					iSize += 2;				
					ip = (int *)cp;
					*ip = m_pClientList[pTile->m_sOwner]->m_iApprColor;	// v1.4 ApprColor
					cp += 4;
					iSize += 4;				
					ip  = (int *)cp;		// Status
					iTemp = m_pClientList[pTile->m_sOwner]->m_iStatus;
					iTemp = 0x0FFBFFFF & iTemp;//Original : sTemp = 0x0FFF & sTemp; 
					bTransparentInvi = FALSE;
					iTemp2 = iGetPlayerABSStatus(pTile->m_sOwner, iClientH, bTransparentInvi); 
					iTemp  = (iTemp | (iTemp2 << 28));//Original : 12
					if (bTransparentInvi == TRUE) 
					{	iTemp = (iTemp | 0x00040000);
					}
					*ip = iTemp;
					cp += 4;//Original 2
					iSize += 4;//Original 2				
					memcpy(cp, m_pClientList[pTile->m_sOwner]->m_cCharName, 10);	// Name
					cp    += 10;
					iSize += 10;
					break;
				
				case DEF_OWNERTYPE_NPC:	// Object ID number(NPC) : 10000~				
					sp  = (short *)cp;
					*sp	= pTile->m_sOwner + 10000;
					cp += 2;
					iSize += 2;				
					sp  = (short *)cp;
					*sp	= m_pNpcList[pTile->m_sOwner]->m_sType;	// object type
					cp += 2;
					iSize += 2;				
					*cp = m_pNpcList[pTile->m_sOwner]->m_cDir;	// dir
					cp++;
					iSize++;				
					sp  = (short *)cp;
					*sp	= m_pNpcList[pTile->m_sOwner]->m_sAppr2;	// Appr2
					cp += 2;
					iSize += 2;				
					ip  = (int *)cp;					
					iTemp = m_pNpcList[pTile->m_sOwner]->m_iStatus;	// Status
					iTemp = 0x0FFBFFFF & iTemp;//Original : sTemp = 0x0FFF & sTemp; 
					bTransparentInvi = FALSE;
					iTemp2 = iGetNpcRelationship(pTile->m_sOwner, iClientH, bTransparentInvi);
					if (bTransparentInvi == TRUE) iTemp = iTemp | 0x00040000;
					iTemp  = (iTemp | (iTemp2 << 28));//Original : 12
					*ip = iTemp;
					cp += 4;//Original 2
					iSize += 4;//Original 2				
					memcpy(cp, m_pNpcList[pTile->m_sOwner]->m_cName, 5);	// Name
					cp    += 5;
					iSize += 5;
					break;
				}//end switch
			}// if ((ucHeader & 0x01) != 0)
			if ((ucHeader & 0x02) != 0) {	// something dead/pretend here
				switch (pTile->m_cDeadOwnerClass) {
				case DEF_OWNERTYPE_PLAYER:
					// Object ID number : 1~10000
					sp  = (short *)cp;
					*sp	= pTile->m_sDeadOwner;
					cp += 2;
					iSize += 2;					// object type
					sp  = (short *)cp;
					*sp	= m_pClientList[pTile->m_sDeadOwner]->m_sType;
					cp += 2;
					iSize += 2;					// dir
					*cp = m_pClientList[pTile->m_sDeadOwner]->m_cDir;
					cp++;
					iSize++;					// Appearance1
					sp  = (short *)cp;
					*sp	= m_pClientList[pTile->m_sDeadOwner]->m_sAppr1;
					cp += 2;
					iSize += 2;					// Appearance2
					sp  = (short *)cp;
					*sp	= m_pClientList[pTile->m_sDeadOwner]->m_sAppr2;
					cp += 2;
					iSize += 2;					// Appearance3
					sp  = (short *)cp;
					*sp	= m_pClientList[pTile->m_sDeadOwner]->m_sAppr3;
					cp += 2;
					iSize += 2;					// Appearance4
					sp  = (short *)cp;
					*sp	= m_pClientList[pTile->m_sDeadOwner]->m_sAppr4;
					cp += 2;
					iSize += 2;					// v1.4 ApprColor
					ip = (int *)cp;
					*ip = m_pClientList[pTile->m_sDeadOwner]->m_iApprColor;
					cp += 4;
					iSize += 4;					// Status
					ip  = (int *)cp;					
					iTemp = m_pClientList[pTile->m_sDeadOwner]->m_iStatus;
					iTemp = 0x0FFBFFFF & iTemp;//Original : sTemp = 0x0FFF & sTemp; 
					bTransparentInvi = FALSE;				
					iTemp2 = iGetPlayerABSStatus(pTile->m_sDeadOwner, iClientH, bTransparentInvi);
					if (bTransparentInvi == TRUE) iTemp = (iTemp | 0x00040000);
					iTemp  = (iTemp | (iTemp2 << 28));//Original : 12
					*ip = iTemp;
					cp += 4;//Original 2
					iSize += 4;//Original 2
					memcpy(cp, m_pClientList[pTile->m_sDeadOwner]->m_cCharName, 10);
					cp    += 10;
					iSize += 10;
					break;
				
				case DEF_OWNERTYPE_NPC:	// Object ID number : 10000	~
					sp  = (short *)cp;
					*sp	= pTile->m_sDeadOwner + 10000;
					cp += 2;
					iSize += 2;	// object type
					sp  = (short *)cp;
					*sp	= m_pNpcList[pTile->m_sDeadOwner]->m_sType;
					cp += 2;
					iSize += 2;		// dir
					*cp = m_pNpcList[pTile->m_sDeadOwner]->m_cDir;
					cp++;
					iSize++;				// Appr2
					sp  = (short *)cp;
					*sp	= m_pNpcList[pTile->m_sDeadOwner]->m_sAppr2;
					cp += 2;
					iSize += 2;					// Status
					ip  = (int *)cp;					
					iTemp = m_pNpcList[pTile->m_sDeadOwner]->m_iStatus;
					iTemp = 0x0FFBFFFF & iTemp;					//Original : sTemp = 0x0FFF & sTemp; 
					bTransparentInvi = FALSE;
					iTemp2 = iGetNpcRelationship(pTile->m_sDeadOwner, iClientH, bTransparentInvi);
					if (bTransparentInvi == TRUE) iTemp = iTemp | 0x00040000;
					iTemp  = (iTemp | (iTemp2 << 28));//Original : 12
					*ip = iTemp;					//*sp = DEF_TEST;
					cp += 4;//Original 2
					iSize += 4;//Original 2					// Name
					memcpy(cp, m_pNpcList[pTile->m_sDeadOwner]->m_cName, 5);
					cp    += 5;
					iSize += 5;
					break;
				}
			}
			if (pTile->m_pItem[0] != NULL) 
			{	sp  = (short *)cp;
				*sp	= pTile->m_pItem[0]->m_sSprite;
				cp += 2;
				iSize += 2;
				sp  = (short *)cp;
				*sp	= pTile->m_pItem[0]->m_sSpriteFrame;
				cp += 2;
				iSize += 2;
				*cp = pTile->m_pItem[0]->m_cItemColor;
				cp++;
				iSize++;
			}
			if (pTile->m_sDynamicObjectType != NULL) 
			{	wp  = (WORD *)cp;
				*wp = pTile->m_wDynamicObjectID;
				cp += 2;
				iSize += 2;				
				sp  = (short *)cp;
				*sp	= pTile->m_sDynamicObjectType;
				cp += 2;
				iSize += 2;
			}
		} // Big if
	} // while(1)
	*pTotal = iTileExists;
	return iSize;
}

// SNOOPY: Hack will not be Disconnected instantlly...
void CGame::DelayedDeleteClient(int iClientH, BOOL bSave, BOOL bNotify, BOOL bCountLogout, BOOL bForceCloseConn)
{	if (m_pClientList[iClientH] == NULL) return;
	if ((bNotify == FALSE) || (m_pClientList[iClientH]->m_bIsInitComplete == FALSE))
	{	DeleteClient(iClientH, bSave, bNotify, bCountLogout, bForceCloseConn);
		return;
	}
	if (m_pClientList[iClientH]->m_cDelayedDeco == 1) return; // Already on DelayedDeleteClient process
	DWORD dwTime = timeGetTime();
	m_pClientList[iClientH]->m_dwTime = dwTime+1000; // prevent a TimeOut
	m_pClientList[iClientH]->m_cDelayedDeco = 1;	 // 1: Prevent processing client messages, 0: normal, 2: deco now
	dwTime += 5000;
	bRegisterDelayEvent(DEF_DELAYEVENTTYPE_DELETECLIENT, 0, dwTime, iClientH, DEF_OWNERTYPE_PLAYER
		, 0, 0, 0, (int) bSave, (int) bCountLogout, (int) bForceCloseConn);
	wsprintf(G_cTxt,"<%d> Client Delayed Disconn. : (%s)", iClientH, m_pClientList[iClientH]->m_cIPaddress);
	PutLogList(G_cTxt); 
}

// SNOOPY: Fixed For Party bug
void CGame::DeleteClient(int iClientH, BOOL bSave, BOOL bNotify, BOOL bCountLogout, BOOL bForceCloseConn)
{int i, iExH;
 char * cp, cData[120], cTmpMap[30];
 DWORD * dwp;
 WORD * wp;		 
 DWORD dwTime = timeGetTime();
	if (iClientH  < 1) return;
	if (m_pClientList[iClientH] == NULL) return;
	if (m_pClientList[iClientH]->m_cDelayedDeco == 1) return;// 1: Prevent delete while delayed

 int iClientMapIndex = m_pClientList[iClientH]->m_cMapIndex;
 int iFutureMapIndex = -1; // Stays -1 if current map is not on this server

 	// Avatar Anti-TP
	if (   (m_bIsAvatarMode == TRUE) && (m_iPLmapIndex != -1) && (m_iAvatarMessenger == iClientH)) 
		CheckIfRelicDrop(iClientH);	

	if (m_pClientList[iClientH]->m_bIsInitComplete == TRUE) 	
	{	for (i = 0; i < DEF_MAXMAPS; i++)// Retrieve Client MapIndex
		{	if (m_pMapList[i] != NULL) 
			{	if (memcmp(m_pMapList[i]->m_cName, m_pClientList[iClientH]->m_cMapName, 10) == 0) 
				{	iFutureMapIndex = i;
		}	}	}
		//printf(G_cTxt,"<%d> Client Delete now: (%s)  Account(%s)  PC(%s)  Lvl(%d)  PartyID(%d)"
		if (m_pClientList[iClientH]->m_bIsOnWaitingProcess  == TRUE)
		{	wsprintf(G_cTxt,"<%d> Client Delete now: (%s)  Account(%s)  PC(%s) - Going %s."
				, iClientH
				, m_pClientList[iClientH]->m_cIPaddress
				, m_pClientList[iClientH]->m_cAccountName
				, m_pClientList[iClientH]->m_cCharName
				, m_pClientList[iClientH]->m_cMapName); // MapName on future server
		}else
		{	wsprintf(G_cTxt,"<%d> Client Delete now: (%s)  Account(%s)  PC(%s) - Disconnected."
				, iClientH
				, m_pClientList[iClientH]->m_cIPaddress
				, m_pClientList[iClientH]->m_cAccountName
				, m_pClientList[iClientH]->m_cCharName);
		}
		PutLogList(G_cTxt); 
// Snoopy: added code to debug here.1st line...
		if (m_iPartyLog == TRUE) 
		{	wsprintf(G_cTxt, "Debug::DeleteClient: PC(%s) iClientH(%d) m_iPartyID(%d) bSave(%d) bNotify(%d) bCountLogout(%d) bForceCloseConn(%d)"
				, m_pClientList[iClientH]->m_cCharName
				, (int) iClientH
				, m_pClientList[iClientH]->m_iPartyID
				, (int) bSave
				, (int) bNotify
				, (int) bCountLogout
				, (int) bForceCloseConn);			
			PutPartyLogFileList(G_cTxt);
		}
// Snoopy: added code to debug here.2nd line...
		if (m_iPartyLog == TRUE) 
		{	wsprintf(G_cTxt, "Debug::DeleteClient: PC(%s) iClientH(%d) \t%s(%d %d)\tMap index(%d->%d)\tIP(%s)"
				, m_pClientList[iClientH]->m_cCharName
				, (int) iClientH
				, (int) m_pClientList[iClientH]->m_cMapName
				, m_pClientList[iClientH]->m_sX
				, m_pClientList[iClientH]->m_sY
				, iClientMapIndex
				, iFutureMapIndex
				, m_pClientList[iClientH]->m_cIPaddress);				
			PutPartyLogFileList(G_cTxt);
		}
		// Log special destination maps environments
		if (   (m_pClientList[iClientH]->m_bIsOnWaitingProcess == FALSE)// Client didn't ask TP to another to change server
			&& (m_pMapList[iClientMapIndex] != NULL))					// Current map is OK
		{	if (m_pMapList[iClientMapIndex]->m_nIsNotPermanentMap == TRUE)		
			{	if (m_pClientList[iClientH]->m_bIsKilled == FALSE)		// Client deco from NotPermanentMap	
				{	wsprintf(G_cTxt, "<%d> Client Disconnected from not-permanent map:(%s)  PC(%s)"
						, iClientH
						, m_pClientList[iClientH]->m_cMapName
						, m_pClientList[iClientH]->m_cCharName);		
				}else
				{	wsprintf(G_cTxt, "<%d> Client Dead on not-permanent map:(%s)  PC(%s)"
						, iClientH
						, m_pClientList[iClientH]->m_cMapName
						, m_pClientList[iClientH]->m_cCharName);				
				}
				PutLogEventFileList(G_cTxt);
			}else if (memcmp(m_pClientList[iClientH]->m_cMapName, "fight", 5) == 0) 
			{	if (m_pClientList[iClientH]->m_bIsKilled == FALSE)		// Client deco from Arenas
				{	wsprintf(G_cTxt, "<%d> Client Disconnected in Arena:(%s)  PC(%s)"
						, iClientH
						, m_pClientList[iClientH]->m_cMapName
						, m_pClientList[iClientH]->m_cCharName);
				}else
				{	wsprintf(G_cTxt, "<%d> Client Dead in Arena:(%s)  PC(%s)"
						, iClientH
						, m_pClientList[iClientH]->m_cMapName
						, m_pClientList[iClientH]->m_cCharName);
				}
				PutLogEventFileList(G_cTxt);
		}	}
		// If client dc from arena or temporary map, any attemps to loggin will work OK 
		// during next minute
		// if log in  after 1 minute the character will be force recalled...

		// Remove metamorphosis before deleting
		if (m_pClientList[iClientH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_METAMORPHOSIS ] != 0) 
		{	bRemoveFromDelayEventList(iClientH, DEF_OWNERTYPE_PLAYER, DEF_MAGICTYPE_METAMORPHOSIS);
			SetMetamorphosisFlag(iClientH, DEF_OWNERTYPE_PLAYER, FALSE);
		}
		if (m_pClientList[iClientH]->m_bIsExchangeMode == TRUE) 
		{	iExH = m_pClientList[iClientH]->m_iExchangeH;
			_ClearExchangeStatus(iExH);
			_ClearExchangeStatus(iClientH);
		}
		if ((m_pClientList[iClientH]->m_iAllocatedFish != NULL) && (m_pFish[m_pClientList[iClientH]->m_iAllocatedFish] != NULL)) 
			m_pFish[m_pClientList[iClientH]->m_iAllocatedFish]->m_sEngagingCount--;

		if (bNotify == TRUE)
			SendEventToNearClient_TypeA(iClientH, DEF_OWNERTYPE_PLAYER, MSGID_EVENT_LOG, DEF_MSGTYPE_REJECT, NULL, NULL, NULL);
		RemoveFromTarget(iClientH, DEF_OWNERTYPE_PLAYER);
		// Tell to clients whisping character
		for (i = 1; i < DEF_MAXCLIENTS; i++) 
		if ((m_pClientList[i] != NULL) && (m_pClientList[i]->m_iWhisperPlayerIndex	== iClientH)) 
		{	m_pClientList[i]->m_iWhisperPlayerIndex = -1;
			SendNotifyMsg(NULL, i, DEF_NOTIFY_WHISPERMODEOFF, NULL, NULL, NULL, m_pClientList[iClientH]->m_cCharName);
		}
		// SNOOPY: remove whisps
		ZeroMemory(cData, sizeof(cData));
		cp = (char *)cData;
		*cp = GSM_DISCONNECT;
		cp++;
		memcpy(cp, m_pClientList[iClientH]->m_cCharName, 10);
		cp += 10;
		bStockMsgToGateServer(cData, 11);

		m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->ClearOwner(2, iClientH, DEF_OWNERTYPE_PLAYER,
					m_pClientList[iClientH]->m_sX, 
					m_pClientList[iClientH]->m_sY);
		bRemoveFromDelayEventList(iClientH, DEF_OWNERTYPE_PLAYER, NULL);
	}

	// Real Logout SAVE data
	if ((bSave == TRUE) && (m_pClientList[iClientH]->m_bIsOnWaitingProcess == FALSE)) 
	{	// Real Logout, client is dead		
		if (m_pClientList[iClientH]->m_bIsKilled == TRUE) 
		{	m_pClientList[iClientH]->m_sX = -1;
			m_pClientList[iClientH]->m_sY = -1;
			m_pClientList[iClientH]->m_cdwDecoTime = NULL; // Will not be able to login a not-permenent map
			strcpy(cTmpMap,m_pClientList[iClientH]->m_cMapName) ;
			ZeroMemory(m_pClientList[iClientH]->m_cMapName, sizeof(m_pClientList[iClientH]->m_cMapName));

			// SNOOPY: New routine to determine restart location depanding on character side
			switch (m_pClientList[iClientH]->m_cSide) {
			case 0: // Travellers
				strcpy(m_pClientList[iClientH]->m_cMapName, "default");
				break;
			case 1: // Aresden
				if (m_bIsCrusadeMode == TRUE) 
				{	if (m_pClientList[iClientH]->m_iDeadPenaltyTime > 0) 
					{	ZeroMemory(m_pClientList[iClientH]->m_cLockedMapName, sizeof(m_pClientList[iClientH]->m_cLockedMapName));
						strcpy(m_pClientList[iClientH]->m_cLockedMapName, "aresden");
						m_pClientList[iClientH]->m_iLockedMapTime = 60*5;
						m_pClientList[iClientH]->m_iDeadPenaltyTime = 60*10;
					}
					else 
					{	m_pClientList[iClientH]->m_iDeadPenaltyTime = 60*10;
					}
				}
				if (strcmp(cTmpMap, "elvine") == 0)
				{	ZeroMemory(m_pClientList[iClientH]->m_cLockedMapName, sizeof(m_pClientList[iClientH]->m_cLockedMapName));
					strcpy(m_pClientList[iClientH]->m_cLockedMapName, "elvjail");
					m_pClientList[iClientH]->m_iLockedMapTime = 60*3 ;			// 3 min, forced recall 5 min
					memcpy(m_pClientList[iClientH]->m_cMapName, "elvjail", 7);
				}else 
				{	if (m_pClientList[iClientH]->m_iLevel > 80)
						 memcpy(m_pClientList[iClientH]->m_cMapName, "resurr1", 7);
					else memcpy(m_pClientList[iClientH]->m_cMapName, "arefarm", 7);
				}
				break;
			case 2 : // Elvines
				if (m_bIsCrusadeMode == TRUE) 
				{	if (m_pClientList[iClientH]->m_iDeadPenaltyTime > 0) 
					{	ZeroMemory(m_pClientList[iClientH]->m_cLockedMapName, sizeof(m_pClientList[iClientH]->m_cLockedMapName));
						strcpy(m_pClientList[iClientH]->m_cLockedMapName, "elvine");
						m_pClientList[iClientH]->m_iLockedMapTime   = 60*5;
						m_pClientList[iClientH]->m_iDeadPenaltyTime = 60*10;
					}else 
					{	m_pClientList[iClientH]->m_iDeadPenaltyTime = 60*10;
					}
				}
				if (strcmp(cTmpMap, "aresden") == 0)
				{	ZeroMemory(m_pClientList[iClientH]->m_cLockedMapName, sizeof(m_pClientList[iClientH]->m_cLockedMapName));
					strcpy(m_pClientList[iClientH]->m_cLockedMapName, "arejail");
					m_pClientList[iClientH]->m_iLockedMapTime = 60*3 ;			// 3 min, forced recall 5 min
					memcpy(m_pClientList[iClientH]->m_cMapName, "arejail", 7); 
				}else 
				{	if (m_pClientList[iClientH]->m_iLevel > 80)
						memcpy(m_pClientList[iClientH]->m_cMapName, "resurr2", 7);
					else memcpy(m_pClientList[iClientH]->m_cMapName, "elvfarm", 7);
				}
				break;
			case 4:  // Evil
			default: // or anything else
				switch(iDice(1,2)) {
				case 1:					
					strcpy(m_pClientList[iClientH]->m_cMapName, "resurr1");
					break;
				case 2:					
					strcpy(m_pClientList[iClientH]->m_cMapName, "resurr2");
					break;
				}
				if (strcmp(cTmpMap, "aresden") == 0)
				{	ZeroMemory(m_pClientList[iClientH]->m_cLockedMapName, sizeof(m_pClientList[iClientH]->m_cLockedMapName));
					strcpy(m_pClientList[iClientH]->m_cLockedMapName, "arejail");
					m_pClientList[iClientH]->m_iLockedMapTime = 60*3 ;
					ZeroMemory(m_pClientList[iClientH]->m_cMapName, sizeof(m_pClientList[iClientH]->m_cMapName));
					memcpy(m_pClientList[iClientH]->m_cMapName, "arejail", 7);
				}				
				if (strcmp(cTmpMap, "elvine") == 0)
				{	ZeroMemory(m_pClientList[iClientH]->m_cLockedMapName, sizeof(m_pClientList[iClientH]->m_cLockedMapName));
					strcpy(m_pClientList[iClientH]->m_cLockedMapName, "elvjail");
					m_pClientList[iClientH]->m_iLockedMapTime = 60*3 ;
					ZeroMemory(m_pClientList[iClientH]->m_cMapName, sizeof(m_pClientList[iClientH]->m_cMapName));
					memcpy(m_pClientList[iClientH]->m_cMapName, "elvjail", 7);
				}				
				if (strcmp(cTmpMap, "lost") == 0)
				{	ZeroMemory(m_pClientList[iClientH]->m_cLockedMapName, sizeof(m_pClientList[iClientH]->m_cLockedMapName));
					strcpy(m_pClientList[iClientH]->m_cLockedMapName, "elvjail");
					m_pClientList[iClientH]->m_iLockedMapTime = 60*3 ;
					ZeroMemory(m_pClientList[iClientH]->m_cMapName, sizeof(m_pClientList[iClientH]->m_cMapName));
					memcpy(m_pClientList[iClientH]->m_cMapName, "elvjail", 7);
				}
				break;
			}
		}else // client is alive, just log out... 
		{	m_pClientList[iClientH]->m_cdwDecoTime = dwTime; 		
			if (bForceCloseConn == TRUE) 	// real Logout, by admin order
			{	ZeroMemory(m_pClientList[iClientH]->m_cMapName, sizeof(m_pClientList[iClientH]->m_cMapName));
				memcpy(m_pClientList[iClientH]->m_cMapName, "bisle", 5);
				m_pClientList[iClientH]->m_sX = -1;
				m_pClientList[iClientH]->m_sY = -1;	
				ZeroMemory(m_pClientList[iClientH]->m_cLockedMapName, sizeof(m_pClientList[iClientH]->m_cLockedMapName));
				strcpy(m_pClientList[iClientH]->m_cLockedMapName, "bisle");
				m_pClientList[iClientH]->m_iLockedMapTime = 10*60;
		}	}
		if (m_pClientList[iClientH]->m_bIsObserverMode == TRUE) 
		{	ZeroMemory(m_pClientList[iClientH]->m_cMapName, sizeof(m_pClientList[iClientH]->m_cMapName));
			// SNOOPY: New routine to determine Observer location depanding on character side
			switch (m_pClientList[iClientH]->m_cSide) {
			case 1: // Aresden
					memcpy(m_pClientList[iClientH]->m_cMapName, "aresden", 7);
				break;
			case 2 : // Elvines
					memcpy(m_pClientList[iClientH]->m_cMapName, "elvine", 6);
				break;
			case 0:  // Travellers
			case 4:  // Evil
			default: // others
				switch (iDice(1,2)) {
				case 1:
					memcpy(m_pClientList[iClientH]->m_cMapName, "aresden", 7);
					break;
				case 2:
					memcpy(m_pClientList[iClientH]->m_cMapName, "elvine", 6);
					break;
				}
				break;
			}
			if (m_bMapModeEquilibrium)
			{	ZeroMemory(m_pClientList[iClientH]->m_cMapName, sizeof(m_pClientList[iClientH]->m_cMapName));
				memcpy(m_pClientList[iClientH]->m_cMapName, "lost", 4);				
			}
			m_pClientList[iClientH]->m_sX = -1;
			m_pClientList[iClientH]->m_sY = -1;
		}

		if (m_pClientList[iClientH]->m_bIsInitComplete == TRUE) 
		{	if (m_pClientList[iClientH]->m_iPartyID != NULL) 
			{	ZeroMemory(cData, sizeof(cData));
				cp = (char *)cData;
				dwp = (DWORD *)cp;
				*dwp = MSGID_PARTYOPERATION;
				cp += 4;
				wp = (WORD*)cp;
				*wp = 4; // 4: Withdraw from party
				cp += 2;
				wp = (WORD *)cp;
				*wp = iClientH;
				cp += 2;
				memcpy(cp, m_pClientList[iClientH]->m_cCharName, 10);
				cp += 10;
				wp = (WORD *)cp;
				*wp = m_pClientList[iClientH]->m_iPartyID;
				cp += 2;
				// Party message
				if (m_iPartyLog == TRUE) 
				{	wsprintf(G_cTxt, "<Msg4 -> Gate> (1-DeleteClient): PC(%s) iClientH(%d) m_iPartyID(%d) "
						, m_pClientList[iClientH]->m_cCharName
						, (int) iClientH
						, m_pClientList[iClientH]->m_iPartyID);					
					PutPartyLogFileList(G_cTxt);
				}
				SendMsgToGateServer(MSGID_PARTYOPERATION, iClientH, cData);
			}
			// Gate server is suposed to ask gservers to removed this client from party, in all party members
			// Ask to save player data and local tempory save if error
			if (bSendMsgToLS(MSGID_REQUEST_SAVEPLAYERDATALOGOUT, iClientH, bCountLogout) == FALSE) 
				LocalSavePlayerData(iClientH);
		}else bSendMsgToLS(MSGID_REQUEST_NOSAVELOGOUT, iClientH, bCountLogout); //Don't save if not InitComplete
	}else // No SAVE or not onServerChange
	{	if (m_pClientList[iClientH]->m_bIsOnWaitingProcess == FALSE) // => bSave == FALSE ....
		{	// Real LogOUT:
			// Strange case! Real logout and don't save players character !?!?!
	    	if (m_pClientList[iClientH]->m_bIsKilled == TRUE) 
			{	m_pClientList[iClientH]->m_cdwDecoTime = NULL; // Will not be able to login a not-permenent map
			}else
			{	m_pClientList[iClientH]->m_cdwDecoTime = dwTime;
			}
			if (m_pClientList[iClientH]->m_iPartyID != NULL) 
			{	ZeroMemory(cData, sizeof(cData));
				cp = (char *)cData;
				dwp = (DWORD *)cp;
				*dwp = MSGID_PARTYOPERATION;
				cp += 4;
				wp = (WORD*)cp;
				*wp = 4;// 4: Withdraw from party
				cp += 2;
				wp = (WORD *)cp;
				*wp = iClientH;
				cp += 2;
				memcpy(cp, m_pClientList[iClientH]->m_cCharName, 10);
				cp += 10;
				wp = (WORD *)cp;
				*wp = m_pClientList[iClientH]->m_iPartyID;
				cp += 2;
				// Party message
				if (m_iPartyLog == TRUE) 
				{	wsprintf(G_cTxt, "<Msg4 -> Gate> (2-DeleteClient): PC(%s) iClientH(%d) m_iPartyID(%d) "
						, m_pClientList[iClientH]->m_cCharName
						, (int) iClientH
						, m_pClientList[iClientH]->m_iPartyID);
					PutPartyLogFileList(G_cTxt);
				}
				SendMsgToGateServer(MSGID_PARTYOPERATION, iClientH, cData);
			}
			//m_pClientList[iClientH]->m_cdwDecoTime = dwTime; 
			bSendMsgToLS(MSGID_REQUEST_NOSAVELOGOUT, iClientH, bCountLogout);
		}else //bSave == TRUE, IsOnServerChange == TRUE
		// Not a real Logout, only changes SERVER
		{	if (m_pClientList[iClientH]->m_bIsKilled == TRUE) 
			{	m_pClientList[iClientH]->m_cdwDecoTime = NULL; // Will not be able to login a not-permenent map
			}else
			{	m_pClientList[iClientH]->m_cdwDecoTime = dwTime;
			}			
			if (m_pClientList[iClientH]->m_iPartyID != NULL) 
			{	ZeroMemory(cData, sizeof(cData));
				cp = (char *)cData;
				dwp = (DWORD *)cp;
				*dwp = MSGID_PARTYOPERATION;
				cp += 4;
				wp = (WORD*)cp;
				*wp = 7; // 7 : ??? Supose it asks the Gate serveur to dismiss the party in few seconds
				cp += 2;       // if client is not connected to another server
				wp = (WORD *)cp;
				*wp = NULL;
				cp += 2;
				memcpy(cp, m_pClientList[iClientH]->m_cCharName, 10);
				cp += 10;
				wp = (WORD *)cp;
				*wp = m_pClientList[iClientH]->m_iPartyID;
				cp += 2;
				// Party message
				if (m_iPartyLog == TRUE) 
				{	wsprintf(G_cTxt, "<Msg7 -> Gate> (3-DeleteClient): PC(%s) iClientH(%d) m_iPartyID(%d) "
						, m_pClientList[iClientH]->m_cCharName
						, (int) iClientH
						, m_pClientList[iClientH]->m_iPartyID);					
					PutPartyLogFileList(G_cTxt);
				}
				SendMsgToGateServer(MSGID_PARTYOPERATION, iClientH, cData);
				// I supose this messages asks the Gate server to wait for some confirmation then
				// senf a party dismiss msg if no gserver confirm reconnection off the client.
			}
			bSendMsgToLS(MSGID_REQUEST_SETACCOUNTWAITSTATUS, iClientH, FALSE); 
		}
	}
	// Remember erased clients
	for (i = 0; i < DEF_MAXCLIENTS; i++) 
	{	if ((m_stOldClientList[i].iClientH == 0)||((m_stOldClientList[i].m_dwDeleteTime + 60*1000) < dwTime ))
		{	m_stOldClientList[i].iClientH = iClientH;
			m_stOldClientList[i].m_dwDeleteTime = dwTime;
			ZeroMemory(m_stOldClientList[i].m_cCharName,        sizeof(m_stOldClientList[i].m_cCharName));
			ZeroMemory(m_stOldClientList[i].m_cAccountName,     sizeof(m_stOldClientList[i].m_cAccountName));
			ZeroMemory(m_stOldClientList[i].m_cAccountPassword, sizeof(m_stOldClientList[i].m_cAccountPassword));
			strcpy(m_stOldClientList[i].m_cCharName,           m_pClientList[iClientH]->m_cCharName);
			strcpy(m_stOldClientList[i].m_cAccountName,        m_pClientList[iClientH]->m_cAccountName);
			strcpy(m_stOldClientList[i].m_cAccountPassword,    m_pClientList[iClientH]->m_cAccountPassword);
			break;
	}	}
	delete m_pClientList[iClientH];
	m_pClientList[iClientH] = NULL;
	RemoveClientShortCut(iClientH);
	m_iTotalClients--;
}

void CGame::SendEventToNearClient_TypeA(short sOwnerH, char cOwnerType, DWORD dwMsgID, WORD wMsgType, short sV1, short sV2, short sV3)
{	int * ip, i, iRet, iShortCutIndex;
	char  * cp_a, * cp_s, * cp_sv, cData_All[200], cData_Srt[200], cData_Srt_Av[200];
	DWORD * dwp;
	WORD  * wp;
	int * ipStatus,iDumm;
	short * sp, sRange, sX, sY;
	BOOL  bFlag, cOwnerSend;
	char cKey;
	int iTemp3,iTemp,iTemp2;
	BOOL bTransparentInvi = FALSE;	
	
	ZeroMemory(cData_All, sizeof(cData_All));
	ZeroMemory(cData_Srt, sizeof(cData_Srt));
	ZeroMemory(cData_Srt_Av, sizeof(cData_Srt_Av));
	ipStatus = (int *)&iDumm;
	cKey = (rand() % 255) + 1;

	dwp  = (DWORD *)(cData_All + DEF_INDEX4_MSGID);
	*dwp = dwMsgID;
	wp   = (WORD *)(cData_All + DEF_INDEX2_MSGTYPE);
	*wp  = wMsgType;

	dwp  = (DWORD *)(cData_Srt + DEF_INDEX4_MSGID);
	*dwp = dwMsgID;
	wp   = (WORD *)(cData_Srt + DEF_INDEX2_MSGTYPE);
	*wp  = wMsgType;

	dwp  = (DWORD *)(cData_Srt_Av + DEF_INDEX4_MSGID);
	*dwp = dwMsgID;
	wp   = (WORD *)(cData_Srt_Av + DEF_INDEX2_MSGTYPE);
	*wp  = wMsgType;

	cp_a  = (char *)(cData_All + DEF_INDEX2_MSGTYPE + 2);
	cp_s  = (char *)(cData_Srt + DEF_INDEX2_MSGTYPE + 2);
	cp_sv = (char *)(cData_Srt_Av + DEF_INDEX2_MSGTYPE + 2);

	if ((dwMsgID == MSGID_EVENT_LOG) || (wMsgType == DEF_OBJECTMOVE) || (wMsgType == DEF_OBJECTRUN) || 
		(wMsgType == DEF_OBJECTATTACKMOVE) || (wMsgType == DEF_OBJECTDAMAGEMOVE) || (wMsgType == DEF_OBJECTDYING))
		sRange = 1;
	else sRange = 0;

	if (cOwnerType == DEF_OWNERTYPE_PLAYER) {
		if (m_pClientList[sOwnerH] == NULL) return;

		switch(wMsgType){
			case DEF_OBJECTNULLACTION:
			case DEF_OBJECTDAMAGE:
			case DEF_OBJECTDYING:
			case DEF_MSGTYPE_CONFIRM:
				cOwnerSend = TRUE;
				break;
			default:
				cOwnerSend = FALSE;
				break;
		}
		//cData_All
		wp  = (WORD *)cp_a;
		*wp = sOwnerH;
		cp_a += 2;
		sp  = (short *)cp_a;
		sX  = m_pClientList[sOwnerH]->m_sX;
		*sp = sX;
		cp_a += 2;
		sp  = (short *)cp_a;
		sY  = m_pClientList[sOwnerH]->m_sY;
		*sp = sY;
		cp_a += 2;
		sp  = (short *)cp_a;
		*sp = m_pClientList[sOwnerH]->m_sType;
		cp_a += 2;
		*cp_a = m_pClientList[sOwnerH]->m_cDir;
		cp_a++;
		memcpy(cp_a, m_pClientList[sOwnerH]->m_cCharName, 10);
		cp_a += 10;
		sp  = (short *)cp_a;
		*sp = m_pClientList[sOwnerH]->m_sAppr1;
		cp_a += 2;
		sp  = (short *)cp_a;
		*sp = m_pClientList[sOwnerH]->m_sAppr2;
		cp_a += 2;
		sp  = (short *)cp_a;
		*sp = m_pClientList[sOwnerH]->m_sAppr3;
		cp_a += 2;
		sp  = (short *)cp_a;
		*sp = m_pClientList[sOwnerH]->m_sAppr4;
		cp_a += 2;
		ip = (int *)cp_a;
		*ip = m_pClientList[sOwnerH]->m_iApprColor;
		cp_a += 4;
		ip  = (int *)cp_a;
		ipStatus = ip; // note this pointer to later change m_iStatus value
		*ip = m_pClientList[sOwnerH]->m_iStatus;
		cp_a += 4;
		iTemp3 = m_pClientList[sOwnerH]->m_iStatus & 0x0F0FFFF7F; //0F0FFFF7Fh
		// Hide illusion, DefShield, PFM, PFA,Poisonned information
		// Do not hide invi, zerk, ice, weaponspeed, slates, inhibcasting, illu mvt, hero
		if (wMsgType == DEF_OBJECTNULLACTION) 
		{	if (m_pClientList[sOwnerH]->m_bIsKilled == TRUE)
				*cp_a = 1; 
			else *cp_a = 0; 
		}else *cp_a = 0;
		cp_a++;
		//cData_Srt
		wp  = (WORD *)cp_s;
		*wp = sOwnerH + 30000;
		cp_s += 2;
		*cp_s = m_pClientList[sOwnerH]->m_cDir;
		cp_s++;
		*cp_s = (unsigned char)sV1;
		cp_s++;
		*cp_s = (unsigned char)sV2;
		cp_s++;
		sp  = (short *)cp_s;
		sX  = m_pClientList[sOwnerH]->m_sX;
		*sp = sX;
		cp_s += 2;
		sp  = (short *)cp_s;
		sY  = m_pClientList[sOwnerH]->m_sY;
		*sp = sY;
		cp_s += 2;
		//cData_Srt_Av
		wp  = (WORD *)cp_sv;
		*wp = sOwnerH + 30000;
		cp_sv += 2;
		*cp_sv = m_pClientList[sOwnerH]->m_cDir;
		cp_sv++;
		*cp_sv = sV1 - sX;
		cp_sv++;
		*cp_sv = sV2 - sY;
		cp_sv++;
		sp  = (short *)cp_sv;
		*sp = sV3;
		cp_sv += 2;
		bFlag = TRUE;
		iShortCutIndex = 0;

		while(bFlag){
			i = m_iClientShortCut[iShortCutIndex];
			iShortCutIndex++;
			if (i == 0) bFlag = FALSE;				
				if ((bFlag == TRUE) && (m_pClientList[i] != NULL) && (m_pClientList[i]->m_bIsInitComplete == TRUE))
				if ((m_pClientList[i]->m_cMapIndex == m_pClientList[sOwnerH]->m_cMapIndex) &&
					(m_pClientList[i]->m_sX >= m_pClientList[sOwnerH]->m_sX - 10 - sRange) &&
					(m_pClientList[i]->m_sX <= m_pClientList[sOwnerH]->m_sX + 10 + sRange) &&
					(m_pClientList[i]->m_sY >= m_pClientList[sOwnerH]->m_sY - 8 - sRange) &&
					(m_pClientList[i]->m_sY <= m_pClientList[sOwnerH]->m_sY + 8 + sRange) ) 
				{	/*//If player not same side and is invied (Beholder Hack)
					if (m_pClientList[sOwnerH] != NULL && i != sOwnerH)
						if ((m_pClientList[i]->m_cSide != m_pClientList[sOwnerH]->m_cSide) &&
							((m_pClientList[sOwnerH]->m_iStatus & 0x00000010) != 0)) {
							if(wMsgType == DEF_OBJECTRUN || wMsgType == DEF_OBJECTMOVE || wMsgType == DEF_OBJECTSTOP || wMsgType == DEF_OBJECTGETITEM)
								if we filter attacking
								[KLKS] - http://xtremehb.com -> Play Abaddon (PRO ARESDEN) says:
								the poor guy who's being attacked wont know what hit him
						continue;
					}*/									
						if (m_pClientList[sOwnerH]->m_cSide != m_pClientList[i]->m_cSide) 
						{	if ( m_pClientList[i]->m_iAdminUserLevel > 0)// do not hide for GMs	
							{	iTemp = m_pClientList[sOwnerH]->m_iStatus;
							}else if (i != sOwnerH)	// iTemp3 Hides illusion, DefShield, PFM, PFA,Poisonned information								
								{	iTemp = iTemp3;
								}else 
								{	iTemp = m_pClientList[sOwnerH]->m_iStatus;
								}
						}else
						{	iTemp = m_pClientList[sOwnerH]->m_iStatus;	//iTemp = 0x0FFFFFFF;
						}	
						// SNOOPY If same Party, show auras	
						if (   (m_pClientList[i]->m_iPartyID != NULL) 
							&& (m_pClientList[sOwnerH]->m_iPartyID != NULL) )
						{	if ( m_pClientList[i]->m_iPartyID == m_pClientList[sOwnerH]->m_iPartyID)
							{	iTemp = m_pClientList[sOwnerH]->m_iStatus;
							}
						}
						//iTemp = m_pClientList[sOwnerH]->m_iStatus;
						iTemp = 0x0FFBFFFF & iTemp;
						bTransparentInvi = FALSE;
						iTemp2 = iGetPlayerABSStatus(sOwnerH, i, bTransparentInvi);
						if (bTransparentInvi == TRUE) iTemp = (iTemp | 0x00040000);
						iTemp  = (iTemp | (iTemp2 << 28));
						*ipStatus = iTemp;
						if ( (m_pClientList[i]->m_sX >= m_pClientList[sOwnerH]->m_sX - 9) &&
							(m_pClientList[i]->m_sX <= m_pClientList[sOwnerH]->m_sX + 9) &&
							(m_pClientList[i]->m_sY >= m_pClientList[sOwnerH]->m_sY - 7) &&
							(m_pClientList[i]->m_sY <= m_pClientList[sOwnerH]->m_sY + 7) ) 
							{	switch (wMsgType) {// Objets is in player's screen
									case DEF_MSGTYPE_CONFIRM:
									case DEF_MSGTYPE_REJECT:
									case DEF_OBJECTNULLACTION:
										if (cOwnerSend == TRUE) 
											iRet = m_pClientList[i]->m_pXSock->iSendMsg(cData_All, 43, cKey);
										else
											if (i != sOwnerH)
												iRet = m_pClientList[i]->m_pXSock->iSendMsg(cData_All, 43, cKey);
										break;

									case DEF_OBJECTATTACK:
									case DEF_OBJECTATTACKMOVE:
										if (cOwnerSend == TRUE) 
											iRet = m_pClientList[i]->m_pXSock->iSendMsg(cData_Srt_Av, 13, cKey);
										else
											if (i != sOwnerH)
												iRet = m_pClientList[i]->m_pXSock->iSendMsg(cData_Srt_Av, 13, cKey);
										break;

									case DEF_OBJECTMAGIC:
									case DEF_OBJECTDAMAGE:
									case DEF_OBJECTDAMAGEMOVE:
										if (cOwnerSend == TRUE) 
											iRet = m_pClientList[i]->m_pXSock->iSendMsg(cData_Srt, 11, cKey);
										else
											if (i != sOwnerH)
												iRet = m_pClientList[i]->m_pXSock->iSendMsg(cData_Srt, 11, cKey);
										break;

									case DEF_OBJECTDYING:
										if (cOwnerSend == TRUE) 
											iRet = m_pClientList[i]->m_pXSock->iSendMsg(cData_Srt, 15, cKey);
										else
											if (i != sOwnerH)
												iRet = m_pClientList[i]->m_pXSock->iSendMsg(cData_Srt, 15, cKey);
										break;

									default:
										if (cOwnerSend == TRUE) 
											iRet = m_pClientList[i]->m_pXSock->iSendMsg(cData_Srt, 9, cKey);
										else
											if (i != sOwnerH)
												iRet = m_pClientList[i]->m_pXSock->iSendMsg(cData_Srt, 9, cKey);
										break;
								} //Switch
							} // If 
						else {
							switch (wMsgType) { // Object's outside player's screen
								case DEF_MSGTYPE_CONFIRM:
								case DEF_MSGTYPE_REJECT:
								case DEF_OBJECTNULLACTION:
									if (cOwnerSend == TRUE) 
										iRet = m_pClientList[i]->m_pXSock->iSendMsg(cData_All, 43, cKey);
									else
										if (i != sOwnerH)
											iRet = m_pClientList[i]->m_pXSock->iSendMsg(cData_All, 43, cKey);
									break;

								case DEF_OBJECTATTACK:
								case DEF_OBJECTATTACKMOVE:
									if (cOwnerSend == TRUE) 
										iRet = m_pClientList[i]->m_pXSock->iSendMsg(cData_Srt_Av, 13, cKey);
									else
										if (i != sOwnerH)
											iRet = m_pClientList[i]->m_pXSock->iSendMsg(cData_Srt_Av, 13, cKey);
									break;

								case DEF_OBJECTMAGIC:
								case DEF_OBJECTDAMAGE:
								case DEF_OBJECTDAMAGEMOVE:
									if (cOwnerSend == TRUE) 
										iRet = m_pClientList[i]->m_pXSock->iSendMsg(cData_Srt, 11, cKey);
									else
										if (i != sOwnerH)
											iRet = m_pClientList[i]->m_pXSock->iSendMsg(cData_Srt, 11, cKey);
									break;

								case DEF_OBJECTDYING:
									if (cOwnerSend == TRUE) 
										iRet = m_pClientList[i]->m_pXSock->iSendMsg(cData_Srt, 15, cKey);
									else
										if (i != sOwnerH)
											iRet = m_pClientList[i]->m_pXSock->iSendMsg(cData_Srt, 15, cKey);
									break;

								default:// DEF_OBJECTMOVE, DEF_OBJECTSTOP, DEF_OBJECTRUN, DEF_OBJECTGETITEM,
									if (cOwnerSend == TRUE) 
										iRet = m_pClientList[i]->m_pXSock->iSendMsg(cData_All, 43, cKey);
									else
										if (i != sOwnerH)
											iRet = m_pClientList[i]->m_pXSock->iSendMsg(cData_All, 43, cKey);
									break;
							} //Switch
						} //else
					} // If 1
		} //While finish
	} //Finish Player
	else { // Build npc object data
		if (m_pNpcList[sOwnerH] == NULL) return;
		wp  = (WORD *)cp_a;
		*wp = sOwnerH + 10000;
		cp_a += 2;
		sp  = (short *)cp_a;
		sX  = m_pNpcList[sOwnerH]->m_sX;
		*sp = sX;
		cp_a += 2;
		sp  = (short *)cp_a;
		sY  = m_pNpcList[sOwnerH]->m_sY;
		*sp = sY;
		cp_a += 2;
		sp  = (short *)cp_a;
		*sp = m_pNpcList[sOwnerH]->m_sType;
		cp_a += 2;
		*cp_a = m_pNpcList[sOwnerH]->m_cDir;
		cp_a++;
		memcpy(cp_a, m_pNpcList[sOwnerH]->m_cName, 5);
		cp_a += 5;
		sp  = (short *)cp_a;
		*sp = m_pNpcList[sOwnerH]->m_sAppr2;
		cp_a += 2;
		ip  = (int *)cp_a;
		ipStatus = ip;
		*ip = m_pNpcList[sOwnerH]->m_iStatus; 
		cp_a += 4;
		if (wMsgType == DEF_OBJECTNULLACTION) 
		{	if (m_pNpcList[sOwnerH]->m_bIsKilled == TRUE)
				*cp_a = 1; 
			else *cp_a = 0;
		}
		else *cp_a = 0;
		cp_a++;
		wp  = (WORD *)cp_s;
		*wp = sOwnerH + 40000;
		cp_s += 2;
		*cp_s = m_pNpcList[sOwnerH]->m_cDir;
		cp_s++;
		*cp_s = (unsigned char)sV1;
		cp_s++;
		*cp_s = (unsigned char)sV2;
		cp_s++;
		sp  = (short *)cp_s;
		sX  = m_pNpcList[sOwnerH]->m_sX;
		*sp = sX;
		cp_s += 2;
		sp  = (short *)cp_s;
		sY  = m_pNpcList[sOwnerH]->m_sY;
		*sp = sY;
		cp_s += 2;

		wp  = (WORD *)cp_sv;
		*wp = sOwnerH + 40000;
		cp_sv += 2;
		*cp_sv = m_pNpcList[sOwnerH]->m_cDir;
		cp_sv++;
		*cp_sv = sV1 - sX;
		cp_sv++;
		*cp_sv = sV2 - sY;
		cp_sv++;
		sp  = (short *)cp_sv;
		*sp = sV3;
		cp_sv += 2;

		bFlag = TRUE;
		iShortCutIndex = 0;

		while(bFlag){

			i = m_iClientShortCut[iShortCutIndex];
			iShortCutIndex++;
			if (i == 0) bFlag = FALSE;

			if ((bFlag == TRUE) && (m_pClientList[i] != NULL))

				if ( (m_pClientList[i]->m_cMapIndex == m_pNpcList[sOwnerH]->m_cMapIndex) &&
					(m_pClientList[i]->m_sX >= m_pNpcList[sOwnerH]->m_sX - 10 - sRange) &&
					(m_pClientList[i]->m_sX <= m_pNpcList[sOwnerH]->m_sX + 10 + sRange) &&
					(m_pClientList[i]->m_sY >= m_pNpcList[sOwnerH]->m_sY - 8 - sRange) &&
					(m_pClientList[i]->m_sY <= m_pNpcList[sOwnerH]->m_sY + 8 + sRange) ) 
				{	// npc objetc is in player's screen
					iTemp = *ipStatus;
					iTemp = 0x0FFBFFFF & iTemp;
					bTransparentInvi = FALSE;
					iTemp2 = iGetNpcRelationship(sOwnerH, i, bTransparentInvi);
					if (bTransparentInvi == TRUE) iTemp = iTemp | 0x00040000;
					iTemp  = (iTemp | (iTemp2 << 28));
					*ipStatus = iTemp;

					if ( (m_pClientList[i]->m_sX >= m_pNpcList[sOwnerH]->m_sX - 9) &&
						(m_pClientList[i]->m_sX <= m_pNpcList[sOwnerH]->m_sX + 9) &&
						(m_pClientList[i]->m_sY >= m_pNpcList[sOwnerH]->m_sY - 7) &&
						(m_pClientList[i]->m_sY <= m_pNpcList[sOwnerH]->m_sY + 7) ) 
					{	switch (wMsgType) {
						case DEF_MSGTYPE_CONFIRM:
						case DEF_MSGTYPE_REJECT:
						case DEF_OBJECTNULLACTION:
							iRet = m_pClientList[i]->m_pXSock->iSendMsg(cData_All, 27,cKey);
							break;

						case DEF_OBJECTDYING:
							iRet = m_pClientList[i]->m_pXSock->iSendMsg(cData_Srt, 15, cKey);
							break;

						case DEF_OBJECTDAMAGE:
						case DEF_OBJECTDAMAGEMOVE:
							iRet = m_pClientList[i]->m_pXSock->iSendMsg(cData_Srt, 11, cKey);
							break;

						case DEF_OBJECTATTACK:
						case DEF_OBJECTATTACKMOVE:
							iRet = m_pClientList[i]->m_pXSock->iSendMsg(cData_Srt_Av, 13, cKey);
							break;

						default: // DEF_OBJECTMOVE, DEF_OBJECTSTOP, DEF_OBJECTRUN, DEF_OBJECTMAGIC
								 // DEF_OBJECTGETITEM,
							iRet = m_pClientList[i]->m_pXSock->iSendMsg(cData_Srt, 9, cKey);
							break;
						} //Switch
					}else // npc object is outside player's screen
					{	switch (wMsgType) {
						case DEF_MSGTYPE_CONFIRM:
						case DEF_MSGTYPE_REJECT:
						case DEF_OBJECTNULLACTION:
							iRet = m_pClientList[i]->m_pXSock->iSendMsg(cData_All, 27,cKey);
							break;

						case DEF_OBJECTDYING:
							iRet = m_pClientList[i]->m_pXSock->iSendMsg(cData_Srt, 15, cKey);
							break;

						case DEF_OBJECTDAMAGE:
						case DEF_OBJECTDAMAGEMOVE:
							iRet = m_pClientList[i]->m_pXSock->iSendMsg(cData_Srt, 11, cKey);
							break;

						case DEF_OBJECTATTACK:
						case DEF_OBJECTATTACKMOVE:
							iRet = m_pClientList[i]->m_pXSock->iSendMsg(cData_Srt_Av, 13, cKey);
							break;

						default:
							iRet = m_pClientList[i]->m_pXSock->iSendMsg(cData_All, 27, cKey);
							break;

						} //Switch
					}
				}
		}
	} // else - NPC
}

// Snoopy: This version sends back info to concerned client as well as to others
// Needed to Show StormBringer auto-Attack feature
void CGame::SendEventToNearClient_TypeASelf(short sOwnerH, char cOwnerType, DWORD dwMsgID, WORD wMsgType, short sV1, short sV2, short sV3)
{	int * ip, i, iRet, iShortCutIndex;
	char  * cp_a, * cp_s, * cp_sv, cData_All[200], cData_Srt[200], cData_Srt_Av[200];
	DWORD * dwp;
	WORD  * wp;
	int * ipStatus,iDumm;
	short * sp, sRange, sX, sY;
	BOOL  bFlag, cOwnerSend;
	char cKey;
	int iTemp3,iTemp,iTemp2;
	BOOL bTransparentInvi = FALSE;	
	
	ZeroMemory(cData_All, sizeof(cData_All));
	ZeroMemory(cData_Srt, sizeof(cData_Srt));
	ZeroMemory(cData_Srt_Av, sizeof(cData_Srt_Av));
	ipStatus = (int *)&iDumm;
	cKey = (rand() % 255) + 1;
	dwp  = (DWORD *)(cData_All + DEF_INDEX4_MSGID);
	*dwp = dwMsgID;
	wp   = (WORD *)(cData_All + DEF_INDEX2_MSGTYPE);
	*wp  = wMsgType;
	dwp  = (DWORD *)(cData_Srt + DEF_INDEX4_MSGID);
	*dwp = dwMsgID;
	wp   = (WORD *)(cData_Srt + DEF_INDEX2_MSGTYPE);
	*wp  = wMsgType;
	dwp  = (DWORD *)(cData_Srt_Av + DEF_INDEX4_MSGID);
	*dwp = dwMsgID;
	wp   = (WORD *)(cData_Srt_Av + DEF_INDEX2_MSGTYPE);
	*wp  = wMsgType;
	cp_a  = (char *)(cData_All + DEF_INDEX2_MSGTYPE + 2);
	cp_s  = (char *)(cData_Srt + DEF_INDEX2_MSGTYPE + 2);
	cp_sv = (char *)(cData_Srt_Av + DEF_INDEX2_MSGTYPE + 2);

	if ((dwMsgID == MSGID_EVENT_LOG) || (wMsgType == DEF_OBJECTMOVE) || (wMsgType == DEF_OBJECTRUN) || 
		(wMsgType == DEF_OBJECTATTACKMOVE) || (wMsgType == DEF_OBJECTDAMAGEMOVE) || (wMsgType == DEF_OBJECTDYING))
		sRange = 1;
	else sRange = 0;
	if (cOwnerType == DEF_OWNERTYPE_PLAYER) {
		if (m_pClientList[sOwnerH] == NULL) return;
		// SNOOPY: Here is the difference
		cOwnerSend = TRUE;	
		wp  = (WORD *)cp_a;
		*wp = sOwnerH;
		cp_a += 2;
		sp  = (short *)cp_a;
		sX  = m_pClientList[sOwnerH]->m_sX;
		*sp = sX;
		cp_a += 2;
		sp  = (short *)cp_a;
		sY  = m_pClientList[sOwnerH]->m_sY;
		*sp = sY;
		cp_a += 2;
		sp  = (short *)cp_a;
		*sp = m_pClientList[sOwnerH]->m_sType;
		cp_a += 2;
		*cp_a = m_pClientList[sOwnerH]->m_cDir;
		cp_a++;
		memcpy(cp_a, m_pClientList[sOwnerH]->m_cCharName, 10);
		cp_a += 10;
		sp  = (short *)cp_a;
		*sp = m_pClientList[sOwnerH]->m_sAppr1;
		cp_a += 2;
		sp  = (short *)cp_a;
		*sp = m_pClientList[sOwnerH]->m_sAppr2;
		cp_a += 2;
		sp  = (short *)cp_a;
		*sp = m_pClientList[sOwnerH]->m_sAppr3;
		cp_a += 2;
		sp  = (short *)cp_a;
		*sp = m_pClientList[sOwnerH]->m_sAppr4;
		cp_a += 2;
		ip = (int *)cp_a;
		*ip = m_pClientList[sOwnerH]->m_iApprColor;
		cp_a += 4;
		ip  = (int *)cp_a;
		ipStatus = ip; // note this pointer to later change m_iStatus value
		*ip = m_pClientList[sOwnerH]->m_iStatus;
		cp_a += 4;
		//iTemp += m_pClientList[sOwnerH]->m_iStatus & 0x0F0;
		iTemp3 = m_pClientList[sOwnerH]->m_iStatus & 0x0F0FFFF7F; //0F0FFFF7Fh
		// Hide illusion, DefShield, PFM, PFA,Poisonned information, 
		if (wMsgType == DEF_OBJECTNULLACTION) 
		{	if (m_pClientList[sOwnerH]->m_bIsKilled == TRUE)
				*cp_a = 1; 
			else *cp_a = 0; 
		}else *cp_a = 0;
		cp_a++;
		wp  = (WORD *)cp_s;
		*wp = sOwnerH + 30000;
		cp_s += 2;
		*cp_s = m_pClientList[sOwnerH]->m_cDir;
		cp_s++;
		*cp_s = (unsigned char)sV1;
		cp_s++;
		*cp_s = (unsigned char)sV2;
		cp_s++;
		sp  = (short *)cp_s;
		sX  = m_pClientList[sOwnerH]->m_sX;
		*sp = sX;
		cp_s += 2;
		sp  = (short *)cp_s;
		sY  = m_pClientList[sOwnerH]->m_sY;
		*sp = sY;
		cp_s += 2;
		wp  = (WORD *)cp_sv;
		*wp = sOwnerH + 30000;
		cp_sv += 2;
		*cp_sv = m_pClientList[sOwnerH]->m_cDir;
		cp_sv++;
		*cp_sv = sV1 - sX;
		cp_sv++;
		*cp_sv = sV2 - sY;
		cp_sv++;
		sp  = (short *)cp_sv;
		*sp = sV3;
		cp_sv += 2;
		bFlag = TRUE;
		iShortCutIndex = 0;

		while(bFlag){
			i = m_iClientShortCut[iShortCutIndex];
			iShortCutIndex++;
			if (i == 0) bFlag = FALSE;				
				if ((bFlag == TRUE) && (m_pClientList[i] != NULL) && (m_pClientList[i]->m_bIsInitComplete == TRUE))
				if ((m_pClientList[i]->m_cMapIndex == m_pClientList[sOwnerH]->m_cMapIndex) &&
					(m_pClientList[i]->m_sX >= m_pClientList[sOwnerH]->m_sX - 10 - sRange) &&
					(m_pClientList[i]->m_sX <= m_pClientList[sOwnerH]->m_sX + 10 + sRange) &&
					(m_pClientList[i]->m_sY >= m_pClientList[sOwnerH]->m_sY - 8 - sRange) &&
					(m_pClientList[i]->m_sY <= m_pClientList[sOwnerH]->m_sY + 8 + sRange) ) {						
					/*//If player not same side and is invied (Beholder Hack)
					if (m_pClientList[sOwnerH] != NULL && i != sOwnerH)
						if ((m_pClientList[i]->m_cSide != m_pClientList[sOwnerH]->m_cSide) &&
							((m_pClientList[sOwnerH]->m_iStatus & 0x00000010) != 0)) {
							if(wMsgType == DEF_OBJECTRUN || wMsgType == DEF_OBJECTMOVE || wMsgType == DEF_OBJECTSTOP || wMsgType == DEF_OBJECTGETITEM)
								if we filter attacking
								[KLKS] - http://xtremehb.com -> Play Abaddon (PRO ARESDEN) says:
								the poor guy who's being attacked wont know what hit him
						continue;
					}*/								
						if (m_pClientList[sOwnerH]->m_cSide != m_pClientList[i]->m_cSide) 
						{	if ( m_pClientList[i]->m_iAdminUserLevel > 0)	
							{	iTemp = m_pClientList[sOwnerH]->m_iStatus;
							}else if (i != sOwnerH)									
							{	// iTemp3 Hides illusion, DefShield, PFM, PFA,Poisonned information
								iTemp = iTemp3;
							}else 
							{	iTemp = m_pClientList[sOwnerH]->m_iStatus;
							}
						}else
						{	iTemp = m_pClientList[sOwnerH]->m_iStatus;
							//iTemp = 0x0FFFFFFF;
						}							
						// SNOOPY If same Party, show auras	
						if (   (m_pClientList[i]->m_iPartyID != NULL) 
							&& (m_pClientList[sOwnerH]->m_iPartyID != NULL) )
						{	if ( m_pClientList[i]->m_iPartyID == m_pClientList[sOwnerH]->m_iPartyID)
							{	iTemp = m_pClientList[sOwnerH]->m_iStatus;
							}
						}
						//iTemp = m_pClientList[sOwnerH]->m_iStatus;
						iTemp = 0x0FFBFFFF & iTemp;
						bTransparentInvi = FALSE;
						iTemp2 = iGetPlayerABSStatus(sOwnerH, i, bTransparentInvi);
						if (bTransparentInvi == TRUE) iTemp = (iTemp | 0x00040000);
						iTemp  = (iTemp | (iTemp2 << 28));
						*ipStatus = iTemp;
						if (   (m_pClientList[i]->m_sX >= m_pClientList[sOwnerH]->m_sX - 9)
							&& (m_pClientList[i]->m_sX <= m_pClientList[sOwnerH]->m_sX + 9) 
							&& (m_pClientList[i]->m_sY >= m_pClientList[sOwnerH]->m_sY - 7) 
							&& (m_pClientList[i]->m_sY <= m_pClientList[sOwnerH]->m_sY + 7) ) 
						{	switch (wMsgType) {// Objets is in player's screen
							case DEF_MSGTYPE_CONFIRM:
							case DEF_MSGTYPE_REJECT:
							case DEF_OBJECTNULLACTION:
								if (cOwnerSend == TRUE) 
									iRet = m_pClientList[i]->m_pXSock->iSendMsg(cData_All, 43, cKey);
								else if (i != sOwnerH)
										iRet = m_pClientList[i]->m_pXSock->iSendMsg(cData_All, 43, cKey);
								break;
							case DEF_OBJECTATTACK:
							case DEF_OBJECTATTACKMOVE:
								if (cOwnerSend == TRUE) 
									iRet = m_pClientList[i]->m_pXSock->iSendMsg(cData_Srt_Av, 13, cKey);
								else if (i != sOwnerH)
										iRet = m_pClientList[i]->m_pXSock->iSendMsg(cData_Srt_Av, 13, cKey);
								break;
							case DEF_OBJECTMAGIC:
							case DEF_OBJECTDAMAGE:
							case DEF_OBJECTDAMAGEMOVE:
								if (cOwnerSend == TRUE) 
									iRet = m_pClientList[i]->m_pXSock->iSendMsg(cData_Srt, 11, cKey);
								else if (i != sOwnerH)
										iRet = m_pClientList[i]->m_pXSock->iSendMsg(cData_Srt, 11, cKey);
								break;
							case DEF_OBJECTDYING:
								if (cOwnerSend == TRUE) 
									iRet = m_pClientList[i]->m_pXSock->iSendMsg(cData_Srt, 15, cKey);
								else if (i != sOwnerH)
										iRet = m_pClientList[i]->m_pXSock->iSendMsg(cData_Srt, 15, cKey);
								break;
							default:
								if (cOwnerSend == TRUE) 
									iRet = m_pClientList[i]->m_pXSock->iSendMsg(cData_Srt, 9, cKey);
								else if (i != sOwnerH)
										iRet = m_pClientList[i]->m_pXSock->iSendMsg(cData_Srt, 9, cKey);
								break;
							} //Switch
						}else 
						{	switch (wMsgType) { // Object's outside player's screen
							case DEF_MSGTYPE_CONFIRM:
							case DEF_MSGTYPE_REJECT:
							case DEF_OBJECTNULLACTION:
								if (cOwnerSend == TRUE) 
									iRet = m_pClientList[i]->m_pXSock->iSendMsg(cData_All, 43, cKey);
								else if (i != sOwnerH)
										iRet = m_pClientList[i]->m_pXSock->iSendMsg(cData_All, 43, cKey);
								break;
							case DEF_OBJECTATTACK:
							case DEF_OBJECTATTACKMOVE:
								if (cOwnerSend == TRUE) 
									iRet = m_pClientList[i]->m_pXSock->iSendMsg(cData_Srt_Av, 13, cKey);
								else if (i != sOwnerH)
										iRet = m_pClientList[i]->m_pXSock->iSendMsg(cData_Srt_Av, 13, cKey);
								break;
							case DEF_OBJECTMAGIC:
							case DEF_OBJECTDAMAGE:
							case DEF_OBJECTDAMAGEMOVE:
								if (cOwnerSend == TRUE) 
									iRet = m_pClientList[i]->m_pXSock->iSendMsg(cData_Srt, 11, cKey);
								else if (i != sOwnerH)
										iRet = m_pClientList[i]->m_pXSock->iSendMsg(cData_Srt, 11, cKey);
								break;
							case DEF_OBJECTDYING:
								if (cOwnerSend == TRUE) 
									iRet = m_pClientList[i]->m_pXSock->iSendMsg(cData_Srt, 15, cKey);
								else
									if (i != sOwnerH)
										iRet = m_pClientList[i]->m_pXSock->iSendMsg(cData_Srt, 15, cKey);
								break;
							default:// DEF_OBJECTMOVE, DEF_OBJECTSTOP, DEF_OBJECTRUN, DEF_OBJECTGETITEM,
								if (cOwnerSend == TRUE) 
									iRet = m_pClientList[i]->m_pXSock->iSendMsg(cData_All, 43, cKey);
								else if (i != sOwnerH)
									iRet = m_pClientList[i]->m_pXSock->iSendMsg(cData_All, 43, cKey);
								break;
							} //Switch
						} //else
					} // If 1
		} //While finish
	} //Finish Player
	else { // Build npc object data
		if (m_pNpcList[sOwnerH] == NULL) return;
		wp  = (WORD *)cp_a;
		*wp = sOwnerH + 10000;
		cp_a += 2;
		sp  = (short *)cp_a;
		sX  = m_pNpcList[sOwnerH]->m_sX;
		*sp = sX;
		cp_a += 2;
		sp  = (short *)cp_a;
		sY  = m_pNpcList[sOwnerH]->m_sY;
		*sp = sY;
		cp_a += 2;
		sp  = (short *)cp_a;
		*sp = m_pNpcList[sOwnerH]->m_sType;
		cp_a += 2;
		*cp_a = m_pNpcList[sOwnerH]->m_cDir;
		cp_a++;
		memcpy(cp_a, m_pNpcList[sOwnerH]->m_cName, 5);
		cp_a += 5;
		sp  = (short *)cp_a;
		*sp = m_pNpcList[sOwnerH]->m_sAppr2;
		cp_a += 2;
		ip  = (int *)cp_a;
		ipStatus = ip;
		*ip = m_pNpcList[sOwnerH]->m_iStatus; 
		cp_a += 4;
		if (wMsgType == DEF_OBJECTNULLACTION) 
		{	if (m_pNpcList[sOwnerH]->m_bIsKilled == TRUE)
				*cp_a = 1; 
			else *cp_a = 0;
		}
		else *cp_a = 0;

		cp_a++;
		wp  = (WORD *)cp_s;
		*wp = sOwnerH + 40000;
		cp_s += 2;
		*cp_s = m_pNpcList[sOwnerH]->m_cDir;
		cp_s++;
		*cp_s = (unsigned char)sV1;
		cp_s++;
		*cp_s = (unsigned char)sV2;
		cp_s++;
		sp  = (short *)cp_s;
		sX  = m_pNpcList[sOwnerH]->m_sX;
		*sp = sX;
		cp_s += 2;
		sp  = (short *)cp_s;
		sY  = m_pNpcList[sOwnerH]->m_sY;
		*sp = sY;
		cp_s += 2;
		wp  = (WORD *)cp_sv;
		*wp = sOwnerH + 40000;
		cp_sv += 2;
		*cp_sv = m_pNpcList[sOwnerH]->m_cDir;
		cp_sv++;
		*cp_sv = sV1 - sX;
		cp_sv++;
		*cp_sv = sV2 - sY;
		cp_sv++;
		sp  = (short *)cp_sv;
		*sp = sV3;
		cp_sv += 2;
		bFlag = TRUE;
		iShortCutIndex = 0;
		while(bFlag){
			i = m_iClientShortCut[iShortCutIndex];
			iShortCutIndex++;
			if (i == 0) bFlag = FALSE;
			if ((bFlag == TRUE) && (m_pClientList[i] != NULL))
				if ( (m_pClientList[i]->m_cMapIndex == m_pNpcList[sOwnerH]->m_cMapIndex) &&
					(m_pClientList[i]->m_sX >= m_pNpcList[sOwnerH]->m_sX - 10 - sRange) &&
					(m_pClientList[i]->m_sX <= m_pNpcList[sOwnerH]->m_sX + 10 + sRange) &&
					(m_pClientList[i]->m_sY >= m_pNpcList[sOwnerH]->m_sY - 8 - sRange) &&
					(m_pClientList[i]->m_sY <= m_pNpcList[sOwnerH]->m_sY + 8 + sRange) ) 
				{	// npc objetc is in player's screen
					iTemp = *ipStatus;
					iTemp = 0x0FFBFFFF & iTemp;
					bTransparentInvi = FALSE;
					iTemp2 = iGetNpcRelationship(sOwnerH, i, bTransparentInvi);
					if (bTransparentInvi == TRUE) iTemp = iTemp | 0x00040000;
					iTemp  = (iTemp | (iTemp2 << 28));
					*ipStatus = iTemp;
					if ( (m_pClientList[i]->m_sX >= m_pNpcList[sOwnerH]->m_sX - 9) &&
						(m_pClientList[i]->m_sX <= m_pNpcList[sOwnerH]->m_sX + 9) &&
						(m_pClientList[i]->m_sY >= m_pNpcList[sOwnerH]->m_sY - 7) &&
						(m_pClientList[i]->m_sY <= m_pNpcList[sOwnerH]->m_sY + 7) ) 
					{	switch (wMsgType) {
						case DEF_MSGTYPE_CONFIRM:
						case DEF_MSGTYPE_REJECT:
						case DEF_OBJECTNULLACTION:
							iRet = m_pClientList[i]->m_pXSock->iSendMsg(cData_All, 27,cKey);
							break;

						case DEF_OBJECTDYING:
							iRet = m_pClientList[i]->m_pXSock->iSendMsg(cData_Srt, 15, cKey);
							break;

						case DEF_OBJECTDAMAGE:
						case DEF_OBJECTDAMAGEMOVE:
							iRet = m_pClientList[i]->m_pXSock->iSendMsg(cData_Srt, 11, cKey);
							break;

						case DEF_OBJECTATTACK:
						case DEF_OBJECTATTACKMOVE:
							iRet = m_pClientList[i]->m_pXSock->iSendMsg(cData_Srt_Av, 13, cKey);
							break;

						default: // DEF_OBJECTMOVE, DEF_OBJECTSTOP, DEF_OBJECTRUN, DEF_OBJECTMAGIC
								 // DEF_OBJECTGETITEM,
							iRet = m_pClientList[i]->m_pXSock->iSendMsg(cData_Srt, 9, cKey);
							break;
						} //Switch
					}else // npc object is outside player's screen
					{	switch (wMsgType) {
						case DEF_MSGTYPE_CONFIRM:
						case DEF_MSGTYPE_REJECT:
						case DEF_OBJECTNULLACTION:
							iRet = m_pClientList[i]->m_pXSock->iSendMsg(cData_All, 27,cKey);
							break;

						case DEF_OBJECTDYING:
							iRet = m_pClientList[i]->m_pXSock->iSendMsg(cData_Srt, 15, cKey);
							break;

						case DEF_OBJECTDAMAGE:
						case DEF_OBJECTDAMAGEMOVE:
							iRet = m_pClientList[i]->m_pXSock->iSendMsg(cData_Srt, 11, cKey);
							break;

						case DEF_OBJECTATTACK:
						case DEF_OBJECTATTACKMOVE:
							iRet = m_pClientList[i]->m_pXSock->iSendMsg(cData_Srt_Av, 13, cKey);
							break;

						default:
							iRet = m_pClientList[i]->m_pXSock->iSendMsg(cData_All, 27, cKey);
							break;

						} //Switch
					}
				}
		}
	} // else - NPC
}

// SNOOPY: Use this function to send info about a client/mob to a confused victim, or when switching behoder power
void CGame::SendNearClientToChar(short sOwnerH, short sClient)
{	int * ip, iRet;
	char  * cp_a, cData_All[200];
	DWORD * dwp;
	WORD  * wp;
	int * ipStatus,iDumm;
	short * sp, sX, sY;
	char cKey;
	int iTemp3,iTemp,iTemp2;		
	ZeroMemory(cData_All, sizeof(cData_All));
	ipStatus = (int *)&iDumm;
	cKey = (rand() % 255) + 1;
	dwp  = (DWORD *)(cData_All + DEF_INDEX4_MSGID);
	*dwp = MSGID_EVENT_MOTION;
	wp   = (WORD *)(cData_All + DEF_INDEX2_MSGTYPE);
	*wp  = DEF_OBJECTNULLACTION;
	cp_a  = (char *)(cData_All + DEF_INDEX2_MSGTYPE + 2);
	if (m_pClientList[sOwnerH] == NULL) return;
	if (m_pClientList[sClient] == NULL) return;
	if (sClient == sOwnerH) return;

	wp  = (WORD *)cp_a;
	*wp = sOwnerH;
	cp_a += 2;
	sp  = (short *)cp_a;
	sX  = m_pClientList[sOwnerH]->m_sX;
	*sp = sX;
	cp_a += 2;
	sp  = (short *)cp_a;
	sY  = m_pClientList[sOwnerH]->m_sY;
	*sp = sY;
	cp_a += 2;
	sp  = (short *)cp_a;
	*sp = m_pClientList[sOwnerH]->m_sType;
	cp_a += 2;
	*cp_a = m_pClientList[sOwnerH]->m_cDir;
	cp_a++;
	memcpy(cp_a, m_pClientList[sOwnerH]->m_cCharName, 10);
	cp_a += 10;
	sp  = (short *)cp_a;
	*sp = m_pClientList[sOwnerH]->m_sAppr1;
	cp_a += 2;
	sp  = (short *)cp_a;
	*sp = m_pClientList[sOwnerH]->m_sAppr2;
	cp_a += 2;
	sp  = (short *)cp_a;
	*sp = m_pClientList[sOwnerH]->m_sAppr3;
	cp_a += 2;
	sp  = (short *)cp_a;
	*sp = m_pClientList[sOwnerH]->m_sAppr4;
	cp_a += 2;
	ip = (int *)cp_a;
	*ip = m_pClientList[sOwnerH]->m_iApprColor;
	cp_a += 4;
	ip  = (int *)cp_a;
	ipStatus = ip; // note this pointer to later change m_iStatus value
	*ip = m_pClientList[sOwnerH]->m_iStatus;
	cp_a += 4;
	iTemp3 = m_pClientList[sOwnerH]->m_iStatus & 0x0F0FFFF7F;
	// Hide illusion, DefShield, PFM, PFA,Poisonned information
	*cp_a = 0;
	cp_a++;	
	if (m_pClientList[sOwnerH]->m_cSide != m_pClientList[sClient]->m_cSide) 
	{	if ( m_pClientList[sClient]->m_iAdminUserLevel > 0)
		{	iTemp = m_pClientList[sOwnerH]->m_iStatus;	// do not hide for GMs
		}else 
		{	if (sClient != sOwnerH)	
			{	iTemp = iTemp3;// iTemp3 Hides illusion, DefShield, PFM, PFA,Poisonned information
			}else 
			{	iTemp = m_pClientList[sOwnerH]->m_iStatus;
		}	}
	}else
	{	iTemp = m_pClientList[sOwnerH]->m_iStatus;	//iTemp = 0x0FFFFFFF;	
	}		
	// SNOOPY If same Party, show auras	
	if (   (m_pClientList[sClient]->m_iPartyID != NULL) 
		&& (m_pClientList[sOwnerH]->m_iPartyID != NULL) )
	{	if ( m_pClientList[sClient]->m_iPartyID == m_pClientList[sOwnerH]->m_iPartyID)
		{	iTemp = m_pClientList[sOwnerH]->m_iStatus;
		}
	}			
	iTemp = 0x0FFBFFFF & iTemp;
	BOOL bTransparentInvi = FALSE;
	if (m_pClientList[sClient]->m_cMagicEffectStatus[ DEF_MAGICTYPE_CONFUSE ] == 2)
	{	iTemp2 = iGetPlayerABSStatus(sClient, sClient, bTransparentInvi);
		bTransparentInvi = FALSE;
	}else
	{	iTemp2 = iGetPlayerABSStatus(sOwnerH, sClient, bTransparentInvi);
	}
	if (bTransparentInvi == TRUE) iTemp = (iTemp | 0x00040000);
	iTemp  = (iTemp | (iTemp2 << 28));
	*ipStatus = iTemp;
	iRet = m_pClientList[sClient]->m_pXSock->iSendMsg(cData_All, 43, cKey);
}
void CGame::SendNearMobToChar(short sOwnerH, short sClient)
{	int * ip, iRet;
	char  * cp_a, cData_All[200];
	DWORD * dwp;
	WORD  * wp;
	int * ipStatus,iDumm;
	short * sp, sX, sY;
	char cKey;
	int iTemp3,iTemp,iTemp2;		
	ZeroMemory(cData_All, sizeof(cData_All));
	ipStatus = (int *)&iDumm;
	cKey = (rand() % 255) + 1;
	dwp  = (DWORD *)(cData_All + DEF_INDEX4_MSGID);
	*dwp = MSGID_EVENT_MOTION;
	wp   = (WORD *)(cData_All + DEF_INDEX2_MSGTYPE);
	*wp  = DEF_OBJECTNULLACTION;
	cp_a  = (char *)(cData_All + DEF_INDEX2_MSGTYPE + 2);
	if (m_pClientList[sClient] == NULL) return;
	if (m_pNpcList[sOwnerH] == NULL) return;

	wp  = (WORD *)cp_a;
	*wp = sOwnerH + 10000;
	cp_a += 2;
	sp  = (short *)cp_a;
	sX  = m_pNpcList[sOwnerH]->m_sX;
	*sp = sX;
	cp_a += 2;
	sp  = (short *)cp_a;
	sY  = m_pNpcList[sOwnerH]->m_sY;
	*sp = sY;
	cp_a += 2;
	sp  = (short *)cp_a;
	*sp = m_pNpcList[sOwnerH]->m_sType;
	cp_a += 2;
	*cp_a = m_pNpcList[sOwnerH]->m_cDir;
	cp_a++;
	memcpy(cp_a, m_pNpcList[sOwnerH]->m_cName, 5);
	cp_a += 5;
	sp  = (short *)cp_a;
	*sp = m_pNpcList[sOwnerH]->m_sAppr2;
	cp_a += 2;
	ip  = (int *)cp_a;
	ipStatus = ip; // note this pointer to later change m_iStatus value
	*ip = m_pNpcList[sOwnerH]->m_iStatus; 
	cp_a += 4;
	iTemp3 = m_pNpcList[sOwnerH]->m_iStatus & 0x0F0FFFF7F;
	// Hide illusion, DefShield, PFM, PFA,Poisonned information
	if (m_pNpcList[sOwnerH]->m_bIsKilled == TRUE)
		*cp_a = 1; 
	else *cp_a = 0;
	cp_a++;
	if (m_pNpcList[sOwnerH]->m_cSide != m_pClientList[sClient]->m_cSide) 
	{	if ( m_pClientList[sClient]->m_iAdminUserLevel > 0)
		{	iTemp = m_pNpcList[sOwnerH]->m_iStatus;	// do not hide for GMs
		}else 
		{	iTemp = iTemp3;// iTemp3 Hides illusion, DefShield, PFM, PFA,Poisonned information
		}
	}else
	{	iTemp = m_pNpcList[sOwnerH]->m_iStatus;	//iTemp = 0x0FFFFFFF;	
	}
	iTemp = 0x0FFBFFFF & iTemp;
	BOOL bTransparentInvi = FALSE;
	iTemp2 = iGetNpcRelationship(sOwnerH, sClient, bTransparentInvi);
	if (bTransparentInvi == TRUE) iTemp = iTemp | 0x00040000;
	iTemp  = (iTemp | (iTemp2 << 28));
	*ipStatus = iTemp;
	iRet = m_pClientList[sClient]->m_pXSock->iSendMsg(cData_All, 27, cKey);
}

int CGame::iComposeMoveMapData(short sX, short sY, int iClientH, char cDir, char * pData)
{
register int * ip, ix, iy, iSize, iTileExists, iIndex;
class CTile * pTileSrc, * pTile;
unsigned char ucHeader;
short * sp, * pTotal;
int iTemp, iTemp2;
WORD  * wp;
char  * cp;
BOOL bTransparentInvi = FALSE;

	if (m_pClientList[iClientH] == NULL) return 0;
	pTotal = (short *)pData;
	cp = (char *)(pData + 2);
	iSize = 2;
	iTileExists = 0;
	pTileSrc = (class CTile *)(m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_pTile + 
		(sX) + (sY)*m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_sSizeY);
	iIndex = 0;
	while (1) {
		ix = _tmp_iMoveLocX[cDir][iIndex];
		iy = _tmp_iMoveLocY[cDir][iIndex];
		if ((ix == -1) || (iy == -1)) break;
		iIndex++;
		pTile = (class CTile *)(pTileSrc + ix + iy*m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_sSizeY);
		if (   (pTile->m_sOwner != NULL)   || (pTile->m_sDeadOwner != NULL) 
			|| (pTile->m_pItem[0] != NULL) || (pTile->m_sDynamicObjectType != NULL) ) 
		{	iTileExists++;
			sp = (short *)cp;
			*sp = ix;
			cp += 2;
			sp = (short *)cp;
			*sp = iy;
			cp += 2;
			iSize += 4;
			ucHeader = 0;
			if (pTile->m_sOwner != NULL) 
			{	if (pTile->m_cOwnerClass == DEF_OWNERTYPE_PLAYER)  
				{	if (m_pClientList[pTile->m_sOwner] != NULL) ucHeader = ucHeader | 0x01;
					else pTile->m_sOwner = NULL;
				}
				if (pTile->m_cOwnerClass == DEF_OWNERTYPE_NPC) 
				{	if (m_pNpcList[pTile->m_sOwner] != NULL) ucHeader = ucHeader | 0x01;
					else pTile->m_sOwner = NULL;
				}
			}
			if (pTile->m_sDeadOwner != NULL) 
			{	if (pTile->m_cDeadOwnerClass == DEF_OWNERTYPE_PLAYER)  
				{	if (m_pClientList[pTile->m_sDeadOwner] != NULL)	ucHeader = ucHeader | 0x02;
					else pTile->m_sDeadOwner = NULL;
				}
				if (pTile->m_cDeadOwnerClass == DEF_OWNERTYPE_NPC)  
				{	if (m_pNpcList[pTile->m_sDeadOwner] != NULL) ucHeader = ucHeader | 0x02;
					else pTile->m_sDeadOwner = NULL;
			}	}
			if (pTile->m_pItem[0] != NULL)				ucHeader = ucHeader | 0x04;
			if (pTile->m_sDynamicObjectType != NULL)    ucHeader = ucHeader | 0x08;
			*cp = ucHeader;
			cp++;
			iSize++;
			if ((ucHeader & 0x01) != 0)  // alive pc or npc
			{	switch (pTile->m_cOwnerClass) {
				case DEF_OWNERTYPE_PLAYER:	// Object ID number(Player) : 1~10000	
					sp  = (short *)cp;
					*sp	= pTile->m_sOwner;
					cp += 2;
					iSize += 2;
					sp  = (short *)cp;
					*sp	= m_pClientList[pTile->m_sOwner]->m_sType;
					cp += 2;
					iSize += 2;
					*cp = m_pClientList[pTile->m_sOwner]->m_cDir;
					cp++;
					iSize++;
					sp  = (short *)cp;
					*sp	= m_pClientList[pTile->m_sOwner]->m_sAppr1;
					cp += 2;
					iSize += 2;
					sp  = (short *)cp;
					*sp	= m_pClientList[pTile->m_sOwner]->m_sAppr2;
					cp += 2;
					iSize += 2;
					sp  = (short *)cp;
					*sp	= m_pClientList[pTile->m_sOwner]->m_sAppr3;
					cp += 2;
					iSize += 2;
					sp  = (short *)cp;
					*sp	= m_pClientList[pTile->m_sOwner]->m_sAppr4;
					cp += 2;
					iSize += 2;
					ip = (int *)cp;
					*ip = m_pClientList[pTile->m_sOwner]->m_iApprColor;
					cp += 4;
					iSize += 4;
					ip  = (int *)cp;
					if (m_pClientList[iClientH]->m_cSide != m_pClientList[pTile->m_sOwner]->m_cSide)
					{	if (iClientH != pTile->m_sOwner) 
						{	iTemp = m_pClientList[pTile->m_sOwner]->m_iStatus & 0x0F0FFFF7F;
						}else 
						{	iTemp = m_pClientList[pTile->m_sOwner]->m_iStatus;
						}
					}else 
					{	iTemp = m_pClientList[pTile->m_sOwner]->m_iStatus;
					}
					//iTemp = m_pClientList[pTile->m_sOwner]->m_iStatus;
					iTemp = 0x0FFBFFFF & iTemp;
					bTransparentInvi = FALSE;
					iTemp2 = iGetPlayerABSStatus(pTile->m_sOwner, iClientH, bTransparentInvi);
					if (bTransparentInvi == TRUE) iTemp = (iTemp | 0x00040000);
					iTemp  = (iTemp | (iTemp2 << 28));
					*ip = iTemp;
					cp += 4;
					iSize += 4;
					memcpy(cp, m_pClientList[pTile->m_sOwner]->m_cCharName, 10);
					cp    += 10;
					iSize += 10;
					break;

				case DEF_OWNERTYPE_NPC:	// Object ID number(NPC) : 10000~	
					sp  = (short *)cp;
					*sp	= pTile->m_sOwner + 10000;
					cp += 2;
					iSize += 2;
					sp  = (short *)cp;
					*sp	= m_pNpcList[pTile->m_sOwner]->m_sType;
					cp += 2;
					iSize += 2;
					*cp = m_pNpcList[pTile->m_sOwner]->m_cDir;
					cp++;
					iSize++;
					sp  = (short *)cp;
					*sp	= m_pNpcList[pTile->m_sOwner]->m_sAppr2;
					cp += 2;
					iSize += 2;
					ip  = (int *)cp;
					iTemp = m_pNpcList[pTile->m_sOwner]->m_iStatus;
					iTemp = 0x0FFBFFFF & iTemp;
					bTransparentInvi = FALSE;
					iTemp2 = iGetNpcRelationship(pTile->m_sOwner, iClientH, bTransparentInvi);
					if (bTransparentInvi == TRUE) iTemp = iTemp | 0x00040000;
					iTemp  = (iTemp | (iTemp2 << 28));
					*ip = iTemp;
					cp += 4;
					iSize += 4;
					memcpy(cp, m_pNpcList[pTile->m_sOwner]->m_cName, 5);
					cp    += 5;
					iSize += 5;
				}//end switch
			}// if ((ucHeader & 0x01) != 0)
			if ((ucHeader & 0x02) != 0) 
			{	switch (pTile->m_cDeadOwnerClass) {	// something dead/pretend here
				case DEF_OWNERTYPE_PLAYER:
					sp  = (short *)cp;
					*sp	= pTile->m_sDeadOwner;
					cp += 2;
					iSize += 2;
					sp  = (short *)cp;
					*sp	= m_pClientList[pTile->m_sDeadOwner]->m_sType;
					cp += 2;
					iSize += 2;
					*cp = m_pClientList[pTile->m_sDeadOwner]->m_cDir;
					cp++;
					iSize++;
					sp  = (short *)cp;
					*sp	= m_pClientList[pTile->m_sDeadOwner]->m_sAppr1;
					cp += 2;
					iSize += 2;
					sp  = (short *)cp;
					*sp	= m_pClientList[pTile->m_sDeadOwner]->m_sAppr2;
					cp += 2;
					iSize += 2;
					sp  = (short *)cp;
					*sp	= m_pClientList[pTile->m_sDeadOwner]->m_sAppr3;
					cp += 2;
					iSize += 2;
					sp  = (short *)cp;
					*sp	= m_pClientList[pTile->m_sDeadOwner]->m_sAppr4;
					cp += 2;
					iSize += 2;
					ip = (int *)cp;
					*ip = m_pClientList[pTile->m_sDeadOwner]->m_iApprColor;
					cp += 4;
					iSize += 4;
					ip  = (int *)cp;
					if (m_pClientList[iClientH]->m_cSide != m_pClientList[pTile->m_sDeadOwner]->m_cSide)
					{	if (iClientH != pTile->m_sDeadOwner) 
						{	iTemp = m_pClientList[pTile->m_sDeadOwner]->m_iStatus & 0x0F0FFFF7F;
						}else 
						{	iTemp = m_pClientList[pTile->m_sDeadOwner]->m_iStatus;
						}
					}else 
					{	iTemp = m_pClientList[pTile->m_sDeadOwner]->m_iStatus;
					}
					//iTemp = m_pClientList[pTile->m_sDeadOwner]->m_iStatus;
					iTemp = 0x0FFBFFFF & iTemp;
					bTransparentInvi = FALSE;
					iTemp2 = iGetPlayerABSStatus(pTile->m_sDeadOwner, iClientH, bTransparentInvi);
					if (bTransparentInvi == TRUE) iTemp = (iTemp | 0x00040000);
					iTemp  = (iTemp | (iTemp2 << 28));
					*ip = iTemp;
					cp += 4;
					iSize += 4;
					memcpy(cp, m_pClientList[pTile->m_sDeadOwner]->m_cCharName, 10);
					cp    += 10;
					iSize += 10;
					break;

				case DEF_OWNERTYPE_NPC:	// Object ID number : 10000	~
					sp  = (short *)cp;
					*sp	= pTile->m_sDeadOwner + 10000;
					cp += 2;
					iSize += 2;
					sp  = (short *)cp;
					*sp	= m_pNpcList[pTile->m_sDeadOwner]->m_sType;
					cp += 2;
					iSize += 2;
					*cp = m_pNpcList[pTile->m_sDeadOwner]->m_cDir;
					cp++;
					iSize++;
					sp  = (short *)cp;
					*sp	= m_pNpcList[pTile->m_sDeadOwner]->m_sAppr2;
					cp += 2;
					iSize += 2;
					ip  = (int *)cp;
					iTemp = m_pNpcList[pTile->m_sDeadOwner]->m_iStatus;
					iTemp = 0x0FFBFFFF & iTemp;
					bTransparentInvi = FALSE;
					iTemp2 = iGetNpcRelationship(pTile->m_sDeadOwner, iClientH, bTransparentInvi);
					if (bTransparentInvi == TRUE) iTemp = iTemp | 0x00040000;
					iTemp  = (iTemp | (iTemp2 << 28));
					*ip = iTemp;
					cp += 4;
					iSize += 4;
					memcpy(cp, m_pNpcList[pTile->m_sDeadOwner]->m_cName, 5);
					cp    += 5;
					iSize += 5;
					break;
				}//End Switch
			}// if ((ucHeader & 0x02) != 0)
			if (pTile->m_pItem[0] != NULL) 
			{	sp  = (short *)cp;
				*sp	= pTile->m_pItem[0]->m_sSprite;
				cp += 2;
				iSize += 2;
				sp  = (short *)cp;
				*sp	= pTile->m_pItem[0]->m_sSpriteFrame;
				cp += 2;
				iSize += 2;
				*cp = pTile->m_pItem[0]->m_cItemColor;
				cp++;
				iSize++;
			}
			if (pTile->m_sDynamicObjectType != NULL) 
			{	wp  = (WORD *)cp;
				*wp = pTile->m_wDynamicObjectID;
				cp += 2;
				iSize += 2;
				sp  = (short *)cp;
				*sp	= pTile->m_sDynamicObjectType;
				cp += 2;
				iSize += 2;
			} //(pTile->m_sDynamicObjectType != NULL)
		} //(pTile->m_sOwner != NULL)
	} // end While(1)
	*pTotal = iTileExists;
	return iSize;
}
// SNOOPY: Check if Orc/Troll/Ogres around 
bool CGame::SpecialWeapon_DS(int iClientH)
{
 register int ix, iy, sX, sY;
 short sOwnerH;
 char  cOwnerType;
	
	if (m_pClientList[iClientH] == NULL) return FALSE;

	sX = m_pClientList[iClientH]->m_sX;
	sY = m_pClientList[iClientH]->m_sY;

	for (ix = sX - 20; ix <= sX + 20; ix++)
	for (iy = sY - 20; iy <= sY + 20; iy++) {
		m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, ix, iy);
		if (   (sOwnerH != NULL) 
			&& (cOwnerType == DEF_OWNERTYPE_NPC) 
			&& (m_pNpcList[sOwnerH] != NULL) )
		{	if (   ((m_pNpcList[sOwnerH]->m_sType == 31))
				&& (m_pNpcList[sOwnerH]->m_bIsKilled == FALSE) ) 
			{	return TRUE;
			}			
		}
	} 
	return FALSE;
}
// SNOOPY: Check if Orc around 
bool CGame::SpecialWeapon_Orc(int iClientH)
{
 register int ix, iy, sX, sY;
 short sOwnerH;
 char  cOwnerType;
	
	if (m_pClientList[iClientH] == NULL) return FALSE;

	sX = m_pClientList[iClientH]->m_sX;
	sY = m_pClientList[iClientH]->m_sY;

	for (ix = sX - 20; ix <= sX + 20; ix++)
	for (iy = sY - 20; iy <= sY + 20; iy++) {
		m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, ix, iy);
		if (   (sOwnerH != NULL) 
			&& (cOwnerType == DEF_OWNERTYPE_NPC) 
			&& (m_pNpcList[sOwnerH] != NULL) )
		{	if (   (m_pNpcList[sOwnerH]->m_sType == 14) // Orc
				|| (m_pNpcList[sOwnerH]->m_sType == 77)) // MasterMageOrc
			{	if (m_pNpcList[sOwnerH]->m_bIsKilled == FALSE) 
				{	return TRUE;
				}
			}			
		}
	} 
	return FALSE;
}
// SNOOPY: Check shining condition for StormBringer
bool CGame::SpecialWeapon_StormBringer(int iClientH, int sItemIndex)
{	short sOwnerH;
	char  cOwnerType;	
	if (m_pClientList[iClientH] == NULL) return FALSE;
	// Not on safe maps
	if (m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_iPKmode >=3 ) return FALSE;	
	if (m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_iPKmode <=-3 ) return FALSE;	
	// Not in no Attack Area
	if (m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->iGetAttribute(m_pClientList[iClientH]->m_sX, m_pClientList[iClientH]->m_sY, 0x00000006) != 0) return FALSE;
	// Needs 100% LS
	if (m_pClientList[iClientH]->m_cSkillMastery[8] == 0) return FALSE;
	// Needs not in peace mode 
	//short sAppr2 = (short)((m_pClientList[iClientH]->m_sAppr2 & 0xF000) >> 12);
	//if (sAppr2 == 0) // peace mode
	if (m_pClientList[iClientH]->m_IsPeaceMode == TRUE)
	{	return FALSE;
	}
	// Needs Full swing
	if(sItemIndex != -1) 
	{	if((m_pClientList[iClientH]->m_iStr + m_pClientList[iClientH]->m_iAngelicStr) < (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cSpeed *13))
		{	return FALSE;
		}
	}else  return FALSE;
	// Needs neither 0 or full crits
	if (m_pClientList[iClientH]->m_iSuperAttackLeft  == 0) return FALSE;
	if (m_pClientList[iClientH]->m_iSuperAttackLeft  >= m_pClientList[iClientH]->m_iLevel / 10) return FALSE;


 register int ix, iy, sX, sY;
	sX = m_pClientList[iClientH]->m_sX;
	sY = m_pClientList[iClientH]->m_sY;
	for (ix = sX - 10; ix <= sX + 10; ix++)
	for (iy = sY - 10; iy <= sY + 10; iy++){
		m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, ix, iy);
		if (   (sOwnerH != NULL) 
			&& (cOwnerType == DEF_OWNERTYPE_PLAYER)
			&& (m_pClientList[sOwnerH] != NULL)
			&& (m_pClientList[sOwnerH]->m_cSide != 0)				// Not Travellers
			&& (m_pClientList[sOwnerH]->m_cSide != m_pClientList[iClientH]->m_cSide ) // Not same side
			&& (m_pClientList[sOwnerH]->m_iAdminUserLevel == 0)		// Not admins
			&& (m_pClientList[sOwnerH]->m_bIsPlayerCivil == FALSE)	// Not civilians
			// May shine if detecting invisible ennemy
			//&& ((m_pClientList[sOwnerH]->m_iStatus & 0x10) == 0)	// Not invisible
			&& (m_pClientList[sOwnerH]->m_bIsKilled == FALSE) )		// Not dead characters
		{	return TRUE; 
		}
	}
	return FALSE;
}

// Have the StormBringer strike any character to restore is own life...
void CGame::SpecialWeapon_StormBringer_KillsNow(int iClientH, int sItemIndex)
{		
	if (m_pClientList[iClientH] == NULL) return;
	if (m_pClientList[iClientH]->m_iHP <= 0) return;

	short sOwnerH;
	char  cOwnerType;
	int j, sX, sY;
	bool bSBfed = FALSE;
	char cDir;
	int iBladeDamage;
	iBladeDamage = iDice(m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectValue1,m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectValue2)+m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectValue3;
	iBladeDamage *= 4; // Simplification for lvl 150 and Str 221+	
	iBladeDamage += m_pClientList[iClientH]->m_iAddPhysicalDamage;

	for ( j = 0; j <= 150; j++) 
	{	sX = m_pClientList[iClientH]->m_sX + (rand() % 11) - 5;
		sY = m_pClientList[iClientH]->m_sY + (rand() % 11) - 5;
		m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, sX, sY);
		if (   (sOwnerH != NULL) 
			&& (cOwnerType == DEF_OWNERTYPE_PLAYER)
			&& (m_pClientList[sOwnerH] != NULL)
			&& (m_pClientList[sOwnerH]->m_cSide != 0)				// Not Travellers
			&& (m_pClientList[sOwnerH]->m_iAdminUserLevel == 0)		// Not admins
			&& (m_pClientList[sOwnerH]->m_bIsPlayerCivil == FALSE)	// Not civilians
			&& ((m_pClientList[sOwnerH]->m_iStatus & 0x10) == 0)	// Not invisible
			// Not in no Attack Area
			&& (m_pMapList[m_pClientList[sOwnerH]->m_cMapIndex]->iGetAttribute(m_pClientList[sOwnerH]->m_sX, m_pClientList[sOwnerH]->m_sY, 0x00000006) == 0)
			&& (m_pClientList[sOwnerH]->m_bIsKilled == FALSE) )		// Not dead characters
		{	// Strike the character
				bSBfed = TRUE;
			if (iClientH == sOwnerH) 
			{	//Testcode 
				wsprintf(G_cTxt, "(!) %s's StormBringer's Auto Attack - 1", m_pClientList[sOwnerH]->m_cCharName);
				PutLogList(G_cTxt);

				m_pClientList[iClientH]->m_iHP -= iBladeDamage;
				if (m_pClientList[iClientH]->m_iHP <= 0) 
				{	ClientKilledHandler(iClientH, iClientH, DEF_OWNERTYPE_PLAYER, iBladeDamage);	
				}else
				{	SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_HP, NULL, NULL, NULL, NULL);					
					m_pClientList[iClientH]->m_dwLastDamageTime = timeGetTime();
					SendEventToNearClient_TypeASelf(iClientH, DEF_OWNERTYPE_PLAYER, MSGID_EVENT_MOTION, DEF_OBJECTDAMAGE, iBladeDamage, NULL, NULL);		
				}
			}else
			{	//Testcode 
				wsprintf(G_cTxt, "(!) %s's StormBringer's Attacks %s "
					, m_pClientList[iClientH]->m_cCharName
					, m_pClientList[sOwnerH]->m_cCharName);
				PutLogList(G_cTxt);
				// Turns to the right direction
				cDir = m_Misc.cGetNextMoveDir(m_pClientList[iClientH]->m_sX, m_pClientList[iClientH]->m_sY, m_pClientList[sOwnerH]->m_sX, m_pClientList[sOwnerH]->m_sY);
				m_pClientList[iClientH]->m_cDir = cDir;
				iClientMotion_Move_Handler(iClientH, m_pClientList[iClientH]->m_sX, m_pClientList[iClientH]->m_sY, cDir, 6);//  special value to prevent Hack detection	
				SendEventToNearClient_TypeASelf(iClientH, DEF_OWNERTYPE_PLAYER, MSGID_EVENT_MOTION, DEF_OBJECTMOVE, NULL, NULL, NULL);
				
				// Then strikes!
				iClientMotion_Attack_Handler(iClientH
					, m_pClientList[iClientH]->m_sX
					, m_pClientList[iClientH]->m_sY
					, m_pClientList[sOwnerH]->m_sX
					, m_pClientList[sOwnerH]->m_sY
					, 23		// LongSword critical attack 
					, m_pClientList[iClientH]->m_cDir
					, sOwnerH
					, -1		// Client Time
					, -1		// msg time (<=> max DWORD
					, TRUE		// Send msg to client
					, FALSE		//not Dash
					, TRUE);	//Sent by server: no not count for Speedhack detection.
				SendEventToNearClient_TypeASelf(iClientH, DEF_OWNERTYPE_PLAYER, MSGID_EVENT_MOTION, DEF_OBJECTATTACK, m_pClientList[sOwnerH]->m_sX, m_pClientList[sOwnerH]->m_sY, 23);
	
				// Then restore blade's own life...
				m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_wCurLifeSpan = m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_wMaxLifeSpan;
			}
			break;

		}
	}
	if (bSBfed == FALSE)
	{	// Then Attack Blade's bearer	
		//Testcode 
		wsprintf(G_cTxt, "(!) %s's StormBringer's Auto Attack - 2", m_pClientList[iClientH]->m_cCharName);
		PutLogList(G_cTxt);

		m_pClientList[iClientH]->m_iHP -= iBladeDamage;				
		if (m_pClientList[iClientH]->m_iHP <= 0) 
		{	ClientKilledHandler(iClientH, iClientH, DEF_OWNERTYPE_PLAYER, iBladeDamage);	
		}else
		{	SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_HP, NULL, NULL, NULL, NULL);
			m_pClientList[iClientH]->m_dwLastDamageTime = timeGetTime();
			SendEventToNearClient_TypeASelf(iClientH, DEF_OWNERTYPE_PLAYER, MSGID_EVENT_MOTION, DEF_OBJECTDAMAGE, iBladeDamage, NULL, NULL);		
		}
	}
}

void CGame::CheckClientResponseTime() // executed every 3 seconds
{	register int i, iPlusTime, iMaxSuperAttack, iValue;
	short sTemp;
	DWORD dwTime;
	short sItemIndex;
	int iSBmissingLife;	// SNOOPY
 //SYSTEMTIME SysTime;
	/*	GetLocalTime(&SysTime);
	switch (SysTime.wDayOfWeek) {
	case 1:	iWarPeriod = 30; break; //Â¿Ã¹Â¿Ã¤Ã€Ã 
	case 2:	iWarPeriod = 30; break; //ÃˆÂ­Â¿Ã¤Ã€Ã 
	case 3:	iWarPeriod = 60; break; //Â¼Ã¶Â¿Ã¤Ã€Ã 
	case 4:	iWarPeriod = 60*2;  break; //Â¸Ã±Â¿Ã¤Ã€Ã 
	case 5:	iWarPeriod = 60*5;  break; //Â±ÃÂ¿Ã¤Ã€Ã 
	case 6:	iWarPeriod = 60*10; break; //Ã…Ã¤Â¿Ã¤Ã€Ã 
	case 0:	iWarPeriod = 60*20; break; //Ã€ÃÂ¿Ã¤Ã€Ã 
	}
	*/	
   	dwTime = timeGetTime();	
	for (i = 1; i < DEF_MAXCLIENTS; i++) {
		if (m_pClientList[i] != NULL) 			
		{	if ((dwTime - m_pClientList[i]->m_dwTime) > m_iVariableTimeOut) //DEF_CLIENTTIMEOUT  
			{	if (m_pClientList[i]->m_bIsInitComplete == TRUE) 
				{	wsprintf(G_cTxt, "Client Timeout: %s", m_pClientList[i]->m_cIPaddress);
					PutLogList(G_cTxt);
					DeleteClient(i, TRUE, TRUE);
				}else if ((dwTime - m_pClientList[i]->m_dwTime) > m_iVariableTimeOut + 2000) // Longer.DEF_CLIENTTIMEOUT) 
				{	wsprintf(G_cTxt, "Client Timeout before m_bIsInitComplete: %s", m_pClientList[i]->m_cIPaddress);
					PutLogList(G_cTxt);					
					DeleteClient(i, FALSE, FALSE); 
				}
			}else if (m_pClientList[i]->m_bIsInitComplete == TRUE) 
			{	m_pClientList[i]->m_iTimeLeft_ShutUp--;
				if (m_pClientList[i]->m_iTimeLeft_ShutUp < 0) m_pClientList[i]->m_iTimeLeft_ShutUp = 0;	
				m_pClientList[i]->m_iTimeLeft_Rating--;
				if (m_pClientList[i]->m_iTimeLeft_Rating < 0) m_pClientList[i]->m_iTimeLeft_Rating = 0;
				if (((dwTime - m_pClientList[i]->m_dwHungerTime) > DEF_HUNGERTIME) && (m_pClientList[i]->m_bIsKilled == FALSE)) 
				{	if ((m_pClientList[i]->m_iLevel < 20) || (m_pClientList[i]->m_iAdminUserLevel > 0 )) 
					{/*No hungry if level 1..19*/} else m_pClientList[i]->m_iHungerStatus--; 
					if (m_pClientList[i]->m_iHungerStatus <= 0) m_pClientList[i]->m_iHungerStatus = 0;
					m_pClientList[i]->m_dwHungerTime = dwTime;					
					if ( (m_pClientList[i]->m_iHP > 0) && (m_pClientList[i]->m_iHungerStatus < 30) ) 
					{	SendNotifyMsg(NULL, i, DEF_NOTIFY_HUNGER, m_pClientList[i]->m_iHungerStatus, NULL, NULL, NULL);
					}
				}				
				if (_bCheckCharacterData(i) == FALSE) 
				{	DeleteClient(i, TRUE, TRUE);
					break;	
				}
								
				// Snoopy: I introduced a protection on the player's connection (Anti-Login Kill)	
				if (m_pClientList[i]->m_bAntiTPLameEK == TRUE)
				{	if ((dwTime - m_pClientList[i]->m_dwXPHackCheckTime) > DEF_LOGPROTECTIONTIME) 			
					// Using XPHackCheckTime, because only reset every hour or at the end of a crusade.
					{	m_pClientList[i]->m_bAntiTPLameEK = FALSE; 
					}
					// Nota: this value is set to FALSE by 1st COMMON_MOVE Message received.
				}

				// Snoopy added Tile where you can't stay (behind crusade structures)
				if (   (m_bIsCrusadeMode == TRUE)
					&& (m_pClientList[i]->m_iAdminUserLevel == 0)
					&& (m_pMapList[m_pClientList[i]->m_cMapIndex]->bGetIsStayAllowedTile(m_pClientList[i]->m_sX, m_pClientList[i]->m_sY) == FALSE))
				{	char iDir = (char)iDice(1,7);
					if (iDir >= 5) iDir += 1;
					int iDamage = m_pClientList[i]->m_iHP/8 + iDice(1,20);					
					if (iDamage < 40) iDamage = 30 + iDice(1,20);
					if (iDamage > m_pClientList[i]->m_iHP) iDamage = m_pClientList[i]->m_iHP -1;
					m_pClientList[i]->m_iHP -= iDamage;					
					m_pClientList[i]->m_iLastDamage = iDamage;		
					m_pClientList[i]->m_dwLastDamageMoveTime = dwTime;
					m_pClientList[i]->m_dwDamageMoveCounter ++;
					SendNotifyMsg(NULL, i, DEF_NOTIFY_DAMAGEMOVE, iDir, iDamage, 0, NULL);
				}

				if ((m_pClientList[i]->m_iHungerStatus <= 30) && (m_pClientList[i]->m_iHungerStatus >= 0)) 
					iPlusTime = (30 - m_pClientList[i]->m_iHungerStatus)*1000;
				else iPlusTime = 0;				
				iPlusTime = abs(iPlusTime);
				// HP up
				if ((dwTime - m_pClientList[i]->m_dwHPTime) > (DWORD)(DEF_HPUPTIME + iPlusTime)) { // 15 sec
					TimeHitPointsUp(i);
					m_pClientList[i]->m_dwHPTime = dwTime;
				}				
				// MP up
				if ((dwTime - m_pClientList[i]->m_dwMPTime) > (DWORD)(DEF_MPUPTIME + iPlusTime)) { // 20 sec
					TimeManaPointsUp(i);
					m_pClientList[i]->m_dwMPTime = dwTime;
					CheckCrusadeResultCalculation(i);   // Gives the XP some time after Event end announcement
					CheckHeldenianResultCalculation(i); // Gives the XP some time after Event end announcement
				}				
				// SP up
				if ((dwTime - m_pClientList[i]->m_dwSPTime) > (DWORD)(DEF_SPUPTIME + iPlusTime)) { //10 sec
					TimeStaminarPointsUp(i);
					m_pClientList[i]->m_dwSPTime = dwTime;
				}				
				// Poison
				if ((m_pClientList[i]->m_bIsPoisoned == TRUE) && ((dwTime - m_pClientList[i]->m_dwPoisonTime) > DEF_POISONTIME)) {
					PoisonEffect(i, NULL);
					m_pClientList[i]->m_dwPoisonTime = dwTime;
				}				// Save chararcter 
				if (   (m_pMapList[m_pClientList[i]->m_cMapIndex]->m_bIsFightZone == FALSE)
					&& ((dwTime - m_pClientList[i]->m_dwAutoSaveTime) > (DWORD)DEF_AUTOSAVETIME)) { // 6 min
					bSendMsgToLS(MSGID_REQUEST_SAVEPLAYERDATA, i);
					m_pClientList[i]->m_dwAutoSaveTime = dwTime;
				}				
				// ExpStock 
				if ((dwTime - m_pClientList[i]->m_dwExpStockTime) > (DWORD)DEF_EXPSTOCKTIME) { // 10 sec
					m_pClientList[i]->m_dwExpStockTime = dwTime; 
					CalcExpStock(i);
					CheckUniqueItemEquipment(i);
				}
				// Auto XP
				if ((dwTime - m_pClientList[i]->m_dwAutoExpTime) > (DWORD)DEF_AUTOEXPTIME)  // 6 min
				{	iValue = iDice(2, m_pClientList[i]->m_iLevel);
					if (iValue <= 0) iValue = 1;
					if (m_pClientList[i]->m_iAutoExpAmount < iValue) // Don't give auto XP if player have normal XP
					{	if ((m_pClientList[i]->m_iExp + iValue) < m_iLevelExpTable[m_pClientList[i]->m_iLevel+1]) 
						{	GetExp(i, iValue, FALSE);
							CalcExpStock(i);
						}
					}			
					m_pClientList[i]->m_iAutoExpAmount = 0;
					m_pClientList[i]->m_dwAutoExpTime = dwTime;
				}
						
				// Special Ability Time (20min).
				if (m_pClientList[i]->m_iSpecialAbilityTime == 3) 
				{	SendNotifyMsg(NULL, i, DEF_NOTIFY_SPECIALABILITYENABLED, NULL, NULL, NULL, NULL);
					// After the time up, add magic back
					// Say client that Resurection is again available
					sItemIndex = m_pClientList[i]->m_sItemEquipmentStatus[DEF_EQUIPPOS_RHAND];
					if (sItemIndex != -1) {
						if ((m_pClientList[i]->m_pItemList[sItemIndex]->m_sIDnum == 865) || (m_pClientList[i]->m_pItemList[sItemIndex]->m_sIDnum == 866)) {
							if(    ((m_pClientList[i]->m_iInt + m_pClientList[i]->m_iAngelicInt) > 99) 
								&& ((m_pClientList[i]->m_iMag + m_pClientList[i]->m_iAngelicMag) > 99))
							{	m_pClientList[i]->m_cMagicMastery[94] = TRUE;
								SendNotifyMsg(NULL, i, DEF_NOTIFY_STATECHANGE_SUCCESS, NULL, NULL, NULL, NULL);
					}	}	}
					// Add resurection for Priests here
					if ((m_pClientList[i]->m_iCharisma > 89)
						&& ((m_pClientList[i]->m_iStr + m_pClientList[i]->m_iAngelicStr) > 89)
						&& (m_pClientList[i]->m_iPriestDruidID == 1))						
					{	m_pClientList[i]->m_cMagicMastery[94] = TRUE; // Resurection
						SendNotifyMsg(NULL, i, DEF_NOTIFY_STATECHANGE_SUCCESS, NULL, NULL, NULL, NULL);
					}
				}
				// SNOOPY:  Remove special weapons visual effects
				//			1- In RealeaseItemHandler, , unequiping "normal" weapon/armor will remove possible assiciated shinning
				//			2- If shinning condition is wrong, below

				// SNOOPY: Added shinning DemonSlayer if Demon/GG around
				//         Added shinning to StormBringer (Elric version sword)
				//         Added shinning Hobbit blade if Orc arround
				sItemIndex = m_pClientList[i]->m_sItemEquipmentStatus[DEF_EQUIPPOS_TWOHAND];	
				if(sItemIndex != -1) 
				{	if(m_pClientList[i]->m_pItemList[sItemIndex]->m_sIDnum == 616)   // DS equiped
					{	if(SpecialWeapon_DS(i) == true )
						{	sTemp = m_pClientList[i]->m_sAppr4;
							sTemp = sTemp | 0x0004;		
						}else
						{	sTemp = m_pClientList[i]->m_sAppr4;
							sTemp = sTemp & 0xFFFB;					
						}
						if (m_pClientList[i]->m_sAppr4 != sTemp) // has changed
						{	m_pClientList[i]->m_sAppr4 = sTemp;
							SendEventToNearClient_TypeA(i, DEF_OWNERTYPE_PLAYER, MSGID_EVENT_MOTION, DEF_OBJECTNULLACTION, NULL, NULL, NULL);
					}	}	
					if (m_pClientList[i]->m_pItemList[sItemIndex]->m_sIDnum == 767)   // Elric Blade equiped
					{	if (SpecialWeapon_StormBringer(i, sItemIndex) == true )
						{	sTemp = m_pClientList[i]->m_sAppr4;
							sTemp = sTemp | 0x0004;					
							// The Shinning Blade's life is wipping out...
							m_pClientList[i]->m_pItemList[sItemIndex]->m_wCurLifeSpan --;	
							// If the blade's life is too low 
							iSBmissingLife = m_pClientList[i]->m_pItemList[sItemIndex]->m_wMaxLifeSpan - m_pClientList[i]->m_pItemList[sItemIndex]->m_wCurLifeSpan;
							if (iSBmissingLife >= 20 + iDice(1,100))
							{	SpecialWeapon_StormBringer_KillsNow(i, sItemIndex);							
							}
						}else // Not shining
						{	sTemp = m_pClientList[i]->m_sAppr4;
							sTemp = sTemp & 0xFFFB;					
							// Not shinning, the player life is wipping out....(to repair the blade)
							if (m_pClientList[i]->m_pItemList[sItemIndex]->m_wCurLifeSpan < m_pClientList[i]->m_pItemList[sItemIndex]->m_wMaxLifeSpan)
							{	m_pClientList[i]->m_iHP -= iDice(1,7);
								m_pClientList[i]->m_pItemList[sItemIndex]->m_wCurLifeSpan ++;
								if (m_pClientList[i]->m_iHP <= 0) 
								{	ClientKilledHandler(i, i, DEF_OWNERTYPE_PLAYER, 1);	
								}else
								{	m_pClientList[i]->m_dwLastDamageTime = dwTime;
									SendNotifyMsg(NULL, i, DEF_NOTIFY_HP, NULL, NULL, NULL, NULL);
									//SendEventToNearClient_TypeA(i, DEF_OWNERTYPE_PLAYER, MSGID_EVENT_MOTION, DEF_OBJECTDAMAGE, 1, NULL, NULL);
						}	}	}
						if (m_pClientList[i]->m_sAppr4 != sTemp) // has changed
						{	m_pClientList[i]->m_sAppr4 = sTemp;
							SendEventToNearClient_TypeA(i, DEF_OWNERTYPE_PLAYER, MSGID_EVENT_MOTION, DEF_OBJECTNULLACTION, NULL, NULL, NULL);
				}	}	}
				sItemIndex = m_pClientList[i]->m_sItemEquipmentStatus[DEF_EQUIPPOS_RHAND];	
				if(sItemIndex != -1) 
				{	if(m_pClientList[i]->m_pItemList[sItemIndex]->m_sIDnum == 19)   // Sting-Dart equiped
					{	if(SpecialWeapon_Orc(i) == true )
						{	sTemp = m_pClientList[i]->m_sAppr4;
							sTemp = sTemp | 0x000C;	
						}else
						{	sTemp = m_pClientList[i]->m_sAppr4;
							sTemp = sTemp & 0xFFF3;					
						}
						if (m_pClientList[i]->m_sAppr4 != sTemp) // has changed
						{	m_pClientList[i]->m_sAppr4 = sTemp;
							SendEventToNearClient_TypeA(i, DEF_OWNERTYPE_PLAYER, MSGID_EVENT_MOTION, DEF_OBJECTNULLACTION, NULL, NULL, NULL);
				}	}	}
				//  Check Elven cape duration
				sItemIndex = m_pClientList[i]->m_sItemEquipmentStatus[DEF_EQUIPPOS_BACK];	
				if (sItemIndex != -1) 
				{	if (m_pClientList[i]->m_pItemList[sItemIndex]->m_sIDnum == 646)   // Elven Cape equiped
					{	// The Cape's life is wipping out...
						m_pClientList[i]->m_pItemList[sItemIndex]->m_wCurLifeSpan --;
						if (m_pClientList[i]->m_pItemList[sItemIndex]->m_wCurLifeSpan == 0) 
							ReleaseItemHandler(i, sItemIndex, TRUE);
				}	}
				//SNOOPY: Remove Resurection spell if applicable Special Ability Time (20min).
				if ((m_pClientList[i]->m_iSpecialAbilityTime > 3) && (m_pClientList[i]->m_iAdminUserLevel == 0)) 
				{	if (m_pClientList[i]->m_cMagicMastery[94] == TRUE) 
					{	m_pClientList[i]->m_cMagicMastery[94] = FALSE;
						SendNotifyMsg(NULL, i, DEF_NOTIFY_STATECHANGE_SUCCESS, NULL, NULL, NULL, NULL);
					}
				}
				m_pClientList[i]->m_iSpecialAbilityTime -= 3;
				if (m_pClientList[i]->m_iSpecialAbilityTime < 0) m_pClientList[i]->m_iSpecialAbilityTime = 0;
				if (m_pClientList[i]->m_bIsSpecialAbilityEnabled == TRUE) 
				{	if (((dwTime - m_pClientList[i]->m_dwSpecialAbilityStartTime)/1000) > m_pClientList[i]->m_iSpecialAbilityLastSec) 
					{	m_pClientList[i]->m_bIsSpecialAbilityEnabled = FALSE;
						m_pClientList[i]->m_iSpecialAbilityTime = DEF_SPECABLTYTIMESEC;
						SendNotifyMsg(NULL, i, DEF_NOTIFY_SPECIALABILITYSTATUS, 3, NULL, m_pClientList[i]->m_iSpecialAbilityTime, NULL);
						sTemp = m_pClientList[i]->m_sAppr4;
						sTemp = sTemp & 0xFF0F;
						m_pClientList[i]->m_sAppr4 = sTemp;
						SendEventToNearClient_TypeA(i, DEF_OWNERTYPE_PLAYER, MSGID_EVENT_MOTION, DEF_OBJECTNULLACTION, NULL, NULL, NULL);
				}	}
				
				//Client is Locked on this map(s)
				m_pClientList[i]->m_iLockedMapTime -= 3; // remove 3 seconds
				if (m_pClientList[i]->m_iLockedMapTime <= 0) 
				{	m_pClientList[i]->m_iLockedMapTime = 0;
					ZeroMemory(m_pClientList[i]->m_cLockedMapName, sizeof(m_pClientList[i]->m_cLockedMapName));
					strcpy(m_pClientList[i]->m_cLockedMapName, "NONE");
				}
			
				m_pClientList[i]->m_iDeadPenaltyTime -= 3;
				if (m_pClientList[i]->m_iDeadPenaltyTime < 0) m_pClientList[i]->m_iDeadPenaltyTime = 0;

				if (m_pClientList[i]->m_iBeholderPower > 1) // Reduce Boholder potion duration
				{	m_pClientList[i]->m_iBeholderPower -= 3;
					if (m_pClientList[i]->m_iBeholderPower < 2) 
					{	m_pClientList[i]->m_iBeholderPower = 0; 
						SendNewInitMapData(i);
				}	}				
				if ( (m_pClientList[i]->m_bIsWarLocation == TRUE) ) 
				{	if (m_bIsCrusadeMode == FALSE) // do not reduce m_iTimeLeft_ForceRecall during crusade			
						m_pClientList[i]->m_iTimeLeft_ForceRecall--;
					if (m_pClientList[i]->m_iTimeLeft_ForceRecall <= 0) 
					{	m_pClientList[i]->m_iTimeLeft_ForceRecall = 0;
						m_pClientList[i]->m_bIsWarLocation = FALSE;	
						SendNotifyMsg(NULL, i, DEF_NOTIFY_TOBERECALLED, NULL, NULL, NULL, NULL);
						if (m_pClientList[i]->m_iAdminUserLevel == 0)
							RequestTeleportHandler(i, "0   ");		// SNOOPY: changed to forced recall
					}
				}
				// Every 3 seconds, give Hero flag effect if Flag set arround...
				if (   (m_bHeldenianWarInitiated == TRUE)
					&& (bCheckHeldenianMap(i, DEF_OWNERTYPE_PLAYER) == 1)) 
				{	if (m_pClientList[i]->bIsHeldenianHeroEnabled == FALSE)					
						SetHeroFlag(i, DEF_OWNERTYPE_PLAYER, TRUE);
				}else 
				{	if (m_pClientList[i]->bIsHeldenianHeroEnabled == TRUE)		
						SetHeroFlag(i, DEF_OWNERTYPE_PLAYER, FALSE);
				}		

				if (m_pClientList[i] == NULL) break;
				if (m_pClientList[i]->m_iSkillMsgRecvCount >= 2) 
				{	///rintf(G_cTxt, "(!) Player(%s) response time too high (Lagged-Out!)", m_pClientList[i]->m_cCharName);
					wsprintf(G_cTxt, "Alchemy / Manuf.:  PC(%s) - Uses skill too fast. (Disc.)\t\tIP(%s)."
							, m_pClientList[i]->m_cCharName
							, m_pClientList[i]->m_cIPaddress);
					PutHackLogFileList(G_cTxt);
					DeleteClient(i, TRUE, TRUE);
				}else 
				{	m_pClientList[i]->m_iSkillMsgRecvCount = 0;
				}
				// Snoopy: reintroduced Hourlly XP check
				if (m_pClientList[i] == NULL) break;
				if (   (m_pMapList[m_pClientList[i]->m_cMapIndex]->m_iXPRate <101) // Don't log on high XP map
					&& ((dwTime - m_pClientList[i]->m_dwXPHackCheckTime) > (DWORD)1000*60*60)) 
				{	if ((m_pClientList[i]->m_iExp - m_pClientList[i]->m_iXPHackCheckExp) > m_iHourllyXP250) 
						// Logg the fact but do log out character 
					{	wsprintf(G_cTxt, "Abnormal XP :      PC(%s) - Scored %d XP during past hour.\t%s(%d %d)\tIP(%s)."
							, m_pClientList[i]->m_cCharName
							, (m_pClientList[i]->m_iExp - m_pClientList[i]->m_iXPHackCheckExp)
							, m_pMapList[ m_pClientList[i]->m_cMapIndex ]->m_cName
							, m_pClientList[i]->m_sX
							, m_pClientList[i]->m_sY
							, m_pClientList[i]->m_cIPaddress);
						// Show this if over 250k / hour
						PutLogList(G_cTxt);		
						// Log this if over 300k / hour
						if((m_pClientList[i]->m_iExp - m_pClientList[i]->m_iXPHackCheckExp) > m_iHourllyXP300) 						
							PutLogFileList(G_cTxt);
						// Hack Log this and closeconn if over 400k/hour
						// Client is not XP Penalty blocked
						if((m_pClientList[i]->m_iExp - m_pClientList[i]->m_iXPHackCheckExp) > m_iHourllyXP400) 
						{	PutHackLogFileList(G_cTxt);
							/* // Dont block character
							SYSTEMTIME SysTime;
							GetLocalTime(&SysTime);													
							if ((SysTime.wMonth+1) >= 13) 
							{	m_pClientList[i]->m_iPenaltyBlockYear = SysTime.wYear+1;
								m_pClientList[i]->m_iPenaltyBlockMonth = 1;
								m_pClientList[i]->m_iPenaltyBlockDay = SysTime.wDay;
							}else 
							{	m_pClientList[i]->m_iPenaltyBlockYear = SysTime.wYear;
								m_pClientList[i]->m_iPenaltyBlockMonth = SysTime.wMonth+1;
								m_pClientList[i]->m_iPenaltyBlockDay = SysTime.wDay;
							} */
							DeleteClient(i, TRUE, TRUE);
						}else  //Useless to RAZ if client deleted
						{	m_pClientList[i]->m_dwXPHackCheckTime = dwTime;
							m_pClientList[i]->m_iXPHackCheckExp = m_pClientList[i]->m_iExp;
						}
							
					}else { // less than bix XP scored, RAZ it
						m_pClientList[i]->m_dwXPHackCheckTime = dwTime;
						m_pClientList[i]->m_iXPHackCheckExp = m_pClientList[i]->m_iExp;
					}
				}

				// Map Level Limit
				if (m_pClientList[i] == NULL) break;
				if (   (m_pClientList[i]->m_iLevel < m_pMapList[m_pClientList[i]->m_cMapIndex]->m_iLevelLimit) 
					&& (m_pClientList[i]->m_iAdminUserLevel < 2) ) 
				{	m_pClientList[i]->m_bIsWarLocation = TRUE;
					m_pClientList[i]->m_iTimeLeft_ForceRecall = 0;
				}

				// Map Upper level limit
				if (m_pClientList[i] == NULL) break;
				if (    (m_pMapList[m_pClientList[i]->m_cMapIndex]->m_iUpperLevelLimit != 0)
					 && (m_pClientList[i]->m_iLevel > m_pMapList[m_pClientList[i]->m_cMapIndex]->m_iUpperLevelLimit) 
					 && (m_pClientList[i]->m_iAdminUserLevel < 2) ) 
				{	m_pClientList[i]->m_bIsWarLocation = TRUE;
					m_pClientList[i]->m_iTimeLeft_ForceRecall = 0;
				}
				// Anti Traveller hack
				if (m_pClientList[i] == NULL) break;
				if (   (strcmp(m_pClientList[i]->m_cLocation, "elvine") != 0) 
					&& (strcmp(m_pClientList[i]->m_cLocation, "elvhunter") != 0) 
					&& (strcmp(m_pClientList[i]->m_cLocation, "arehunter") != 0) 
					&& (strcmp(m_pClientList[i]->m_cLocation, "aresden") != 0) 
					// SNOOPY: Added "evil" location
					&& (strcmp(m_pClientList[i]->m_cLocation, "evil") != 0)
					&& (strcmp(m_pClientList[i]->m_cLocation, "executor") != 0)
					&& (m_pClientList[i]->m_iLevel >= 20) 
					&& (m_pClientList[i]->m_iAdminUserLevel == 0) ) 
				{	wsprintf(G_cTxt, "Traveller Hack:    PC(%s) - Is a traveller and is greater than level 19.(Disc.) \tIP(%s)"
						, m_pClientList[i]->m_cCharName
						, m_pClientList[i]->m_cIPaddress);
					PutHackLogFileList(G_cTxt);
					DeleteClient(i, TRUE, TRUE);
				}
				// Recall clients from apocalypse map if not Apocalypse time
				if (m_pClientList[i] == NULL) break;
				if (   (m_pMapList[m_pClientList[i]->m_cMapIndex]->m_bIsApocalypseMap == TRUE) 
					&& (m_bIsApocalypseMode == FALSE)
					&& (m_pClientList[i]->m_iAdminUserLevel == 0))
				{	m_pClientList[i]->m_bIsWarLocation = TRUE;
					m_pClientList[i]->m_iTimeLeft_ForceRecall = 0;				
				}
							
				if (m_pClientList[i] == NULL) break;			
				// In enemy shops => Set recall time if Crusade or Standard Map settings
				if (   ((!m_bMapModeEquilibrium) || (m_bIsCrusadeMode == TRUE))
					&& (m_pClientList[i]->m_cSide == iGetMapLocationForbiddenSide(m_pMapList[m_pClientList[i]->m_cMapIndex]->m_cName)) 
					&& (m_pClientList[i]->m_iAdminUserLevel == 0))  // Not in own town
				{	m_pClientList[i]->m_bIsWarLocation = TRUE;
					m_pClientList[i]->m_iTimeLeft_ForceRecall = 0;
				}

				// SNOOPY: CitizenLimit was not implemented
				if (m_pClientList[i] == NULL) break;
				// Civilians/Travellers forbidden on map definition file
				if (   (m_pMapList[m_pClientList[i]->m_cMapIndex]->m_bIsCitizenLimit == TRUE)
					&& (m_pClientList[i]->m_iAdminUserLevel == 0)
					&& (   (m_pClientList[i]->m_cSide == 0) 
						|| (memcmp(m_pClientList[i]->m_cLocation, "elvhunter",9) == 0)
						|| (memcmp(m_pClientList[i]->m_cLocation, "arehunter",9) == 0)))
				{	m_pClientList[i]->m_bIsWarLocation = TRUE;
					m_pClientList[i]->m_iTimeLeft_ForceRecall = 1; // 1 will allow that in crusade times
				}
				// SNOOPY:added Apoc teleport Gates here		
				Use_ApocalypseGate(i);

				// not allowed to go in opposite Farm  (revamped by Snoopy)
				if (m_pClientList[i]->m_iAdminUserLevel == 0)
				{	if (strcmp(m_pClientList[i]->m_cMapName, "elvfarm") == 0) 
					{	if (   (m_pClientList[i]->m_cSide == 1)/*
							|| (m_pClientList[i]->m_cSide == 4)*/)
						{	m_pClientList[i]->m_bIsWarLocation = TRUE;
							m_pClientList[i]->m_iTimeLeft_ForceRecall = 1; // allowed at crusade time	
					}	}
					if (strcmp(m_pClientList[i]->m_cMapName, "arefarm") == 0) 
					{	if (   (m_pClientList[i]->m_cSide == 2)/*
							|| (m_pClientList[i]->m_cSide == 4)*/)
						{	m_pClientList[i]->m_bIsWarLocation = TRUE;
							m_pClientList[i]->m_iTimeLeft_ForceRecall = 1; // allowed at crusade time	
				}	}	}
					
				if (m_pClientList[i] == NULL) break;
				// increase Crits every 12 times this function is executed.
				m_pClientList[i]->m_iSuperAttackCount++;
				if (   (m_pClientList[i]->m_iPriestDruidID == 6) // Barbarians
					&& (m_pClientList[i]->m_bSpecialFeatureAllowed == TRUE) )
				{	m_pClientList[i]->m_iSuperAttackCount++; // Barbarians regen crits x2 faster
				}
				if (m_pClientList[i]->m_iSuperAttackCount > 12)  					
				{	m_pClientList[i]->m_iSuperAttackCount = 0;
					iMaxSuperAttack = (m_pClientList[i]->m_iLevel / 10);
					if (m_pClientList[i]->m_iSuperAttackLeft < iMaxSuperAttack) m_pClientList[i]->m_iSuperAttackLeft++;
					SendNotifyMsg(NULL, i, DEF_NOTIFY_SUPERATTACKLEFT, NULL, NULL, NULL, NULL);
				}
				// v1.42 
				m_pClientList[i]->m_iTimeLeft_FirmStaminar--;
				if (m_pClientList[i]->m_iTimeLeft_FirmStaminar < 0) m_pClientList[i]->m_iTimeLeft_FirmStaminar = 0;

				// Crusade
				if (m_pClientList[i] == NULL) break;
				if (m_pClientList[i]->m_bIsSendingMapStatus == TRUE) _SendMapStatus(i);
				if (   (m_bIsCrusadeMode == TRUE)
					&& (m_pClientList[i]->m_iConstructionPoint > 0))
				{	CheckCommanderConstructionPoint(i);	
	}	}	}	}
}

void CGame::OnMainLogSocketEvent(UINT message, WPARAM wParam, LPARAM lParam)
{	int   iRet;	
	if (m_pMainLogSock == NULL) return;
	iRet = m_pMainLogSock->iOnSocketEvent(wParam, lParam);
	//wsprintf(G_cTxt,"iRet   de ::OnMainLogSocketEvent %d", iRet);
	//PutLogList(G_cTxt);
	switch (iRet) {
	case DEF_XSOCKEVENT_UNKNOWN:
		wsprintf(G_cTxt,"(???M) DEF_XSOCKEVENT_UNKNOWN");
		PutLogList(G_cTxt);
		break;

	case DEF_XSOCKEVENT_UNSENTDATASENDCOMPLETE: // Changed here as well by Snoopy
		PutLogList("(>>>W) Main socket connected to WorldServer!");
		bSendMsgToLS(MSGID_REQUEST_REGISTERGAMESERVER, NULL);
		break;

	case DEF_XSOCKEVENT_CONNECTIONESTABLISH:
		break;
	
	case DEF_XSOCKEVENT_READCOMPLETE:
		OnMainLogRead();
		break;
	
	case DEF_XSOCKEVENT_BLOCK:
		PutLogList("(###M) Main-log-socket BLOCKED!");
		break;
	
	case DEF_XSOCKEVENT_CONFIRMCODENOTMATCH:
	case DEF_XSOCKEVENT_MSGSIZETOOLARGE:
	case DEF_XSOCKEVENT_SOCKETERROR:
	case DEF_XSOCKEVENT_SOCKETCLOSED:
		delete m_pMainLogSock;
		m_pMainLogSock = NULL;
		PutLogList("(---M) Main-log-socket connection lost!");
		m_bIsLogSockAvailable = FALSE;

		if (m_bOnExitProcess == FALSE) {
			m_cShutDownCode      = 3;
			m_bOnExitProcess     = TRUE;
			m_dwExitProcessTime  = timeGetTime();
			PutLogList("(!!!) GAME SERVER SHUTDOWN PROCESS BEGIN(by main-log-socket connection Lost)!!!");
		}
		break;
	}
}

void CGame::OnMainLogRead()
{
 DWORD dwMsgSize;
 char * pData, cKey;
	pData = m_pMainLogSock->pGetRcvDataPointer(&dwMsgSize, &cKey);
	if (bPutMsgQuene(DEF_MSGFROM_LOGSERVER, pData, dwMsgSize, NULL, cKey, NULL) == FALSE) {
		PutLogList("(@@@M) CRITICAL ERROR in MsgQuene!!! @@@@@@");
	}	
}


BOOL CGame::bSendMsgToLS(DWORD dwMsg, int iClientH, BOOL bFlag, char* pData)
{DWORD * dwp;
 WORD  * wp;
 int     iRet = NULL, i, iSize;
 char    cCharName[11], cAccountName[11], cAccountPassword[11], cAddress[16], cGuildName[21], cTxt[120], * cp;
 char    cGuildLoc[11], cTemp[120];
 int   * ip, iSendSize = 0;
	ZeroMemory(G_cData50000, sizeof(G_cData50000));
	ZeroMemory(cCharName, sizeof(cCharName));
	ZeroMemory(cAccountName, sizeof(cAccountName));
	ZeroMemory(cAccountPassword, sizeof(cAccountPassword));
	ZeroMemory(cAddress,   sizeof(cAddress));
	ZeroMemory(cGuildName, sizeof(cGuildName));
	ZeroMemory(cGuildLoc,  sizeof(cGuildLoc));
	
	switch (dwMsg) { // Sub-log-socket
	case MSGID_GAMEMASTERLOG:
		if (_bCheckSubLogSocketIndex() == FALSE) return FALSE;
		if (m_pClientList[iClientH] == NULL) return FALSE;
		if (pData == NULL) return FALSE ;
		dwp  = (DWORD *)(G_cData50000 + DEF_INDEX4_MSGID);
		*dwp = MSGID_GAMEMASTERLOG;
		wp   = (WORD *)(G_cData50000 + DEF_INDEX2_MSGTYPE);
		*wp  = DEF_MSGTYPE_CONFIRM;
		cp = (char *)(G_cData50000 + DEF_INDEX2_MSGTYPE + 2);
		iSize =  strlen(pData) ;
		memcpy((char *)cp, pData, iSize);
		iRet = m_pSubLogSock[m_iCurSubLogSockIndex]->iSendMsg(G_cData50000, 6 + iSize);
		iSendSize = 6 + iSize;
		break;
		// v2.15 

	case MSGID_GAMEITEMLOG:		// Sub-log-socket
	case MSGID_GAMECRUSADELOG:	// Sub-log-socket
		if (_bCheckSubLogSocketIndex() == FALSE) return FALSE;
		if (pData == NULL) return FALSE ;
		dwp  = (DWORD *)(G_cData50000 + DEF_INDEX4_MSGID);
		*dwp = dwMsg;
		wp   = (WORD *)(G_cData50000 + DEF_INDEX2_MSGTYPE);
		*wp  = DEF_MSGTYPE_CONFIRM;
		cp = (char *)(G_cData50000 + DEF_INDEX2_MSGTYPE + 2);
		iSize =  strlen(pData) ;
		memcpy((char *)cp, pData, iSize);
		iRet = m_pSubLogSock[m_iCurSubLogSockIndex]->iSendMsg(G_cData50000, 6 + iSize);
		iSendSize = 6 + iSize;
		break;

	case MSGID_SENDSERVERSHUTDOWNMSG:// m_pMainLogSock
		if (m_pMainLogSock == NULL) return FALSE;
		dwp  = (DWORD *)(G_cData50000 + DEF_INDEX4_MSGID);
		*dwp = MSGID_SENDSERVERSHUTDOWNMSG;
		wp   = (WORD *)(G_cData50000 + DEF_INDEX2_MSGTYPE);
		*wp  = DEF_MSGTYPE_CONFIRM;
		iRet = m_pMainLogSock->iSendMsg(G_cData50000, 6);
		return TRUE; // Added by Snoopy
		break;
	
	case MSGID_GAMESERVERSHUTDOWNED:// m_pMainLogSock
		if (m_pMainLogSock == NULL) return FALSE;
		dwp  = (DWORD *)(G_cData50000 + DEF_INDEX4_MSGID);
		*dwp = MSGID_GAMESERVERSHUTDOWNED;
		wp   = (WORD *)(G_cData50000 + DEF_INDEX2_MSGTYPE);
		*wp  = DEF_MSGTYPE_CONFIRM;		
		iRet = m_pMainLogSock->iSendMsg(G_cData50000, 6);
		return TRUE;
		break;

	case MSGID_REQUEST_SETACCOUNTWAITSTATUS:
	case MSGID_REQUEST_SETACCOUNTINITSTATUS: // Sub-log-socket
		if (_bCheckSubLogSocketIndex() == FALSE) return FALSE;		
		if (m_pClientList[iClientH] == NULL) return FALSE;
		dwp  = (DWORD *)(G_cData50000 + DEF_INDEX4_MSGID);
		*dwp = dwMsg;
		wp   = (WORD *)(G_cData50000 + DEF_INDEX2_MSGTYPE);
		*wp  = DEF_MSGTYPE_CONFIRM;		
		cp = (char *)(G_cData50000 + DEF_INDEX2_MSGTYPE + 2);
		memcpy(cp, m_pClientList[iClientH]->m_cAccountName, 10);
		cp += 10;
		ip = (int *)cp;
		*ip = m_pClientList[iClientH]->m_iLevel;
		cp += 4;
		iRet = m_pSubLogSock[m_iCurSubLogSockIndex]->iSendMsg(G_cData50000, 20);
		iSendSize = 16;
		break;

	case MSGID_ENTERGAMECONFIRM: // Sub-log-socket
//PutLogList("MSGID_ENTERGAMECONFIRM"); // debug
		if (_bCheckSubLogSocketIndex() == FALSE) return FALSE;		
		if (m_pClientList[iClientH] == NULL) return FALSE;
		dwp  = (DWORD *)(G_cData50000 + DEF_INDEX4_MSGID);
		*dwp = MSGID_ENTERGAMECONFIRM;
		wp   = (WORD *)(G_cData50000 + DEF_INDEX2_MSGTYPE);
		*wp  = DEF_MSGTYPE_CONFIRM;		
		cp = (char *)(G_cData50000 + DEF_INDEX2_MSGTYPE + 2);
		memcpy(cp, m_pClientList[iClientH]->m_cAccountName, 10);
		cp += 10;
		memcpy(cp, m_pClientList[iClientH]->m_cAccountPassword, 10);
		cp += 10;
		memcpy(cp, m_cServerName, 10);
		cp += 10;
		ZeroMemory(cTxt, sizeof(cTxt));
		m_pClientList[iClientH]->m_pXSock->iGetPeerAddress(cTxt);
		memcpy(cp, cTxt, 16);
		cp += 16;
		ip = (int *)cp;
		*ip = m_pClientList[iClientH]->m_iLevel;
		cp += 4;
		//testcode
		wsprintf(G_cTxt,"<%d> Client Confirmed : (%s)  Account(%s)  PC(%s)  Lvl(%d)  PartyID(%d)"
			, iClientH
			, m_pClientList[iClientH]->m_cIPaddress
			, m_pClientList[iClientH]->m_cAccountName
			, m_pClientList[iClientH]->m_cCharName
			, m_pClientList[iClientH]->m_iLevel
			, m_pClientList[iClientH]->m_iPartyID);
		PutLogList(G_cTxt);
		iRet = m_pSubLogSock[m_iCurSubLogSockIndex]->iSendMsg(G_cData50000, 56);
		iSendSize = 56;
		break;
	
	case MSGID_REQUEST_REGISTERGAMESERVER: // to MAINLOG, m_pMainLogSock
		if (m_pMainLogSock == NULL) return FALSE;				
		wsprintf(cTxt, "(...W) Try to register game server(%s) to WorldServer.", m_cServerName);		
		PutLogList(cTxt);		
		dwp  = (DWORD *)(G_cData50000 + DEF_INDEX4_MSGID);
		//*dwp = MSGID_REQUEST_REGISTERGAMESERVER;
		*dwp = m_dwMSGID_REQUEST_REGISTERGAMESERVER;
		wp   = (WORD *)(G_cData50000 + DEF_INDEX2_MSGTYPE);
		*wp  = DEF_MSGTYPE_CONFIRM;		
		cp = (char *)(G_cData50000 + DEF_INDEX2_MSGTYPE + 2);
		memcpy(cAccountName, m_cServerName, 10);
		if (m_iGameServerMode == 1) // ROUTER/LAN mode, behind router
		{	memcpy(cAddress, m_cGameServerAddrExternal, strlen(m_cGameServerAddrExternal));
		}else //if (m_iGameServerMode == 2)
		{	memcpy(cAddress, m_cGameServerAddr, strlen(m_cGameServerAddr));
		}
		memcpy(cp, cAccountName, 10);
		cp += 10;
		memcpy(cp, cAddress, 16);
		cp += 16;
		wp  = (WORD *)cp;
		*wp = m_iGameServerPort;
		cp += 2;
		*cp = m_iTotalMaps;
		cp++;
		for (i = 0; i < m_iTotalMaps; i++) 
		{	memcpy(cp, m_pMapList[i]->m_cName, 11);
			cp += 11;
		}
		iRet = m_pMainLogSock->iSendMsg(G_cData50000, 35 + m_iTotalMaps*11); 
		return TRUE;

	case MSGID_REQUEST_PLAYERDATA: // Sub-log-socket
		if (_bCheckSubLogSocketIndex() == FALSE) return FALSE;
		if (m_pClientList[iClientH] == NULL) return FALSE;
		dwp  = (DWORD *)(G_cData50000 + DEF_INDEX4_MSGID);
		*dwp = MSGID_REQUEST_PLAYERDATA;
		wp   = (WORD *)(G_cData50000 + DEF_INDEX2_MSGTYPE);
		*wp  = DEF_MSGTYPE_CONFIRM;
		cp = (char *)(G_cData50000 + DEF_INDEX2_MSGTYPE + 2);
		//testcode
		//if (strlen(m_pClientList[iClientH]->m_cCharName) == 0) PutLogList("(X) Sent CharName NULL to LS!");
		memcpy(cCharName, m_pClientList[iClientH]->m_cCharName, 10);
		memcpy(cAccountName, m_pClientList[iClientH]->m_cAccountName, 10);
		memcpy(cAccountPassword, m_pClientList[iClientH]->m_cAccountPassword, 10);
		memcpy((char *)cp, cCharName, 10);
		cp += 10;
		memcpy((char *)cp, cAccountName, 10);
		cp += 10;
		memcpy((char *)cp, cAccountPassword, 10);
		cp += 10;
		ZeroMemory(cTemp, sizeof(cTemp));
		iRet = m_pClientList[iClientH]->m_pXSock->iGetPeerAddress(cTemp);
		memcpy((char *)cp, cTemp, 15);
		cp += 15;		
		iRet = m_pSubLogSock[m_iCurSubLogSockIndex]->iSendMsg(G_cData50000, 52);
		iSendSize = 52;
		break;

	case MSGID_REQUEST_SAVEPLAYERDATA_REPLY:
	case MSGID_REQUEST_SAVEPLAYERDATA:
	case MSGID_REQUEST_SAVEPLAYERDATALOGOUT: // Sub-log-socket
		if (_bCheckSubLogSocketIndex() == FALSE) return FALSE;		
		if (m_pClientList[iClientH] == NULL) return FALSE;		
		dwp  = (DWORD *)(G_cData50000 + DEF_INDEX4_MSGID);
		*dwp = dwMsg;
		wp   = (WORD *)(G_cData50000 + DEF_INDEX2_MSGTYPE);
		*wp  = DEF_MSGTYPE_CONFIRM;
		cp = (char *)(G_cData50000 + DEF_INDEX2_MSGTYPE + 2);
		memcpy(cCharName, m_pClientList[iClientH]->m_cCharName, 10);
		memcpy(cAccountName, m_pClientList[iClientH]->m_cAccountName, 10);
		memcpy(cAccountPassword, m_pClientList[iClientH]->m_cAccountPassword, 10);
		memcpy((char *)cp, cCharName, 10);
		cp += 10;
		memcpy((char *)cp, cAccountName, 10);
		cp += 10;
		memcpy((char *)cp, cAccountPassword, 10);
		cp += 10;
		*cp = (char)bFlag;
		cp++;		
		iSize = _iComposePlayerDataFileContents(iClientH, cp);		
		iRet = m_pSubLogSock[m_iCurSubLogSockIndex]->iSendMsg(G_cData50000, 37 + iSize);
		iSendSize = 37 + iSize;
		break;

	case MSGID_REQUEST_NOSAVELOGOUT: // Sub-log-socket
		if (_bCheckSubLogSocketIndex() == FALSE) return FALSE;		
		if (m_pClientList[iClientH] == NULL) return FALSE;		
		dwp  = (DWORD *)(G_cData50000 + DEF_INDEX4_MSGID);
		*dwp = MSGID_REQUEST_NOSAVELOGOUT;
		wp   = (WORD *)(G_cData50000 + DEF_INDEX2_MSGTYPE);
		*wp  = DEF_MSGTYPE_CONFIRM;
		cp = (char *)(G_cData50000 + DEF_INDEX2_MSGTYPE + 2);
		memcpy(cCharName, m_pClientList[iClientH]->m_cCharName, 10);
		memcpy(cAccountName, m_pClientList[iClientH]->m_cAccountName, 10);
		memcpy(cAccountPassword, m_pClientList[iClientH]->m_cAccountPassword, 10);
		memcpy((char *)cp, cCharName, 10);
		cp += 10;
		memcpy((char *)cp, cAccountName, 10);
		cp += 10;
		memcpy((char *)cp, cAccountPassword, 10);
		cp += 10;		
		*cp = (char)bFlag;
		cp++;		
		iRet = m_pSubLogSock[m_iCurSubLogSockIndex]->iSendMsg(G_cData50000, 37);
		iSendSize = 37;
		break;
	
	case MSGID_REQUEST_CREATENEWGUILD: // Sub-log-socket
		if (_bCheckSubLogSocketIndex() == FALSE) return FALSE;		
		if (m_pClientList[iClientH] == NULL) return FALSE;		
		dwp  = (DWORD *)(G_cData50000 + DEF_INDEX4_MSGID);
		*dwp = MSGID_REQUEST_CREATENEWGUILD;
		wp   = (WORD *)(G_cData50000 + DEF_INDEX2_MSGTYPE);
		*wp  = DEF_MSGTYPE_CONFIRM;
		cp = (char *)(G_cData50000 + DEF_INDEX2_MSGTYPE + 2);
		memcpy(cCharName, m_pClientList[iClientH]->m_cCharName, 10);
		memcpy(cAccountName, m_pClientList[iClientH]->m_cAccountName, 10);
		memcpy(cAccountPassword, m_pClientList[iClientH]->m_cAccountPassword, 10);
		memcpy(cGuildName, m_pClientList[iClientH]->m_cGuildName, 20);
		memcpy(cGuildLoc, m_pClientList[iClientH]->m_cLocation, 10);
		memcpy((char *)cp, cCharName, 10);
		cp += 10;
		memcpy((char *)cp, cAccountName, 10);
		cp += 10;
		memcpy((char *)cp, cAccountPassword, 10);
		cp += 10;
		memcpy((char *)cp, cGuildName, 20);
		cp += 20;
		memcpy((char *)cp, cGuildLoc, 10);
		cp += 10;
		ip = (int *)cp;
		*ip = m_pClientList[iClientH]->m_iGuildGUID;
		cp += 4;
		iRet = m_pSubLogSock[m_iCurSubLogSockIndex]->iSendMsg(G_cData50000, 75);
		iSendSize = 75;
		break;

	case MSGID_REQUEST_DISBANDGUILD: // Sub-log-socket		
		if (_bCheckSubLogSocketIndex() == FALSE) return FALSE;		
		if (m_pClientList[iClientH] == NULL) return FALSE;		
		dwp  = (DWORD *)(G_cData50000 + DEF_INDEX4_MSGID);
		*dwp = MSGID_REQUEST_DISBANDGUILD;
		wp   = (WORD *)(G_cData50000 + DEF_INDEX2_MSGTYPE);
		*wp  = DEF_MSGTYPE_CONFIRM;
		cp = (char *)(G_cData50000 + DEF_INDEX2_MSGTYPE + 2);
		memcpy(cCharName, m_pClientList[iClientH]->m_cCharName, 10);
		memcpy(cAccountName, m_pClientList[iClientH]->m_cAccountName, 10);
		memcpy(cAccountPassword, m_pClientList[iClientH]->m_cAccountPassword, 10);
		memcpy(cGuildName, m_pClientList[iClientH]->m_cGuildName, 20);
		memcpy((char *)cp, cCharName, 10);
		cp += 10;
		memcpy((char *)cp, cAccountName, 10);
		cp += 10;
		memcpy((char *)cp, cAccountPassword, 10);
		cp += 10;
		memcpy((char *)cp, cGuildName, 20);
		cp += 20;		
		iRet = m_pSubLogSock[m_iCurSubLogSockIndex]->iSendMsg(G_cData50000, 56);
		iSendSize = 56;
		break;

	case MSGID_REQUEST_HELDENIAN_WINNER: // Sub-log-socket	
		if (_bCheckSubLogSocketIndex() == FALSE) return FALSE;		
		dwp  = (DWORD *)(G_cData50000 + DEF_INDEX4_MSGID);
		*dwp = MSGID_REQUEST_HELDENIAN_WINNER;
		wp   = (WORD *)(G_cData50000 + DEF_INDEX2_MSGTYPE);
		*wp  = DEF_MSGTYPE_CONFIRM;
		cp = (char *)(G_cData50000 + DEF_INDEX2_MSGTYPE + 2);
		if (m_cHeldenianWinner == 1)
			memcpy(cp, "aresden", 7);
		else if (m_cHeldenianWinner == 2)
			memcpy(cp, "elvine", 6);
		else 
			memcpy(cp, "draw", 4);
		iRet = m_pSubLogSock[m_iCurSubLogSockIndex]->iSendMsg(G_cData50000, 21);
		iSendSize = 21;
		break;
	
	case MSGID_REQUEST_UPDATE_NEWGUILDSMAN: // Sub-log-socket
		if (_bCheckSubLogSocketIndex() == FALSE) return FALSE;		
		if (m_pClientList[iClientH] == NULL) return FALSE;		
		dwp  = (DWORD *)(G_cData50000 + DEF_INDEX4_MSGID);
		*dwp = MSGID_REQUEST_UPDATE_NEWGUILDSMAN;
		wp   = (WORD *)(G_cData50000 + DEF_INDEX2_MSGTYPE);
		*wp  = DEF_MSGTYPE_CONFIRM;
		cp = (char *)(G_cData50000 + DEF_INDEX2_MSGTYPE + 2);
		memcpy(cCharName, m_pClientList[iClientH]->m_cCharName, 10);
		memcpy(cGuildName, m_pClientList[iClientH]->m_cGuildName, 20);
		memcpy((char *)cp, cCharName, 10);
		cp += 10;
		memcpy((char *)cp, cGuildName, 20);
		cp += 20;
		iRet = m_pSubLogSock[m_iCurSubLogSockIndex]->iSendMsg(G_cData50000, 36);
		iSendSize = 36;
		break;

	case MSGID_REQUEST_UPDATE_DELGUILDSMAN: // Sub-log-socket
		if (_bCheckSubLogSocketIndex() == FALSE) return FALSE;		
		if (m_pClientList[iClientH] == NULL) return FALSE;
		dwp  = (DWORD *)(G_cData50000 + DEF_INDEX4_MSGID);
		*dwp = MSGID_REQUEST_UPDATE_DELGUILDSMAN;
		wp   = (WORD *)(G_cData50000 + DEF_INDEX2_MSGTYPE);
		*wp  = DEF_MSGTYPE_CONFIRM;
		cp = (char *)(G_cData50000 + DEF_INDEX2_MSGTYPE + 2);
		memcpy(cCharName, m_pClientList[iClientH]->m_cCharName, 10);
		memcpy(cGuildName, m_pClientList[iClientH]->m_cGuildName, 20);
		memcpy((char *)cp, cCharName, 10);
		cp += 10;
		memcpy((char *)cp, cGuildName, 20);
		cp += 20;
		iRet = m_pSubLogSock[m_iCurSubLogSockIndex]->iSendMsg(G_cData50000, 36);
		iSendSize = 36;
		break;
	}
	switch (iRet) {
	case DEF_XSOCKEVENT_QUENEFULL:
	case DEF_XSOCKEVENT_SOCKETERROR:
	case DEF_XSOCKEVENT_CRITICALERROR:
	case DEF_XSOCKEVENT_SOCKETCLOSED:
		// Sub-log-socket
		wsprintf(G_cTxt, "(---W) Sub-log-socket(%d) send error!", m_iCurSubLogSockIndex);
		PutLogList(G_cTxt);
		PutLogFileList(G_cTxt);
		delete m_pSubLogSock[m_iCurSubLogSockIndex];
		m_pSubLogSock[m_iCurSubLogSockIndex] = NULL;
		m_bIsSubLogSockAvailable[m_iCurSubLogSockIndex] = FALSE;
		m_iSubLogSockActiveCount--;
		m_pSubLogSock[m_iCurSubLogSockIndex] = new class XSocket(m_hWnd, DEF_SERVERSOCKETBLOCKLIMIT);
		m_bIsSubLogSockInitialPointer[m_iCurSubLogSockIndex] = (int) m_pSubLogSock[m_iCurSubLogSockIndex];
		m_pSubLogSock[m_iCurSubLogSockIndex]->bConnect(m_cLogServerAddr, m_iLogServerPort, (WM_ONLOGSOCKETEVENT + m_iCurSubLogSockIndex + 1));
		m_pSubLogSock[m_iCurSubLogSockIndex]->bInitBufferSize(DEF_MSGBUFFERSIZE);
		wsprintf(G_cTxt, "(!) Try to reconnect sub-log-socket(%d)... Addr:%s  Port:%d", m_iCurSubLogSockIndex, m_cLogServerAddr, m_iLogServerPort);
		PutLogList(G_cTxt);		
		// v1.41 sub-log-socket
		m_iSubLogSockFailCount++;
		// v1.41 
		if (_bCheckSubLogSocketIndex() == FALSE) return FALSE;
		m_pSubLogSock[m_iCurSubLogSockIndex]->iSendMsg(G_cData50000, iSendSize);

		return FALSE;
	}
	return TRUE;
}

void CGame::ResponsePlayerDataHandler(char * pData, DWORD dwSize)
{
 WORD * wp;
 char * cp, cCharName[11], cTxt[120];
 int  i; 
 
	ZeroMemory(cCharName, sizeof(cCharName));
	cp = (char *)(pData + DEF_INDEX2_MSGTYPE + 2);
	memcpy(cCharName, cp, 10);
	cp += 10;
	for (i = 1; i < DEF_MAXCLIENTS; i++) 
	if (m_pClientList[i] != NULL) {
		if (memcmp(m_pClientList[i]->m_cCharName, cCharName, 10) == 0) {
			wp = (WORD *)(pData + DEF_INDEX2_MSGTYPE);
			switch (*wp) {
			case DEF_LOGRESMSGTYPE_CONFIRM:
				InitPlayerData(i, pData, dwSize); 
				break;	
			case DEF_LOGRESMSGTYPE_REJECT:
				wsprintf(G_cTxt, "(HACK?) Not existing character(%s) data request! Rejected!", m_pClientList[i]->m_cCharName);
				PutLogList(G_cTxt);
				PutLogFileList(G_cTxt);
				DeleteClient(i, FALSE, FALSE);
				break;			
			default:
				break;
			}		
			return;
		}	
	}
	wsprintf(cTxt, "(!)Non-existing player data received from Log server: CharName(%s)", cCharName);
	PutLogList(cTxt);
	PutLogFileList(G_cTxt);
}

void CGame::InitPlayerData(int iClientH, char * pData, DWORD dwSize)
{	char  * cp, cName[11], cData[256], cTxt[256], cGuildStatus, cQuestRemain;
	DWORD * dwp;
	WORD  * wp;
	int     iRet, iDiscountRatio;
	BOOL    bRet;
	if (m_pClientList[iClientH] == NULL) return;
	if (m_pClientList[iClientH]->m_bIsInitComplete == TRUE) return; 

	// Log Server
	cp = (char *)(pData + DEF_INDEX2_MSGTYPE + 2);
	ZeroMemory(cName, sizeof(cName));
	memcpy(cName, cp, 10);
	cp += 10;
	//m_pClientList[iClientH]->m_cAccountStatus = *cp;
	cp++;

	cGuildStatus = *cp;
	cp++;

	m_pClientList[iClientH]->m_iHitRatio      = 0;
	m_pClientList[iClientH]->m_iHitRatio3     = 0; // for MG attack
	m_pClientList[iClientH]->m_iDefenseRatio  = 0;
	m_pClientList[iClientH]->m_iDefenseRatio2 = 0;
	m_pClientList[iClientH]->m_iDefenseRatio3 = 0;
	m_pClientList[iClientH]->m_cSide          = 0;
	m_pClientList[iClientH]->m_bSpecialFeatureAllowed = FALSE;
	m_pClientList[iClientH]->m_bAntiTPLameEK  = TRUE;
	m_pClientList[iClientH]->m_IsPeaceMode	  = TRUE;	
	m_pClientList[iClientH]->m_iBeholderPower = 0;

	bRet = _bDecodePlayerDatafileContents(iClientH, cp, dwSize - 19);
	if (bRet == FALSE) // Loged in ::_bDecodePlayerDatafileContents function
	{	DeleteClient(iClientH, FALSE, TRUE);
		return;
	}
	___RestorePlayerRating(iClientH);

	if ((m_pClientList[iClientH]->m_sX == -1) && (m_pClientList[iClientH]->m_sY == -1)) 
	{	GetMapInitialPoint(m_pClientList[iClientH]->m_cMapIndex, &m_pClientList[iClientH]->m_sX, &m_pClientList[iClientH]->m_sY, m_pClientList[iClientH]->m_cSide);
	}
	// SNOOPY: Compute character m_cDiscount
	iDiscountRatio = ((m_pClientList[iClientH]->m_iCharisma -50)/ -4);   // 50..90 charisma gives 0..10% price discount.	
	if (iDiscountRatio > 0 ) iDiscountRatio = 0;	// No price majoration for charisma
	if (m_sLastHeldenianWinner + m_pClientList[iClientH]->m_cSide == 3) // Lost last Heldenian +10% prices
	{	iDiscountRatio += 10;
	}			
	if (m_iCrusadeWinnerSide   + m_pClientList[iClientH]->m_cSide == 3) // Lost last Crusade +10% prices
	{	iDiscountRatio += 10;
	}			
	if (iDiscountRatio <  0 ) iDiscountRatio =  0;	 // Never lower prices
	if (iDiscountRatio > 10 ) iDiscountRatio = 10;	 // Sometimes increase them up to 10%

	// NB: I removed all discount for Charisma here, as in the client.
	if (m_pClientList[iClientH]->m_iAdminUserLevel == 0) iDiscountRatio = 0;

	m_pClientList[iClientH]->m_cDiscount = (char) iDiscountRatio;

	// New 17/05/2004
	SetPlayingStatus(iClientH);
	int iTemp, iTemp2;
	iTemp = m_pClientList[iClientH]->m_iStatus;
	iTemp = 0x0FFBFFFF & iTemp;
	iTemp2 = iGetPlayerABSStatus(iClientH);
	iTemp = iTemp | (iTemp2 << 28);
	m_pClientList[iClientH]->m_iStatus = iTemp;

	if (m_pClientList[iClientH]->m_iLevel > 100)
		if (m_pClientList[iClientH]->m_bIsPlayerCivil == TRUE)
			ForceChangePlayMode(iClientH, FALSE);

	// Computing Next level XP
	m_pClientList[iClientH]->m_iNextLevelExp = m_iLevelExpTable[m_pClientList[iClientH]->m_iLevel + 1]; 
	//iGetLevelExp(m_pClientList[iClientH]->m_iLevel + 1);
	// SNOOPY: Trap for above max level for non-executors
	if (m_pClientList[iClientH]->m_cSide != 4) 
	{	if (m_pClientList[iClientH]->m_iLevel >= m_iPlayerMaxLevel) 		
		{	m_pClientList[iClientH]->m_iNextLevelExp = m_iLevelExpTable[m_iPlayerMaxLevel + 1];	
	}	}
	//SNOOPY: Set Priest or Druid condition
	Set_PriestDruid(iClientH);
	// bCheckMagicInt(iClientH); Deplacé un peu + bas a cause des Angels qui pourraient modifier une stat
	// Then Items availability, & class effects.
	CalcTotalItemEffect(iClientH, -1, TRUE); //FALSE
	iCalcTotalWeight(iClientH);
	bCheckMagicInt(iClientH);

	//GM Invi comes here
	if (m_pClientList[iClientH]->m_iAdminUserLevel > 0) 
	{	SetInvisibilityFlag(iClientH, DEF_OWNERTYPE_PLAYER, TRUE);
	}	
	if (   (m_pClientList[iClientH]->m_iLevel > 2) 
		&& (m_pClientList[iClientH]->m_iAdminUserLevel == 0) 
		&& (m_pClientList[iClientH]->m_iExp < iGetLevelExp(m_pClientList[iClientH]->m_iLevel-1)-3000)
		&& (m_pClientList[iClientH]->m_iLevel <= m_iPlayerMaxLevel) ) 
	{	wsprintf(G_cTxt, "Data Error:        PC(%s) - Current xp: %d --- Minimum xp: %d.(Disc.) \tIP(%s)"
			, m_pClientList[iClientH]->m_cCharName
			, m_pClientList[iClientH]->m_iExp
			, (iGetLevelExp(m_pClientList[iClientH]->m_iLevel)-1)
			, m_pClientList[iClientH]->m_cIPaddress);	
		PutHackLogFileList(G_cTxt);
		DeleteClient(iClientH, TRUE, TRUE);
		return;
	}		
	// This can give you Memorial ring, depending on special event number
	CheckSpecialEvent(iClientH);
	//SNOOPY Check Skills (in case of stats change)
	// will also check max skill points and reduce if needed.
	Check_Skill_Is_Valid(iClientH); 
	
	// Just in case Skill total reduction failled.
	int i, iTotalPoints = 0;
	for (i = 0; i <	DEF_MAXSKILLTYPE; i++) 
		iTotalPoints += m_pClientList[iClientH]->m_cSkillMastery[i];
	if (   (iTotalPoints > m_sCharSkillLimit) 
		&& (m_pClientList[iClientH]->m_iAdminUserLevel == 0))
	{	wsprintf(G_cTxt, "Packet Editing:    PC(%s) - Has more than allowed skill points (%d).(Disc.) \tIP(%s)"
			, m_pClientList[iClientH]->m_cCharName
			, iTotalPoints
			, m_pClientList[iClientH]->m_cIPaddress);
		PutHackLogFileList(G_cTxt);
		PutLogList(cTxt);
		DeleteClient(iClientH, TRUE, TRUE);	
		return;		
	}

	// GuildName NONE ­ GuildStatus 
	if ((cGuildStatus == 0) && (memcmp(m_pClientList[iClientH]->m_cGuildName, "NONE", 4) != 0)) {
		ZeroMemory(m_pClientList[iClientH]->m_cGuildName, sizeof(m_pClientList[iClientH]->m_cGuildName));
		strcpy(m_pClientList[iClientH]->m_cGuildName, "NONE");
		m_pClientList[iClientH]->m_iGuildRank = -1;
		m_pClientList[iClientH]->m_iGuildGUID = -1;
		SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_GUILDDISBANDED, NULL, NULL, NULL, m_pClientList[iClientH]->m_cGuildName);
	}
	if (m_pClientList[iClientH]->m_iQuest != NULL)  
	{	cQuestRemain = (m_pQuestConfigList[m_pClientList[iClientH]->m_iQuest]->m_iMaxCount - m_pClientList[iClientH]->m_iCurQuestCount);
		SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_QUESTCOUNTER, cQuestRemain, NULL, NULL, NULL);
		_bCheckIsQuestCompleted(iClientH);
	} 
	if (m_pClientList[iClientH] == NULL) 
	{	wsprintf(cTxt, "<%d> InitPlayerData error - Socket error! Disconnected.", iClientH);
		PutLogList(cTxt);
		return;
	}

	ZeroMemory(cData, sizeof(cData));
	dwp  = (DWORD *)(cData + DEF_INDEX4_MSGID);
	*dwp = MSGID_RESPONSE_INITPLAYER;
	wp   = (WORD *)(cData + DEF_INDEX2_MSGTYPE);
	*wp  = DEF_MSGTYPE_CONFIRM;

	// 
	iRet = m_pClientList[iClientH]->m_pXSock->iSendMsg(cData, 6);
	switch (iRet) {
	case DEF_XSOCKEVENT_QUENEFULL:
	case DEF_XSOCKEVENT_SOCKETERROR:
	case DEF_XSOCKEVENT_CRITICALERROR:
	case DEF_XSOCKEVENT_SOCKETCLOSED:
		wsprintf(cTxt, "<%d> InitPlayerData - Socket error! Disconnected.", iClientH);
		PutLogList(cTxt);
		DeleteClient(iClientH, FALSE, TRUE); //
		return;
	}

	bSendMsgToLS(MSGID_ENTERGAMECONFIRM, iClientH);		// Changed order of those 2 lines
	m_pClientList[iClientH]->m_bIsInitComplete = TRUE;	// Changed order of those 2 lines
	m_pClientList[iClientH]->m_dwLastActionTime = m_pClientList[iClientH]->m_dwAFKCheckTime = timeGetTime();

	if (m_iTotalClients > DEF_MAXONESERVERUSERS) {
		switch (iDice(1,2)) {
		case 1: 
			RequestTeleportHandler(iClientH, "2   ", "bisle", -1, -1);
			break;
		case 2: 
			switch (m_pClientList[iClientH]->m_cSide) {
			case 0: RequestTeleportHandler(iClientH, "2   ", "resurr1", -1, -1); break;
			case 1: RequestTeleportHandler(iClientH, "2   ", "resurr1", -1, -1); break;
			case 2: 
			default:
				RequestTeleportHandler(iClientH, "2   ", "resurr2", -1, -1); break;
			}
			break;
		}
	}

	if (!m_bMapModeEquilibrium) 
	{	// If Crusade was started in Equilibrium map mode
		if (   (m_bMapModeEquilibriumChanged == TRUE) //Just changed to play crusade
			&& (memcmp(m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cLocationName, "lost", 4) == 0))
		{	switch (m_pClientList[iClientH]->m_cSide) {					
			case 1: // Aresden
				RequestTeleportHandler(iClientH, "2   ", "wrhus_1", -1, -1);
				break;
			case 2: // Elvine
				RequestTeleportHandler(iClientH, "2   ", "wrhus_2", -1, -1);
				break;
			default:
				break;
			}
		}else
	//SNOOPY  If a player disconect in Equi WH in EQUILIBRIUM Mode,
	//        then reconnect in CLASSIC mode, he can find himself in 
	//		  opposite town 2nd WH.
	// so: Every player logging in ennemy 2nd WH, in CLASSIC mode 
	//     is changed to home WH		
		{	if ((memcmp(m_pClientList[iClientH]->m_cMapName, "arewrhus", 8) == 0) && (m_pClientList[iClientH]->m_cSide == 2))
				RequestTeleportHandler(iClientH, "2   ", "wrhus_2", -1, -1);
			if ((memcmp(m_pClientList[iClientH]->m_cMapName, "elvwrhus", 8) == 0) && (m_pClientList[iClientH]->m_cSide == 1))
				RequestTeleportHandler(iClientH, "2   ", "wrhus_1", -1, -1);		
		}
	}

	// SNOOPY: For party dismissing 20 sec after changing server...
	// Confirm connection to Gate server
	//
	// When deleting client, the gserver sends a "7" message to the Gate
	// When the client reconnects to another server, it must tell the Gate
	// or else the gate will remove the client from party a few seconds later
	// Here the proper way to tell Gate, using "5" msg (request party info)
	GetPartyInfoHandler(iClientH);
	// Recover summons you may had before deco...
	iRecoverFollowers(iClientH, FALSE);
	return;
}

void CGame::GameProcess()
{   NpcProcess();
	MsgProcess();
	//DelayEventProcess(); Now on timer if Timer >1000
}

BOOL CGame::bReadProgramConfigFile(char * cFn)
{FILE * pFile;
 HANDLE hFile;
 DWORD  dwFileSize;
 char * cp, * token, cReadMode, cTxt[120], cGSMode[16] = "";
 char seps[] = "= \t\n";	
 class CStrTok * pStrTok;
 bool bGateDNS = false; // bGateDNS added by snaipperi
 bool bLogDNS = false; // bLogDNS added by snaipperi
	cReadMode = 0;
	hFile = CreateFile(cFn, GENERIC_READ, NULL, NULL, OPEN_EXISTING, NULL, NULL);
	dwFileSize = GetFileSize(hFile, NULL);
	if (hFile != INVALID_HANDLE_VALUE) CloseHandle(hFile);
	pFile = fopen(cFn, "rt");
	if (pFile == NULL) return FALSE;
	else 
	{	PutLogList("(!) Reading configuration file...");
		cp = new char[dwFileSize+2];
		ZeroMemory(cp, dwFileSize+2);
		fread(cp, dwFileSize, 1, pFile);
		pStrTok = new class CStrTok(cp, seps);
		token = pStrTok->pGet();	//token = strtok( cp, seps );   
		while( token != NULL )   {
			if (cReadMode != 0) 
			{	switch (cReadMode) {
				case 1: // game-server-name
					ZeroMemory(m_cServerName, sizeof(m_cServerName));
					if (strlen(token) > 10) 
					{	wsprintf(cTxt, "(!!!) Game server name(%s) must within 10 chars!", token);
						PutLogList(cTxt);
						delete pStrTok;	return FALSE;
					}
					strcpy(m_cServerName, token);
					wsprintf(cTxt, "(*) Game server name : %s", m_cServerName);
					PutLogList(cTxt);
					cReadMode = 0;
					break;
				case 2: // game-server-port
					ZeroMemory(m_cGameServerAddr, sizeof(m_cGameServerAddr));
					char ServerAddr[50];
					::gethostname(ServerAddr,50); 
					struct hostent *pHostEnt;
					pHostEnt = ::gethostbyname(ServerAddr);
					if( pHostEnt != NULL )
					{	wsprintf(ServerAddr, "%d.%d.%d.%d",
							( pHostEnt->h_addr_list[0][0] & 0x00ff ),
							( pHostEnt->h_addr_list[0][1] & 0x00ff ),
							( pHostEnt->h_addr_list[0][2] & 0x00ff ),
							( pHostEnt->h_addr_list[0][3] & 0x00ff ) );
					}
					strcpy(m_cGameServerAddr,ServerAddr );
					wsprintf(cTxt, "(*) Game server address : %s", m_cGameServerAddr);
					PutLogList(cTxt);
					m_iGameServerPort = atoi(token);
					wsprintf(cTxt, "(*) Game server port : %d", m_iGameServerPort);
					PutLogList(cTxt);
					cReadMode = 0;
					break;

				case 3: // log-server-address
					ZeroMemory(m_cLogServerAddr, sizeof(m_cLogServerAddr));
					if (bLogDNS == true)  //bLogDNS by Snaipperi
					{	PutLogList(cTxt);
						char *cAddress = token;
						char cDnsResult[40];
						struct hostent *host_entry;
						host_entry = gethostbyname(cAddress);
						if (host_entry == NULL) 
						{	wsprintf(cTxt, "(!)DNS (%s) failed",token);
							PutLogList(cTxt);
							delete pStrTok;	return FALSE;
						}
						wsprintf(cDnsResult, "%d.%d.%d.%d",
							( pHostEnt->h_addr_list[0][0] & 0x00ff ),
							( pHostEnt->h_addr_list[0][1] & 0x00ff ),
							( pHostEnt->h_addr_list[0][2] & 0x00ff ),
							( pHostEnt->h_addr_list[0][3] & 0x00ff ) );
						wsprintf(cTxt, "(!)DNS from (%s) to (%s) success!",token,cDnsResult);
						PutLogList(cTxt);
						strcpy(m_cLogServerAddr, cDnsResult);
						wsprintf(cTxt, "(*) Log server address : %s", m_cLogServerAddr);
						PutLogList(cTxt);
						cReadMode = 0;
						break;
					}
					if (strlen(token) > 20) 
					{	wsprintf(cTxt, "(!!!) Log server address(%s) must within 20 chars!", token);
						PutLogList(cTxt);
						delete pStrTok;	return FALSE;
					}
					strcpy(m_cLogServerAddr, token);
					wsprintf(cTxt, "(*) Log server IP : %s", m_cLogServerAddr);
					PutLogList(cTxt);
					cReadMode = 0;
					break;

				case 4: // internal-log-server-port
					m_iLogServerPort = atoi(token);
					wsprintf(cTxt, "(*) Log server internal port : %d", m_iLogServerPort);
					PutLogList(cTxt);
					cReadMode = 0;
					break;

				case 5: // game-server-map
					if (strlen(token) > 10) 
					{	wsprintf(cTxt, "(!!!) CRITICAL ERROR! Map name(%s) must within 10 chars!", token);
						PutLogList(cTxt);
						delete pStrTok;	return FALSE;
					}
					if (_bRegisterMap(token) == FALSE) // Load .amd file
					{	delete pStrTok;	return FALSE;
					}
					cReadMode = 0;
					break;

				case 6: // gate-server-address
					ZeroMemory(m_cGateServerAddr, sizeof(m_cGateServerAddr));
					if (bGateDNS == true)  //bGateDNS by Snaipperi
					{	PutLogList(cTxt);
						char *cAddress = token;
						char cDnsResult[40];
						struct hostent *host_entry;
						host_entry = gethostbyname(cAddress);
						if (host_entry == NULL) 
						{	wsprintf(cTxt, "(!)DNS (%s) failed",token);
							PutLogList(cTxt);
							delete pStrTok;	return FALSE;
						}					
						wsprintf(cDnsResult, "%d.%d.%d.%d",
							( host_entry->h_addr_list[0][0] & 0x00ff ),
							( host_entry->h_addr_list[0][1] & 0x00ff ),
							( host_entry->h_addr_list[0][2] & 0x00ff ),
							( host_entry->h_addr_list[0][3] & 0x00ff ) );
				
						wsprintf(cTxt, "(!)DNS from (%s) to (%s) success!",token,cDnsResult);
						PutLogList(cTxt);
						strcpy(m_cGateServerAddr, cDnsResult);
						wsprintf(cTxt, "(*) Gate server address : %s", m_cGateServerAddr);
						PutLogList(cTxt);
						cReadMode = 0;
						break;
					}				
					if (strlen(token) > 20) 
					{	wsprintf(cTxt, "(!!!) Gate server address(%s) must within 20 chars!", token);
						PutLogList(cTxt);
						delete pStrTok;	return FALSE;
					}
					strcpy(m_cGateServerAddr, token);
					wsprintf(cTxt, "(*) Gate server IP : %s", m_cGateServerAddr);
					PutLogList(cTxt);
					cReadMode = 0;
					break;

				case 7: // gate-server-port
					m_iGateServerPort = atoi(token);
					wsprintf(cTxt, "(*) Gate server port : %d", m_iGateServerPort);
					PutLogList(cTxt);
					cReadMode = 0;
					break;

				case 8: // game-server-internal-address
					ZeroMemory(m_cGameServerAddrInternal, sizeof(m_cGameServerAddrInternal));
					if (strlen(token) > 15) 
					{	wsprintf(cTxt, "(!!!) Internal (LAN) Game server IP(%s) must within 15 chars!", token);
						PutLogList(cTxt);
						delete pStrTok;	return FALSE;
					}
					strcpy(m_cGameServerAddrInternal, token);
					wsprintf(cTxt, "(*) Internal (LAN) Game server IP : %s", m_cGameServerAddrInternal);
					PutLogList(cTxt);
					cReadMode = 0;
					break;

				case 9: // game-server-external-address
					ZeroMemory(m_cGameServerAddrExternal, sizeof(m_cGameServerAddrExternal));
					if (strlen(token) > 15) 
					{	wsprintf(cTxt, "(!!!) External (Internet) Game server IP(%s) must within 15 chars!", token);
						PutLogList(cTxt);
						delete pStrTok;	return FALSE;
					}
					strcpy(m_cGameServerAddrExternal, token);
					wsprintf(cTxt, "(*) External (Internet) Game server IP : %s", m_cGameServerAddrExternal);
					PutLogList(cTxt);
					cReadMode = 0;
					break;

				case 10: // game-server-address
					ZeroMemory(m_cGameServerAddr, sizeof(m_cGameServerAddr));
					if (strlen(token) > 15) 
					{	wsprintf(cTxt, "(!!!) Game server IP(%s) must within 15 chars!", token);
						PutLogList(cTxt);
						delete pStrTok;	return FALSE;
					}
					strcpy(m_cGameServerAddr, token);
					wsprintf(cTxt, "(*) Game server IP : %s", m_cGameServerAddr);
					PutLogList(cTxt);
					cReadMode = 0;
					break;

				case 11: // game-server-mode
					if ((memcmp(token, "lan", 3) == 0) || (memcmp(token, "LAN", 3) == 0))
					{	m_iGameServerMode = 1;
						memcpy(cGSMode, "ROUTER", 3);
					}
					if ((memcmp(token, "router", 6) == 0) || (memcmp(token, "ROUTER", 6) == 0))
					{	m_iGameServerMode = 1;
						memcpy(cGSMode, "ROUTER", 8);
					}
					if ((memcmp(token, "internet", 8) == 0) || (memcmp(token, "INTERNET", 8) == 0))
					{	m_iGameServerMode = 2;
						memcpy(cGSMode, "INTERNET", 8);
					}
					if (m_iGameServerMode == 0)
					{	wsprintf(cTxt, "(!!!) Game server mode(%s) must be either ROUTER/router/LAN/lan or INTERNET/internet", token);
						PutLogList(cTxt);
						delete pStrTok;	return FALSE;
					}
					wsprintf(cTxt, "(*) Game server mode : %s", cGSMode);
					PutLogList(cTxt);
					cReadMode = 0;
					break;
			
				case 12: // gate-server-dns
					if (memcmp(token, "true", 4) == 0) 
					{	bGateDNS = TRUE; //Gate DNS by SNaipperi
					}else bGateDNS = FALSE;
					wsprintf(cTxt, "Gate DNS is set to %i",bGateDNS);
					PutLogList(cTxt);
					cReadMode = 0;
					break;

				case 13: // log-server-dns
					if (memcmp(token, "true", 4) == 0) 
					{	bLogDNS = TRUE; //Log DNS by Snaipperi
					}else bLogDNS = FALSE;
					wsprintf(cTxt, "Log DNS is set to %i",bLogDNS);
					PutLogList(cTxt);
					cReadMode = 0;
					break;

				case 14: // build-date
					m_dwBuildDate = atoi(token); // build-date by Snoopy
					wsprintfA(G_cTxt, "(*) Build Date : %d", m_dwBuildDate);
					PutLogList(G_cTxt);
					cReadMode = 0;
					break;
				}
			}else 
			{	if (memcmp(token, "game-server-name", 16) == 0)			cReadMode = 1;
				if (memcmp(token, "game-server-port", 16) == 0)			cReadMode = 2;
				if (memcmp(token, "log-server-address", 18) == 0)		cReadMode = 3;
				if (memcmp(token, "log-server-port", 15) == 0)			cReadMode = 4;
				if (memcmp(token, "internal-log-server-port", 24) == 0) cReadMode = 4;
				if (memcmp(token, "game-server-map", 15) == 0)			cReadMode = 5;
				if (memcmp(token, "gate-server-address", 19) == 0)		cReadMode = 6;
				if (memcmp(token, "gate-server-port", 16) == 0)			cReadMode = 7;
				if (memcmp(token, "game-server-internal-address", 28) == 0)			cReadMode = 8;
				if (memcmp(token, "game-server-external-address", 28) == 0)			cReadMode = 9;
				if (memcmp(token, "game-server-address", 19) == 0)		cReadMode = 10;
				if (memcmp(token, "game-server-mode", 16) == 0)			cReadMode = 11;
				if (memcmp(token, "gate-server-dns", 15) == 0)			cReadMode = 12;
				if (memcmp(token, "log-server-dns", 14) == 0)			cReadMode = 13;	
				if (memcmp(token, "build-date", 10) == 0)				cReadMode = 14;
			}
			token = pStrTok->pGet();//token = strtok( NULL, seps );
		}
		delete pStrTok;
		delete cp;
	}
	if (pFile != NULL) fclose(pFile);
	if (m_iGameServerMode == 0) 
	{	wsprintf(cTxt, "(!!!) Game server mode cannot be empty. It must be either ROUTER/router/LAN/lan or INTERNET/internet", token);
		PutLogList(cTxt);
		return FALSE;	
	}	
	if (m_iGameServerMode == 1) // Default address is always internal in ROUTER mode
	{	ZeroMemory(m_cGameServerAddr, sizeof(m_cGameServerAddr));
		strcpy(m_cGameServerAddr, m_cGameServerAddrInternal);
	}else if (m_iGameServerMode == 2) // Internal are always normal in INTERNET mode
	{	ZeroMemory(m_cGameServerAddrInternal, sizeof(m_cGameServerAddrInternal));
		ZeroMemory(m_cGameServerAddrExternal, sizeof(m_cGameServerAddrExternal));
		strcpy(m_cGameServerAddrInternal, m_cGameServerAddr);
		strcpy(m_cGameServerAddrExternal, m_cGameServerAddr);
	}	
	return TRUE;
}

BOOL CGame::bReadSettingsConfigFile(char * cFn) 
{FILE * pFile; 
 HANDLE hFile; 
 DWORD  dwFileSize; 
 char * cp, * token, cReadMode, cTxt[120], len;//, cGSMode[16] = ""; 
 char seps[] = "= \t\n"; 
 class CStrTok * pStrTok; 
 float fAverage;
 BOOL bFileReadOK = FALSE; // Check for an empty file (or read error): must at least read primary-drop-rate
	cReadMode = 0; 
	hFile = CreateFile(cFn, GENERIC_READ, NULL, NULL, OPEN_EXISTING, NULL, NULL); 
	dwFileSize = GetFileSize(hFile, NULL); 
	if (hFile != INVALID_HANDLE_VALUE) CloseHandle(hFile); 
	pFile = fopen(cFn, "rt"); 
	if (pFile == NULL) 
	{  PutLogList("(!) Cannot open Settings.cfg file."); 
		return FALSE; 
	} else  
    {	PutLogList("(!) Reading settings file..."); 
		cp = new char[dwFileSize+2]; 
 		ZeroMemory(cp, dwFileSize+2); 
		fread(cp, dwFileSize, 1, pFile);
		pStrTok = new class CStrTok(cp, seps); 
		token = pStrTok->pGet(); 
		//token = strtok( cp, seps );    
		while( token != NULL )    
		{   if (cReadMode != 0)  
			{	switch (cReadMode) { 
            case 1: // SNOOPY: Buggy! strlen means String Length & not value !
				if ((memcmp(token, "equilibrium", 11) == 0) || (memcmp(token, "EQUILIBRIUM", 11) == 0)) 
				{	m_iPrimaryDropRate = 8720; // Default Equi value
				}else 
				{	if (_bGetIsStringIsNumber(token) == FALSE) 
					{	PutLogList("(!!!) CRITICAL ERROR! Settings.cfg - Wrong Data format (Primary drop rate)."); 
						delete pStrTok;
						return FALSE; 
					};
					m_iPrimaryDropRate = atoi(token); 
				}// Check value and use defaut if wrong				
				if ((m_iPrimaryDropRate <1) || (m_iPrimaryDropRate > 10000)) 
				{   m_iPrimaryDropRate = 7750; // Default HB value
					wsprintf(cTxt, "(!!!) Primary drop rate(%s) invalid must be between 1 to 10000, or EQUILIBRIUM (using default 7750).", token); 
				}else 
				{	wsprintf(cTxt, "(*) Primary drop rate: (%d)", m_iPrimaryDropRate); 
				}   
				PutLogList(cTxt);     
				bFileReadOK = TRUE;
               cReadMode = 0; 
               break; 
            case 2: // SNOOPY: Buggy! strlen means String Lentgh & not value !
				if ((memcmp(token, "equilibrium", 11) == 0) || (memcmp(token, "EQUILIBRIUM", 11) == 0)) 
				{	m_iSecondaryDropRate = 7800; // Default Equi value
				}else {
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! Settings.cfg - Wrong Data format (Secondary drop rate).");
						delete pStrTok;
						return FALSE; 
					};
					m_iSecondaryDropRate = atoi(token); 
				}// Check value and use defaut if wrong				
				if ((m_iSecondaryDropRate <1) || (m_iSecondaryDropRate > 10000)) 
				{   m_iSecondaryDropRate = 9000; // Default HB value
					wsprintf(cTxt, "(!!!) Secondary drop rate(%s) invalid must be between 1 to 10000, or EQUILIBRIUM (using default 9000).", token); 
				}else 
				{	wsprintf(cTxt, "(*) Secondary drop rate: (%d)", m_iSecondaryDropRate); 					                   
				}   
				PutLogList(cTxt); 
               cReadMode = 0; 
               break; 

            case 3: 
               if ((memcmp(token, "classic", 7) == 0) || (memcmp(token, "CLASSIC", 7) == 0)) 
               {  m_bEnemyKillMode = FALSE; 
                  wsprintf(cTxt, "(*) Enemy Kill Mode: CLASSIC"); 
                  PutLogList(cTxt); 
               }else if ((memcmp(token, "deathmatch", 10) == 0) || (memcmp(token, "DEATHMATCH", 10) == 0)) 
               {  m_bEnemyKillMode = TRUE; 
                  wsprintf(cTxt, "(*) Enemy Kill Mode: DEATHMATCH"); 
                  PutLogList(cTxt); 
               }else 
               {  wsprintf(cTxt, "(!!!) ENEMY-KILL-MODE: (%s) must be either DEATHMATCH or CLASSIC", token); 
                  PutLogList(cTxt); 
				  delete pStrTok;
                  return FALSE; 
               } 
               cReadMode = 0; 
               break; 
            case 4: // SNOOPY: Buggy! strlen means String Lentgh & not value !
				if (_bGetIsStringIsNumber(token) == FALSE)
				{	PutLogList("(!!!) CRITICAL ERROR! Settings.cfg - Wrong Data format ( Enemy Kill Adjust).");
				}
				m_iEnemyKillAdjust = atoi(token);
				if (( m_iEnemyKillAdjust < 0) || (m_iEnemyKillAdjust > 100)) 
				{	m_iEnemyKillAdjust = 1;
					wsprintf(cTxt, "(!!!) ENEMY-KILL-ADJUST: (%s) invalid must be between 1 to 100, used default (1)", token); 
					PutLogList(cTxt);
				} 
				wsprintf(cTxt, "(*) Player gains (%d) EK per enemy kill.", m_iEnemyKillAdjust); 
				PutLogList(cTxt); 
				cReadMode = 0; 
				break; 
            case 5: 
               if ((memcmp(token, "on", 2) == 0) || (memcmp(token, "ON", 2) == 0)) 
               {  m_bAdminSecurity = TRUE; 
                  wsprintf(cTxt, "(*) Administator actions limited through security."); 
                  PutLogList(cTxt); 
               } 
               if ((memcmp(token, "off", 3) == 0) || (memcmp(token, "OFF", 3) == 0)) 
               {  m_bAdminSecurity = FALSE; 
                  wsprintf(cTxt, "(*) Administator vulnerability ignored."); 
                  PutLogList(cTxt); 
               } 
               cReadMode = 0; 
               break; 
            case 6: 
               m_sRaidTimeMonday = atoi(token); 
               if (m_sRaidTimeMonday == 0) m_sRaidTimeMonday = 3; 
               wsprintf(cTxt, "(*) Monday Raid Time : (%d) minutes", m_sRaidTimeMonday); 
               PutLogList(cTxt); 
               cReadMode = 0; 
               break; 
            case 7: 
               m_sRaidTimeTuesday = atoi(token); 
               if (m_sRaidTimeTuesday == 0) m_sRaidTimeTuesday = 3; 
               wsprintf(cTxt, "(*) Tuesday Raid Time : (%d) minutes", m_sRaidTimeTuesday); 
               PutLogList(cTxt); 
               cReadMode = 0; 
               break; 
            case 8: 
               m_sRaidTimeWednesday = atoi(token); 
               if (m_sRaidTimeWednesday == 0) m_sRaidTimeWednesday = 3; 
               wsprintf(cTxt, "(*) Wednesday Raid Time : (%d) minutes", m_sRaidTimeWednesday); 
               PutLogList(cTxt); 
               cReadMode = 0; 
               break; 
            case 9: 
               m_sRaidTimeThursday = atoi(token); 
               if (m_sRaidTimeThursday == 0) m_sRaidTimeThursday = 3; 
               wsprintf(cTxt, "(*) Thursday Raid Time : (%d) minutes", m_sRaidTimeThursday); 
               PutLogList(cTxt); 
               cReadMode = 0; 
               break; 
            case 10: 
               m_sRaidTimeFriday = atoi(token); 
               if (m_sRaidTimeFriday == 0) m_sRaidTimeFriday = 10; 
               wsprintf(cTxt, "(*) Friday Raid Time : (%d) minutes", m_sRaidTimeFriday); 
               PutLogList(cTxt); 
               cReadMode = 0; 
               break; 
            case 11: 
               m_sRaidTimeSaturday = atoi(token); 
               if (m_sRaidTimeSaturday == 0) m_sRaidTimeSaturday = 45; 
               wsprintf(cTxt, "(*) Saturday Raid Time : (%d) minutes", m_sRaidTimeSaturday); 
               PutLogList(cTxt); 
               cReadMode = 0; 
               break; 
            case 12: 
               m_sRaidTimeSunday = atoi(token); 
               if (m_sRaidTimeSunday == 0) m_sRaidTimeSunday = 60; 
               wsprintf(cTxt, "(*) Sunday Raid Time : (%d) minutes", m_sRaidTimeSunday); 
               PutLogList(cTxt); 
               cReadMode = 0; 
               break; 		
			case 13:
				if ((memcmp(token, "player", 6) == 0) || (memcmp(token, "PLAYER", 6) == 0))
				{	m_bLogChatOption = 1;
					wsprintf(cTxt, "(*) Logging Player Chat.");
					PutLogList(cTxt);
				}
				if ((memcmp(token, "gm", 2) == 0) || (memcmp(token, "GM", 2) == 0))
				{	m_bLogChatOption = 2;
					wsprintf(cTxt, "(*) Logging GM Chat.");
					PutLogList(cTxt);
				}
				if ((memcmp(token, "all", 3) == 0) || (memcmp(token, "ALL", 3) == 0))
				{	m_bLogChatOption = 3;
					wsprintf(cTxt, "(*) Logging All Chat.");
					PutLogList(cTxt);
				}
				if ((memcmp(token, "none", 4) == 0) || (memcmp(token, "NONE", 4) == 0))
				{	m_bLogChatOption = 4;
					wsprintf(cTxt, "(*) Not Logging Any Chat.");
					PutLogList(cTxt);
				}
				cReadMode = 0;
				break;
            case 14: 
               m_iSummonGuildCost = atoi(token); 
               wsprintf(cTxt, "(*) Summoning guild costs (%d) gold", m_iSummonGuildCost); 
               PutLogList(cTxt); 
               cReadMode = 0; 
               break; 
			case 15: 
               m_sSlateSuccessRate = atoi(token); 
               wsprintf(cTxt, "(*) Slate Success Rate (%d) percent", m_sSlateSuccessRate); 
               PutLogList(cTxt); 
			   if (m_sSlateSuccessRate == 0) m_sSlateSuccessRate = 14; 
               cReadMode = 0; 
               break;
			case 16: 
               m_sCharStatLimit = atoi(token); 
               if (m_sCharStatLimit == 0) m_sCharStatLimit = 200; 
               cReadMode = 0;
               break;
			case 17: 
               m_sCharSkillLimit = atoi(token); 
               if (m_sCharSkillLimit <= 0) m_sCharSkillLimit = 700; 
               cReadMode = 0;
               break;
			case 18: 
               m_cRepDropModifier = atoi(token); 
               wsprintf(cTxt, "(*) Rep<->Drop modifier: (%d)", m_cRepDropModifier); 
               PutLogList(cTxt); 
               if (m_cRepDropModifier < 0) m_cRepDropModifier = 0;
               cReadMode = 0; 
               break;
			case 19: 
               ZeroMemory(m_cSecurityNumber, sizeof(m_cSecurityNumber));
			   len = strlen(token);
			   if(len > 10) len = 10;
			   memcpy(m_cSecurityNumber, token, len);
               wsprintf(cTxt, "(*) Security number memorized!"); 
               PutLogList(cTxt); 
               cReadMode = 0; 
               break;
			case 20: //Snoopy added num value check
				if (_bGetIsStringIsNumber(token) == FALSE) 
				{	PutLogList("(!!!) CRITICAL ERROR! Settings.cfg - Wrong Data format (Max Player Level).");
					delete pStrTok;
					return FALSE; 
				};
                m_sAbsoluteMaxPlayerLevel = atoi(token); 
                if (m_sAbsoluteMaxPlayerLevel == 0) m_sAbsoluteMaxPlayerLevel = DEF_PLAYERMAXLEVEL; 
                cReadMode = 0;
                break;
// SNOOPY: Added map-mode = EQUILIBRIUM or CLASSIC
// used for allowing many settings in game
            case 21: 
               if ((memcmp(token, "classic", 7) == 0) || (memcmp(token, "CLASSIC", 7) == 0)) 
               {	m_bMapModeEquilibrium = FALSE; 
					wsprintf(cTxt, "(*) Map Mode: CLASSIC"); 
					PutLogList(cTxt); 
               }else if ((memcmp(token, "equilibrium", 11) == 0) || (memcmp(token, "EQUILIBRIUM", 11) == 0)) 
               {	m_bMapModeEquilibrium = TRUE;  
					wsprintf(cTxt, "(*) Map Mode: EQUILIBRIUM"); 
					PutLogList(cTxt); 
               }else 
               {	wsprintf(cTxt, "(!!!) MAP-MODE: (%s) must be either EQUILIBRIUM or CLASSIC", token); 
					PutLogList(cTxt); 
					delete pStrTok;
					return FALSE; 
               } 
               cReadMode = 0; 
               break; 
// SNOOPY: Added pvp-hp-mode = HIGH or LOW
// in HIGH mode PvP, Player attacking player has a far better chance to hit.
// Defence formula is changed from Dext x 1 to Dext x1
// Critical attacks give a -100 malus to defender instead of +100 to hit 
            case 22: 
               if ((memcmp(token, "low", 3) == 0) || (memcmp(token, "LOW", 3) == 0)) 
               {	m_bPVPHPMode = FALSE; 
					wsprintf(cTxt, "(*) PVP HP Mode: LOW (HB standard)"); 
					PutLogList(cTxt); 
               } 
               else if ((memcmp(token, "high", 4) == 0) || (memcmp(token, "HIGH", 4) == 0)) 
               {	m_bPVPHPMode = TRUE;  
					wsprintf(cTxt, "(*) PVP HP Mode: HIGH (Easier to hit characters!)"); 
					PutLogList(cTxt); 
               } 
               else 
               {	wsprintf(cTxt, "(!!!) pvp-hp-mode: (%s) must be either HIGH or LOW (HB standard)", token); 
					PutLogList(cTxt); 
					return FALSE; 
               } 
               cReadMode = 0; 
               break; 
// SNOOPY: Added Gold drop rate (default was 6000)
// The aim is to reduce gold drops too enhance HB economy
// Beware to reduce primary drop rate if using low gold drop rate or there will be many items instead!
            case 23: // SNOOPY: Gold drop rate 6000 (standard) means 60% of drops are gold.
				if ((memcmp(token, "equilibrium", 11) == 0) || (memcmp(token, "EQUILIBRIUM", 11) == 0)) 
				{	m_iGoldDropRate = 3000; // Default Equi value
				}else {
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! Settings.cfg - Wrong Data format (Gold drop rate)."); 
						delete pStrTok;
						return FALSE; 
					};
					m_iGoldDropRate = atoi(token); 
				}
				// Check value and use defaut if wrong
				if ((m_iGoldDropRate <1) || (m_iGoldDropRate > 10000)) 
				{   m_iGoldDropRate = 6500; // Default HB value
					wsprintf(cTxt, "(!!!) Gold drop rate(%s) invalid must be between 1 to 10000, or EQUILIBRIUM (using default 6500).", token); 
				} 
				else 
				{	wsprintf(cTxt, "(*) Gold drop rate: (%d)", m_iGoldDropRate); 
				}   
				PutLogList(cTxt);              
               cReadMode = 0; 
               break; 
// SNOOPY: Added Alchimy item upgrade ON or OFF (default)
// default is OFF
            case 24: 
				if ((memcmp(token, "on", 2) == 0) || (memcmp(token, "ON", 2) == 0)) 
				{	 // Default Equi value				
					m_iAlchimyItemUpgradeEnabled = TRUE;
					wsprintf(cTxt, "(*) Alchimy Item upgrade mode ON"); 
				}else {
					m_iAlchimyItemUpgradeEnabled = FALSE;
					wsprintf(cTxt, "(*) Alchimy Item upgrade mode OFF"); 				
				}
				PutLogList(cTxt);              
				cReadMode = 0; 
				break; 
// SNOOPY: Added Gizon item upgrade ON or OFF (default)
// default is OFF
            case 25: 
				if ((memcmp(token, "on", 2) == 0) || (memcmp(token, "ON", 2) == 0)) 
				{	 // Default Equi value				
					m_iGizonItemUpgradeEnabled = TRUE;
					wsprintf(cTxt, "(*) Gizon Item upgrade mode ON"); 
				}else 
				{	m_iGizonItemUpgradeEnabled = FALSE;
					wsprintf(cTxt, "(*) Gizon Item upgrade mode OFF"); 				
				}
				PutLogList(cTxt);              
				cReadMode = 0; 
				break; 
// SNOOPY: Added this to choose the XP mode for the server
// 0-Classic is standard HB (bonus up to level 80, reduced in farms above lvl 80
// 1-USA is huge bonusses up to lvl 120.
// 2-EQUILIBRIUM is my standard:
//             bonus up to lvl 120 instead of 80, no malus in farms at high levels
//			   malus for 10 max levels of the server (140 -> 150 (2% per level)
//			   XP20% weapons are counted AFTER the party XP sharing.

            case 26: 
               if ((memcmp(token, "HB", 2) == 0) || (memcmp(token, "hb", 2) == 0)) 
               {	m_iXPBonusType = 0; 
					wsprintf(cTxt, "(*) XP Mode: BH (HB standard)"); 
					PutLogList(cTxt); 
               }else if ((memcmp(token, "usa", 3) == 0) || (memcmp(token, "USA", 3) == 0)) 
               {	m_iXPBonusType = 1;  
					wsprintf(cTxt, "(*) XP Mode: USA (Vast bonusses up to lvl 120)"); 
					PutLogList(cTxt); 
               }else if ((memcmp(token, "equilibrium", 11) == 0) || (memcmp(token, "EQUILIBRIUM", 11) == 0)) 
               {	m_iXPBonusType = 2;  
					wsprintf(cTxt, "(*) XP Mode: EQUILIBRIUM (default)"); 
					PutLogList(cTxt); 
               }else 
               {	wsprintf(cTxt, "(!!!) xp-mode: (%s) must be either HB, USA or EQUILIBRIUM(default)", token); 
					PutLogList(cTxt); 
					delete pStrTok;
					return FALSE; 
               } 
               cReadMode = 0; 
               break; 
// SNOOPY: party-log:
//			VERBOSE, verbose
//			STANDARD, standard

            case 27: 
			   m_iPartyLog = FALSE; 
               if ((memcmp(token, "VERBOSE", 7) == 0) || (memcmp(token, "verbose", 7) == 0)) 
               {	m_iPartyLog = TRUE; 
					wsprintf(cTxt, "(*) Party log Mode: (Verbose)"); 
					PutLogList(cTxt); 
               }else if ((memcmp(token, "STANDARD", 8) == 0) || (memcmp(token, "standard", 8) == 0)) 
               {	m_iPartyLog = FALSE;  
					wsprintf(cTxt, "(*) Party log Mode: (Standard)"); 
					PutLogList(cTxt); 
               }else 
               {	PutLogList("(!!!) party-log must be either VERBOSE or STANDARD (default)"); 
					//return FALSE; 
               } 
               cReadMode = 0; 
               break; 
// SNOOPY: Evil	MaxPlayerLevel		   
			case 28: //Snoopy added num value check
				if (_bGetIsStringIsNumber(token) == FALSE) {
					PutLogList("(!!!) CRITICAL ERROR! Settings.cfg - Wrong Data format (Max Evil Player Level).");
					delete pStrTok;
					return FALSE; 
				};
                m_sEvilMaxPlayerLevel = atoi(token); 
                if (m_sEvilMaxPlayerLevel == 0) m_sEvilMaxPlayerLevel = DEF_PLAYERMAXLEVEL; 
                cReadMode = 0;
                break;		
// SNOOPY: Validation number		   
			case 29: //Snoopy added num value check
				if (_bGetIsStringIsNumber(token) == FALSE) {
					PutLogList("(!) RECOVERABLE ERROR! Settings.cfg - Wrong Data format (validation-number).");
					m_iServerValidationNumber = 0;
				}else
				{   m_iServerValidationNumber = atoi(token); 
				}
				if (m_iServerValidationNumber != 0) 
					PutLogList("(*) validation-number set.");
                cReadMode = 0;
                break;	
// SNOOPY: bShowActivity		   
			case 30: //Snoopy added num value check
				bShowActivity = TRUE;
				if (_bGetIsStringIsNumber(token) == FALSE) {
					PutLogList("(!!!) CRITICAL ERROR! Settings.cfg - Wrong Data format (show-city-power).");
				}else
				{   if (atoi(token) != 0) bShowActivity = FALSE; 
				}
				if (bShowActivity == FALSE) 
					PutLogList("(*) server will show relative side power. ((F2] to toggle)");
				else
					PutLogList("(*) server will show player/npc activity. ((F2] to toggle)");
                cReadMode = 0;
                break;
// SNOOPY: 	m_iClientConnectionCheckTime				
			case 31: //Snoopy added m_iClientConnectionCheckTime if we want to change it client side.
				if (_bGetIsStringIsNumber(token) == FALSE) 
				{	PutLogList("(!) RECOVERABLE ERROR! Settings.cfg - Wrong Data format (ClientConnectionCheckTime).");
					m_iClientConnectionCheckTime = 8000;
					m_iVariableTimeOut = DEF_CLIENTTIMEOUT; // DEF_CLIENTTIMEOUT =10000
					m_iCCCNeededForValidation = 12;
				}else
				{   int iTemp = atoi(token);
					if (iTemp < 1) 
					{	iTemp = 8000;
					}
					m_iClientConnectionCheckTime = iTemp;
					if (iTemp < 2450) 
					{	m_iClientConnectionCheckTime = 8000; 
						PutLogList("(*) Connection Check Time wrong (below 2450)."); 
						iTemp = 8000;
					}else if (iTemp > 19900) 
					{	m_iClientConnectionCheckTime = 8000; 
						PutLogList("(*) Connection Check Time wrong (bbove 19900)."); 
						iTemp = 8000;
					}
					if (iTemp != 8000)
					{	while (iTemp >= 1100) {iTemp -= 1000;}
						if ((iTemp >900) && (iTemp <1100))
						{	// Such values would render SpeedHack detection mor presise, but very subject to false alarms
							m_iClientConnectionCheckTime = 8000; 
							PutLogList("(*) Connection Check Time wrong (too close from thousands).");               
						}
					}					
				}
				m_iClientConnectionCheckMaxNumber = (m_iClientConnectionCheckTime + 2000) / 300; //8000: ->33
				fAverage = ((float)m_iClientConnectionCheckTime + 1050.0)/1000.0;
				m_iClientConnectionCheckTimeRound = ((int)fAverage) * 1000;	
				if (m_iClientConnectionCheckTime > 8000)
				{	m_iVariableTimeOut = m_iClientConnectionCheckTime + 3000;				
				}	
				if (m_iClientConnectionCheckTime == 8000)
				{	m_iCCCNeededForValidation = 5;	// sdr client is 12. 5 means using my edited client...
				}
				wsprintf(cTxt, "(*) Connection Check Time set to %d/%d (max packets%d).", m_iClientConnectionCheckTime, m_iClientConnectionCheckTimeRound, m_iClientConnectionCheckMaxNumber); 
				PutLogList(cTxt); 
                cReadMode = 0;
                break;
// SNOOPY: killer indicator		   
			case 32: //Snoopy added num value check
				m_cKillerIndicator = 0;
				if (_bGetIsStringIsNumber(token) == FALSE) {
					PutLogList("(!!!) CRITICAL ERROR! Settings.cfg - Wrong Data format (killer-indicator).");
				}else
				{   switch(atoi(token)) { 
					case 1:
					case 2:
						PutLogList("(*) Killer indicator on.");
						m_cKillerIndicator = atoi(token);
						break;
					case 0:
					default:
						m_cKillerIndicator = 0;
						break;
					}
				}
                cReadMode = 0;
                break;	   
			case 33: // heldenian-war-time
				if (_bGetIsStringIsNumber(token) == FALSE) {
					PutLogList("(!!!) CRITICAL ERROR! Settings.cfg - Wrong Data format (heldenian-war-time).");
				}else
				{   if (atoi(token) > 0) 
					m_dwHeldenianWarTime	= atoi(token)*60*1000;
				}
				wsprintf(cTxt, "(*) Heldenian War starting time set to %d minutes.",atoi(token)); 
				PutLogList(cTxt); 
                cReadMode = 0;
                break;	   
			case 34: // heldenian-end-time
				if (_bGetIsStringIsNumber(token) == FALSE) {
					PutLogList("(!!!) CRITICAL ERROR! Settings.cfg - Wrong Data format (heldenian-end-time).");
				}else
				{   if (atoi(token) > 0) 
					m_dwHeldenianEndTime	= atoi(token)*60*1000;
				}
				wsprintf(cTxt, "(*) Heldenian War total duration set to %d minutes.",atoi(token)); 
				PutLogList(cTxt); 
                cReadMode = 0;
                break;
			case 35: // heldenian-summon
				if (_bGetIsStringIsNumber(token) == FALSE) {
					PutLogList("(!!!) CRITICAL ERROR! Settings.cfg - Wrong Data format (heldenian-summon).");
				}else
				{   switch(atoi(token)) { 
					case 1:
						PutLogList("(*) Heldenian Summon mode set to 1, (Summon survive all battle).");
						m_cHeldenianSummonMode = 1;
						break;
					case 2:
						PutLogList("(*) Heldenian Summon mode set to 2, (Summon survive all battle, Anybody can take control).");
						m_cHeldenianSummonMode = 2;
						break;
					case 0:
					default:
						PutLogList("(*) Heldenian Summon mode set to 0, (Summon dye on master's death).");
						m_cHeldenianSummonMode = 0;
						break;					
					}
				}
                cReadMode = 0;
                break;	
// SNOOPY: Validation crc1		   
			case 36: //Snoopy added num value check
				if (_bGetIsStringIsNumber(token) == FALSE) {
					PutLogList("(!) RECOVERABLE ERROR! Settings.cfg - Wrong Data format (validation-crc1).");
					m_wServerValidationCRC1 = 0;
				}else
				{   m_wServerValidationCRC1 = (WORD) atoi(token); 
				}
				if ((m_wServerValidationCRC2 != 0) && (m_wServerValidationCRC1 != 0)) 
				{	if (m_wServerValidationCRC2 < m_wServerValidationCRC1)
					{	WORD wTemp = m_wServerValidationCRC2;
						m_wServerValidationCRC2 = m_wServerValidationCRC1;
						m_wServerValidationCRC1 = wTemp;
					}
					PutLogList("(*) validation-CRC set.");
				}
                cReadMode = 0;
                break;		
// SNOOPY: Validation crc2 
			case 37: //Snoopy added num value check
				if (_bGetIsStringIsNumber(token) == FALSE) {
					PutLogList("(!) RECOVERABLE ERROR! Settings.cfg - Wrong Data format (validation-crc2).");
					m_wServerValidationCRC2 = 0;
				}else
				{   m_wServerValidationCRC2 = (WORD) atoi(token); 
				}
				if ((m_wServerValidationCRC2 != 0) && (m_wServerValidationCRC1 != 0)) 
				{	if (m_wServerValidationCRC2 < m_wServerValidationCRC1)
					{	WORD wTemp = m_wServerValidationCRC2;
						m_wServerValidationCRC2 = m_wServerValidationCRC1;
						m_wServerValidationCRC1 = wTemp;
					}
					PutLogList("(*) validation-CRC set.");
				}
                cReadMode = 0;
                break;	
			case 38: // MSGID_REQUEST_REGISTERGAMESERVER = 
			/*	if (_bGetIsStringIsNumber(token) == FALSE) 
				{	PutLogList("(!) RECOVERABLE ERROR! Settings.cfg - Wrong Data format (MSGID_REQUEST_REGISTERGAMESERVER).");
					m_dwMSGID_REQUEST_REGISTERGAMESERVER = MSGID_REQUEST_REGISTERGAMESERVER;
				}else
				{  */ m_dwMSGID_REQUEST_REGISTERGAMESERVER = (DWORD) atoi(token); 
			        wsprintf(cTxt,"(*) New MSGID_REQUEST_REGISTERGAMESERVER set: %#08X", m_dwMSGID_REQUEST_REGISTERGAMESERVER);
					PutLogList(cTxt);
			/*	}*/

                cReadMode = 0;
                break;			 
			}
         }else  
         {  if (memcmp(token, "primary-drop-rate"      , 17) == 0)		cReadMode = 1; 
            if (memcmp(token, "secondary-drop-rate"      , 19) == 0)	cReadMode = 2; 
            if (memcmp(token, "enemy-kill-mode"        , 15) == 0)		cReadMode = 3; 
            if (memcmp(token, "enemy-kill-adjust"      , 17) == 0)		cReadMode = 4; 
            if (memcmp(token, "admin-security"         , 14) == 0)		cReadMode = 5; 
            if (memcmp(token, "monday-raid-time"      , 16) == 0)		cReadMode = 6; 
            if (memcmp(token, "tuesday-raid-time"      , 17) == 0)		cReadMode = 7; 
            if (memcmp(token, "wednesday-raid-time"      , 19) == 0)	cReadMode = 8; 
            if (memcmp(token, "thursday-raid-time"      , 18) == 0)		cReadMode = 9; 
            if (memcmp(token, "friday-raid-time"      , 16) == 0)		cReadMode = 10; 
            if (memcmp(token, "saturday-raid-time"      , 18) == 0)		cReadMode = 11; 
            if (memcmp(token, "sunday-raid-time"      , 16) == 0)		cReadMode = 12; 
			if (memcmp(token, "log-chat-settings", 17) == 0)			cReadMode = 13;
			if (memcmp(token, "summonguild-cost", 16) == 0)				cReadMode = 14;
			if (memcmp(token, "slate-success-rate", 18) == 0)			cReadMode = 15;
			if (memcmp(token, "character-stat-limit", 20) == 0)			cReadMode = 16;
			if (memcmp(token, "character-skill-limit", 21) == 0)		cReadMode = 17;
			if (memcmp(token, "rep-drop-modifier", 17) == 0)			cReadMode = 18;
			if (memcmp(token, "admin-security-code", 19) == 0)			cReadMode = 19;
			if (memcmp(token, "absolute-max-player-level", 25) == 0)	cReadMode = 20;
			if (memcmp(token, "map-mode", 8) == 0)						cReadMode = 21;
			if (memcmp(token, "pvp-hp-mode", 11) == 0)					cReadMode = 22;
            if (memcmp(token, "gold-drop-rate" , 14) == 0)				cReadMode = 23; 
            if (memcmp(token, "alchi-item-upgrade" , 18) == 0)			cReadMode = 24;         
            if (memcmp(token, "gizon-item-upgrade" , 18) == 0)			cReadMode = 25;       
            if (memcmp(token, "xp-mode" , 7) == 0)						cReadMode = 26;    
            if (memcmp(token, "party-log" , 9) == 0)					cReadMode = 27; 
			if (memcmp(token, "evil-max-player-level", 21) == 0)	    cReadMode = 28;
			if (memcmp(token, "validation-number", 17) == 0)	        cReadMode = 29;
			if (memcmp(token, "show-city-power", 15) == 0)				cReadMode = 30;
			if (memcmp(token, "connection-check-time", 21) == 0)		cReadMode = 31;
			if (memcmp(token, "killer-indicator", 16) == 0)				cReadMode = 32;
			if (memcmp(token, "heldenian-war-time", 18) == 0)			cReadMode = 33;
			if (memcmp(token, "heldenian-end-time", 18) == 0)			cReadMode = 34;
			if (memcmp(token, "heldenian-summon", 16) == 0)				cReadMode = 35;
			if (memcmp(token, "validation-crc1", 15) == 0)				cReadMode = 36;
			if (memcmp(token, "validation-crc2", 15) == 0)				cReadMode = 37;
			if (memcmp(token, "MSGID_REQUEST_REGISTERGAMESERVER", 32) == 0)	cReadMode = 38;
		} 
        token = pStrTok->pGet();        //token = strtok( NULL, seps );  
      } 
      delete pStrTok; 
      delete cp; 
   } 
   
	if ( (m_wServerValidationCRC1 == 0) || ( m_wServerValidationCRC2 == 0))
	{	m_wServerValidationCRC1 = 0; // Either both not Null or don't use the system
		m_wServerValidationCRC2 = 0; // PatchIP will never send NULL CRC
	}
   if (pFile != NULL) fclose(pFile); 
   return (bFileReadOK); 
} 
 

BOOL CGame::bReadCrusadeStructureConfigFile(char * cFn)
{
 FILE * pFile;
 HANDLE hFile;
 DWORD  dwFileSize;
 char * cp, * token, cReadModeA, cReadModeB;
 char seps[] = "= \t\n";
 int   iIndex;
 class CStrTok * pStrTok;

	cReadModeA = 0;
	cReadModeB = 0;

	hFile = CreateFile(cFn, GENERIC_READ, NULL, NULL, OPEN_EXISTING, NULL, NULL);
	dwFileSize = GetFileSize(hFile, NULL);
	if (hFile != INVALID_HANDLE_VALUE) CloseHandle(hFile);

	pFile = fopen(cFn, "rt");
	if (pFile == NULL) {
		// 
		PutLogList("(!) Cannot open Crusade configuration file.");
		return FALSE;
	}
	else {
		PutLogList("(!) Reading Crusade configuration file...");
		cp = new char[dwFileSize+2];
		ZeroMemory(cp, dwFileSize+2);
		fread(cp, dwFileSize, 1, pFile);

		iIndex = 0;
		pStrTok = new class CStrTok(cp, seps);
		token = pStrTok->pGet();
		while( token != NULL ) {
			if (cReadModeA != 0) {
				switch (cReadModeA) {
				case 1:
					switch (cReadModeB) {
					case 1:	// index
						if (_bGetIsStringIsNumber(token) == FALSE) 
						{	PutLogList("(!!!) CRITICAL ERROR!  Crusade configuration file error - Wrong Data format(1).");
							delete cp;
							delete pStrTok;
							return FALSE;
						}
						iIndex = atoi(token);
						if (m_stCrusadeStructures[iIndex].cType != NULL) 
						{	PutLogList("(!!!) CRITICAL ERROR!  Crusade configuration file error - Duplicate portion number.");
							delete cp;
							delete pStrTok;
							return FALSE;
						}						
						cReadModeB = 2;
						break;

					case 2: // Map name
						ZeroMemory(m_stCrusadeStructures[iIndex].cMapName, sizeof(m_stCrusadeStructures[iIndex].cMapName));
						memcpy(m_stCrusadeStructures[iIndex].cMapName, token, strlen(token));
						cReadModeB = 3;
						break;
						
					case 3: // Type
						if (_bGetIsStringIsNumber(token) == FALSE) 
						{	PutLogList("(!!!) CRITICAL ERROR!  Crusade configuration file error - Wrong Data format.");
							delete cp;
							delete pStrTok;
							return FALSE;
						}
						m_stCrusadeStructures[iIndex].cType = atoi(token);
						cReadModeB = 4;
						break;

					case 4:	// X
						if (_bGetIsStringIsNumber(token) == FALSE) 
						{	PutLogList("(!!!) CRITICAL ERROR!  Crusade configuration file error - Wrong Data format.");
							delete cp;
							delete pStrTok;
							return FALSE;
						}
						m_stCrusadeStructures[iIndex].dX = atoi(token);
						cReadModeB = 5;
						break;
	
					case 5:	// Y
						if (_bGetIsStringIsNumber(token) == FALSE) 
						{	PutLogList("(!!!) CRITICAL ERROR!  Crusade configuration file error - Wrong Data format.");
							delete cp;
							delete pStrTok;
							return FALSE;
						}
						m_stCrusadeStructures[iIndex].dY = atoi(token);
						cReadModeA = 0;
						cReadModeB = 0;
						break;
					}
					break;

				case 2: // snone-number (added by SNOOPY
					if (_bGetIsStringIsNumber(token) == FALSE) 
					{	PutLogList("(!!!) CRITICAL ERROR!  Crusade configuration file error - stone-number.");
						delete cp;
						delete pStrTok;
						return FALSE;
					}
					m_iManaStoneNumber = atoi(token);
					if (m_iManaStoneNumber == 0) m_iManaStoneNumber = 3;
					if (m_iManaStoneNumber <0 )  m_iManaStoneNumber = iDice(1,5);
					if (m_iManaStoneNumber >10 )  m_iManaStoneNumber = 10;						
					wsprintf(G_cTxt,"Crusade stone-number: %d",m_iManaStoneNumber); 
					PutLogList(G_cTxt); 
					cReadModeA = 0; 
					cReadModeB = 0; 
					break; 
				default: 
					break;
				}
			}
			else {
				if (memcmp(token, "crusade-structure", 17) == 0) {
					cReadModeA = 1;
					cReadModeB = 1;
				}
				if (memcmp(token, "stone-number", 12) == 0) {
					cReadModeA = 2;
					cReadModeB = 1;
				}			
			}
			token = pStrTok->pGet();
		}	
		delete pStrTok;		delete cp;
		if ((cReadModeA != 0) || (cReadModeB != 0)) 
		{	PutLogList("(!!!) CRITICAL ERROR! Crusade Structure configuration file contents error!");
			return FALSE;
		}
	}	
	if (pFile != NULL) fclose(pFile);
	return TRUE;
}

BOOL CGame::_bDecodePlayerDatafileContents(int iClientH, char * pData, DWORD dwSize)
{
	char * pContents, * token, * pOriginContents, cTmpName[11], cTxt[120];
	char   seps[] = "= \t\n";
	char   cReadModeA, cReadModeB;
	int    i, iItemIndex, iItemInBankIndex, iTotalGold, iNotUsedItemPrice, dV1, dV2, dV3;
	class  CStrTok * pStrTok;
	short  sTmpType, sTmpAppr1;
	BOOL   bRet;
	int    iTemp;
	SYSTEMTIME SysTime;
	__int64 iDateSum1, iDateSum2;
	BOOL   bIsNotUsedItemFound = FALSE;
	float fV4;

	if (m_pClientList[iClientH] == NULL) 
	{	wsprintf(cTxt,   "Player data file    PC(XX) - Unknown client");
		PutLogList(cTxt);
		return FALSE;
	}

	iTotalGold = 0;
	iItemIndex = 0;
	iItemInBankIndex  = 0;
	iNotUsedItemPrice = 0;

	cReadModeA = 0;
	cReadModeB = 0;

	pContents = new char[dwSize+2];
	ZeroMemory(pContents, dwSize+2);
	memcpy(pContents, pData, dwSize);

	pOriginContents = pContents;

	pStrTok = new class CStrTok(pContents, seps);
	token = pStrTok->pGet();

	while( token != NULL ) {
		if (cReadModeA != 0) {
			switch (cReadModeA) {
			case 1:
				ZeroMemory(m_pClientList[iClientH]->m_cMapName, sizeof(m_pClientList[iClientH]->m_cMapName));
				strcpy(m_pClientList[iClientH]->m_cMapName, token);
				ZeroMemory(cTmpName, sizeof(cTmpName));
				strcpy(cTmpName, token);
				for (i = 0; i < DEF_MAXMAPS; i++)
					if ((m_pMapList[i] != NULL)	&& (memcmp(m_pMapList[i]->m_cName, cTmpName, 10) == 0)) {
						m_pClientList[iClientH]->m_cMapIndex = (char)i;
					}
					if (m_pClientList[iClientH]->m_cMapIndex == -1) 
					{	wsprintf(cTxt, "(!) Player(%s) tries to enter unknown map : %s", m_pClientList[iClientH]->m_cCharName, cTmpName); 
						PutLogList(cTxt);
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					cReadModeA = 0;
					break;

			case 2:
				if (_bGetIsStringIsNumber(token) == FALSE) {
					wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format ( X posit) - Connection closed. ", m_pClientList[iClientH]->m_cCharName); 
					PutLogList(cTxt);
					delete pContents;
					delete pStrTok;
					return FALSE;
				}
				m_pClientList[iClientH]->m_sX = atoi(token);
				cReadModeA = 0;
				break;

			case 3:
				if (_bGetIsStringIsNumber(token) == FALSE) {
					wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format ( Y posit ) - Connection closed. ", m_pClientList[iClientH]->m_cCharName); 
					PutLogList(cTxt);
					delete pContents;
					delete pStrTok;
					return FALSE;
				}
				m_pClientList[iClientH]->m_sY = atoi(token);
				cReadModeA = 0;
				break;

			case 4:
				/*
				if (_bGetIsStringIsNumber(token) == FALSE) {
				wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[iClientH]->m_cCharName); 
				PutLogList(cTxt);
				delete pContents;
				delete pStrTok;
				return FALSE;
				}
				m_pClientList[iClientH]->m_cAccountStatus = atoi(token);
				*/
				cReadModeA = 0;
				break;

			case 5:
				switch(cReadModeB) {
				case 1:	// New 07/05/2004
					if (iItemIndex >= DEF_MAXITEMS) {
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					// token
					if (_bInitItemAttr(m_pClientList[iClientH]->m_pItemList[iItemIndex], token) == FALSE) {
						wsprintf(cTxt, "(!!!) Client(%s)-Item(%s) is not existing Item! Conection closed.", m_pClientList[iClientH]->m_cCharName, token); 
						PutLogList(cTxt);
						// Debug code @@@@@@@@@@@@@@@
						HANDLE hFile;
						DWORD  nWrite;
						hFile = CreateFile("ItemError.Log", GENERIC_WRITE, NULL, NULL, CREATE_ALWAYS, NULL, NULL);
						WriteFile(hFile, (char *)pContents, dwSize+2, &nWrite, NULL);
						CloseHandle(hFile);
						///////////// @@@@@@@@@@@@@@@
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					cReadModeB = 2;
					break;

				case 2:	// m_dwCount
					if (_bGetIsStringIsNumber(token) == FALSE) {
						wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format ( wrong item count ) - Connection closed. ", m_pClientList[iClientH]->m_cCharName); 
						PutLogList(cTxt);
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					iTemp = atoi(token);
					if (iTemp < 0) iTemp = 1;
					if ( iGetItemWeight(m_pClientList[iClientH]->m_pItemList[iItemIndex], iTemp) > _iCalcMaxLoad(iClientH) ) {
						iTemp = 1;
						wsprintf(G_cTxt, "(!) Player(%s) Item (%d) too heavy for player to carry"
							, m_pClientList[iClientH]->m_cCharName, iItemIndex);
						PutLogList(G_cTxt);
						PutLogFileList(G_cTxt);
					}
					m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwCount = (DWORD)iTemp;
					cReadModeB = 3;
					if (memcmp(m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_cName, "Gold", 4) == 0)
						iTotalGold += iTemp;
					break;

				case 3:	// m_sTouchEffectType
					if (_bGetIsStringIsNumber(token) == FALSE) {
						wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format ( m_sTouchEffectType ) - Connection closed. ", m_pClientList[iClientH]->m_cCharName); 
						PutLogList(cTxt);
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sTouchEffectType = atoi(token);
					cReadModeB = 4;
					break;

				case 4:	// m_sTouchEffectValue1
					if (_bGetIsStringIsNumber(token) == FALSE) {
						wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format ( m_sTouchEffectValue1 ) - Connection closed. ", m_pClientList[iClientH]->m_cCharName); 
						PutLogList(cTxt);
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sTouchEffectValue1 = atoi(token);
					cReadModeB = 5;
					break;

				case 5: // m_sTouchEffectValue2
					if (_bGetIsStringIsNumber(token) == FALSE) {
						wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format ( m_sTouchEffectValue2 ) - Connection closed. ", m_pClientList[iClientH]->m_cCharName); 
						PutLogList(cTxt);
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sTouchEffectValue2 = atoi(token);
					cReadModeB = 6;
					break;

				case 6: // m_sTouchEffectValue3
					if (_bGetIsStringIsNumber(token) == FALSE) {
						wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format ( m_sTouchEffectValue3 ) - Connection closed. ", m_pClientList[iClientH]->m_cCharName); 
						PutLogList(cTxt);
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sTouchEffectValue3 = atoi(token);
					cReadModeB = 7;
					break;

				case 7: // m_cItemColor
					if (_bGetIsStringIsNumber(token) == FALSE) {
							wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format ( m_cItemColor )- Connection closed. ", m_pClientList[iClientH]->m_cCharName); 
						PutLogList(cTxt);
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_cItemColor = atoi(token);
					cReadModeB = 8;
					break;

				case 8: // m_sItemSpecEffectValue1
					if (_bGetIsStringIsNumber(token) == FALSE) {
						wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format ( m_sItemSpecEffectValue1 ) - Connection closed. ", m_pClientList[iClientH]->m_cCharName); 
						PutLogList(cTxt);
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sItemSpecEffectValue1 = atoi(token);
					cReadModeB = 9;
					break;

				case 9: // m_sItemSpecEffectValue2
					if (_bGetIsStringIsNumber(token) == FALSE) {
						wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format ( m_sItemSpecEffectValue2 ) - Connection closed. ", m_pClientList[iClientH]->m_cCharName); 
						PutLogList(cTxt);
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sItemSpecEffectValue2 = atoi(token);
					cReadModeB = 10;
					break;

				case 10: // m_sItemSpecEffectValue3
					if (_bGetIsStringIsNumber(token) == FALSE) {
						wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format ( m_sItemSpecEffectValue3 ) - Connection closed. ", m_pClientList[iClientH]->m_cCharName); 
						PutLogList(cTxt);
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sItemSpecEffectValue3 = atoi(token);
					cReadModeB = 11;
					break;

				case 11: // m_wCurLifeSpan
					if (_bGetIsStringIsNumber(token) == FALSE) {
						wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format ( m_wCurLifeSpan ) - Connection closed. ", m_pClientList[iClientH]->m_cCharName); 
						PutLogList(cTxt);
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_wCurLifeSpan = atoi(token);
					cReadModeB = 12;
					break;

				case 12: //  m_dwAttribute
					if (_bGetIsStringIsNumber(token) == FALSE) 
					{	wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format ( m_dwAttribute ) - Connection closed. ", m_pClientList[iClientH]->m_cCharName); 
						PutLogList(cTxt);
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwAttribute = atoi(token);
					cReadModeA = 0;
					cReadModeB = 0;	
					// Check for unique owner items
					if (m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sTouchEffectType == DEF_ITET_UNIQUE_OWNER) 
					{	if (   (m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sTouchEffectValue1 != m_pClientList[iClientH]->m_sCharIDnum1) 
							|| (m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sTouchEffectValue2 != m_pClientList[iClientH]->m_sCharIDnum2) 
							|| (m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sTouchEffectValue3 != m_pClientList[iClientH]->m_sCharIDnum3) ) 
						{	wsprintf(cTxt, "(!) Unique item owned by wrong character: Player(%s) Item(%s) %d %d %d - %d %d %d\tIP(%s)"
								, m_pClientList[iClientH]->m_cCharName
								, m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_cName
								, m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sTouchEffectValue1
								, m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sTouchEffectValue2
								, m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sTouchEffectValue3
								, m_pClientList[iClientH]->m_sCharIDnum1
								, m_pClientList[iClientH]->m_sCharIDnum2
								, m_pClientList[iClientH]->m_sCharIDnum3
								, m_pClientList[iClientH]->m_cIPaddress); 
							PutLogList(cTxt);
							PutLogFileList(cTxt);
						}
					}
					// Compute every time max item durability if special items
					// Compute Manuf increased durability
					if ((m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwAttribute & 0x00000001) != NULL) 
					{	fV4 = 0.15f;
						dV2 = (int)m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sItemSpecEffectValue2;
						dV3 = (int)m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_wMaxLifeSpan;
						dV1 = (dV2*dV3)/100.0f;
						m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_wMaxLifeSpan = (WORD) (dV3 + dV1);
						m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sItemSpecEffectValue1 = m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_wMaxLifeSpan;
					}else 
					{	fV4 = 0.20f;	
					}					
					// Merien Upgraded items increased durability
					int iValue = (m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwAttribute & 0xF0000000) >> 28;
					if (iValue > 0) // Use ItemSpecialEffectValue1 for MaxLife span
					{	switch (m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_cCategory) {
						case 5:  // shield
						case 6:  // Armor
						case 9:  // Armor, not dyable
						case 10: // Armor, dyeable
						case 11: // clothes
						case 12: // cape boots
						case 13: // cape boots clothes not dyable
							dV1 = (int)m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_wMaxLifeSpan;
							dV2 = fV4 * dV1;
							dV3 = dV1 + dV2;
							m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_wMaxLifeSpan = (WORD)dV3;
							m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sItemSpecEffectValue1 = (short)dV3;
							break;
						}
					}
					// Strong / Ancient increased Durability
					// for enchanted items 
					_AdjustRareItemValue(m_pClientList[iClientH]->m_pItemList[iItemIndex]);
					// Correct MaxLifeSpan if to big
					if (m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_wCurLifeSpan > m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_wMaxLifeSpan)
						m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_wCurLifeSpan = m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_wMaxLifeSpan;
					if (   (m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_wCurLifeSpan == 0)
						&& (m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sItemEffectType == DEF_ITEMEFFECTTYPE_ALTERITEMDROP)) 
					{	// SNOOPY: Translated to English 
						wsprintf(G_cTxt, "(!) Player:(%s) had a Zem type item with 0 life in his bag, put 1 life!", m_pClientList[iClientH]->m_cCharName);				
						PutLogList(cTxt);
						PutLogFileList(G_cTxt);
						m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_wCurLifeSpan = 1;
					}

					// Modify attribute , sending gizoned to my client to show next gizoning cost
					DWORD dwTemp = m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwAttribute;
					dwTemp = dwTemp & 0xF0FFFFFF; 
					dwTemp = dwTemp | (m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sItemSpecEffectValue3 <<24);
					m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwAttribute = dwTemp;

					// Snoopy: This only return True or FALSE ?!?!?!
					// bCheckAndConvertPlusWeaponItem(iClientH, iItemIndex);
					// Remove Type -1 items from client
					if (m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_cItemType == DEF_ITEMTYPE_NOTUSED) 
					{	iNotUsedItemPrice += abs(m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_wPrice);
						delete m_pClientList[iClientH]->m_pItemList[iItemIndex];
						m_pClientList[iClientH]->m_pItemList[iItemIndex] = NULL;
						// Flag to tell client all items in bag
						bIsNotUsedItemFound = TRUE;
					}else if (_bCheckDupItemID(m_pClientList[iClientH]->m_pItemList[iItemIndex]) == TRUE) 
					{	_bItemLog(DEF_ITEMLOG_DUPITEMID, iClientH, NULL, m_pClientList[iClientH]->m_pItemList[iItemIndex]);
						// SNOOPy no gold for dupped item
						//iNotUsedItemPrice += abs(m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_wPrice);
						delete m_pClientList[iClientH]->m_pItemList[iItemIndex];
						m_pClientList[iClientH]->m_pItemList[iItemIndex] = NULL;
					} else iItemIndex++;
					break;

				}// End of items sub-switch
				break;

			case 6: // Sex
				if (_bGetIsStringIsNumber(token) == FALSE) {
					wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format ( Sex ) - Connection closed. ", m_pClientList[iClientH]->m_cCharName); 
					PutLogList(cTxt);
					delete pContents;
					delete pStrTok;
					return FALSE;
				}
				m_pClientList[iClientH]->m_cSex = atoi(token);
				cReadModeA = 0;
				break;

			case 7: // Skin
				if (_bGetIsStringIsNumber(token) == FALSE) {
					wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format ( Skin color) - Connection closed. ", m_pClientList[iClientH]->m_cCharName); 
					PutLogList(cTxt);
					delete pContents;
					delete pStrTok;
					return FALSE;
				}
				m_pClientList[iClientH]->m_cSkin = atoi(token);
				cReadModeA = 0;
				break;

			case 8:	// Hair style
				if (_bGetIsStringIsNumber(token) == FALSE) {
					wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format ( Hair style ) - Connection closed. ", m_pClientList[iClientH]->m_cCharName); 
					PutLogList(cTxt);
					delete pContents;
					delete pStrTok;
					return FALSE;
				}
				m_pClientList[iClientH]->m_cHairStyle = atoi(token);
				cReadModeA = 0;
				break;

			case 9: // Hair color
				if (_bGetIsStringIsNumber(token) == FALSE) {
					wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format ( Hair color) - Connection closed. ", m_pClientList[iClientH]->m_cCharName); 
					PutLogList(cTxt);
					delete pContents;
					delete pStrTok;
					return FALSE;
				}
				m_pClientList[iClientH]->m_cHairColor = atoi(token);
				cReadModeA = 0;
				break;

			case 10: // Underwear color
				if (_bGetIsStringIsNumber(token) == FALSE) {
					wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format ( Underwear ) - Connection closed. ", m_pClientList[iClientH]->m_cCharName); 
					PutLogList(cTxt);
					delete pContents;
					delete pStrTok;
					return FALSE;
				}
				m_pClientList[iClientH]->m_cUnderwear = atoi(token);
				cReadModeA = 0;
				break;

			case 11:
				for (i = 0; i < DEF_MAXITEMEQUIPPOS; i++) 
					m_pClientList[iClientH]->m_sItemEquipmentStatus[i] = -1;
				for (i = 0; i < DEF_MAXITEMS; i++) 
					m_pClientList[iClientH]->m_bIsItemEquipped[i] = FALSE;
				// Do not equip any item if an unused item has been found and deleted
				if (bIsNotUsedItemFound == FALSE) {
					for (i = 0; i < DEF_MAXITEMS; i++) {
						wsprintf(cTxt, "%d", token[i]);
						if ((token[i] == '1') && (m_pClientList[iClientH]->m_pItemList[i] != NULL)) {
							if (m_pClientList[iClientH]->m_pItemList[i]->m_cItemType == DEF_ITEMTYPE_EQUIP) 
								m_pClientList[iClientH]->m_bIsItemEquipped[i] = TRUE;
							else m_pClientList[iClientH]->m_bIsItemEquipped[i] = FALSE;
						}
						else m_pClientList[iClientH]->m_bIsItemEquipped[i] = FALSE;

						if ((m_pClientList[iClientH] != NULL) && (m_pClientList[iClientH]->m_bIsItemEquipped[i] == TRUE)) {
							if (bEquipItemHandler(iClientH, i) == FALSE) // FALSE
								m_pClientList[iClientH]->m_bIsItemEquipped[i] = FALSE; //
						}
					}
				}

				cReadModeA = 0;
				break;

			case 12:
				ZeroMemory(m_pClientList[iClientH]->m_cGuildName, sizeof(m_pClientList[iClientH]->m_cGuildName));
				strcpy(m_pClientList[iClientH]->m_cGuildName, token);
				cReadModeA = 0;
				break;

			case 13:
				if (_bGetIsStringIsNumber(token) == FALSE) {
					wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format ( m_iGuildRank ) - Connection closed. ", m_pClientList[iClientH]->m_cCharName); 
					PutLogList(cTxt);
					delete pContents;
					delete pStrTok;
					return FALSE;
				}
				m_pClientList[iClientH]->m_iGuildRank = atoi(token);
				cReadModeA = 0;
				break;

			case 14: // HP 
				if (_bGetIsStringIsNumber(token) == FALSE) {
					wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format ( HP ) - Connection closed. ", m_pClientList[iClientH]->m_cCharName); 
					PutLogList(cTxt);
					delete pContents;
					delete pStrTok;
					return FALSE;
				}
				m_pClientList[iClientH]->m_iHP = atoi(token);
				cReadModeA = 0;
				break;

			case 15: // DefenseRatio unused
				if (_bGetIsStringIsNumber(token) == FALSE) {
					wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format ( unused 1 ) - Connection closed. ", m_pClientList[iClientH]->m_cCharName); 
					PutLogList(cTxt);
					delete pContents;
					delete pStrTok;
					return FALSE;
				}
				//m_pClientList[iClientH]->m_iOriginDefenseRatio = atoi(token);
				//m_pClientList[iClientH]->m_iCurDefenseRatio = m_pClientList[iClientH]->m_iOriginDefenseRatio;
				cReadModeA = 0;
				break;

			case 16: // HitRatio  unused
				if (_bGetIsStringIsNumber(token) == FALSE) {
					wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format ( unused 2 ) - Connection closed. ", m_pClientList[iClientH]->m_cCharName); 
					PutLogList(cTxt);
					delete pContents;
					delete pStrTok;
					return FALSE;
				}
				//m_pClientList[iClientH]->m_iOriginHitRatio = atoi(token);
				//m_pClientList[iClientH]->m_iCurHitRatio = m_pClientList[iClientH]->m_iOriginHitRatio;
				cReadModeA = 0;
				break;

			case 17: // Level  
				if (_bGetIsStringIsNumber(token) == FALSE) {
					wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format ( level ) - Connection closed. ", m_pClientList[iClientH]->m_cCharName); 
					PutLogList(cTxt);
					delete pContents;
					delete pStrTok;
					return FALSE;
				}
				m_pClientList[iClientH]->m_iLevel = atoi(token);
				cReadModeA = 0;
				if (m_pClientList[iClientH]->m_iLevel <2) // Starting characters are given a good validation number
					m_pClientList[iClientH]->m_iValidationNumber = m_iServerValidationNumber;
				break;

			case 18: // Str 
				if (_bGetIsStringIsNumber(token) == FALSE) 
				{	wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format ( Str ) - Connection closed. ", m_pClientList[iClientH]->m_cCharName); 
					PutLogList(cTxt);
					delete pContents;
					delete pStrTok;
					return FALSE;
				}
				m_pClientList[iClientH]->m_iStr = atoi(token);
				cReadModeA = 0;
				break;

			case 19: // Int 
				if (_bGetIsStringIsNumber(token) == FALSE) {
					wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format ( Int ) - Connection closed. ", m_pClientList[iClientH]->m_cCharName); 
					PutLogList(cTxt);
					delete pContents;
					delete pStrTok;
					return FALSE;
				}
				m_pClientList[iClientH]->m_iInt = atoi(token);
				cReadModeA = 0;
				break;

			case 20: // Vit 
				if (_bGetIsStringIsNumber(token) == FALSE) {
					wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format ( Vit ) - Connection closed. ", m_pClientList[iClientH]->m_cCharName); 
					PutLogList(cTxt);
					delete pContents;
					delete pStrTok;
					return FALSE;
				}
				m_pClientList[iClientH]->m_iVit = atoi(token);
				cReadModeA = 0;
				break;

			case 21: // Dex 
				if (_bGetIsStringIsNumber(token) == FALSE) {
					wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format ( Dex ) - Connection closed. ", m_pClientList[iClientH]->m_cCharName); 
					PutLogList(cTxt);
					delete pContents;
					delete pStrTok;
					return FALSE;
				}
				m_pClientList[iClientH]->m_iDex = atoi(token);
				cReadModeA = 0;
				break;

			case 22: // Mag 
				if (_bGetIsStringIsNumber(token) == FALSE) {
					wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format ( Mag ) - Connection closed. ", m_pClientList[iClientH]->m_cCharName); 
					PutLogList(cTxt);
					delete pContents;
					delete pStrTok;
					return FALSE;
				}
				m_pClientList[iClientH]->m_iMag = atoi(token);
				cReadModeA = 0;
				break;

			case 23: // Charisma 
				if (_bGetIsStringIsNumber(token) == FALSE) {
					wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format ( Charisma ) - Connection closed. ", m_pClientList[iClientH]->m_cCharName); 
					PutLogList(cTxt);
					delete pContents;
					delete pStrTok;
					return FALSE;
				}
				m_pClientList[iClientH]->m_iCharisma = atoi(token);
				cReadModeA = 0;
				break;

			case 24: // Luck 
				if (_bGetIsStringIsNumber(token) == FALSE) {
					wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format ( Luck ) - Connection closed. ", m_pClientList[iClientH]->m_cCharName); 
					PutLogList(cTxt);
					delete pContents;
					delete pStrTok;
					return FALSE;
				}
				m_pClientList[iClientH]->m_iLuck = atoi(token);
				cReadModeA = 0;
				break;

			case 25: // Exp 
				if (_bGetIsStringIsNumber(token) == FALSE) {
					wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format ( Exp ) - Connection closed. ", m_pClientList[iClientH]->m_cCharName); 
					PutLogList(cTxt);
					delete pContents;
					delete pStrTok;
					return FALSE;
				}
				m_pClientList[iClientH]->m_iExp = atoi(token);
				cReadModeA = 0;
				break;

			case 26: // Magic-Mastery 
				for (i = 0; i < DEF_MAXMAGICTYPE; i++) {
					m_pClientList[iClientH]->m_cMagicMastery[i] = token[i] - 48;
				}
				cReadModeA = 0;
				break;

			case 27: // Skill-Mastery 
				if (_bGetIsStringIsNumber(token) == FALSE) {
					wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format ( Skill-Mastery ) - Connection closed. ", m_pClientList[iClientH]->m_cCharName); 
					PutLogList(cTxt);
					delete pContents;
					delete pStrTok;
					return FALSE;
				}
				m_pClientList[iClientH]->m_cSkillMastery[cReadModeB] = atoi(token);
				cReadModeB++;

				if (cReadModeB >= DEF_MAXSKILLTYPE) {
					cReadModeA = 0;
					cReadModeB = 0;
				}
				break;

			case 28: // Warehouse
				switch(cReadModeB) {
			case 1:
				if (iItemInBankIndex >= DEF_MAXBANKITEMS) 
				{	delete pContents;
					delete pStrTok;
					return FALSE;
				}
				// token.
				if (_bInitItemAttr(m_pClientList[iClientH]->m_pItemInBankList[iItemInBankIndex], token) == FALSE) {
					wsprintf(cTxt, "(!!!) Client(%s)-Bank Item(%s) is not existing Item! Conection closed.", m_pClientList[iClientH]->m_cCharName, token); 
					PutLogList(cTxt);
					// Debug code @@@@@@@@@@@@@@@
					HANDLE hFile;
					DWORD  nWrite;
					hFile = CreateFile("WHItemError.Log", GENERIC_WRITE, NULL, NULL, CREATE_ALWAYS, NULL, NULL);
					WriteFile(hFile, (char *)pOriginContents, dwSize+2, &nWrite, NULL);
					CloseHandle(hFile);
					///////////// @@@@@@@@@@@@@@@

					delete pContents;
					delete pStrTok;
					return FALSE;
				}
				cReadModeB = 2;
				break;

			case 2:	// m_dwCount
				if (_bGetIsStringIsNumber(token) == FALSE) {
					wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format ( Bank Item count ) - Connection closed. ", m_pClientList[iClientH]->m_cCharName); 
					PutLogList(cTxt);
					delete pContents;
					delete pStrTok;
					return FALSE;
				}
				iTemp = atoi(token);
				if (iTemp < 0) iTemp = 1;
				// SNOOPY: Strange here computing weigth for Bank item ?????
				if ( iGetItemWeight(m_pClientList[iClientH]->m_pItemInBankList[iItemInBankIndex], iTemp) > _iCalcMaxLoad(iClientH) ) 
				{	iTemp = 1;
					wsprintf(G_cTxt, "(!) Player:(%s) Item (%d) too heavy for player to carry (in Bank)"
						, m_pClientList[iClientH]->m_cCharName, iItemIndex);
					PutLogList(G_cTxt);
					PutLogFileList(G_cTxt);					
				}
				m_pClientList[iClientH]->m_pItemInBankList[iItemInBankIndex]->m_dwCount = (DWORD)iTemp;
				cReadModeB = 3;
				if (memcmp(m_pClientList[iClientH]->m_pItemInBankList[iItemInBankIndex]->m_cName, "Gold", 4) == 0)
					iTotalGold += iTemp;
				break;

			case 3:	// m_sTouchEffectType
				if (_bGetIsStringIsNumber(token) == FALSE) {
					wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format ( Bank: m_sTouchEffectType ) - Connection closed. ", m_pClientList[iClientH]->m_cCharName); 
					PutLogList(cTxt);
					delete pContents;
					delete pStrTok;
					return FALSE;
				}
				m_pClientList[iClientH]->m_pItemInBankList[iItemInBankIndex]->m_sTouchEffectType = atoi(token);
				cReadModeB = 4;
				break;

			case 4:	// m_sTouchEffectValue1
				if (_bGetIsStringIsNumber(token) == FALSE) {
					wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format ( Bank: m_sTouchEffectValue1 ) - Connection closed. ", m_pClientList[iClientH]->m_cCharName); 
					PutLogList(cTxt);
					delete pContents;
					delete pStrTok;
					return FALSE;
				}
				m_pClientList[iClientH]->m_pItemInBankList[iItemInBankIndex]->m_sTouchEffectValue1 = atoi(token);
				cReadModeB = 5;
				break;

			case 5:	// m_sTouchEffectValue2
				if (_bGetIsStringIsNumber(token) == FALSE) 
				{	wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format ( Bank: m_sTouchEffectValue2 ) - Connection closed. ", m_pClientList[iClientH]->m_cCharName); 
					PutLogList(cTxt);
					delete pContents;
					delete pStrTok;
					return FALSE;
				}
				m_pClientList[iClientH]->m_pItemInBankList[iItemInBankIndex]->m_sTouchEffectValue2 = atoi(token);
				cReadModeB = 6;
				break;

			case 6:	// m_sTouchEffectValue3
				if (_bGetIsStringIsNumber(token) == FALSE) 
				{	wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format ( Bank: m_sTouchEffectValue3 ) - Connection closed. ", m_pClientList[iClientH]->m_cCharName); 
					PutLogList(cTxt);
					delete pContents;
					delete pStrTok;
					return FALSE;
				}
				m_pClientList[iClientH]->m_pItemInBankList[iItemInBankIndex]->m_sTouchEffectValue3 = atoi(token);
				cReadModeB = 7;
				break;

			case 7:	// m_cItemColor
				if (_bGetIsStringIsNumber(token) == FALSE) 
				{	wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format ( Bank: m_cItemColor ) - Connection closed. ", m_pClientList[iClientH]->m_cCharName); 
					PutLogList(cTxt);
					delete pContents;
					delete pStrTok;
					return FALSE;
				}
				m_pClientList[iClientH]->m_pItemInBankList[iItemInBankIndex]->m_cItemColor = atoi(token);
				cReadModeB = 8;
				break;

			case 8:	// m_sItemSpecEffectValue1
				if (_bGetIsStringIsNumber(token) == FALSE) 
				{	wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format ( Bank: m_sItemSpecEffectValue1 ) - Connection closed. ", m_pClientList[iClientH]->m_cCharName); 
					PutLogList(cTxt);
					delete pContents;
					delete pStrTok;
					return FALSE;
				}
				m_pClientList[iClientH]->m_pItemInBankList[iItemInBankIndex]->m_sItemSpecEffectValue1 = atoi(token);
				cReadModeB = 9;
				break;

			case 9:	// m_sItemSpecEffectValue2
				if (_bGetIsStringIsNumber(token) == FALSE) 
				{	wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format ( Bank: m_sItemSpecEffectValue2 ) - Connection closed. ", m_pClientList[iClientH]->m_cCharName); 
					PutLogList(cTxt);
					delete pContents;
					delete pStrTok;
					return FALSE;
				}
				m_pClientList[iClientH]->m_pItemInBankList[iItemInBankIndex]->m_sItemSpecEffectValue2 = atoi(token);
				cReadModeB = 10;
				break;

			case 10:// m_sItemSpecEffectValue3
				if (_bGetIsStringIsNumber(token) == FALSE) 
				{	wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format ( Bank: m_sItemSpecEffectValue3 ) - Connection closed. ", m_pClientList[iClientH]->m_cCharName); 
					PutLogList(cTxt);
					delete pContents;
					delete pStrTok;
					return FALSE;
				}
				m_pClientList[iClientH]->m_pItemInBankList[iItemInBankIndex]->m_sItemSpecEffectValue3 = atoi(token);
				cReadModeB = 11;
				break;

			case 11:// m_wCurLifeSpan
				if (_bGetIsStringIsNumber(token) == FALSE) 
				{	wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format ( Bank: m_wCurLifeSpan ) - Connection closed. ", m_pClientList[iClientH]->m_cCharName); 
					PutLogList(cTxt);
					delete pContents;
					delete pStrTok;
					return FALSE;
				}
				m_pClientList[iClientH]->m_pItemInBankList[iItemInBankIndex]->m_wCurLifeSpan = atoi(token);

				cReadModeB = 12;
				break;

			case 12:// m_dwAttribute
				if (_bGetIsStringIsNumber(token) == FALSE) 
				{	wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format ( Bank: m_dwAttribute ) - Connection closed. ", m_pClientList[iClientH]->m_cCharName); 
					PutLogList(cTxt);
					delete pContents;
					delete pStrTok;
					return FALSE;
				}
				m_pClientList[iClientH]->m_pItemInBankList[iItemInBankIndex]->m_dwAttribute = atoi(token);
				cReadModeA = 0;
				cReadModeB = 0;
				// Compute every time max item durability if special items
				// Compute Manuf increased durability
				if ((m_pClientList[iClientH]->m_pItemInBankList[iItemInBankIndex]->m_dwAttribute & 0x00000001) != NULL) 
				{	fV4 = 0.15f;
					dV2 = (int)m_pClientList[iClientH]->m_pItemInBankList[iItemInBankIndex]->m_sItemSpecEffectValue2;
					dV3 = (int)m_pClientList[iClientH]->m_pItemInBankList[iItemInBankIndex]->m_wMaxLifeSpan;
					dV1 = (dV2*dV3)/100.0f;
					m_pClientList[iClientH]->m_pItemInBankList[iItemInBankIndex]->m_wMaxLifeSpan = (WORD) (dV3 + dV1);
					m_pClientList[iClientH]->m_pItemInBankList[iItemInBankIndex]->m_sItemSpecEffectValue1 = m_pClientList[iClientH]->m_pItemInBankList[iItemInBankIndex]->m_wMaxLifeSpan;
				}else 
				{	fV4 = 0.20f;		
				}
				// Merien Upgraded items increased durability
				int iValue = (m_pClientList[iClientH]->m_pItemInBankList[iItemInBankIndex]->m_dwAttribute & 0xF0000000) >> 28;
				if (iValue > 0) // Use ItemSpecialEffectValue1 for MaxLife span
				{	switch (m_pClientList[iClientH]->m_pItemInBankList[iItemInBankIndex]->m_cCategory) {
					case 5:  // shield
					case 6:  // Armor
					case 9:  // Armor, not dyable
					case 10: // Armor, dyeable
					case 11: // clothes
					case 12: // cape boots
					case 13: // cape boots clothes not dyable
						dV1 = (int)m_pClientList[iClientH]->m_pItemInBankList[iItemInBankIndex]->m_wMaxLifeSpan;
						dV2 = fV4 * dV1;
						dV3 = dV1 + dV2;
						m_pClientList[iClientH]->m_pItemInBankList[iItemInBankIndex]->m_wMaxLifeSpan = (WORD)dV3;
						m_pClientList[iClientH]->m_pItemInBankList[iItemInBankIndex]->m_sItemSpecEffectValue1 = (short)dV3;
						break;				
				}	}
				// Strong / Ancient increased Durability
				// for enchanted items 
				_AdjustRareItemValue(m_pClientList[iClientH]->m_pItemInBankList[iItemInBankIndex]);

				// Correct MaxLifeSpan if to big
				if (m_pClientList[iClientH]->m_pItemInBankList[iItemInBankIndex]->m_wCurLifeSpan > m_pClientList[iClientH]->m_pItemInBankList[iItemInBankIndex]->m_wMaxLifeSpan)
					m_pClientList[iClientH]->m_pItemInBankList[iItemInBankIndex]->m_wCurLifeSpan = m_pClientList[iClientH]->m_pItemInBankList[iItemInBankIndex]->m_wMaxLifeSpan;
				if (   (m_pClientList[iClientH]->m_pItemInBankList[iItemInBankIndex]->m_wCurLifeSpan == 0) 
					&& (m_pClientList[iClientH]->m_pItemInBankList[iItemInBankIndex]->m_sItemEffectType == DEF_ITEMEFFECTTYPE_ALTERITEMDROP)) 
				{	// SNOOPY: Translated to English 
					wsprintf(G_cTxt, "(!) Player:(%s) had a Zem type item with 0 life in his WH, put 1 life!", m_pClientList[iClientH]->m_cCharName);				
					PutLogList(G_cTxt);
					PutLogFileList(G_cTxt);
					m_pClientList[iClientH]->m_pItemInBankList[iItemInBankIndex]->m_wCurLifeSpan = 1;
				}

				// Modify attribute , sending gizoned to my client to show next gizoning cost
				DWORD dwTemp = m_pClientList[iClientH]->m_pItemInBankList[iItemInBankIndex]->m_dwAttribute;
				dwTemp = dwTemp & 0xF0FFFFFF; 
				dwTemp = dwTemp | (m_pClientList[iClientH]->m_pItemInBankList[iItemInBankIndex]->m_sItemSpecEffectValue3 <<24);
				m_pClientList[iClientH]->m_pItemInBankList[iItemInBankIndex]->m_dwAttribute = dwTemp;
				
				// Remove Type -1 items from client
				if (m_pClientList[iClientH]->m_pItemInBankList[iItemInBankIndex]->m_cItemType == DEF_ITEMTYPE_NOTUSED) 
				{	iNotUsedItemPrice += abs(m_pClientList[iClientH]->m_pItemInBankList[iItemInBankIndex]->m_wPrice);
					delete m_pClientList[iClientH]->m_pItemInBankList[iItemInBankIndex];
					m_pClientList[iClientH]->m_pItemInBankList[iItemInBankIndex] = NULL;
				}else if (_bCheckDupItemID(m_pClientList[iClientH]->m_pItemInBankList[iItemInBankIndex]) == TRUE) 
				{	_bItemLog(DEF_ITEMLOG_DUPITEMID, iClientH, NULL, m_pClientList[iClientH]->m_pItemInBankList[iItemInBankIndex]);
					// SNOOPY: no gold for dupped item
					//iNotUsedItemPrice += abs(m_pClientList[iClientH]->m_pItemInBankList[iItemInBankIndex]->m_wPrice);
					delete m_pClientList[iClientH]->m_pItemInBankList[iItemInBankIndex];
					m_pClientList[iClientH]->m_pItemInBankList[iItemInBankIndex] = NULL;		
				}else iItemInBankIndex++;
				break;
				}
				break; // end of case 28  ItemBank

			case 29:
				ZeroMemory(m_pClientList[iClientH]->m_cLocation, sizeof(m_pClientList[iClientH]->m_cLocation));
				strcpy(m_pClientList[iClientH]->m_cLocation, token);
				if (memcmp(m_pClientList[iClientH]->m_cLocation+3,"hunter",6) == 0)
					m_pClientList[iClientH]->m_bIsPlayerCivil = TRUE;
				else
					m_pClientList[iClientH]->m_bIsPlayerCivil = FALSE;
				// SNOOPY: Must initialize side here to prevent crash if side condition apply to some item
				m_pClientList[iClientH]->m_cSide = 0;
				if (memcmp(m_pClientList[iClientH]->m_cLocation,"are",3) == 0)
					m_pClientList[iClientH]->m_cSide = 1;
				if (memcmp(m_pClientList[iClientH]->m_cLocation,"elv",3) == 0)
					m_pClientList[iClientH]->m_cSide = 2;
				if (memcmp(m_pClientList[iClientH]->m_cLocation,"evil",4) == 0)
					m_pClientList[iClientH]->m_cSide = 4;
				if (memcmp(m_pClientList[iClientH]->m_cLocation,"executor",8) == 0)
					m_pClientList[iClientH]->m_cSide = 4;

				cReadModeA = 0;
				break;

/* 2.03 Code - Fixed by KLKS
			case 29:
				// Ã‡ÃƒÂ·Â¹Ã€ÃŒÂ¾Ã® Â¼Ã’Â¼Ã“Ã€Ã‡ Â¸Â¶Ã€Â»Ã€Â» ÃƒÃŠÂ±Ã¢ÃˆÂ­Ã‡Ã‘Â´Ã™.
				ZeroMemory(m_pClientList[iClientH]->m_cLocation, sizeof(m_pClientList[iClientH]->m_cLocation));
				strcpy(m_pClientList[iClientH]->m_cLocation, token);
				cReadModeA = 0;
				break;
*/
			case 30:
				// m_iMP
				if (_bGetIsStringIsNumber(token) == FALSE) {
					wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format ( MP ) - Connection closed. ", m_pClientList[iClientH]->m_cCharName); 
					PutLogList(cTxt);
					delete pContents;
					delete pStrTok;
					return FALSE;
				}
				m_pClientList[iClientH]->m_iMP = atoi(token);
				cReadModeA = 0;
				break;

			case 31: // m_iSP
				if (_bGetIsStringIsNumber(token) == FALSE) {
					wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format ( SP ) - Connection closed. ", m_pClientList[iClientH]->m_cCharName); 
					PutLogList(cTxt);
					delete pContents;
					delete pStrTok;
					return FALSE;
				}
				m_pClientList[iClientH]->m_iSP = atoi(token);
				cReadModeA = 0;
				break;

			case 32: // m_cLU_Pool
				if (_bGetIsStringIsNumber(token) == FALSE) {
					wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format ( LU_Pool ) - Connection closed. ", m_pClientList[iClientH]->m_cCharName); 
					PutLogList(cTxt);
					delete pContents;
					delete pStrTok;
					return FALSE;
				}
				m_pClientList[iClientH]->m_iLU_Pool = atoi(token);
				cReadModeA = 0;
				break;

			case 33: // validation-number
				if (_bGetIsStringIsNumber(token) == FALSE) {
					wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format ( validation-number ) - Connection closed. ", m_pClientList[iClientH]->m_cCharName); 
					PutLogList(cTxt);			
					delete pContents;
					delete pStrTok;
					return FALSE;
				}
				m_pClientList[iClientH]->m_iValidationNumber = atoi(token);
				cReadModeA = 0;
				break;

			case 34: // CrazyPlayerKiller
				if (_bGetIsStringIsNumber(token) == FALSE) {
					wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format ( CrazyPlayerKiller ) - Connection closed. ", m_pClientList[iClientH]->m_cCharName); 
					PutLogList(cTxt);			
					delete pContents;
					delete pStrTok;
					return FALSE;
				}
				m_pClientList[iClientH]->m_iCrazyPlayerKiller = atoi(token);
				cReadModeA = 0;
				break;

			// Case 33..37 Lu_Str- Lu Char removed
			case 38:
				// m_iEnemyKillCount
				if (_bGetIsStringIsNumber(token) == FALSE) {
					wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format ( m_iEnemyKillCount ) - Connection closed. ", m_pClientList[iClientH]->m_cCharName); 
					PutLogList(cTxt);
					delete pContents;
					delete pStrTok;
					return FALSE;
				}
				m_pClientList[iClientH]->m_iEnemyKillCount = atoi(token);
				cReadModeA = 0;
				break;

			case 39:
				// m_iPKCount
				if (_bGetIsStringIsNumber(token) == FALSE) {
					wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format ( m_iPKCount ) - Connection closed. ", m_pClientList[iClientH]->m_cCharName); 
					PutLogList(cTxt);
					delete pContents;
					delete pStrTok;
					return FALSE;
				}
				m_pClientList[iClientH]->m_iPKCount = atoi(token);
				cReadModeA = 0;
				break;

			case 40:
				// m_iRewardGold
				if (_bGetIsStringIsNumber(token) == FALSE) {
					wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format ( m_iRewardGold ) - Connection closed. ", m_pClientList[iClientH]->m_cCharName); 
					PutLogList(cTxt);
					delete pContents;
					delete pStrTok;
					return FALSE;
				}
				m_pClientList[iClientH]->m_iRewardGold = atoi(token);
				cReadModeA = 0;
				break;

			case 41: // Skill-SSN 
				if (_bGetIsStringIsNumber(token) == FALSE) {
					wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format ( Skill-SSN ) - Connection closed. ", m_pClientList[iClientH]->m_cCharName); 
					PutLogList(cTxt);
					delete pContents;
					delete pStrTok;
					return FALSE;
				}
				m_pClientList[iClientH]->m_iSkillSSN[cReadModeB] = atoi(token);
				cReadModeB++;
				if (cReadModeB >= DEF_MAXSKILLTYPE) {
					cReadModeA = 0;
					cReadModeB = 0;
				}
				break;

			case 42:
				if (token != NULL) 
				{	ZeroMemory(m_pClientList[iClientH]->m_cProfile, sizeof(m_pClientList[iClientH]->m_cProfile));
					strcpy(m_pClientList[iClientH]->m_cProfile, token);
				}
				cReadModeA = 0;
				break;

			case 43:
				// Hunger-Status 
				if (_bGetIsStringIsNumber(token) == FALSE) {
					wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format ( Hunger-Status ) - Connection closed. ", m_pClientList[iClientH]->m_cCharName); 
					PutLogList(cTxt);
					delete pContents;
					delete pStrTok;
					return FALSE;
				}
				m_pClientList[iClientH]->m_iHungerStatus = atoi(token);
				cReadModeA = 0;
				break;

				case 44:
				// AdminUserLevel
				if (_bGetIsStringIsNumber(token) == FALSE) {
					wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format ( AdminUserLevel ) - Connection closed. ", m_pClientList[iClientH]->m_cCharName); 
					PutLogList(cTxt);
					delete pContents;
					delete pStrTok;
					return FALSE;
				}
				m_pClientList[iClientH]->m_iAdminUserLevel = 0; //Default it to 0
				if (atoi(token) != 0) 
				{	for (i = 0; i < DEF_MAXADMINS; i++) 
					{	if(strlen(m_stAdminList[i].m_cGMName) == 0) break; //No more GM's on list
						if ((strlen(m_stAdminList[i].m_cGMName)) == (strlen(m_pClientList[iClientH]->m_cCharName))) 
						{	if(memcmp(m_stAdminList[i].m_cGMName, m_pClientList[iClientH]->m_cCharName, strlen(m_pClientList[iClientH]->m_cCharName)) == 0)
							{	m_pClientList[iClientH]->m_iAdminUserLevel = atoi(token);
								if (m_pClientList[iClientH]->m_iAdminUserLevel == -1)
								{	m_pClientList[iClientH]->m_bIsAdminStopStart = TRUE;
									m_pClientList[iClientH]->m_iAdminUserLevel = 1;								
								}
								break; //Break goes to cReadModeA = 0;, so no need to do it again
							}
						}
					}
				}
				cReadModeA = 0;
				break;
				
			case 45:
				// TimeLeft_ShutUp
				if (_bGetIsStringIsNumber(token) == FALSE) {
					wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format ( TimeLeft_ShutUp ) - Connection closed. ", m_pClientList[iClientH]->m_cCharName); 
					PutLogList(cTxt);
					delete pContents;
					delete pStrTok;
					return FALSE;
				}
				m_pClientList[iClientH]->m_iTimeLeft_ShutUp = atoi(token);
				cReadModeA = 0;
				break;

			case 46:
				// TimeLeft_Rating
				if (_bGetIsStringIsNumber(token) == FALSE) {
					wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format ( TimeLeft_Rating ) - Connection closed. ", m_pClientList[iClientH]->m_cCharName); 
					PutLogList(cTxt);
					delete pContents;
					delete pStrTok;
					return FALSE;
				}
				m_pClientList[iClientH]->m_iTimeLeft_Rating = atoi(token);
				cReadModeA = 0;
				break;

			case 47:
				// Rating
				if (_bGetIsStringIsNumber(token) == FALSE) {
					wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format ( Rating ) - Connection closed. ", m_pClientList[iClientH]->m_cCharName); 
					PutLogList(cTxt);
					delete pContents;
					delete pStrTok;
					return FALSE;
				}
				m_pClientList[iClientH]->m_iRating = atoi(token);
				AdjustClientDropRate(iClientH);
				cReadModeA = 0;
				break;

			case 48:
				// Guild GUID:
				if (_bGetIsStringIsNumber(token) == FALSE) {
					wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format ( Guild GUID ) - Connection closed. ", m_pClientList[iClientH]->m_cCharName); 
					PutLogList(cTxt);
					delete pContents;
					delete pStrTok;
					return FALSE;
				}
				m_pClientList[iClientH]->m_iGuildGUID = atoi(token);
				cReadModeA = 0;
				break;

			case 49:
				// Down Skill Index
				if (_bGetIsStringIsNumber(token) == FALSE) {
					wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format ( Down Skill Index ) - Connection closed. ", m_pClientList[iClientH]->m_cCharName); 
					PutLogList(cTxt);
					delete pContents;
					delete pStrTok;
					return FALSE;
				}
				m_pClientList[iClientH]->m_iDownSkillIndex = atoi(token);
				cReadModeA = 0;
				break;

			case 50:
				if (_bGetIsStringIsNumber(token) == FALSE) {
					wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format ( m_ItemPosListX ) - Connection closed. ", m_pClientList[iClientH]->m_cCharName); 
					PutLogList(cTxt);
					delete pContents;
					delete pStrTok;
					return FALSE;
				}

				m_pClientList[iClientH]->m_ItemPosList[cReadModeB-1].x = atoi(token);
				cReadModeB++;
				if (cReadModeB > 50) {
					cReadModeA = 0;
					cReadModeB = 0;
				}
				break;

			case 51:
				if (_bGetIsStringIsNumber(token) == FALSE) {
					wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format ( m_ItemPosListY ) - Connection closed. ", m_pClientList[iClientH]->m_cCharName); 
					PutLogList(cTxt);
					delete pContents;
					delete pStrTok;
					return FALSE;
				}
				m_pClientList[iClientH]->m_ItemPosList[cReadModeB-1].y = atoi(token);
				if (m_pClientList[iClientH]->m_ItemPosList[cReadModeB-1].y < -10) m_pClientList[iClientH]->m_ItemPosList[cReadModeB-1].y = -10;
				cReadModeB++;
				if (cReadModeB > 50) {
					cReadModeA = 0;
					cReadModeB = 0;
				}
				break;

			case 52:
				if (_bGetIsStringIsNumber(token) == FALSE) {
					wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format ( m_sCharIDnum1 ) - Connection closed. ", m_pClientList[iClientH]->m_cCharName); 
					PutLogList(cTxt);
					delete pContents;
					delete pStrTok;
					return FALSE;
				}

				m_pClientList[iClientH]->m_sCharIDnum1 = atoi(token);
				cReadModeA = 0;
				break;

			case 53:
				if (_bGetIsStringIsNumber(token) == FALSE) {
					wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format ( m_sCharIDnum2 ) - Connection closed. ", m_pClientList[iClientH]->m_cCharName); 
					PutLogList(cTxt);
					delete pContents;
					delete pStrTok;
					return FALSE;
				}

				m_pClientList[iClientH]->m_sCharIDnum2 = atoi(token);
				cReadModeA = 0;
				break;

			case 54:
				if (_bGetIsStringIsNumber(token) == FALSE) {
					wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format ( m_sCharIDnum3 ) - Connection closed. ", m_pClientList[iClientH]->m_cCharName); 
					PutLogList(cTxt);
					delete pContents;
					delete pStrTok;
					return FALSE;
				}
				m_pClientList[iClientH]->m_sCharIDnum3 = atoi(token);
				cReadModeA = 0;
				break;

			case 55:
				switch (cReadModeB) {
			case 1:
				// Penalty Block Year
				if (_bGetIsStringIsNumber(token) == FALSE) {
					wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format ( Penalty Block Year ) - Connection closed. ", m_pClientList[iClientH]->m_cCharName); 
					PutLogList(cTxt);
					delete pContents;
					delete pStrTok;
					return FALSE;
				}
				m_pClientList[iClientH]->m_iPenaltyBlockYear = atoi(token);
				cReadModeB = 2;
				break;

			case 2:
				// Penalty Block Month
				if (_bGetIsStringIsNumber(token) == FALSE) {
					wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format ( Penalty Block Month ) - Connection closed. ", m_pClientList[iClientH]->m_cCharName); 
					PutLogList(cTxt);
					delete pContents;
					delete pStrTok;
					return FALSE;
				}
				m_pClientList[iClientH]->m_iPenaltyBlockMonth = atoi(token);
				cReadModeB = 3;
				break;

			case 3:
				// Penalty Block day
				if (_bGetIsStringIsNumber(token) == FALSE) {
					wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format ( Penalty Block Day ) - Connection closed. ", m_pClientList[iClientH]->m_cCharName); 
					PutLogList(cTxt);
					delete pContents;
					delete pStrTok;
					return FALSE;
				}
				m_pClientList[iClientH]->m_iPenaltyBlockDay = atoi(token);
				cReadModeA = 0;
				cReadModeB = 0;
				break;
				}
				break;

			case 56:
				if (_bGetIsStringIsNumber(token) == FALSE) {
					wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format ( Quest ) - Connection closed. ", m_pClientList[iClientH]->m_cCharName); 
					PutLogList(cTxt);
					delete pContents;
					delete pStrTok;
					return FALSE;
				}
				m_pClientList[iClientH]->m_iQuest = atoi(token);
				cReadModeA = 0;
				break;

			case 57:
				if (_bGetIsStringIsNumber(token) == FALSE) {
					wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format ( Quest count ) - Connection closed. ", m_pClientList[iClientH]->m_cCharName); 
					PutLogList(cTxt);
					delete pContents;
					delete pStrTok;
					return FALSE;
				}
				m_pClientList[iClientH]->m_iCurQuestCount = atoi(token);
				cReadModeA = 0;
				break;

			case 58:
				cReadModeA = 0;
				break;

			case 59:
				if (_bGetIsStringIsNumber(token) == FALSE) {
					wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format ( Quest Reward type ) - Connection closed. ", m_pClientList[iClientH]->m_cCharName); 
					PutLogList(cTxt);
					delete pContents;
					delete pStrTok;
					return FALSE;
				}
				m_pClientList[iClientH]->m_iQuestRewardType = atoi(token);
				cReadModeA = 0;
				break;

			case 60:
				if (_bGetIsStringIsNumber(token) == FALSE) {
					wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format ( Quest Reward amount ) - Connection closed. ", m_pClientList[iClientH]->m_cCharName); 
					PutLogList(cTxt);
					delete pContents;
					delete pStrTok;
					return FALSE;
				}
				m_pClientList[iClientH]->m_iQuestRewardAmount = atoi(token);
				cReadModeA = 0;
				break;

			case 61:
				if (_bGetIsStringIsNumber(token) == FALSE) {
					wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format ( Contribution ) - Connection closed. ", m_pClientList[iClientH]->m_cCharName); 
					PutLogList(cTxt);
					delete pContents;
					delete pStrTok;
					return FALSE;
				}
				m_pClientList[iClientH]->m_iContribution = atoi(token);
				if (m_pClientList[iClientH]->m_iContribution <0 ) m_pClientList[iClientH]->m_iContribution =0;
				cReadModeA = 0;
				break;

			case 62:
				if (_bGetIsStringIsNumber(token) == FALSE) {
					wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format ( Quest ID ) - Connection closed. ", m_pClientList[iClientH]->m_cCharName); 
					PutLogList(cTxt);
					delete pContents;
					delete pStrTok;
					return FALSE;
				}
				m_pClientList[iClientH]->m_iQuestID = atoi(token);
				cReadModeA = 0;
				break;

			case 63:
				if (_bGetIsStringIsNumber(token) == FALSE) {
					wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format ( m_bIsQuestCompleted ) - Connection closed. ", m_pClientList[iClientH]->m_cCharName); 
					PutLogList(cTxt);
					delete pContents;
					delete pStrTok;
					return FALSE;
				}
				m_pClientList[iClientH]->m_bIsQuestCompleted = (BOOL)atoi(token);
				cReadModeA = 0;
				break;

			case 64:
				if (_bGetIsStringIsNumber(token) == FALSE) {
					wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format ( ForceRecall ) - Connection closed. ", m_pClientList[iClientH]->m_cCharName); 
					PutLogList(cTxt);
					delete pContents;
					delete pStrTok;
					return FALSE;
				}
				m_pClientList[iClientH]->m_iTimeLeft_ForceRecall = (BOOL)atoi(token);
				cReadModeA = 0;
				break;

			case 65:
				if (_bGetIsStringIsNumber(token) == FALSE) {
					wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format ( FirmStaminar ) - Connection closed. ", m_pClientList[iClientH]->m_cCharName); 
					PutLogList(cTxt);
					delete pContents;
					delete pStrTok;
					return FALSE;
				}
				m_pClientList[iClientH]->m_iTimeLeft_FirmStaminar = (BOOL)atoi(token);
				cReadModeA = 0;
				break;

			case 66:
				if (_bGetIsStringIsNumber(token) == FALSE)
				{	wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format ( iSpecialEventID ) - Connection closed. ", m_pClientList[iClientH]->m_cCharName); 
					PutLogList(cTxt);
					delete pContents;
					delete pStrTok;
					return FALSE;
				}
				m_pClientList[iClientH]->m_iSpecialEventID = (BOOL)atoi(token);
				cReadModeA = 0;
				break;

			case 67:
				switch (cReadModeB) {
				case 1:	// FightZone Number
					if (_bGetIsStringIsNumber(token) == FALSE) 
					{	wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format ( m_iFightzoneNumber ) - Connection closed. ", m_pClientList[iClientH]->m_cCharName); 
						PutLogList(cTxt);
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pClientList[iClientH]->m_iFightzoneNumber = atoi(token);
					cReadModeB = 2;
					break;
				case 2:	
					if (_bGetIsStringIsNumber(token) == FALSE)
					{	wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format ( m_iReserveTime ) - Connection closed. ", m_pClientList[iClientH]->m_cCharName); 
						PutLogList(cTxt);
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pClientList[iClientH]->m_iReserveTime = atoi(token);
					cReadModeB = 3;
					break;
				case 3:	 
					if (_bGetIsStringIsNumber(token) == FALSE) 
					{	wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format ( m_iFightZoneTicketNumber ) - Connection closed. ", m_pClientList[iClientH]->m_cCharName); 
						PutLogList(cTxt);
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pClientList[iClientH]->m_iFightZoneTicketNumber = atoi(token);
					cReadModeA = 0;
					cReadModeB = 0;
					break;
				}
				break;

			case 70:
				if (_bGetIsStringIsNumber(token) == FALSE) {
					wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format ( SuperAttack Left ) - Connection closed. ", m_pClientList[iClientH]->m_cCharName); 
					PutLogList(cTxt);
					delete pContents;
					delete pStrTok;
					return FALSE;
				}
				m_pClientList[iClientH]->m_iSuperAttackLeft = (BOOL)atoi(token);
				cReadModeA = 0;
				break;

			case 71:
				if (_bGetIsStringIsNumber(token) == FALSE) {
					wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format ( m_iSpecialAbilityTime ) - Connection closed. ", m_pClientList[iClientH]->m_cCharName); 
					PutLogList(cTxt);
					delete pContents;
					delete pStrTok;
					return FALSE;
				}
				m_pClientList[iClientH]->m_iSpecialAbilityTime = atoi(token);
				cReadModeA = 0;
				break;

			case 72:
				if (_bGetIsStringIsNumber(token) == FALSE) {
					wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format ( m_iWarContribution ) - Connection closed. ", m_pClientList[iClientH]->m_cCharName); 
					PutLogList(cTxt);
					delete pContents;
					delete pStrTok;
					return FALSE;
				}
				m_pClientList[iClientH]->m_iWarContribution = atoi(token);
				cReadModeA = 0;
				break;

			case 73:
				if (strlen(token) > 10) {
					wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format ( m_cLockedMapName ) - Connection closed. ", m_pClientList[iClientH]->m_cCharName); 
					PutLogList(cTxt);
					delete pContents;
					delete pStrTok;
					return FALSE;
				}
				ZeroMemory(m_pClientList[iClientH]->m_cLockedMapName, sizeof(m_pClientList[iClientH]->m_cLockedMapName));
				strcpy(m_pClientList[iClientH]->m_cLockedMapName, token);
				cReadModeA = 0;
				break;

			case 74:
				if (_bGetIsStringIsNumber(token) == FALSE) {
					wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format ( m_iLockedMapTime ) - Connection closed. ", m_pClientList[iClientH]->m_cCharName); 
					PutLogList(cTxt);
					delete pContents;
					delete pStrTok;
					return FALSE;
				}
				m_pClientList[iClientH]->m_iLockedMapTime = atoi(token);
				cReadModeA = 0;
				break;

			case 75:
				if (_bGetIsStringIsNumber(token) == FALSE) {
					wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format ( m_iCrusadeDuty ) - Connection closed. ", m_pClientList[iClientH]->m_cCharName); 
					PutLogList(cTxt);
					delete pContents;
					delete pStrTok;
					return FALSE;
				}
				m_pClientList[iClientH]->m_iCrusadeDuty = atoi(token);
				cReadModeA = 0;
				break;

			case 76:
				if (_bGetIsStringIsNumber(token) == FALSE) {
					wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format ( m_iConstructionPoint ) - Connection closed. ", m_pClientList[iClientH]->m_cCharName); 
					PutLogList(cTxt);
					delete pContents;
					delete pStrTok;
					return FALSE;
				}
				m_pClientList[iClientH]->m_iConstructionPoint = atoi(token);
				cReadModeA = 0;
				break;

			case 77:
				if (_bGetIsStringIsNumber(token) == FALSE) {
					wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format ( m_dwCrusadeGUID ) - Connection closed. ", m_pClientList[iClientH]->m_cCharName); 
					PutLogList(cTxt);
					delete pContents;
					delete pStrTok;
					return FALSE;
				}
				m_pClientList[iClientH]->m_dwCrusadeGUID = atoi(token);
				cReadModeA = 0;
				break;

			case 78:
				if (_bGetIsStringIsNumber(token) == FALSE) {
					wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format ( m_iDeadPenaltyTime ) - Connection closed. ", m_pClientList[iClientH]->m_cCharName); 
					PutLogList(cTxt);
					delete pContents;
					delete pStrTok;
					return FALSE;
				}
				m_pClientList[iClientH]->m_iDeadPenaltyTime = atoi(token);
				cReadModeA = 0;
				break;

			case 79: // PartyID
				if (_bGetIsStringIsNumber(token) == FALSE) {
					wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format ( m_iPartyID ) - Connection closed. ", m_pClientList[iClientH]->m_cCharName); 
					PutLogList(cTxt);
					delete pContents;
					delete pStrTok;
					return FALSE;
				}
				m_pClientList[iClientH]->m_iPartyID = atoi(token);
				if (m_pClientList[iClientH]->m_iPartyID < 0) m_pClientList[iClientH]->m_iPartyID = 0;
				if (m_pClientList[iClientH]->m_iPartyID != NULL) m_pClientList[iClientH]->m_iPartyStatus = DEF_PARTYSTATUS_CONFIRM;
				cReadModeA = 0;
				break;

			case 80: // v
				if (_bGetIsStringIsNumber(token) == FALSE) {
					wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format ( m_iGizonItemUpgradeLeft ) - Connection closed. ", m_pClientList[iClientH]->m_cCharName); 
					PutLogList(cTxt);
					delete pContents;
					delete pStrTok;
					return FALSE;
				}
				m_pClientList[iClientH]->m_iGizonItemUpgradeLeft = atoi(token);
				if (m_pClientList[iClientH]->m_iGizonItemUpgradeLeft < 0) m_pClientList[iClientH]->m_iGizonItemUpgradeLeft = 0;
				cReadModeA = 0;
				break;

			case 81:
				if (_bGetIsStringIsNumber(token) == FALSE) {
					wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format ( m_dwHeldenianGUID ) - Connection closed. ", m_pClientList[iClientH]->m_cCharName); 
					PutLogList(cTxt);
					delete pContents;
					delete pStrTok;
					return FALSE;
				}
				m_pClientList[iClientH]->m_dwHeldenianGUID = atoi(token);
				cReadModeA = 0;
				break;

			case 82: // last-deco-time = m_cdwDecoTime
				if (_bGetIsStringIsNumber(token) == FALSE) 
				{	wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format ( m_cdwDecoTime ) - Connection closed. ", m_pClientList[iClientH]->m_cCharName); 
					PutLogList(cTxt);
					delete pContents;
					delete pStrTok;
					return FALSE;
				}
				m_pClientList[iClientH]->m_cdwDecoTime = atoi(token);
				cReadModeA = 0;
				break;

			case 83: // known-gold = m_KnownPreviousGold
				if (_bGetIsStringIsNumber(token) == FALSE) 
				{	wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format ( m_KnownPreviousGold ) - Connection closed. ", m_pClientList[iClientH]->m_cCharName); 
					PutLogList(cTxt);
					delete pContents;
					delete pStrTok;
					return FALSE;
				}
				m_pClientList[iClientH]->m_KnownPreviousGold = atoi(token);
				cReadModeA = 0;
				break;

			case 84: // "limited-user = %d", (int) m_pClientList[iClientH]->m_bIsLimitedUser);
				if (_bGetIsStringIsNumber(token) == FALSE) 
				{	wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format ( m_bIsLimitedUser ) - Connection closed. ", m_pClientList[iClientH]->m_cCharName); 
					PutLogList(cTxt);
					delete pContents;
					delete pStrTok;
					return FALSE;
				}
				m_pClientList[iClientH]->m_bIsLimitedUser = 0;
				m_pClientList[iClientH]->m_bIsLimitedUser = atoi(token);
				cReadModeA = 0;
				break;
				
			case 85: // m_dwAvatarGUID
				if (_bGetIsStringIsNumber(token) == FALSE) {
					wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format ( m_dwAvatarGUID ) - Connection closed. ", m_pClientList[iClientH]->m_cCharName); 
					PutLogList(cTxt);
					delete pContents;
					delete pStrTok;
					return FALSE;
				}
				m_pClientList[iClientH]->m_dwAvatarGUID = atoi(token);
				cReadModeA = 0;
				break;
			}
		}else 
		{	if (memcmp(token, "character-loc-map", 17) == 0)		 cReadModeA = 1;
			if (memcmp(token, "character-loc-x", 15) == 0)			 cReadModeA = 2;
			if (memcmp(token, "character-loc-y", 15) == 0)			 cReadModeA = 3;
			if (memcmp(token, "character-account-status", 21) == 0)  cReadModeA = 4;
			if (memcmp(token, "character-item", 14) == 0) {
				cReadModeA = 5;
				cReadModeB = 1;
				m_pClientList[iClientH]->m_pItemList[iItemIndex] = new class CItem;
			}
			if (memcmp(token, "character-bank-item", 18) == 0) {
				cReadModeA = 28;
				cReadModeB = 1;
				m_pClientList[iClientH]->m_pItemInBankList[iItemInBankIndex] = new class CItem;
			}
			if (memcmp(token, "sex-status", 10) == 0)        cReadModeA = 6;
			if (memcmp(token, "skin-status", 11) == 0)       cReadModeA = 7;
			if (memcmp(token, "hairstyle-status", 16) == 0)  cReadModeA = 8;
			if (memcmp(token, "haircolor-status", 16) == 0)  cReadModeA = 9;
			if (memcmp(token, "underwear-status", 16) == 0)  cReadModeA = 10;
			if (memcmp(token, "item-equip-status", 17) == 0)    cReadModeA = 11;
			if (memcmp(token, "character-guild-name", 20) == 0) cReadModeA = 12;
			if (memcmp(token, "character-guild-rank", 20) == 0) cReadModeA = 13;
			if (memcmp(token, "character-HP", 12) == 0)         cReadModeA = 14;
			if (memcmp(token, "character-DefenseRatio",22)==0)  cReadModeA = 15;
			if (memcmp(token, "character-HitRatio", 18) == 0)   cReadModeA = 16;
			if (memcmp(token, "character-LEVEL", 15) == 0)      cReadModeA = 17;
			if (memcmp(token, "character-STR", 13) == 0)        cReadModeA = 18;
			if (memcmp(token, "character-INT", 13) == 0)        cReadModeA = 19;
			if (memcmp(token, "character-VIT", 13) == 0)        cReadModeA = 20;
			if (memcmp(token, "character-DEX", 13) == 0)        cReadModeA = 21;
			if (memcmp(token, "character-MAG", 13) == 0)        cReadModeA = 22;
			if (memcmp(token, "character-CHARISMA", 18) == 0)   cReadModeA = 23;
			if (memcmp(token, "character-LUCK", 14) == 0)       cReadModeA = 24;
			if (memcmp(token, "character-EXP", 13) == 0)        cReadModeA = 25;
			if (memcmp(token, "magic-mastery", 13) == 0)        cReadModeA = 26;
			if (memcmp(token, "skill-mastery", 13) == 0) 
			{	cReadModeA = 27;
				cReadModeB = 0;
			}
			if (memcmp(token, "character-location", 18) == 0)   cReadModeA = 29;
			if (memcmp(token, "character-MP", 12) == 0)         cReadModeA = 30;
			if (memcmp(token, "character-SP", 12) == 0)         cReadModeA = 31;
			if (memcmp(token, "character-LU_Pool", 17) == 0)     cReadModeA = 32;
			if (memcmp(token, "validation-number", 17) == 0)     cReadModeA = 33;
			if (memcmp(token, "CrasyKiller-Count", 17) == 0)     cReadModeA = 34;
			/*
			if (memcmp(token, "character-LU_Str", 16) == 0)     cReadModeA = 32;
			if (memcmp(token, "character-LU_Vit", 16) == 0)     cReadModeA = 33;
			if (memcmp(token, "character-LU_Dex", 16) == 0)     cReadModeA = 34;
			if (memcmp(token, "character-LU_Int", 16) == 0)     cReadModeA = 35;
			if (memcmp(token, "character-LU_Mag", 16) == 0)     cReadModeA = 36;
			if (memcmp(token, "character-LU_Char",17) == 0)     cReadModeA = 37;
			*/

			if (memcmp(token, "character-EK-Count",18) == 0)    cReadModeA = 38;
			if (memcmp(token, "character-PK-Count",18) == 0)    cReadModeA = 39;
			if (memcmp(token, "character-reward-gold",21) == 0) cReadModeA = 40;
			if (memcmp(token, "skill-SSN", 9) == 0) 			cReadModeA = 41;
			if (memcmp(token, "character-profile", 17) == 0)	cReadModeA = 42;
			if (memcmp(token, "hunger-status", 13) == 0) 		cReadModeA = 43;
			if (memcmp(token, "admin-user-level", 16) == 0) 	cReadModeA = 44;
			if (memcmp(token, "timeleft-shutup", 15) == 0) 		cReadModeA = 45;
			if (memcmp(token, "timeleft-rating", 15) == 0) 		cReadModeA = 46;
			if (memcmp(token, "character-RATING", 16) == 0)	    cReadModeA = 47;
			if (memcmp(token, "character-guild-GUID", 20) == 0) cReadModeA = 48;
			if (memcmp(token, "character-downskillindex", 24) == 0) cReadModeA = 49;
			if (memcmp(token, "item-position-x", 15) == 0) // Hypnoload fix ....
			{	cReadModeA = 50;
				cReadModeB = 1;
			}
			if (memcmp(token, "item-position-y", 15) == 0) // Hypnoload fix .... 
			{	cReadModeA = 51;
				cReadModeB = 1;
			}
			if (memcmp(token, "character-IDnum1",16) == 0)		cReadModeA = 52;
			if (memcmp(token, "character-IDnum2",16) == 0)		cReadModeA = 53;
			if (memcmp(token, "character-IDnum3",16) == 0)		cReadModeA = 54;
			if (memcmp(token, "penalty-block-date",18) == 0) 
			{	cReadModeA = 55;
				cReadModeB = 1;
			}
			if (memcmp(token, "character-quest-number",22) == 0)	cReadModeA = 56;
			if (memcmp(token, "current-quest-count",19) == 0)		cReadModeA = 57;
			if (memcmp(token, "quest-reward-type", 17) == 0)		cReadModeA = 59;
			if (memcmp(token, "quest-reward-amount", 19) == 0)		cReadModeA = 60;
			if (memcmp(token, "character-contribution", 22) == 0)   cReadModeA = 61;
			if (memcmp(token, "character-quest-ID",18) == 0)        cReadModeA = 62;
			if (memcmp(token, "character-quest-completed",25) == 0) cReadModeA = 63;
			if (memcmp(token, "timeleft-force-recall", 21) == 0)	cReadModeA = 64;
			if (memcmp(token, "timeleft-firm-staminar", 22) == 0)	cReadModeA = 65;
			if (memcmp(token, "special-event-id", 16) == 0)			cReadModeA = 66;
			if (memcmp(token, "super-attack-left", 17) == 0)		cReadModeA = 70;
			if (memcmp(token, "reserved-fightzone-id", 21) == 0)	
			{	cReadModeA = 67;
				cReadModeB = 1;
			}
			if (memcmp(token, "special-ability-time", 20) == 0)		cReadModeA = 71; 
			if (memcmp(token, "character-war-contribution", 26) == 0)	cReadModeA = 72; 
			if (memcmp(token, "locked-map-name", 15) == 0)			cReadModeA = 73;
			if (memcmp(token, "locked-map-time", 15) == 0)			cReadModeA = 74;
			if (memcmp(token, "crusade-job", 11) == 0)				cReadModeA = 75;
			if (memcmp(token, "construct-point", 15) == 0)			cReadModeA = 76;
			if (memcmp(token, "crusade-GUID", 12) == 0)				cReadModeA = 77;
			if (memcmp(token, "dead-penalty-time", 17) == 0)		cReadModeA = 78;
			if (memcmp(token, "party-id", 8) == 0)					cReadModeA = 79; 
			if (memcmp(token, "gizon-item-upgade-left", 22) == 0)	cReadModeA = 80; 
			if (memcmp(token, "heldenian-GUID", 14) == 0)			cReadModeA = 81;
			if (memcmp(token, "last-deco-time", 14) == 0)			cReadModeA = 82;
			if (memcmp(token, "known-gold", 10) == 0)				cReadModeA = 83;
			if (memcmp(token, "limited-user", 12) == 0)				cReadModeA = 84;
			if (memcmp(token, "avatar-GUID", 11) == 0)				cReadModeA = 85;
			if (memcmp(token, "[EOF]", 5) == 0) goto DPDC_STOP_DECODING;
		}
		token = pStrTok->pGet();
		//token = strtok( NULL, seps );							    
	}
DPDC_STOP_DECODING:;
	delete pStrTok;
	delete pContents;
	if ((cReadModeA != 0) || (cReadModeB != 0)) {
		wsprintf(cTxt,   "Player data file:  PC(%s) - Contains error (error code: %d %d) \tIP(%s)"
			, m_pClientList[iClientH]->m_cCharName
			, cReadModeA, cReadModeB
			, m_pClientList[iClientH]->m_cIPaddress);
		PutHackLogFileList(cTxt);	
		PutLogList(cTxt);
		// Debug code @@@@@@@@@@@@@@@
		HANDLE hFile2;
		DWORD  nWrite2;
		hFile2 = CreateFile("Error.Log", GENERIC_WRITE, NULL, NULL, CREATE_ALWAYS, NULL, NULL);
		WriteFile(hFile2, (char *)pOriginContents, dwSize+2, &nWrite2, NULL);
		CloseHandle(hFile2);
		///////////// @@@@@@@@@@@@@@@
		return FALSE;
	}
	bRet = m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->bIsValidLoc(m_pClientList[iClientH]->m_sX, m_pClientList[iClientH]->m_sY);
	if (bRet == FALSE) {
		if ((m_pClientList[iClientH]->m_sX != -1) || (m_pClientList[iClientH]->m_sY != -1)) {
			//printf(cTxt,   "Character data file PC(%s) - Refused character has invalid validation-number...  IP(%s)"
			wsprintf(cTxt,   "Player data file    PC(%s) - Invalid location (x:%d y:%d)  IP(%s)"
				, m_pClientList[iClientH]->m_cCharName
				, m_pClientList[iClientH]->m_sX
				, m_pClientList[iClientH]->m_sY
				, m_pClientList[iClientH]->m_cIPaddress);
			PutLogList(cTxt);
			return FALSE;
		}
	}
	// m_iServerValidationNumber check
	if (m_iServerValidationNumber != 0) 
	{	if (m_pClientList[iClientH]->m_iLevel <2) // Starting characters are given a good validation number
					m_pClientList[iClientH]->m_iValidationNumber = m_iServerValidationNumber;
		if ( m_pClientList[iClientH]->m_iValidationNumber != m_iServerValidationNumber) 
		{	wsprintf(cTxt,   "Validation number: PC(%s) - Refused character, invalid validation-number. \tIP(%s)"
				, m_pClientList[iClientH]->m_cCharName
				, m_pClientList[iClientH]->m_cIPaddress);
			PutHackLogFileList(cTxt);	
			PutLogList(cTxt);
			return FALSE;
		}
	}
	//	if ( (m_pClientList[iClientH]->m_cLU_Str + m_pClientList[iClientH]->m_cLU_Vit + m_pClientList[iClientH]->m_cLU_Dex + 
	//  		  m_pClientList[iClientH]->m_cLU_Int + m_pClientList[iClientH]->m_cLU_Mag + m_pClientList[iClientH]->m_cLU_Char) > DEF_TOTALLEVELUPPOINT) 
	if ((m_pClientList[iClientH]->m_iLU_Pool < 0) || (m_pClientList[iClientH]->m_iLU_Pool > DEF_CHARPOINTLIMIT))
	{	wsprintf(cTxt,   "Player data file    PC(%s) - Stats error LU_pool  IP(%s)"
			, m_pClientList[iClientH]->m_cCharName
			, m_pClientList[iClientH]->m_cIPaddress);
		PutLogList(cTxt);
		return FALSE;
	}
	if ((m_pClientList[iClientH]->m_iStr < 10) || (m_pClientList[iClientH]->m_iStr > DEF_CHARPOINTLIMIT))
	{	wsprintf(cTxt,   "Player data file    PC(%s) - Stats error Str  IP(%s)"
			, m_pClientList[iClientH]->m_cCharName
			, m_pClientList[iClientH]->m_cIPaddress);
		PutLogList(cTxt);
		return FALSE;
	}
	if ((m_pClientList[iClientH]->m_iDex < 10) || (m_pClientList[iClientH]->m_iDex > DEF_CHARPOINTLIMIT))
	{	wsprintf(cTxt,   "Player data file    PC(%s) - Stats error Dex  IP(%s)"
			, m_pClientList[iClientH]->m_cCharName
			, m_pClientList[iClientH]->m_cIPaddress);
		PutLogList(cTxt);
		return FALSE;
	}
	if ((m_pClientList[iClientH]->m_iVit < 10) || (m_pClientList[iClientH]->m_iVit > DEF_CHARPOINTLIMIT))
	{	wsprintf(cTxt,   "Player data file    PC(%s) - Stats error Vit  IP(%s)"
			, m_pClientList[iClientH]->m_cCharName
			, m_pClientList[iClientH]->m_cIPaddress);
		PutLogList(cTxt);
		return FALSE;
	}
	if ((m_pClientList[iClientH]->m_iInt < 10) || (m_pClientList[iClientH]->m_iInt > DEF_CHARPOINTLIMIT))
	{	wsprintf(cTxt,   "Player data file    PC(%s) - Stats error Int  IP(%s)"
			, m_pClientList[iClientH]->m_cCharName
			, m_pClientList[iClientH]->m_cIPaddress);
		PutLogList(cTxt);
		return FALSE;
	}
	if ((m_pClientList[iClientH]->m_iMag < 10) || (m_pClientList[iClientH]->m_iMag > DEF_CHARPOINTLIMIT))
	{	wsprintf(cTxt,   "Player data file    PC(%s) - Stats error Mag  IP(%s)"
			, m_pClientList[iClientH]->m_cCharName
			, m_pClientList[iClientH]->m_cIPaddress);
		PutLogList(cTxt);
		return FALSE;
	}
	if ((m_pClientList[iClientH]->m_iCharisma < 10) || (m_pClientList[iClientH]->m_iCharisma > DEF_CHARPOINTLIMIT))
	{	wsprintf(cTxt,   "Player data file    PC(%s) - Stats error Charisma  IP(%s)"
			, m_pClientList[iClientH]->m_cCharName
			, m_pClientList[iClientH]->m_cIPaddress);
		PutLogList(cTxt);
		return FALSE;
	}
	if ((m_Misc.bCheckValidName(m_pClientList[iClientH]->m_cCharName) == FALSE) || (m_Misc.bCheckValidName(m_pClientList[iClientH]->m_cAccountName) == FALSE)) 
	{	wsprintf(cTxt,   "Player data file:  PC(%s) - Account or Character name non valid. \tIP(%s)"
			, m_pClientList[iClientH]->m_cCharName
			, m_pClientList[iClientH]->m_cIPaddress);
		PutHackLogFileList(cTxt);	
		PutLogList(cTxt);
		return FALSE;
	}
	if (m_pClientList[iClientH]->m_iPenaltyBlockYear != 0) {
		GetLocalTime(&SysTime);
		iDateSum1 = (__int64)(m_pClientList[iClientH]->m_iPenaltyBlockYear*10000 + m_pClientList[iClientH]->m_iPenaltyBlockMonth*100 + m_pClientList[iClientH]->m_iPenaltyBlockDay);
		iDateSum2 = (__int64)(SysTime.wYear*10000 + SysTime.wMonth*100 + SysTime.wDay);
		if (iDateSum1 >= iDateSum2) 	
		{	wsprintf(cTxt,   "Player data file:  PC(%s) - Penalty time blocked  \tIP(%s)"
				, m_pClientList[iClientH]->m_cCharName
				, m_pClientList[iClientH]->m_cIPaddress);
			PutHackLogFileList(cTxt);	
			PutLogList(cTxt);
			return FALSE;
		}
	}
	if (m_pClientList[iClientH]->m_iReserveTime != 0) {
		GetLocalTime(&SysTime);
		iDateSum1 = (__int64)m_pClientList[iClientH]->m_iReserveTime;
		iDateSum2 = (__int64)(SysTime.wMonth*10000 + SysTime.wDay*100 + SysTime.wHour);
		if (iDateSum2 >= iDateSum1) {
			// SNOOPY: Bug here ii wrong, should be iClientH
			//SendNotifyMsg(NULL, i, DEF_NOTIFY_FIGHTZONERESERVE, -2, NULL, NULL, NULL);
			SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_FIGHTZONERESERVE, -2, NULL, NULL, NULL);
			m_pClientList[iClientH]->m_iFightzoneNumber = 0; 
			m_pClientList[iClientH]->m_iReserveTime = 0;
			m_pClientList[iClientH]->m_iFightZoneTicketNumber = 0;
		}
	}
	if (m_pClientList[iClientH]->m_iAdminUserLevel < 0) m_pClientList[iClientH]->m_iAdminUserLevel = 0;
	if (m_pClientList[iClientH]->m_cSex == 1) 
	{	sTmpType = 1;
	}else /* SNOOPY removed useless here if (m_pClientList[iClientH]->m_cSex == 2)*/ 
	{	sTmpType = 4; 
	}
	switch (m_pClientList[iClientH]->m_cSkin) {
	case 1:	break;
	case 2:	sTmpType += 1; break;
	case 3:	sTmpType += 2; break;
	}
	if (m_pClientList[iClientH]->m_iAdminUserLevel >= 10) 
		sTmpType = m_pClientList[iClientH]->m_iAdminUserLevel;

	sTmpAppr1 = (m_pClientList[iClientH]->m_cHairStyle << 8) | (m_pClientList[iClientH]->m_cHairColor << 4) | (m_pClientList[iClientH]->m_cUnderwear);

	m_pClientList[iClientH]->m_sType         = sTmpType;
	m_pClientList[iClientH]->m_sOriginalType = sTmpType;
	m_pClientList[iClientH]->m_sAppr1        = sTmpAppr1;
	iCalcTotalWeight(iClientH);
	// SNOOPY: reintroduced this feature
	if (   (iTotalGold > 1000000) && (m_pClientList[iClientH]->m_iAdminUserLevel == 0)
		&& (iTotalGold > (100000 + m_pClientList[iClientH]->m_KnownPreviousGold)))
	{	wsprintf(cTxt,   "Very rich player:  PC(%s) - Has more than 1 million gold ( %d ) \tIP(%s)"
			, m_pClientList[iClientH]->m_cCharName
			, iTotalGold
			, m_pClientList[iClientH]->m_cIPaddress);
		//PutHackLogFileList(cTxt);
		PutItemLogFileList(cTxt);
		PutLogList(cTxt);
		m_pClientList[iClientH]->m_KnownPreviousGold = iTotalGold;
	}else if ((iTotalGold + 100000) < m_pClientList[iClientH]->m_KnownPreviousGold)
	{	m_pClientList[iClientH]->m_KnownPreviousGold = iTotalGold; // Character has reduced gold
	}

	if (m_pClientList[iClientH]->m_sCharIDnum1 == 0) {
		int _i, _iTemp1, _iTemp2;
		short _sID1, _sID2, _sID3;
		_iTemp1 = 1;
		_iTemp2 = 1;
		for (_i = 0; _i < 10; _i++) {
			_iTemp1 += m_pClientList[iClientH]->m_cCharName[_i];
			_iTemp2 += abs(m_pClientList[iClientH]->m_cCharName[_i] ^ m_pClientList[iClientH]->m_cCharName[_i]);
		}

		_sID1 = (short)timeGetTime(); 
		_sID2 = (short)_iTemp1; 
		_sID3 = (short)_iTemp2; 

		m_pClientList[iClientH]->m_sCharIDnum1 = _sID1;
		m_pClientList[iClientH]->m_sCharIDnum2 = _sID2;
		m_pClientList[iClientH]->m_sCharIDnum3 = _sID3;
	}
	m_pClientList[iClientH]->m_iRewardGold += iNotUsedItemPrice;
	// For hourlly XP check....
	m_pClientList[iClientH]->m_iXPHackCheckExp = m_pClientList[iClientH]->m_iExp;
	if (memcmp(m_pClientList[iClientH]->m_cLocation, "NONE", 4) == 0) m_pClientList[iClientH]->m_bIsNeutral = TRUE;
	return TRUE;
}

int CGame::_iComposePlayerDataFileContents(int iClientH, char * pData)
{SYSTEMTIME SysTime;
 char  cTxt[120], cTmp[21];
 POINT TempItemPosList[DEF_MAXITEMS];
 int   i, iPos;
 DWORD dwTemp;

	if (m_pClientList[iClientH] == NULL) return 0;

	GetLocalTime(&SysTime);
	strcat(pData, "[FILE-DATE]\n\n");
	
	wsprintf(cTxt, "file-saved-date: %d %d %d %d %d\n", SysTime.wYear, SysTime.wMonth, SysTime.wDay, SysTime.wHour, SysTime.wMinute);
	strcat(pData, cTxt);
	strcat(pData, "\n");		
	strcat(pData, "[NAME-ACCOUNT]\n\n");
	strcat(pData, "character-name     = ");
	strcat(pData, m_pClientList[iClientH]->m_cCharName);
	strcat(pData, "\n");
	strcat(pData, "account-name       = ");
	strcat(pData, m_pClientList[iClientH]->m_cAccountName);
	strcat(pData, "\n\n");

	strcat(pData, "[STATUS]\n\n");
	strcat(pData, "character-profile 	=");
	if (strlen(m_pClientList[iClientH]->m_cProfile) == 0) 
	{	strcat(pData, "__________");
	}
	else strcat(pData, m_pClientList[iClientH]->m_cProfile);
	strcat(pData, "\n");
	strcat(pData, "character-location   = ");
	strcat(pData, m_pClientList[iClientH]->m_cLocation);
	strcat(pData, "\n");
	strcat(pData, "character-guild-name = ");
	if (m_pClientList[iClientH]->m_iGuildRank != -1) {
		strcat(pData, m_pClientList[iClientH]->m_cGuildName);
	}
	else strcat(pData, "NONE");
	strcat(pData, "\n");
		strcat(pData, "character-guild-GUID = ");
	if (m_pClientList[iClientH]->m_iGuildRank != -1) {
		ZeroMemory(cTxt, sizeof(cTxt));
		wsprintf(cTxt, "%d", m_pClientList[iClientH]->m_iGuildGUID);
		strcat(pData, cTxt);
	}
	else strcat(pData, "-1");
	strcat(pData, "\n");
	strcat(pData, "character-guild-rank = ");
	itoa( m_pClientList[iClientH]->m_iGuildRank, cTxt, 10);
	strcat(pData, cTxt);
	strcat(pData, "\n");

	strcat(pData, "character-loc-map = ");
	strcat(pData, m_pClientList[iClientH]->m_cMapName);
	strcat(pData, "\n");
	strcat(pData, "character-loc-x   = ");
	itoa( m_pClientList[iClientH]->m_sX, cTxt, 10);
	strcat(pData, cTxt);
	strcat(pData, "\n");
	strcat(pData, "character-loc-y   = ");
	itoa( m_pClientList[iClientH]->m_sY, cTxt, 10);
	strcat(pData, cTxt);
	strcat(pData, "\n\n");
	if (m_pClientList[iClientH]->m_iHP <= 0)  
		m_pClientList[iClientH]->m_iHP = 30;
	wsprintf(cTxt, "character-HP       = %d", m_pClientList[iClientH]->m_iHP);
	strcat(pData, cTxt);
	strcat(pData,"\n");
	wsprintf(cTxt, "character-MP       = %d",  m_pClientList[iClientH]->m_iMP);
	strcat(pData, cTxt);
	strcat(pData,"\n");
	if (m_pClientList[iClientH]->m_iSP < 0) m_pClientList[iClientH]->m_iSP = 0; // v1.1
	wsprintf(cTxt, "character-SP       = %d",  m_pClientList[iClientH]->m_iSP);
	strcat(pData, cTxt);
	strcat(pData,"\n");	
	wsprintf(cTxt, "character-LEVEL    = %d", m_pClientList[iClientH]->m_iLevel);
	strcat(pData, cTxt);
	strcat(pData,"\n");
	wsprintf(cTxt, "character-RATING   = %d", m_pClientList[iClientH]->m_iRating);
	strcat(pData, cTxt);
	strcat(pData,"\n\n");

	wsprintf(cTxt, "character-STR      = %d", m_pClientList[iClientH]->m_iStr);
	strcat(pData, cTxt);
	strcat(pData,"\n");
	wsprintf(cTxt, "character-INT      = %d", m_pClientList[iClientH]->m_iInt);
	strcat(pData, cTxt);
	strcat(pData,"\n");
	wsprintf(cTxt, "character-VIT      = %d", m_pClientList[iClientH]->m_iVit);
	strcat(pData, cTxt);
	strcat(pData,"\n");
	wsprintf(cTxt, "character-DEX      = %d", m_pClientList[iClientH]->m_iDex);
	strcat(pData, cTxt);
	strcat(pData,"\n");
	wsprintf(cTxt, "character-MAG      = %d", m_pClientList[iClientH]->m_iMag);
	strcat(pData, cTxt);
	strcat(pData,"\n");
	wsprintf(cTxt, "character-CHARISMA = %d", m_pClientList[iClientH]->m_iCharisma);
	strcat(pData, cTxt);
	strcat(pData,"\n");
	wsprintf(cTxt, "character-LUCK     = %d", m_pClientList[iClientH]->m_iLuck);
	strcat(pData, cTxt);
	strcat(pData,"\n");
	wsprintf(cTxt, "character-EXP      = %d", m_pClientList[iClientH]->m_iExp);
	strcat(pData, cTxt);
	strcat(pData,"\n");
	wsprintf(cTxt, "character-LU_Pool  = %d", m_pClientList[iClientH]->m_iLU_Pool);
	strcat(pData, cTxt);
	strcat(pData,"\n");	
	wsprintf(cTxt, "admin-user-level   = %d", m_pClientList[iClientH]->m_iAdminUserLevel);
	strcat(pData, cTxt);
	strcat(pData,"\n\n");	
	
	/*	
	wsprintf(cTxt, "character-LU_Str   = %d", m_pClientList[iClientH]->m_cLU_Str);
	strcat(pData, cTxt);	strcat(pData,"\n");
	wsprintf(cTxt, "character-LU_Vit   = %d", m_pClientList[iClientH]->m_cLU_Vit);
	strcat(pData, cTxt);	strcat(pData,"\n");
	wsprintf(cTxt, "character-LU_Dex   = %d", m_pClientList[iClientH]->m_cLU_Dex);
	strcat(pData, cTxt);	strcat(pData,"\n");
	wsprintf(cTxt, "character-LU_Int   = %d", m_pClientList[iClientH]->m_cLU_Int);
	strcat(pData, cTxt);	strcat(pData,"\n");
	wsprintf(cTxt, "character-LU_Mag   = %d", m_pClientList[iClientH]->m_cLU_Mag);
	strcat(pData, cTxt);	strcat(pData,"\n");
	wsprintf(cTxt, "character-LU_Char  = %d", m_pClientList[iClientH]->m_cLU_Char);
	strcat(pData, cTxt);	strcat(pData,"\n");
	*/
	wsprintf(cTxt, "character-EK-Count = %d", m_pClientList[iClientH]->m_iEnemyKillCount);
	strcat(pData, cTxt);
	strcat(pData,"\n");
	wsprintf(cTxt, "CrasyKiller-Count  = %d", m_pClientList[iClientH]->m_iCrazyPlayerKiller);
	strcat(pData, cTxt);
	strcat(pData,"\n");
	wsprintf(cTxt, "character-PK-Count = %d", m_pClientList[iClientH]->m_iPKCount);
	strcat(pData, cTxt);
	strcat(pData,"\n");	
	wsprintf(cTxt, "character-reward-gold    = %d", m_pClientList[iClientH]->m_iRewardGold);
	strcat(pData, cTxt);
	strcat(pData,"\n");
	wsprintf(cTxt, "character-downskillindex = %d", m_pClientList[iClientH]->m_iDownSkillIndex);
	strcat(pData, cTxt);
	strcat(pData,"\n");	
	wsprintf(cTxt, "character-IDnum1 = %d", m_pClientList[iClientH]->m_sCharIDnum1);
	strcat(pData, cTxt);
	strcat(pData,"\n");
	wsprintf(cTxt, "character-IDnum2 = %d", m_pClientList[iClientH]->m_sCharIDnum2);
	strcat(pData, cTxt);
	strcat(pData,"\n");
	wsprintf(cTxt, "character-IDnum3 = %d", m_pClientList[iClientH]->m_sCharIDnum3);
	strcat(pData, cTxt);
	strcat(pData,"\n");	//
	strcat(pData, "sex-status       = ");
	itoa( m_pClientList[iClientH]->m_cSex, cTxt, 10);
	strcat(pData, cTxt);
	strcat(pData, "\n");
	strcat(pData, "skin-status      = ");
	itoa( m_pClientList[iClientH]->m_cSkin, cTxt, 10);
	strcat(pData, cTxt);
	strcat(pData, "\n");
	strcat(pData, "hairstyle-status = ");
	itoa( m_pClientList[iClientH]->m_cHairStyle, cTxt, 10);
	strcat(pData, cTxt);
	strcat(pData, "\n");
	strcat(pData, "haircolor-status = ");
	itoa( m_pClientList[iClientH]->m_cHairColor, cTxt, 10);
	strcat(pData, cTxt);
	strcat(pData, "\n");
	strcat(pData, "underwear-status = ");
	itoa( m_pClientList[iClientH]->m_cUnderwear, cTxt, 10);
	strcat(pData, cTxt);
	strcat(pData, "\n");
	wsprintf(cTxt, "hunger-status    = %d", m_pClientList[iClientH]->m_iHungerStatus);
	strcat(pData, cTxt);
	strcat(pData,"\n");
	wsprintf(cTxt, "timeleft-shutup  = %d", m_pClientList[iClientH]->m_iTimeLeft_ShutUp);
	strcat(pData, cTxt);
	strcat(pData,"\n");
	wsprintf(cTxt, "timeleft-rating  = %d", m_pClientList[iClientH]->m_iTimeLeft_Rating);
	strcat(pData, cTxt);
	strcat(pData,"\n");
	wsprintf(cTxt, "timeleft-force-recall  = %d", m_pClientList[iClientH]->m_iTimeLeft_ForceRecall);
	strcat(pData, cTxt);
	strcat(pData,"\n");
	wsprintf(cTxt, "timeleft-firm-staminar = %d", m_pClientList[iClientH]->m_iTimeLeft_FirmStaminar);
	strcat(pData, cTxt);
	strcat(pData,"\n");
	wsprintf(cTxt, "special-ability-time   = %d", m_pClientList[iClientH]->m_iSpecialAbilityTime);
	strcat(pData, cTxt);
	strcat(pData,"\n\n");

	wsprintf(cTxt, "character-quest-number = %d", m_pClientList[iClientH]->m_iQuest);
	strcat(pData, cTxt);
	strcat(pData,"\n");
	wsprintf(cTxt, "character-quest-ID     = %d", m_pClientList[iClientH]->m_iQuestID);
	strcat(pData, cTxt);
	strcat(pData,"\n");	
	wsprintf(cTxt, "current-quest-count    = %d", m_pClientList[iClientH]->m_iCurQuestCount);
	strcat(pData, cTxt);
	strcat(pData,"\n");
	wsprintf(cTxt, "quest-reward-type      = %d", m_pClientList[iClientH]->m_iQuestRewardType);
	strcat(pData, cTxt);
	strcat(pData,"\n");
	wsprintf(cTxt, "quest-reward-amount    = %d", m_pClientList[iClientH]->m_iQuestRewardAmount);
	strcat(pData, cTxt);
	strcat(pData,"\n");
	wsprintf(cTxt, "character-contribution = %d", m_pClientList[iClientH]->m_iContribution);
	strcat(pData, cTxt);
	strcat(pData,"\n");
	wsprintf(cTxt, "character-quest-completed = %d", (int)m_pClientList[iClientH]->m_bIsQuestCompleted);
	strcat(pData, cTxt);
	strcat(pData,"\n");
	wsprintf(cTxt, "super-attack-left      = %d", (int)m_pClientList[iClientH]->m_iSuperAttackLeft);
	strcat(pData, cTxt);
	strcat(pData,"\n");
	wsprintf(cTxt, "reserved-fightzone-id  = %d %d %d", m_pClientList[iClientH]->m_iFightzoneNumber, m_pClientList[iClientH]->m_iReserveTime,m_pClientList[iClientH]->m_iFightZoneTicketNumber  );
	strcat(pData, cTxt);
	strcat(pData,"\n");
	wsprintf(cTxt, "penalty-block-date     = %d %d %d", m_pClientList[iClientH]->m_iPenaltyBlockYear, m_pClientList[iClientH]->m_iPenaltyBlockMonth, m_pClientList[iClientH]->m_iPenaltyBlockDay);
	strcat(pData, cTxt);
	strcat(pData,"\n");
	wsprintf(cTxt, "locked-map-name        = %s", m_pClientList[iClientH]->m_cLockedMapName);
	strcat(pData, cTxt);
	strcat(pData,"\n");
	wsprintf(cTxt, "locked-map-time        = %d", m_pClientList[iClientH]->m_iLockedMapTime);
	strcat(pData, cTxt);
	strcat(pData,"\n");	
	wsprintf(cTxt, "dead-penalty-time = %d", m_pClientList[iClientH]->m_iDeadPenaltyTime);
	strcat(pData, cTxt);
	strcat(pData,"\n");
	wsprintf(cTxt, "party-id          = %d", m_pClientList[iClientH]->m_iPartyID);
	strcat(pData, cTxt);
	strcat(pData,"\n\n");

	wsprintf(cTxt, "crusade-GUID     = %d", m_pClientList[iClientH]->m_dwCrusadeGUID);
	strcat(pData, cTxt);
	strcat(pData,"\n");
	wsprintf(cTxt, "heldenian-GUID   = %d", m_pClientList[iClientH]->m_dwHeldenianGUID);
	strcat(pData, cTxt);
	strcat(pData,"\n");	
	wsprintf(cTxt, "avatar-GUID      = %d", m_pClientList[iClientH]->m_dwAvatarGUID);
	strcat(pData, cTxt);
	strcat(pData,"\n");	
	wsprintf(cTxt, "crusade-job      = %d", m_pClientList[iClientH]->m_iCrusadeDuty);
	strcat(pData, cTxt);
	strcat(pData,"\n");
	wsprintf(cTxt, "character-war-contribution = %d", m_pClientList[iClientH]->m_iWarContribution);
	strcat(pData, cTxt);
	strcat(pData,"\n");
	wsprintf(cTxt, "construct-point  = %d", m_pClientList[iClientH]->m_iConstructionPoint);
	strcat(pData, cTxt);
	strcat(pData,"\n\n");

	wsprintf(cTxt, "special-event-id       = %d", (int)m_pClientList[iClientH]->m_iSpecialEventID);
	strcat(pData, cTxt);
	strcat(pData,"\n");
	wsprintf(cTxt, "gizon-item-upgade-left = %d", m_pClientList[iClientH]->m_iGizonItemUpgradeLeft);
	strcat(pData, cTxt);
	strcat(pData,"\n");
	wsprintf(cTxt, "limited-user = %d", (int) m_pClientList[iClientH]->m_bIsLimitedUser);
	strcat(pData, cTxt);
	strcat(pData,"\n\n");

	wsprintf(cTxt, "last-deco-time        = %d", m_pClientList[iClientH]->m_cdwDecoTime);
	strcat(pData, cTxt);
	strcat(pData,"\n");
	wsprintf(cTxt, "validation-number     = %d", m_pClientList[iClientH]->m_iValidationNumber);
	strcat(pData, cTxt);
	strcat(pData,"\n");
	wsprintf(cTxt, "Con-check-lower-gap   = %d", m_pClientList[iClientH]->m_iLowerGap);
	strcat(pData, cTxt);  // Store Hacking detection data (not read)
	strcat(pData,"\n");
	wsprintf(cTxt, "Con-check-max-paquets = %d", m_pClientList[iClientH]->m_iMaxPackets);
	strcat(pData, cTxt);  // Store Hacking detection data (not read)
	strcat(pData,"\n");
	wsprintf(cTxt, "Con-check-signature   = 0x%04X%04X", m_pClientList[iClientH]->m_wSignature1, m_pClientList[iClientH]->m_wSignature2);
	strcat(pData, cTxt);  // Store Hacking detection data (not read)
	strcat(pData,"\n");
	wsprintf(cTxt, "known-gold            = %d", m_pClientList[iClientH]->m_KnownPreviousGold);
	strcat(pData, cTxt);  //  // known-gold = m_KnownPreviousGold
	strcat(pData,"\n\n\n");

	strcat(pData, "appr1 = ");
	itoa( m_pClientList[iClientH]->m_sAppr1, cTxt, 10);
	strcat(pData, cTxt);
	strcat(pData, "\n");
	strcat(pData, "appr2 = ");
	//m_pClientList[iClientH]->m_sAppr2 = m_pClientList[iClientH]->m_sAppr2 & 0x0FFF;
	itoa( m_pClientList[iClientH]->m_sAppr2, cTxt, 10);
	strcat(pData, cTxt);
	strcat(pData, "\n");
	strcat(pData, "appr3 = ");
	itoa( m_pClientList[iClientH]->m_sAppr3, cTxt, 10);
	strcat(pData, cTxt);
	strcat(pData, "\n");
	strcat(pData, "appr4 = ");
	itoa( m_pClientList[iClientH]->m_sAppr4, cTxt, 10);
	strcat(pData, cTxt);
	strcat(pData, "\n");
	// v1.4 ApprColor
	strcat(pData, "appr-color = ");
	itoa( m_pClientList[iClientH]->m_iApprColor, cTxt, 10);
	strcat(pData, cTxt);
	strcat(pData, "\n\n");
	strcat(pData, "[ITEMLIST]\n\n");

	for (i = 0; i < DEF_MAXITEMS; i++)
	{	TempItemPosList[i].x = 40;
		TempItemPosList[i].y = 30;
	}
	iPos = 0;
	for (i = 0; i < DEF_MAXITEMS; i++)
	if (m_pClientList[iClientH]->m_pItemList[i] != NULL) 
	{	TempItemPosList[iPos].x = m_pClientList[iClientH]->m_ItemPosList[i].x;
		TempItemPosList[iPos].y = m_pClientList[iClientH]->m_ItemPosList[i].y;
		iPos++;		
		strcat(pData, "character-item = ");
		memset(cTmp, ' ', 21);
		strcpy(cTmp, m_pClientList[iClientH]->m_pItemList[i]->m_cName);
		cTmp[strlen(m_pClientList[iClientH]->m_pItemList[i]->m_cName)] = (char)' ';
		cTmp[20] = NULL;
		strcat(pData, cTmp);
		strcat(pData, " ");
		itoa( m_pClientList[iClientH]->m_pItemList[i]->m_dwCount, cTxt, 10);
		strcat(pData, cTxt);
		strcat(pData, " ");
		itoa( m_pClientList[iClientH]->m_pItemList[i]->m_sTouchEffectType, cTxt, 10);
		strcat(pData, cTxt);
		strcat(pData, " ");
		itoa( m_pClientList[iClientH]->m_pItemList[i]->m_sTouchEffectValue1, cTxt, 10);
		strcat(pData, cTxt);
		strcat(pData, " ");
		itoa( m_pClientList[iClientH]->m_pItemList[i]->m_sTouchEffectValue2, cTxt, 10);
		strcat(pData, cTxt);
		strcat(pData, " ");
		itoa( m_pClientList[iClientH]->m_pItemList[i]->m_sTouchEffectValue3, cTxt, 10);
		strcat(pData, cTxt);
		strcat(pData, " ");
		itoa( m_pClientList[iClientH]->m_pItemList[i]->m_cItemColor, cTxt, 10);
		strcat(pData, cTxt);
		strcat(pData, " ");
		itoa( m_pClientList[iClientH]->m_pItemList[i]->m_sItemSpecEffectValue1, cTxt, 10);
		strcat(pData, cTxt);
		strcat(pData, " ");
		itoa( m_pClientList[iClientH]->m_pItemList[i]->m_sItemSpecEffectValue2, cTxt, 10);
		strcat(pData, cTxt);
		strcat(pData, " ");
		itoa( m_pClientList[iClientH]->m_pItemList[i]->m_sItemSpecEffectValue3, cTxt, 10);
		strcat(pData, cTxt);
		strcat(pData, " ");
		itoa( m_pClientList[iClientH]->m_pItemList[i]->m_wCurLifeSpan, cTxt, 10);
		strcat(pData, cTxt);
		strcat(pData, " ");
		// Don't safe modifyed attribute , sending gizoned to my client to show next gizoning cost
		dwTemp = m_pClientList[iClientH]->m_pItemList[i]->m_dwAttribute;
		dwTemp = dwTemp & 0xF0FFFFFF; 
		itoa( dwTemp, cTxt, 10);
		//itoa( m_pClientList[iClientH]->m_pItemList[i]->m_dwAttribute, cTxt, 10);
		strcat(pData, cTxt);
		strcat(pData, "\n");
	}
	strcat(pData, "\n\n");
	for (i = 0; i < DEF_MAXITEMS; i++) 
	{	m_pClientList[iClientH]->m_ItemPosList[i].x = TempItemPosList[i].x; 
		m_pClientList[iClientH]->m_ItemPosList[i].y = TempItemPosList[i].y;
	}

	for (i = 0; i < DEF_MAXBANKITEMS; i++)
	if (m_pClientList[iClientH]->m_pItemInBankList[i] != NULL) 
	{	strcat(pData, "character-bank-item = ");
		memset(cTmp, ' ', 21);
		strcpy(cTmp, m_pClientList[iClientH]->m_pItemInBankList[i]->m_cName);
		cTmp[strlen(m_pClientList[iClientH]->m_pItemInBankList[i]->m_cName)] = (char)' ';
		cTmp[20] = NULL;
		strcat(pData, cTmp);
		strcat(pData, " ");
		itoa( m_pClientList[iClientH]->m_pItemInBankList[i]->m_dwCount, cTxt, 10);
		strcat(pData, cTxt);
		strcat(pData, " ");
		itoa( m_pClientList[iClientH]->m_pItemInBankList[i]->m_sTouchEffectType, cTxt, 10);
		strcat(pData, cTxt);
		strcat(pData, " ");
		itoa( m_pClientList[iClientH]->m_pItemInBankList[i]->m_sTouchEffectValue1, cTxt, 10);
		strcat(pData, cTxt);
		strcat(pData, " ");
		itoa( m_pClientList[iClientH]->m_pItemInBankList[i]->m_sTouchEffectValue2, cTxt, 10);
		strcat(pData, cTxt);
		strcat(pData, " ");
		itoa( m_pClientList[iClientH]->m_pItemInBankList[i]->m_sTouchEffectValue3, cTxt, 10);
		strcat(pData, cTxt);
		strcat(pData, " ");
		itoa( m_pClientList[iClientH]->m_pItemInBankList[i]->m_cItemColor, cTxt, 10);
		strcat(pData, cTxt);
		strcat(pData, " ");
		itoa( m_pClientList[iClientH]->m_pItemInBankList[i]->m_sItemSpecEffectValue1, cTxt, 10);
		strcat(pData, cTxt);
		strcat(pData, " ");
		itoa( m_pClientList[iClientH]->m_pItemInBankList[i]->m_sItemSpecEffectValue2, cTxt, 10);
		strcat(pData, cTxt);
		strcat(pData, " ");
		itoa( m_pClientList[iClientH]->m_pItemInBankList[i]->m_sItemSpecEffectValue3, cTxt, 10);
		strcat(pData, cTxt);
		strcat(pData, " ");
		itoa( m_pClientList[iClientH]->m_pItemInBankList[i]->m_wCurLifeSpan, cTxt, 10);
		strcat(pData, cTxt);
		strcat(pData, " ");
		// Don't safe modifyed attribute , sending gizoned to my client to show next gizoning cost
		dwTemp = m_pClientList[iClientH]->m_pItemInBankList[i]->m_dwAttribute;
		dwTemp = dwTemp & 0xF0FFFFFF; 
		itoa( dwTemp, cTxt, 10);
		//itoa( m_pClientList[iClientH]->m_pItemInBankList[i]->m_dwAttribute, cTxt, 10);
		strcat(pData, cTxt);
		strcat(pData, "\n");
	}
	strcat(pData, "\n\n");	
	strcat(pData, "[MAGIC-SKILL-MASTERY]\n");
	strcat(pData, "//------------------012345678901234567890123456789012345678901234567890");
	strcat(pData,"\n");
	strcat(pData, "magic-mastery     = ");
	for (i = 0; i < DEF_MAXMAGICTYPE; i++) {
		wsprintf(cTxt,"%d", (int)m_pClientList[iClientH]->m_cMagicMastery[i]);
		strcat(pData, cTxt);
	}
	strcat(pData, "\n");	
	strcat(pData, "skill-mastery     = ");			
	
	for (i = 0; i < 60; i++) {
		ZeroMemory(cTxt, sizeof(cTxt));
		wsprintf(cTxt, "%d ", m_pClientList[iClientH]->m_cSkillMastery[i]);
		strcat(pData, cTxt); 
	}
	strcat(pData,"\n");			
	strcat(pData, "skill-SSN     = ");
	for (i = 0; i < 60; i++) {
		ZeroMemory(cTxt, sizeof(cTxt));
		wsprintf(cTxt, "%d ", m_pClientList[iClientH]->m_iSkillSSN[i]);
		strcat(pData, cTxt);
	}
	strcat(pData,"\n\n");	
	strcat(pData, "[ITEM-EQUIP-STATUS]\n");
	strcat(pData, "item-equip-status = ");	
	ZeroMemory(cTxt, sizeof(cTxt));
	strcpy(cTxt, "00000000000000000000000000000000000000000000000000");
	              
	int iEP = 0;
	for (i = 0; i < DEF_MAXITEMS; i++) 
	if (m_pClientList[iClientH]->m_pItemList[i] != NULL) 
	{	if (   (m_pClientList[iClientH]->m_bIsItemEquipped[i] == TRUE) 
			&& (m_pClientList[iClientH]->m_pItemList[i]->m_cItemType == DEF_ITEMTYPE_EQUIP)) 
		{	 cTxt[iEP] = '1';
		}
		iEP++;
	}
	strcat(pData, cTxt);
	strcat(pData, "\n");	
	strcat(pData, "item-position-x = ");
	for (i = 0; i < DEF_MAXITEMS; i++) 
	{	ZeroMemory(cTxt, sizeof(cTxt));
		wsprintf(cTxt, "%d ", m_pClientList[iClientH]->m_ItemPosList[i].x);
		strcat(pData, cTxt);
	}
	strcat(pData, "\n");	
	strcat(pData, "item-position-y = ");
	for (i = 0; i < DEF_MAXITEMS; i++) 
	{	ZeroMemory(cTxt, sizeof(cTxt));
		wsprintf(cTxt, "%d ", m_pClientList[iClientH]->m_ItemPosList[i].y);
		strcat(pData, cTxt);
	}
	strcat(pData, "\n\n");	
	strcat(pData, "[EOF]");
	strcat(pData, "\n\n\n\n");
	return strlen(pData);
}

BOOL CGame::_bDecodeItemConfigFileContents(char * pData, DWORD dwMsgSize)
{
 char * pContents, * token, cTxt[120];
 char seps[] = "= \t\n";
 char cReadModeA = 0;
 char cReadModeB = 0;
 int  iItemConfigListIndex, iTemp;
 class CStrTok * pStrTok;

	pContents = new char[dwMsgSize+1];
	ZeroMemory(pContents, dwMsgSize+1);
	memcpy(pContents, pData, dwMsgSize);

	pStrTok = new class CStrTok(pContents, seps);
	token = pStrTok->pGet();
	//token = strtok( pContents, seps );   
	while( token != NULL ) {
		if (cReadModeA != 0) {
			switch (cReadModeA) {
			case 1:
				switch (cReadModeB) {
				case 1:
					if (_bGetIsStringIsNumber(token) == FALSE) 
					{	PutLogList("(!!!) CRITICAL ERROR! ITEM configuration file error - ItemIDnumber");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					iItemConfigListIndex = atoi(token);	
					if (m_pItemConfigList[iItemConfigListIndex] != NULL) 
					{	wsprintf(cTxt, "(!!!) CRITICAL ERROR! Duplicate ItemIDnum(%d)", iItemConfigListIndex);
						PutLogList(cTxt);
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pItemConfigList[iItemConfigListIndex] = new class CItem;
					m_pItemConfigList[iItemConfigListIndex]->m_sIDnum = iItemConfigListIndex;
					cReadModeB = 2;
					break;
				case 2: // m_cName 
					ZeroMemory(m_pItemConfigList[iItemConfigListIndex]->m_cName, sizeof(m_pItemConfigList[iItemConfigListIndex]->m_cName));
					memcpy(m_pItemConfigList[iItemConfigListIndex]->m_cName, token, strlen(token));
					cReadModeB = 3;
					break;
				case 3: // m_cItemType
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! ITEM configuration file error - ItemType");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pItemConfigList[iItemConfigListIndex]->m_cItemType = atoi(token);
					cReadModeB = 4;
					break;
				case 4: // m_cEquipPos
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! ITEM configuration file error - EquipPos");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pItemConfigList[iItemConfigListIndex]->m_cEquipPos = atoi(token);
					cReadModeB = 5;
					break;
				case 5: // m_sItemEffectType
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! ITEM configuration file error - ItemEffectType");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pItemConfigList[iItemConfigListIndex]->m_sItemEffectType = atoi(token);
					cReadModeB = 6;
					break;
				case 6: // m_sItemEffectValue1
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! ITEM configuration file error - ItemEffectValue1");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pItemConfigList[iItemConfigListIndex]->m_sItemEffectValue1 = atoi(token);
					cReadModeB = 7;
					break;
				case 7: // m_sItemEffectValue2
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! ITEM configuration file error - ItemEffectValue2");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pItemConfigList[iItemConfigListIndex]->m_sItemEffectValue2 = atoi(token);
					cReadModeB = 8;
					break;
				case 8: // m_sItemEffectValue3
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! ITEM configuration file error - ItemEffectValue3");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pItemConfigList[iItemConfigListIndex]->m_sItemEffectValue3 = atoi(token);
					cReadModeB = 9;
					break;
				case 9: // m_sItemEffectValue4
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! ITEM configuration file error - ItemEffectValue4");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pItemConfigList[iItemConfigListIndex]->m_sItemEffectValue4 = atoi(token);
					cReadModeB = 10;
					break;
				case 10: // m_sItemEffectValue5
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! ITEM configuration file error - ItemEffectValue5");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pItemConfigList[iItemConfigListIndex]->m_sItemEffectValue5 = atoi(token);
					cReadModeB = 11;
					break;
				case 11: // m_sItemEffectValue6
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! ITEM configuration file error - ItemEffectValue6");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pItemConfigList[iItemConfigListIndex]->m_sItemEffectValue6 = atoi(token);
					cReadModeB = 12;
					break;
				case 12: // m_wMaxLifeSpan
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! ITEM configuration file error - MaxLifeSpan");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pItemConfigList[iItemConfigListIndex]->m_wMaxLifeSpan = (WORD)atoi(token);
					// WORD is unsigned, so negative values should have no effect
					cReadModeB = 13;
					break;
				case 13: // m_sSpecialEffect
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! ITEM configuration file error - MaxFixCount");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pItemConfigList[iItemConfigListIndex]->m_sSpecialEffect = atoi(token);
					cReadModeB = 14;
					break;
				case 14: // m_sSprite
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! ITEM configuration file error - Sprite");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pItemConfigList[iItemConfigListIndex]->m_sSprite = atoi(token);
					cReadModeB = 15;
					break;
				case 15: // m_sSpriteFrame
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! ITEM configuration file error - SpriteFrame");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pItemConfigList[iItemConfigListIndex]->m_sSpriteFrame = atoi(token);
					cReadModeB = 16;
					break;
				case 16: // m_wPrice
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! ITEM configuration file error - Price");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					iTemp = atoi(token);
					if (iTemp < 0) 
						 m_pItemConfigList[iItemConfigListIndex]->m_bIsForSale = FALSE;
					else m_pItemConfigList[iItemConfigListIndex]->m_bIsForSale = TRUE;
					
					m_pItemConfigList[iItemConfigListIndex]->m_wPrice = abs(iTemp);
					cReadModeB = 17;
					break;
				case 17: // m_wWeight
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! ITEM configuration file error - Weight");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pItemConfigList[iItemConfigListIndex]->m_wWeight = atoi(token);
					cReadModeB = 18;
					break;
				case 18: // Appr Value
					if (_bGetIsStringIsNumber(token) == FALSE) 
					{	PutLogList("(!!!) CRITICAL ERROR! ITEM configuration file error - ApprValue");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pItemConfigList[iItemConfigListIndex]->m_cApprValue = atoi(token);
					cReadModeB = 19;
					break;
				case 19: // m_cSpeed
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! ITEM configuration file error - Speed");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pItemConfigList[iItemConfigListIndex]->m_cSpeed = atoi(token);
					cReadModeB = 20;
					break;

				case 20: // m_sLevelLimit
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! ITEM configuration file error - LevelLimit");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pItemConfigList[iItemConfigListIndex]->m_sLevelLimit = atoi(token);
					cReadModeB = 21;
					break;

				case 21: // m_cGederLimit
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! ITEM configuration file error - GenderLimit");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pItemConfigList[iItemConfigListIndex]->m_cGenderLimit = atoi(token);
					cReadModeB = 22;
					break;
				
				case 22: // m_sSpecialEffectValue1
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! ITEM configuration file error - SM_HitRatio");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pItemConfigList[iItemConfigListIndex]->m_sSpecialEffectValue1 = atoi(token);
					cReadModeB = 23;
					break;

				case 23: // m_sSpecialEffectValue2
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! ITEM configuration file error - L_HitRatio");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pItemConfigList[iItemConfigListIndex]->m_sSpecialEffectValue2 = atoi(token);
					cReadModeB = 24;
					break;

				case 24: // m_sRelatedSkill
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! ITEM configuration file error - RelatedSkill");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pItemConfigList[iItemConfigListIndex]->m_sRelatedSkill = atoi(token);
					cReadModeB = 25;
					break;

				case 25: // m_cCategory
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! ITEM configuration file error - Category");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pItemConfigList[iItemConfigListIndex]->m_cCategory = atoi(token);
					cReadModeB = 26;
					break;

				case 26: // m_cItemColor
					if (_bGetIsStringIsNumber(token) == FALSE) 
					{	PutLogList("(!!!) CRITICAL ERROR! ITEM configuration file error - Category");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pItemConfigList[iItemConfigListIndex]->m_cItemColor = atoi(token);
					cReadModeA = 0;
					cReadModeB = 0;
					break;
				}
				break;
			default: 
				break;
			}
		}else 
		{	if (memcmp(token, "Item", 4) == 0) 
			{	cReadModeA = 1;
				cReadModeB = 1;
			}			
			if (memcmp(token, "[ENDITEMLIST]", 13) == 0) 
			{	cReadModeA = 0;
				cReadModeB = 0;
				goto DICFC_STOPDECODING;
			}
		}
		token = pStrTok->pGet();
	}	
DICFC_STOPDECODING:;
	delete pStrTok;
	delete pContents;
	if ((cReadModeA != 0) || (cReadModeB != 0)) {
		PutLogList("(!!!) CRITICAL ERROR! ITEM configuration file contents error!");
		return FALSE;
	}
	wsprintf(cTxt, "(!) ITEM (Total:%d) configuration - success!", iItemConfigListIndex);
	PutLogList(cTxt);
	return TRUE;
}


BOOL CGame::_bGetIsStringIsNumber(char * pStr)
{int i;
	for (i = 0; i < (int)strlen(pStr); i++)
	if ((pStr[i] != '-') && ((pStr[i] < (char)'0') || (pStr[i] > (char)'9'))) return FALSE;	
	return TRUE;
}

BOOL CGame::_bReadMapInfoFiles(int iMapIndex)
{	if (__bReadMapInfo(iMapIndex) == FALSE) { return FALSE; }
	return TRUE;
}


int CGame::bCreateNewNpc(char * pNpcName, char * pName, char * pMapName, short sClass, char cSA, char cMoveType, int * poX, int * poY, char * pWaypointList, RECT * pArea, int iSpotMobIndex, char cChangeSide, BOOL bHideGenMode, BOOL bIsSummoned, BOOL bFirmBerserk, BOOL bIsMaster, int iGuildGUID)
{register int i, t, j, k, iMapIndex;
 char  cTmpName[11], cTxt[120];
 short sX, sY, sRange;
 BOOL  bFlag;
 SYSTEMTIME SysTime;
	if (strlen(pName) == 0)   return FALSE;
	if (strlen(pNpcName) == 0) return FALSE;
	GetLocalTime(&SysTime);
	ZeroMemory(cTmpName, sizeof(cTmpName));
	strcpy(cTmpName, pMapName);
	iMapIndex = -1;
	for (i = 0; i < DEF_MAXMAPS; i++)
	if (m_pMapList[i] != NULL) {
		if (memcmp(m_pMapList[i]->m_cName, cTmpName, 10) == 0) 
			iMapIndex = i;
	}	
	if (iMapIndex == -1) return FALSE;	
	for (i = 1; i < DEF_MAXNPCS; i++)
	if (m_pNpcList[i] == NULL) {
		m_pNpcList[i] = new class CNpc(pName);
		if (_bInitNpcAttr(m_pNpcList[i], pNpcName, sClass, cSA) == FALSE) 
		{	wsprintf(cTxt, "(!) Not existing NPC creation request! (%s) Ignored.", pNpcName);
			PutLogList(cTxt);			
			delete m_pNpcList[i];
			m_pNpcList[i] = NULL;
			return FALSE;	
		}
		if (m_pNpcList[i]->m_cDayOfWeekLimit < 10) 
		{	if (m_pNpcList[i]->m_cDayOfWeekLimit != SysTime.wDayOfWeek)	
			{	delete m_pNpcList[i];
				m_pNpcList[i] = NULL;
				return FALSE;			
		}	}
		switch (cMoveType) {
		case DEF_MOVETYPE_GUARD:
		case DEF_MOVETYPE_RANDOM:
			if ( (poX != NULL) && (poY != NULL) && (*poX != NULL) && (*poY != NULL) ) 
			{	sX = *poX;
				sY = *poY;
			}else 
			{	for ( j = 0; j <= 30; j++) {
					// SNOOPY: Why -15 ?
					//sX = (rand() % (m_pMapList[iMapIndex]->m_sSizeX - 50)) + 15;
					//sY = (rand() % (m_pMapList[iMapIndex]->m_sSizeY - 50)) + 15;
					sX = (rand() % (m_pMapList[iMapIndex]->m_sSizeX - 50)) + 25;
					sY = (rand() % (m_pMapList[iMapIndex]->m_sSizeY - 50)) + 25;

					bFlag = TRUE;
					for (k = 0; k < DEF_MAXMGAR; k++)
					if (m_pMapList[iMapIndex]->m_rcMobGenAvoidRect[k].left != -1) 
					{	if ((sX >= m_pMapList[iMapIndex]->m_rcMobGenAvoidRect[k].left) &&
							(sX <= m_pMapList[iMapIndex]->m_rcMobGenAvoidRect[k].right) &&
							(sY >= m_pMapList[iMapIndex]->m_rcMobGenAvoidRect[k].top) &&
							(sY <= m_pMapList[iMapIndex]->m_rcMobGenAvoidRect[k].bottom)) 
						{	// Avoid Rect
							bFlag = FALSE;
						}
					}
					// SNOOPY: Added condition for accessible map place.
					// Secondary possible effect: Less spawns in small corridors ?
					if ( (m_pMapList[iMapIndex]->bGetMoveable(sX, sY)   == FALSE) ||
						 (m_pMapList[iMapIndex]->bGetIsTeleport(sX, sY) == TRUE) ) 
					{	bFlag = FALSE; // Not accessible place
					}
					if (bFlag == TRUE) goto GET_VALIDLOC_SUCCESS;
				}
				delete m_pNpcList[i];
				m_pNpcList[i] = NULL;
				return FALSE;

GET_VALIDLOC_SUCCESS:;
			}
			break;

		case DEF_MOVETYPE_RANDOMAREA:
			sRange = (short)(pArea->right - pArea->left);
			if (sRange <=0) sRange = 1; // Snoopy antibug
			sX     = (short)((rand() % sRange) + pArea->left);
			sRange = (short)(pArea->bottom - pArea->top);
			if (sRange <=0) sRange = 1; // Snoopy antibug
			sY     = (short)((rand() % sRange) + pArea->top);
			break;

		case DEF_MOVETYPE_RANDOMWAYPOINT:
			sX = (short)m_pMapList[iMapIndex]->m_WaypointList[pWaypointList[iDice(1,10) - 1]].x;
			sY = (short)m_pMapList[iMapIndex]->m_WaypointList[pWaypointList[iDice(1,10) - 1]].y;
			break;

		default:
			if ( (poX != NULL) && (poY != NULL) && (*poX != NULL) && (*poY != NULL) ) 
			{	sX = *poX;
				sY = *poY;
			}else 
			{	sX = (short)m_pMapList[iMapIndex]->m_WaypointList[pWaypointList[0]].x;
				sY = (short)m_pMapList[iMapIndex]->m_WaypointList[pWaypointList[0]].y;
			}
			break;
		}		
		if (bGetEmptyPosition(&sX, &sY, iMapIndex) == FALSE) 			
		{	delete m_pNpcList[i];
			m_pNpcList[i] = NULL;
			return FALSE;
		}
		if ( (bHideGenMode == TRUE) && (_iGetPlayerNumberOnSpot(sX, sY, iMapIndex, 7) != 0) ) 
		{	delete m_pNpcList[i];
			m_pNpcList[i] = NULL;
			return FALSE;	
		}
		if ((poX != NULL) && (poY != NULL)) 
		{	*poX = sX;
			*poY = sY;
		}
		m_pNpcList[i]->m_sX = sX;
		m_pNpcList[i]->m_sY = sY;		
		m_pNpcList[i]->m_vX = sX;
		m_pNpcList[i]->m_vY = sY;
		// WaypointIndex
		for (t = 0; t < 10; t++)
			m_pNpcList[i]->m_iWayPointIndex[t] = pWaypointList[t];
		m_pNpcList[i]->m_cTotalWaypoint = 0;
		for (t = 0; t < 10; t++)
		if (m_pNpcList[i]->m_iWayPointIndex[t] != -1) m_pNpcList[i]->m_cTotalWaypoint++;
		if (pArea != NULL) // RANDOMAREA Copy
		{	SetRect(&m_pNpcList[i]->m_rcRandomArea, pArea->left, pArea->top, pArea->right, pArea->bottom);
		}
		switch (cMoveType) {
		case DEF_MOVETYPE_GUARD:
			m_pNpcList[i]->m_dX = m_pNpcList[i]->m_sX;
			m_pNpcList[i]->m_dY = m_pNpcList[i]->m_sY;
			break;		
		case DEF_MOVETYPE_SEQWAYPOINT: 
			m_pNpcList[i]->m_cCurWaypoint = 1;			
			m_pNpcList[i]->m_dX  = (short)m_pMapList[iMapIndex]->m_WaypointList[ m_pNpcList[i]->m_iWayPointIndex[ m_pNpcList[i]->m_cCurWaypoint ] ].x;
			m_pNpcList[i]->m_dY  = (short)m_pMapList[iMapIndex]->m_WaypointList[ m_pNpcList[i]->m_iWayPointIndex[ m_pNpcList[i]->m_cCurWaypoint ] ].y;
			break;
		case DEF_MOVETYPE_RANDOMWAYPOINT:
			m_pNpcList[i]->m_cCurWaypoint = (rand() % (m_pNpcList[i]->m_cTotalWaypoint - 1)) + 1;			
			m_pNpcList[i]->m_dX  = (short)m_pMapList[iMapIndex]->m_WaypointList[ m_pNpcList[i]->m_iWayPointIndex[ m_pNpcList[i]->m_cCurWaypoint ] ].x;
			m_pNpcList[i]->m_dY  = (short)m_pMapList[iMapIndex]->m_WaypointList[ m_pNpcList[i]->m_iWayPointIndex[ m_pNpcList[i]->m_cCurWaypoint ] ].y;
			break;
		case DEF_MOVETYPE_RANDOMAREA:
			m_pNpcList[i]->m_cCurWaypoint = 0;			
			sRange = (short)(m_pNpcList[i]->m_rcRandomArea.right - m_pNpcList[i]->m_rcRandomArea.left);
			m_pNpcList[i]->m_dX = (short)((rand() % sRange) + m_pNpcList[i]->m_rcRandomArea.left);
			sRange = (short)(m_pNpcList[i]->m_rcRandomArea.bottom - m_pNpcList[i]->m_rcRandomArea.top);
			m_pNpcList[i]->m_dY = (short)((rand() % sRange) + m_pNpcList[i]->m_rcRandomArea.top);
			break;
		case DEF_MOVETYPE_RANDOM:
			m_pNpcList[i]->m_dX = (short)((rand() % (m_pMapList[iMapIndex]->m_sSizeX - 50)) + 15);
			m_pNpcList[i]->m_dY = (short)((rand() % (m_pMapList[iMapIndex]->m_sSizeY - 50)) + 15);
			break;
		}
		m_pNpcList[i]->m_tmp_iError = 0;
		m_pNpcList[i]->m_cMoveType = cMoveType;
		switch (m_pNpcList[i]->m_cActionLimit) {
		case 2: // fixed mechants
		case 3: // dummy
		case 5: // struct sade, crops
			m_pNpcList[i]->m_cBehavior = DEF_BEHAVIOR_STOP;			
			switch (m_pNpcList[i]->m_sType) {
			case 15: // ShopKeeper-W
			case 19: // Gandlf
			case 20: // Howard
			case 24: // Tom
			case 25: // William
			case 26: // Kennedy
				m_pNpcList[i]->m_cDir      = 3 + iDice(1,3);
				break;
			default:
				m_pNpcList[i]->m_cDir      = iDice(1,8);
				break;
			}
			break;
		case 8: // Heldenian gate
			m_pNpcList[i]->m_cDir      = 3;
			m_pNpcList[i]->m_cBehavior = DEF_BEHAVIOR_STOP;	
			if (m_pNpcList[i]->m_cArea > 0)
			{	for(short sx1 = (sX - 1); sx1 <= sX + 1; sx1++)
				for(short sy1 = (sY - 1); sy1 <= sY + 1; sy1++)
				{	m_pMapList[iMapIndex]->SetTempMoveAllowedFlag(sx1, sy1, FALSE);		
			}	}
			break;

		default: 
			m_pNpcList[i]->m_cBehavior = DEF_BEHAVIOR_MOVE;
			m_pNpcList[i]->m_cDir      = 5;
			break;
		}
		m_pNpcList[i]->m_iFollowOwnerIndex	= NULL;
		ZeroMemory(m_pNpcList[i]->m_cFollowOwnerCharName,sizeof(m_pNpcList[i]->m_cFollowOwnerCharName));
		m_pNpcList[i]->m_iTargetIndex	    = NULL;
		m_pNpcList[i]->m_cTurn              = (rand() % 2);		
		switch (m_pNpcList[i]->m_sType) {
		case 1:
		case 2:
		case 3:
		case 4:
		case 5:
		case 6:
			// Criminal & mercenaries.
			m_pNpcList[i]->m_sAppr2 = (short) 0xF000;
			m_pNpcList[i]->m_sAppr2 = m_pNpcList[i]->m_sAppr2 | ((rand() % 13) << 4);
			m_pNpcList[i]->m_sAppr2 = m_pNpcList[i]->m_sAppr2 | (rand() % 9);
			break;
		case 36: // AGT-Aresden/AGT-Elvine
		case 37: // CGT-Aresden/CGT-Elvine
		case 38: // MS-Aresden/MS-Elvine
		case 39: // DT-Aresden/DT-Elvine
			m_pNpcList[i]->m_sAppr2 = 3;
			break;
		case 64: // Crop
			m_pNpcList[i]->m_sAppr2 = 1; // 1 bud; 2 grown; 3 large 
			break;
		default:
			m_pNpcList[i]->m_sAppr2 = 0;
			break;
		}		
		m_pNpcList[i]->m_cMapIndex          = (char)iMapIndex;
		m_pNpcList[i]->m_dwTime             = timeGetTime() + (rand() % 10000);
		m_pNpcList[i]->m_dwActionTime      += (rand() % 300);
		m_pNpcList[i]->m_dwMPupTime			= timeGetTime();
		m_pNpcList[i]->m_dwHPupTime			= m_pNpcList[i]->m_dwMPupTime;
		m_pNpcList[i]->m_sBehaviorTurnCount	= 0;
		m_pNpcList[i]->m_bIsSummoned        = bIsSummoned;
		m_pNpcList[i]->m_bIsMaster          = bIsMaster;
		if (bIsSummoned == TRUE) 
		{	m_pNpcList[i]->m_dwSummonedTime = timeGetTime();	
			m_pNpcList[i]->m_dwSummonWaitTime = 0;	
		}
		if (bFirmBerserk == TRUE) 
		{	m_pNpcList[i]->m_cMagicEffectStatus[DEF_MAGICTYPE_BERSERK] = 10; // SNOOPY: 10 = +100% dmg <=> normal zerk
			m_pNpcList[i]->m_iStatus = m_pNpcList[i]->m_iStatus | 0x20;
			//Berserk
			//iExpRoll = iDice(m_pNpcList[i]->m_iExpDiceMin, m_pNpcList[i]->m_iExpDiceMax);
			//iExpRoll *= 2;
		}
		if (cChangeSide != -1) m_pNpcList[i]->m_cSide = cChangeSide;
		m_pNpcList[i]->m_iSpotMobIndex		= iSpotMobIndex;
		m_pNpcList[i]->m_iGuildGUID         = iGuildGUID;
		//testcode
		/*if (iGuildGUID != 0) 
		{	wsprintf(G_cTxt, "Summon War Unit(%d) GUID(%d)", m_pNpcList[i]->m_sType, iGuildGUID);
			PutLogList(G_cTxt);
		}*/		
		if (   (m_bIsHeldenianMode == TRUE) // If any mob created as Helnian war not started,, ensure it's Neutral...
			&& (m_bHeldenianWarInitiated == FALSE)
			&& (m_pMapList[iMapIndex]->m_bIsHeldenianMap == TRUE)
			&& (m_pNpcList[i]->m_cSide > 2))
		{	m_pNpcList[i]->m_cOriginalSide = m_pNpcList[i]->m_cSide;
			m_pNpcList[i]->m_cSide = 0;
		}
		m_pMapList[iMapIndex]->SetOwner(i, DEF_OWNERTYPE_NPC, sX, sY);
		m_pMapList[iMapIndex]->m_iTotalActiveObject++;
		switch (m_pNpcList[i]->m_sType) {
		case 36: // AGT-Aresden/AGT-Elvine
		case 37: // CGT-Aresden/CGT-Elvine
		case 38: // MS-Aresden/MS-Elvine
		case 39: // DT-Aresden/DT-Elvine
		case 42: // ManaStone
			m_pMapList[iMapIndex]->bAddCrusadeStructureInfo(m_pNpcList[i]->m_sType, sX, sY, m_pNpcList[i]->m_cSide);
			break;
		case 64:
			m_pMapList[iMapIndex]->bAddCropsTotalSum();
			break;
		}		
		SendEventToNearClient_TypeA(i, DEF_OWNERTYPE_NPC, MSGID_EVENT_LOG, DEF_MSGTYPE_CONFIRM, NULL, NULL, NULL);
		return TRUE;
	}
	return FALSE;
}

void CGame::NpcProcess()
{register int i, iMaxHP;
 DWORD dwTime, dwActionTime;
 // SNOOPY: Poisonned npcs
 int iHPup = 0;
	dwTime = timeGetTime();
	for (i = 1; i < DEF_MAXNPCS; i++) 
	{ 	if (m_pNpcList[i] != NULL) 
		{	if (m_pNpcList[i]->m_cBehavior == DEF_BEHAVIOR_ATTACK) 
			{	switch (iDice(1,7)) {
				case 1: dwActionTime = m_pNpcList[i]->m_dwActionTime; break;
				case 2: dwActionTime = m_pNpcList[i]->m_dwActionTime - 100; break;
				case 3: dwActionTime = m_pNpcList[i]->m_dwActionTime - 200; break;
				case 4: dwActionTime = m_pNpcList[i]->m_dwActionTime - 300; break;
				case 5: dwActionTime = m_pNpcList[i]->m_dwActionTime - 400; break;
				case 6: dwActionTime = m_pNpcList[i]->m_dwActionTime - 600; break;
				case 7: dwActionTime = m_pNpcList[i]->m_dwActionTime - 700; break;
				}
				if (dwActionTime < 600) dwActionTime = 600;
			}else dwActionTime = m_pNpcList[i]->m_dwActionTime; 
			if (m_pNpcList[i]->m_cMagicEffectStatus[ DEF_MAGICTYPE_ICE ] >= 1) 
			{	dwActionTime += (dwActionTime/2);
				if (m_pNpcList[i]->m_cMagicEffectStatus[ DEF_MAGICTYPE_ICE ] >= 2) 
					dwActionTime += (dwActionTime/2);
			}
			// Snoopy: Added safety here
			if (m_pNpcList[i]->m_iHP <= 0) m_pNpcList[i]->m_cBehavior = DEF_BEHAVIOR_DEAD;
		}
		//SNOOPY Added here for ending Taming
		if (   (m_pNpcList[i] != NULL) 
			&& (m_pNpcList[i]->m_dwTamingTime != 0)
			&& (m_pNpcList[i]->m_cOriginalSide != m_pNpcList[i]->m_cSide)
			&& (dwTime > m_pNpcList[i]->m_dwTamingTime)) 
		{	m_pNpcList[i]->m_cSide = m_pNpcList[i]->m_cOriginalSide;
			m_pNpcList[i]->m_dwTamingTime = 0;
			m_pNpcList[i]->m_cMoveType = DEF_MOVETYPE_RANDOMWAYPOINT;
			SendEventToNearClient_TypeA(i, DEF_OWNERTYPE_NPC, MSGID_EVENT_MOTION, DEF_OBJECTNULLACTION, NULL, NULL, NULL);		
		}

		if ((m_pNpcList[i] != NULL) && ((dwTime - m_pNpcList[i]->m_dwTime) > dwActionTime)) 
		{	m_pNpcList[i]->m_dwTime = dwTime;			
			if (abs(m_pNpcList[i]->m_cMagicLevel) > 0) 
			{	if ((dwTime - m_pNpcList[i]->m_dwMPupTime) > DEF_MPUPTIME) 
				{	m_pNpcList[i]->m_dwMPupTime = dwTime;	
					if (m_pNpcList[i]->m_bIsSummoned == FALSE)
					{	m_pNpcList[i]->m_iMana += iDice(1, (m_pNpcList[i]->m_iMaxMana/5));	
					}else if ( (m_bHeldenianWarInitiated == TRUE) // Heldenians soldiers can regen mana
							&& (m_pMapList[m_pNpcList[i]->m_cMapIndex]->m_bIsHeldenianMap == TRUE))
					{	m_pNpcList[i]->m_iMana += iDice(1, (m_pNpcList[i]->m_iMaxMana/5));						
					}					
					if (m_pNpcList[i]->m_iMana > m_pNpcList[i]->m_iMaxMana)
						m_pNpcList[i]->m_iMana = m_pNpcList[i]->m_iMaxMana;
			}	}			
			// HP up
			if (((dwTime - m_pNpcList[i]->m_dwHPupTime) > DEF_HPUPTIME) && (m_pNpcList[i]->m_bIsKilled == FALSE)) 
			{	m_pNpcList[i]->m_dwHPupTime = dwTime;					
				iMaxHP = iDice(m_pNpcList[i]->m_iHitDice, 8) + m_pNpcList[i]->m_iHitDice;
				if (   (m_pNpcList[i]->m_iHP < iMaxHP) 					
					&& (m_pNpcList[i]->m_cActionLimit != 5) && (m_pNpcList[i]->m_cActionLimit != 8)) // Building do not regenerate.					
				{	if (m_pNpcList[i]->m_bIsSummoned == FALSE) 
					{	iHPup = iDice(1, m_pNpcList[i]->m_iHitDice); 
					}else if ( (m_bHeldenianWarInitiated == TRUE) // Soldiars regenerate on Heldenian battlefield
							&& (m_pMapList[m_pNpcList[i]->m_cMapIndex]->m_bIsHeldenianMap == TRUE))
					{	iHPup = iDice(1, m_pNpcList[i]->m_iHitDice); 						
					}
					// SNOOPY: Added poison support for npcs...
					if (m_pNpcList[i]->m_iPoisonLevel != 0) 
					{	iHPup -= m_pNpcList[i]->m_iPoisonLevel;
						if (iHPup < 0) iHPup = 0;
						if	(bCheckResistingPoisonSuccess(i, DEF_OWNERTYPE_NPC) == TRUE) 
						{	m_pNpcList[i]->m_iPoisonLevel = 0;					
							SetPoisonFlag(i, DEF_OWNERTYPE_NPC, FALSE);
					}	}
					m_pNpcList[i]->m_iHP += iHPup; 
					if (m_pNpcList[i]->m_iHP > iMaxHP) m_pNpcList[i]->m_iHP = iMaxHP;
					if (m_pNpcList[i]->m_iHP <= 0)     m_pNpcList[i]->m_iHP = 1;
				}
			}
			switch (m_pNpcList[i]->m_cBehavior) {
			case DEF_BEHAVIOR_DEAD:
				NpcBehavior_Dead(i);
				break;
			case DEF_BEHAVIOR_STOP:
				NpcBehavior_Stop(i);
				break;
			case DEF_BEHAVIOR_MOVE:
				NpcBehavior_Move(i);
				break;
			case DEF_BEHAVIOR_ATTACK:
				NpcBehavior_Attack(i);
				break;
			case DEF_BEHAVIOR_FLEE:
				NpcBehavior_Flee(i);
				break;
			}

			//SNOOPY Added here for ending waiting for Tamed mobs
			if (   (m_pNpcList[i] != NULL) && (m_pNpcList[i]->m_iHP > 0) 
				&& (m_pNpcList[i]->m_dwTamingTime != 0)
				&& (m_pNpcList[i]->m_cFollowOwnerType  == DEF_OWNERTYPE_PLAYER_WAITING) 
				&& ((dwTime - m_pNpcList[i]->m_dwSummonWaitTime) > 1000*60)) // Wait 60sec for the character to connect again
			{	m_pNpcList[i]->m_cFollowOwnerType   = 0;	
				m_pNpcList[i]->m_iSummonControlMode = 0;
			}
			// !!! m_pNpcList
			if ((m_pNpcList[i] != NULL) && (m_pNpcList[i]->m_iHP > 0) && (m_pNpcList[i]->m_bIsSummoned == TRUE)) 
			{	switch (m_pNpcList[i]->m_sType) {
				case 29: // Ogre summon popo:10 min
				case 33: // WW summon popo		
				case 31: // Demon summon popo
					if ((dwTime - m_pNpcList[i]->m_dwSummonedTime) > 1000*60*10) 
						NpcKilledHandler(NULL, NULL, i, 0);
					else if (   (m_pNpcList[i]->m_cFollowOwnerType  == DEF_OWNERTYPE_PLAYER_WAITING)
						&& ((dwTime - m_pNpcList[i]->m_dwSummonWaitTime) > 1000*60)) // Wait 60sec for the character to connect again
					{	m_pNpcList[i]->m_cFollowOwnerType   = 0;	
						m_pNpcList[i]->m_iSummonControlMode = 0;
					}
					break;	
				case 43: // LWB
				case 44: // GHK
				case 45: // GHKABS
				case 46: // TK
				case 47: // BG Crusade summons 10 min
					if ((dwTime - m_pNpcList[i]->m_dwSummonedTime) > 1000*60*10) 
						NpcKilledHandler(NULL, NULL, i, 0);
					else if (   (m_pNpcList[i]->m_cFollowOwnerType  == DEF_OWNERTYPE_PLAYER_WAITING)
						&& ((dwTime - m_pNpcList[i]->m_dwSummonWaitTime) > 1000*60)) // Wait 60sec for the character to connect again
					{	m_pNpcList[i]->m_cFollowOwnerType   = 0;		
						m_pNpcList[i]->m_iSummonControlMode = 0;
					}
					break;		
				case 82: // Sorceress	
				case 83: // ATK	
				case 84: // MasterElf	
				case 85: // DSK	
				case 86: // HBT		
				case 88: // Barbarian
					if (   (m_bIsHeldenianMode == TRUE)
						&& (m_pMapList[m_pNpcList[i]->m_cMapIndex] != NULL)
						&& (m_pMapList[m_pNpcList[i]->m_cMapIndex]->m_bIsHeldenianMap == 1))
					{	if (   (m_pNpcList[i]->m_cFollowOwnerType  == DEF_OWNERTYPE_PLAYER_WAITING)
							&& ((dwTime - m_pNpcList[i]->m_dwSummonWaitTime) > 1000*60)) // Wait 60sec for the character to connect again
						{	switch (m_cHeldenianSummonMode) {
							case 0: // Master has not connected again, remove summon
								NpcKilledHandler(NULL, NULL, i, 0);
								break;
							case 1: // Master has not connected again, wait forever			
								m_pNpcList[i]->m_iSummonControlMode = 0; // Un"/hold"
								break;
							case 2: // Master has not connected again, available for others to take over	
								m_pNpcList[i]->m_cFollowOwnerType   = DEF_OWNERTYPE_PLAYER_FREE;			
								m_pNpcList[i]->m_iSummonControlMode = 0; // Un"/hold"
								break;
							}
						}else break; // Keep them alive					
					}else if ((dwTime - m_pNpcList[i]->m_dwSummonedTime) > 1000*60*15) 
						NpcKilledHandler(NULL, NULL, i, 0);		// Heldenian soldiars limited to 15min if not Heldenian
					break;	
				case 36: // AGT         Those will last forever when summonned
				case 37: // AGC
				case 38: // MS
				case 39: // DT
				case 40: // ESG
				case 41: // ManaStone
				case 87: // CT
				case 89: // AGC
				case 91: // gates
					if (   (m_pNpcList[i]->m_cFollowOwnerType  == DEF_OWNERTYPE_PLAYER_WAITING)
						&& ((dwTime - m_pNpcList[i]->m_dwSummonWaitTime) > 1000*60)) // Wait 60sec for the character to connect again
					{	m_pNpcList[i]->m_cFollowOwnerType   = 0;		
						m_pNpcList[i]->m_iSummonControlMode = 0;
					}
					break;
				default: //other summons: 5 minutes
					if ((dwTime - m_pNpcList[i]->m_dwSummonedTime) > DEF_SUMMONTIME) 
						NpcKilledHandler(NULL, NULL, i, 0);
					else if (   (m_pNpcList[i]->m_cFollowOwnerType  == DEF_OWNERTYPE_PLAYER_WAITING)
						&& ((dwTime - m_pNpcList[i]->m_dwSummonWaitTime) > 1000*60)) // Wait 60sec for the character to connect again
					{	m_pNpcList[i]->m_cFollowOwnerType   = 0;		
						m_pNpcList[i]->m_iSummonControlMode = 0;
					}
					break;
	}	}	}	}
}

void CGame::ChatMsgHandler(int iClientH, char * pData, DWORD dwMsgSize)
{register int i, iRet = 0;
 WORD * wp;
 int  * ip;
 char * cp, * cp2;
 char   cBuffer[256], cTemp[256], cSendMode = NULL;
	if (m_pClientList[iClientH] == NULL) return;
	if (m_pClientList[iClientH]->m_bIsInitComplete == FALSE) return;
	if (dwMsgSize > 83 +30) return; 
	if (m_pClientList[iClientH]->m_iTimeLeft_ShutUp > 0) return;	
	if (memcmp((pData + 10), m_pClientList[iClientH]->m_cCharName, strlen(m_pClientList[iClientH]->m_cCharName)) != 0) return;
	if ((m_pClientList[iClientH]->m_bIsObserverMode == TRUE) && (m_pClientList[iClientH]->m_iAdminUserLevel == 0)) return;
	// Not AFK, chating...
	m_pClientList[iClientH]->m_dwAFKCheckTime = timeGetTime(); 
	int iStX, iStY;
	if (m_pMapList[m_pClientList[iClientH]->m_cMapIndex] != NULL) {
		iStX = m_pClientList[iClientH]->m_sX / 20;
		iStY = m_pClientList[iClientH]->m_sY / 20;
		m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_stTempSectorInfo[iStX][iStY].iPlayerActivity++;
		switch (m_pClientList[iClientH]->m_cSide) {
		case 1: m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_stTempSectorInfo[iStX][iStY].iAresdenActivity++;  break;
		case 2: m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_stTempSectorInfo[iStX][iStY].iElvineActivity++;   break;
		case 4: m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_stTempSectorInfo[iStX][iStY].iExecutorActivity++; break;
		case 0:
		default: m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_stTempSectorInfo[iStX][iStY].iNeutralActivity++;  break;
		}
	}
	cp = (char *)(pData + 21);
	switch (m_bLogChatOption) {	
		case 1: // Chat Logs of only players
			if (m_pClientList[iClientH]->m_iAdminUserLevel == 0)
			{	ZeroMemory(cTemp,sizeof(cTemp));
				pData[dwMsgSize-1] = 0;
				wsprintf(cTemp,"Loc(%-10s) IP(%-15s) PC(%-10s):\"%s\"", m_pClientList[iClientH]->m_cMapName, m_pClientList[iClientH]->m_cIPaddress, m_pClientList[iClientH]->m_cCharName, cp);
				bSendMsgToLS(MSGID_GAMEMASTERLOG,iClientH, FALSE,cTemp);
			}
			break;		
		case 2: // Chat Logs of only GM
			if (m_pClientList[iClientH]->m_iAdminUserLevel != 0)
			{	ZeroMemory(cTemp,sizeof(cTemp));
				pData[dwMsgSize-1] = 0;
				wsprintf(cTemp,"Loc(%-10s) IP(%-15s) GM(%-10s):\"%s\"", m_pClientList[iClientH]->m_cMapName, m_pClientList[iClientH]->m_cIPaddress, m_pClientList[iClientH]->m_cCharName, cp);
				bSendMsgToLS(MSGID_GAMEMASTERLOG,iClientH, FALSE,cTemp);
			}
			break;	
		case 3:	// Chat logs of all
			if (m_pClientList[iClientH]->m_iAdminUserLevel != 0)
			{	ZeroMemory(cTemp,sizeof(cTemp));
				pData[dwMsgSize-1] = 0;
				wsprintf(cTemp,"Loc(%-10s) IP(%-15s) GM(%-10s):\"%s\"", m_pClientList[iClientH]->m_cMapName, m_pClientList[iClientH]->m_cIPaddress, m_pClientList[iClientH]->m_cCharName, cp);
				bSendMsgToLS(MSGID_GAMEMASTERLOG,iClientH, FALSE,cTemp);
			}else
			{	ZeroMemory(cTemp,sizeof(cTemp));
				pData[dwMsgSize-1] = 0;
				wsprintf(cTemp,"Loc(%-10s) IP(%-15s) PC(%-10s):\"%s\"", m_pClientList[iClientH]->m_cMapName, m_pClientList[iClientH]->m_cIPaddress, m_pClientList[iClientH]->m_cCharName, cp);
				bSendMsgToLS(MSGID_GAMEMASTERLOG,iClientH, FALSE,cTemp);
			}	
			break;		
		case 4:	// Chat logs of none		
			break;
	}
	switch (*cp) {
	case '@': // Guild chat
		*cp = 32;		
		if ((strlen(cp) < 90) && (m_pClientList[iClientH]->m_iGuildRank == 0)) 
		{	ZeroMemory(cTemp, sizeof(cTemp));
			cp2 = (char *)cTemp;
			*cp2 = GSM_CHATMSG;
			cp2++;
			*cp2 = 1; // Green
			cp2++;
			ip = (int *)cp2;
			*ip = m_pClientList[iClientH]->m_iGuildGUID;
			cp2 += 4;
			memcpy(cp2, m_pClientList[iClientH]->m_cCharName, 10);
			cp2 += 10;
			wp  = (WORD *)cp2;
			*wp = (WORD)strlen(cp);
			cp2 += 2;
			strcpy(cp2, cp);
			cp2 += strlen(cp);
			bStockMsgToGateServer(cTemp, strlen(cp) + 18);
		}				
		if (   (m_pClientList[iClientH]->m_iTimeLeft_ShutUp == 0) && (m_pClientList[iClientH]->m_iLevel > 1) 
			&& (m_pClientList[iClientH]->m_iSP >= 3) ) 
		{	if (m_pClientList[iClientH]->m_iTimeLeft_FirmStaminar == 0) 
			{	m_pClientList[iClientH]->m_iSP -= 3;
				SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_SP, NULL, NULL, NULL, NULL);
			}
			cSendMode = 1;
		}else cSendMode = NULL;		
		if (m_pClientList[iClientH]->m_iTimeLeft_ShutUp > 0) cSendMode = NULL;
		break;

	case '$': // Party chat
		*cp = 32;
		if ((m_pClientList[iClientH]->m_iTimeLeft_ShutUp == 0) && (m_pClientList[iClientH]->m_iSP >= 3))
		{	if (m_pClientList[iClientH]->m_iTimeLeft_FirmStaminar == 0) 
			{	m_pClientList[iClientH]->m_iSP -= 3;
				SendNotifyMsg(NULL,iClientH,DEF_NOTIFY_SP,NULL,NULL,NULL,NULL);
			}
			cSendMode = 4;
		}else
		{	cSendMode = NULL;
		}
		if (m_pClientList[iClientH]->m_iTimeLeft_ShutUp > 0)
		{	cSendMode = NULL;
		}
		break;

	case '^': // Guild Chat
		*cp = 32;
		if ((strlen(cp) < 90) && (m_pClientList[iClientH]->m_iAdminUserLevel > 0)) 
		{	ZeroMemory(cTemp, sizeof(cTemp));
			cp2 = (char *)cTemp;
			*cp2 = GSM_CHATMSG;
			cp2++;			
			*cp2 = 1; // //*cp2 = 10; General chat for GM
			cp2++;
			ip = (int *)cp2;
			*ip = NULL;
			cp2 += 4;
			memcpy(cp2, m_pClientList[iClientH]->m_cCharName, 10);
			cp2 += 10;
			wp  = (WORD *)cp2;
			*wp = (WORD)strlen(cp);
			cp2 += 2;
			strcpy(cp2, cp);
			cp2 += strlen(cp);
			bStockMsgToGateServer(cTemp, strlen(cp) + 18);
		}

		if ((strlen(cp) < 90) && (m_pClientList[iClientH]->m_iGuildRank != -1)) 
		{	ZeroMemory(cTemp, sizeof(cTemp));
			cp2 = (char *)cTemp;
			*cp2 = GSM_CHATMSG;
			cp2++;
			*cp2 = 1;
			cp2++;
			ip = (int *)cp2;
			*ip = m_pClientList[iClientH]->m_iGuildGUID;
			cp2 += 4;
			memcpy(cp2, m_pClientList[iClientH]->m_cCharName, 10);
			cp2 += 10;
			wp  = (WORD *)cp2;
			*wp = (WORD)strlen(cp);
			cp2 += 2;
			strcpy(cp2, cp);
			cp2 += strlen(cp);
			bStockMsgToGateServer(cTemp, strlen(cp) + 18);
		}
		if (   (m_pClientList[iClientH]->m_iTimeLeft_ShutUp == 0) && (m_pClientList[iClientH]->m_iLevel > 10) 
			&& (m_pClientList[iClientH]->m_iSP > 5) && m_pClientList[iClientH]->m_iGuildRank != -1) 
		{	if (m_pClientList[iClientH]->m_iTimeLeft_FirmStaminar == 0) 
			{	m_pClientList[iClientH]->m_iSP -= 3;
				SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_SP, NULL, NULL, NULL, NULL);
			}
			cSendMode = 1;
		}else cSendMode = NULL;
		if (m_pClientList[iClientH]->m_iTimeLeft_ShutUp > 0) cSendMode = NULL;
		//if (m_pClientList[iClientH]->m_iHP < 0) cSendMode = NULL;// useless (bug ?) because HP never go below 0...
		// SNOOPY: removed this to enable GM to chat in Guild Chat not seen by everybody
		//if (m_pClientList[iClientH]->m_iAdminUserLevel > 0) cSendMode = 10;
		break;

	case '!': // Server Red Chat
		*cp = 32;		
		if ((strlen(cp) < 90) && (m_pClientList[iClientH]->m_iAdminUserLevel > 0)) 
		{	ZeroMemory(cTemp, sizeof(cTemp));
			cp2 = (char *)cTemp;
			*cp2 = GSM_CHATMSG;
			cp2++;
			*cp2 = 10; // red chat
			cp2++;
			ip = (int *)cp2;
			*ip = NULL;
			cp2 += 4;
			memcpy(cp2, m_pClientList[iClientH]->m_cCharName, 10);
			cp2 += 10;
			wp  = (WORD *)cp2;
			*wp = (WORD)strlen(cp);
			cp2 += 2;
			strcpy(cp2, cp);
			cp2 += strlen(cp);
			bStockMsgToGateServer(cTemp, strlen(cp) + 18);
		}
		if (   (m_pClientList[iClientH]->m_iTimeLeft_ShutUp == 0) 
			&& (m_pClientList[iClientH]->m_iLevel > 10) 
			&& (m_pClientList[iClientH]->m_iSP >= 5) ) 
		{	if (m_pClientList[iClientH]->m_iTimeLeft_FirmStaminar == 0) 
			{	m_pClientList[iClientH]->m_iSP -= 5;
				SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_SP, NULL, NULL, NULL, NULL);
			}
			cSendMode = 2;
		}else cSendMode = NULL;		
		if (m_pClientList[iClientH]->m_iTimeLeft_ShutUp > 0) cSendMode = NULL;
		if (m_pClientList[iClientH]->m_iHP <= 0) cSendMode = NULL;
		if (m_pClientList[iClientH]->m_iAdminUserLevel > 0) cSendMode = 10;
		break;

	case '~': // City chat
		*cp = 32;
		if (   (m_pClientList[iClientH]->m_iTimeLeft_ShutUp == 0) 
			&& (m_pClientList[iClientH]->m_iLevel > 1) 
			&& (m_pClientList[iClientH]->m_iSP >= 3) ) 
		{	if (m_pClientList[iClientH]->m_iTimeLeft_FirmStaminar == 0) 
			{	m_pClientList[iClientH]->m_iSP -= 3;
				SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_SP, NULL, NULL, NULL, NULL);
			}
			cSendMode = 3;
		}else cSendMode = NULL;		
		if (m_pClientList[iClientH]->m_iTimeLeft_ShutUp > 0) cSendMode = NULL;
		if (m_pClientList[iClientH]->m_iHP <= 0) cSendMode = NULL;
		break;

	case '/':
		ZeroMemory(cBuffer, sizeof(cBuffer));
		memcpy(cBuffer, cp, dwMsgSize - 21);
		cp = (char *)(cBuffer);	
// Standard player commands
		if (memcmp(cp, "/rep+ ", 6) == 0) 					// All
		{	SetPlayerReputation(iClientH, cp, 1, dwMsgSize - 21);
			return;}
		if (memcmp(cp, "/rep- ", 6) == 0) 					// All
		{	SetPlayerReputation(iClientH, cp, 0, dwMsgSize - 21);
			return;}
		if (memcmp(cp, "/to", 3) == 0)						// All
		{	ToggleWhisperPlayer(iClientH, cp, dwMsgSize - 21);
			return;}
		if (memcmp(cp, "/pf ", 4) == 0) {					// All
			GetPlayerProfile(iClientH, cp, dwMsgSize - 21);
			return;}
		if (memcmp(cp, "/setpf ", 7) == 0)					// All
		{	SetPlayerProfile(iClientH, cp, dwMsgSize - 21);
			return;}
		if (memcmp(cp, "/checkstats", 11) == 0) 			// All
		{	AdminOrder_CheckStats(iClientH, iClientH);
			return;}
		if (   (memcmp(cp, "/tgt ", 5) == 0) 				// All
			|| (memcmp(cp, "/target ", 8) == 0)) 		
		{	SetSummonMobAction(iClientH, 2, dwMsgSize - 21, cp);
			return;}
		if (memcmp(cp, "/hold", 5) == 0) 					// All
		{	SetSummonMobAction(iClientH, 1, dwMsgSize - 21);
			return;}
		if (memcmp(cp, "/free", 5) == 0) 					// All
		{	SetSummonMobAction(iClientH, 0, dwMsgSize - 21);
			return;}
		if (memcmp(cp, "/mobilise", 9) == 0) 				// All
		{	SetSummonMobAction(iClientH, 8, dwMsgSize - 21);
			return;}		
		if (memcmp(cp, "/summons", 8) == 0) 				// All
		{	wsprintf(G_cTxt, "You currentlly control %d creatures.", iGetFollowerNumber(iClientH, DEF_OWNERTYPE_PLAYER) );
			ShowClientMsg(iClientH,  "Summons", G_cTxt);
			return;}
		if (memcmp(cp, "/version", 8) == 0) 				// All
		{	ShowVersion(iClientH);
			return;}
		if (memcmp(cp, "/ban", 4) == 0) 					// Guild masters
		{	UserCommand_BanGuildsman(iClientH, cp, dwMsgSize - 21);
			return;}		
		if (memcmp(cp, "/dissmiss ", 9) == 0) 				// Not implemented.....
		{	UserCommand_DissmissGuild(iClientH, cp, dwMsgSize - 21);
			return;}

// Party commands
		if (memcmp(cp, "/createparty", 12) == 0)			// All
		{	RequestCreatePartyHandler(iClientH);
			return;}
		if (memcmp(cp, "/deleteparty", 12) == 0)			// All
		{	RequestDeletePartyHandler(iClientH);
			return;}
		if (memcmp(cp, "/joinparty ", 11) == 0)				// All
		{	RequestJoinPartyHandler(iClientH,cp,dwMsgSize - 21);
			return;}
		if (memcmp(cp, "/dismissparty", 13) == 0)			// All
		{	RequestDismissPartyHandler(iClientH);
			return;}	

// Ball commands
		if (memcmp(cp, "/blueball", 9) == 0)				// All
		{	Command_BlueBall(iClientH, cp, dwMsgSize - 21);
			return;}
		if (memcmp(cp, "/redball", 8) == 0)					// All
		{	Command_RedBall(iClientH, cp, dwMsgSize - 21);
			return;}
		if (memcmp(cp, "/yellowball ", 12) == 0)			// All
		{	Command_YellowBall(iClientH, cp, dwMsgSize - 21);
			return;}		
// SNOOPY added: /getgizoninfo, /savechar, /getgizonlevel
		if (   (memcmp(cp, "/readgizon", 10) == 0)			// All
			|| (memcmp(cp, "/checkgizon", 11) == 0) )
		{	AdminOrder_GetGizonInfo(iClientH, cp, dwMsgSize - 21);
			return;}
		if (memcmp(cp, "/savechar", 9) == 0) 				// All
		{	AdminOrder_SaveChar(iClientH, cp, dwMsgSize - 21);
			return;}
		if (memcmp(cp, "/getgizonlevel", 14) == 0) 			// All
		{	AdminOrder_GetGizonLevel(iClientH, cp, dwMsgSize - 21);
			return;}
		if (memcmp(cp, "/unpretend", 10) == 0) 			// All
		{	RequestTeleportHandler(iClientH,"2   ", m_pClientList[iClientH]->m_cMapName, m_pClientList[iClientH]->m_sX, m_pClientList[iClientH]->m_sY);
			if (m_pClientList[iClientH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_HOLDOBJECT ] != 0)
			{	char cParaLevel = m_pClientList[iClientH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_HOLDOBJECT ]; 					
				if (cParaLevel == 20 )						// 20: Medusa Kiss
				{}else if (cParaLevel >1)   cParaLevel = 2;
				SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_MAGICEFFECTON, DEF_MAGICTYPE_HOLDOBJECT, cParaLevel, NULL, NULL);
				return;
		}	}
		if ((memcmp(cp, "/plraider 90", 12) == 0) 			// All
			&& (m_pClientList[iClientH]->m_iLevel <= DEF_PLRAIDER_LEVELLIMIT)
			&& (m_pClientList[iClientH]->m_bIsPlayerCivil == FALSE)
			&& (m_pClientList[iClientH]->m_cSide >0)
			&& (m_pClientList[iClientH]->m_cSide <3))
		{	wsprintf(G_cTxt, "(!) PromizeLand raider: %s choose to limit his level to %d."
			, m_pClientList[iClientH]->m_cCharName
			, DEF_PLRAIDER_LEVELLIMIT);
			PutLogList(G_cTxt);
			PutLogFileList(G_cTxt);
			SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_IPACCOUNTINFO, NULL, NULL, NULL, G_cTxt); // Say to character
			_bPKLog(DEF_PKLOG_PLRAIDER, NULL,iClientH,  NULL);
			m_pClientList[iClientH]->m_bIsLimitedUser = TRUE;			
		
			return;}
// Commands with improved result for GMs...
		if (memcmp(cp, "/fi ", 4) == 0)						// info quality depends on m_iAdminLevelGoto
		{	CheckAndNotifyPlayerConnection(iClientH, cp, dwMsgSize - 21);
			return;}
		if (memcmp(cp, "/checkrep", 9) == 0) 				// info on others with m_iAdminLevelGMCheckRep
		{	AdminOrder_CheckRep(iClientH,cp, dwMsgSize - 21);
			return;}
		if (memcmp(cp, "/getactivegservers", 18) == 0)		// info quality depends on m_iAdminLevelGoto
		{	CheckAndNotifyGServersConnection(iClientH);
			return;}		
		if (memcmp(cp, "/summonguild ", 13) == 0) 			// m_iAdminLevelSummonGuild
		{	AdminOrder_SummonGuild(iClientH, cp, dwMsgSize - 21);// SNOOPY re-activated this
			return;
		}		
		if (   (memcmp(cp, "/readmapinfo", 12) == 0) 
			|| (memcmp(cp, "/checkmapinfo", 13) == 0))		// full info if m_iAdminLevelGetServerInfo
		{	AdminOrder_GetMapInfo(iClientH, cp, dwMsgSize - 21);
			return;
		}

		if (m_pClientList[iClientH]->m_iAdminUserLevel == 0) return;
// GM commands
		if (memcmp(cp, "/enableadmincommand ", 20) == 0) // All GMs, logg it if wrong or not GM
		{	AdminOrder_EnableAdminCommand(iClientH, cp, dwMsgSize - 21);
			return;}
		if (memcmp(cp, "/kill ", 6) == 0) 				//m_iAdminLevelGMKill
		{	AdminOrder_Kill(iClientH, cp, dwMsgSize - 21);
			return;}
		if (memcmp(cp, "/revive ", 8) == 0) 			//m_iAdminLevelGMRevive
		{	AdminOrder_Revive(iClientH, cp, dwMsgSize - 21);
			return;}
		if (memcmp(cp, "/closeconn ", 11) == 0) 		//m_iAdminLevelGMCloseconn
		{	AdminOrder_CloseConn(iClientH, cp, dwMsgSize - 21);
			return;}
		if (memcmp(cp, "/who", 4) == 0)					//m_iAdminLevelWho
		{	if (m_pClientList[iClientH]->m_iAdminUserLevel >= m_iAdminLevelWho) 
			{	SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_TOTALUSERS, NULL, NULL, NULL, NULL);
			}return;
		}
		if (memcmp(cp, "/energysphere", 13) == 0) 	// m_iAdminLevelEnergySphere
		{	if (m_pClientList[iClientH]->m_iAdminUserLevel >= m_iAdminLevelEnergySphere) EnergySphereProcessor(TRUE, iClientH);
			wsprintf(G_cTxt, "GM Order(%-10s): /energysphere", m_pClientList[iClientH]->m_cCharName);
			bSendMsgToLS(MSGID_GAMEMASTERLOG, iClientH, FALSE, G_cTxt);
			return;
		}
		if (   (memcmp(cp, "/shutdownthisserverrightnow ", 28) == 0) // m_iAdminLevelShutdown + m_bIsAdminCommandEnabled
			&& (  (m_pClientList[iClientH]->m_iAdminUserLevel >= m_iAdminLevelShutdown)
				|| (m_pClientList[iClientH]->m_bIsAdminStopStart == TRUE))
			&& (m_pClientList[iClientH]->m_bIsAdminCommandEnabled == TRUE)) 
		{	wsprintf(G_cTxt, "GM Order(%-10s): /shutdownthisserverrightnow", m_pClientList[iClientH]->m_cCharName);
			bSendMsgToLS(MSGID_GAMEMASTERLOG, iClientH, FALSE, G_cTxt);
			wsprintf(G_cTxt, "Admin Order(%s): Shutdown the server\tAdminIP(%s)"
				, m_pClientList[iClientH]->m_cCharName
				, m_pClientList[iClientH]->m_cIPaddress);
			PutAdminLogFileList(G_cTxt);
			m_cShutDownCode      = 2;
			m_bOnExitProcess     = TRUE;
			m_dwExitProcessTime  = timeGetTime();
			PutLogList("(!) GAME SERVER SHUTDOWN PROCESS BEGIN(by Admin-Command)!!!");
			bSendMsgToLS(MSGID_GAMESERVERSHUTDOWNED, NULL);		
			return;
		}
		if (   (memcmp(cp, "/restartthisserverrightnow ", 27) == 0) // m_iAdminLevelShutdown + m_bIsAdminCommandEnabled
			&& (  (m_pClientList[iClientH]->m_iAdminUserLevel >= m_iAdminLevelShutdown)
				|| (m_pClientList[iClientH]->m_bIsAdminStopStart == TRUE))
			&& (m_pClientList[iClientH]->m_bIsAdminCommandEnabled == TRUE)) 		
		{	wsprintf(G_cTxt, "Admin Order(%s): Restart the server\tAdminIP(%s)"
				, m_pClientList[iClientH]->m_cCharName
				, m_pClientList[iClientH]->m_cIPaddress);
			PutAdminLogFileList(G_cTxt);
			PutLogList("(!) RELOADING CONFIGS MANUALY...(by Admin-Command)!!!");
			if (m_iTotalClients > 0)
			{	_iForcePlayerDisconect(15);
				DWORD dwTime = timeGetTime();	
				bRegisterDelayEvent(DEF_DELAYEVENTTYPE_RESTART_SERVER, 0, dwTime + 2000 ,0, 0, NULL, NULL, NULL, 0, NULL, NULL);
			}else
			{	PutLogList("(!) CONFIGS RELOADING NOW...");
				bInit();
			}				
			wsprintf(G_cTxt, "GM Order(%-10s): /restartthisserverrightnow", m_pClientList[iClientH]->m_cCharName);
			bSendMsgToLS(MSGID_GAMEMASTERLOG, iClientH, FALSE, G_cTxt);
			return;
		}	
		if (memcmp(cp, "/setobservermode ", 17) == 0)		// m_iAdminLevelObserver
		{	AdminOrder_SetObserverMode(iClientH);
			return;
		}
		if (memcmp(cp, "/shutup ", 8) == 0) 				// m_iAdminLevelShutup
		{	ShutUpPlayer(iClientH, cp, dwMsgSize - 21);
			return;
		}
		if (  (memcmp(cp, "/callguard ", 11) == 0) 			// m_iAdminLevelCallGaurd
		   || (memcmp(cp, "/attack ", 8) == 0)) 			
		{	AdminOrder_CallGuard(iClientH, cp, dwMsgSize - 21);
			return;
		}
		if (memcmp(cp, "/summondemon", 12) == 0) 			// m_iAdminLevelSummonDemon
		{	AdminOrder_SummonDemon(iClientH);
			return;
		}
		if (memcmp(cp, "/summondeath", 12) == 0) 			//m_iAdminLevelSummonDeath + m_bIsAdminCommandEnabled
		{	AdminOrder_SummonDeath(iClientH);
			return;
		}
		if (memcmp(cp, "/reservefightzone", 17) == 0) 		// m_iAdminLevelReserveFightzone
		{	AdminOrder_ReserveFightzone(iClientH, cp, dwMsgSize - 21);
			return;
		}
		if (memcmp(cp, "/getticket", 10) == 0)				// m_iAdminLevelReserveFightzone
		{	AdminOrder_GetFightzoneTicket(iClientH);
			return;
		}
		if (memcmp(cp, "/createfish", 11) == 0) 			// m_iAdminLevelCreateFish
		{	AdminOrder_CreateFish(iClientH, cp, dwMsgSize - 21);
			return;
		}
		if (memcmp(cp, "/teleport ", 10) == 0 || memcmp(cp, "/tp ", 4) == 0) 
		{	AdminOrder_Teleport(iClientH, cp, dwMsgSize - 21, FALSE); // m_iAdminLevelTeleport
			return;
		}
		if (memcmp(cp, "/forcetp ", 9) == 0) 
		{	AdminOrder_Teleport(iClientH, cp, dwMsgSize - 21, TRUE); // m_iAdminLevelTeleport
			return;
		}
		if (memcmp(cp, "/gate ", 6) == 0 || memcmp(cp, "/gateto ", 8) == 0) 
		{	AdminOrder_Gate(iClientH, cp, dwMsgSize - 21, FALSE);  // m_iAdminLevelSummonAll
			return;
		}
		if (memcmp(cp, "/forcegate ", 11) == 0 || memcmp(cp, "/forcegateto ", 13) == 0) 
		{	AdminOrder_Gate(iClientH, cp, dwMsgSize - 21, FALSE);  // m_iAdminLevelSummonAll
			return;
		}
		if (memcmp(cp, "/checkip ", 9) == 0) 				// m_iAdminLevelCheckIP
		{	AdminOrder_CheckIP(iClientH, cp, dwMsgSize - 21);
			return;
		}
		if (memcmp(cp, "/polymorph ", 11) == 0) 			// m_iAdminLevelPolymorph
		{	AdminOrder_Polymorph(iClientH, cp, dwMsgSize - 21);
			return;
		}
		if (memcmp(cp, "/setinvi ", 9) == 0) 				// m_iAdminLevelSetInvis
		{	AdminOrder_SetInvi(iClientH, cp, dwMsgSize - 21);
			return;	
		}
		if (memcmp(cp, "/setzerk ", 9) == 0) 				// m_iAdminLevelSetZerk
		{	AdminOrder_SetZerk(iClientH, cp, dwMsgSize - 21);
			return;	
		}
		if (memcmp(cp, "/setfreeze ", 11) == 0) 			// m_iAdminLevelSetIce
		{	AdminOrder_SetFreeze(iClientH, cp, dwMsgSize - 21);
			return;	
		}
		if (memcmp(cp, "/gns ", 4) == 0) 					// m_iAdminLevelGetNpcStatus
		{	AdminOrder_GetNpcStatus(iClientH, cp, dwMsgSize - 21);
			return;	
		}
		if (memcmp(cp, "/setattackmode 1", 16) == 0) 		// m_iAdminLevelSetAttackMode
		{	AdminOrder_Safe(iClientH, false);		
			wsprintf(G_cTxt, "GM Order(%-10s): /setattackmode 1", m_pClientList[iClientH]->m_cCharName);
			bSendMsgToLS(MSGID_GAMEMASTERLOG, iClientH, FALSE, G_cTxt);	
			return;	
		}
		if (memcmp(cp, "/setattackmode 0", 16) == 0) 		// m_iAdminLevelSetAttackMode
		{	AdminOrder_Safe(iClientH, true);
			wsprintf(G_cTxt, "GM Order(%-10s): /setattackmode 0", m_pClientList[iClientH]->m_cCharName);
			bSendMsgToLS(MSGID_GAMEMASTERLOG, iClientH, FALSE, G_cTxt);	
			return;	
		}
		if (   (memcmp(cp, "/safe", 5) == 0) || (memcmp(cp, "/peace", 6) == 0))	
		{	AdminOrder_Safe(iClientH, true);
			wsprintf(G_cTxt, "GM Order(%-10s): /safe or /peace", m_pClientList[iClientH]->m_cCharName);
			bSendMsgToLS(MSGID_GAMEMASTERLOG, iClientH, FALSE, G_cTxt);					// m_iAdminLevelSetAttackMode
			return;	
		}
		if (   (memcmp(cp, "/unsafe", 7) == 0) || (memcmp(cp, "/war", 4) == 0)) 			
		{	AdminOrder_Safe(iClientH, false);				// m_iAdminLevelSetAttackMode
			wsprintf(G_cTxt, "GM Order(%-10s): /unsafe or /war", m_pClientList[iClientH]->m_cCharName);
			bSendMsgToLS(MSGID_GAMEMASTERLOG, iClientH, FALSE, G_cTxt);	
			return;	
		}
		if (memcmp(cp, "/unsummonall", 12) == 0) 			// m_iAdminLevelUnsummonAll
		{	AdminOrder_UnsummonAll(iClientH);				// Kill all player's summons
			return;			
		}
		if (memcmp(cp, "/unsummondemon", 14) == 0) 			// m_iAdminLevelUnsummonDemon
		{	AdminOrder_UnsummonDemon(iClientH);				// Kill all demons
			return;			
		}	
		if (memcmp(cp, "/summon ", 8) == 0) 				// m_iAdminLevelSummon + m_bIsAdminCommandEnabled
		{	AdminOrder_Summon(iClientH, cp, dwMsgSize - 21, 0);
			return;
		}	
		if (memcmp(cp, "/summonboss ", 12) == 0) 			// m_iAdminLevelSummon + m_bIsAdminCommandEnabled
		{	AdminOrder_Summon(iClientH, cp, dwMsgSize - 21, -12);
			return;
		}
		if (memcmp(cp, "/summonall ", 11) == 0) 			// m_iAdminLevelSummonAll + m_bIsAdminCommandEnabled
		{	AdminOrder_SummonAll(iClientH, cp, dwMsgSize - 21);
			return;
		}
		if (memcmp(cp, "/summonplayer ", 14) == 0) 			// m_iAdminLevelSummonPlayer
		{	AdminOrder_SummonPlayer(iClientH, cp, dwMsgSize - 21);
			return;
		}		
		if (memcmp(cp, "/monitor ", 9) == 0) 				// m_iAdminLevelSummonPlayer
		{	AdminOrder_MonitorPlayer(iClientH, cp, dwMsgSize - 21);
			return;	
		}	
		if (memcmp(cp, "/disconnectall ", 15) == 0) 		// m_iAdminLevelDisconnectAll + m_bIsAdminCommandEnabled
		{	AdminOrder_DisconnectAll(iClientH, cp, dwMsgSize - 21);
			return;
		}
		if (memcmp(cp, "/createitem ", 12) == 0) 			// m_iAdminLevelCreateItem + m_bIsAdminCommandEnabled
		{	AdminOrder_CreateItem(iClientH, cp, dwMsgSize - 21);
			return;
		}
		if (memcmp(cp, "/createtoken ", 13) == 0) 			// m_iAdminLevelSummon + m_bIsAdminCommandEnabled
		{	AdminOrder_CreateToken(iClientH, cp, dwMsgSize - 21);
			return;
		}
		if (memcmp(cp, "/itemeventnow", 13) == 0) 			// m_iAdminLevelSummon + m_bIsAdminCommandEnabled
		{	AdminOrder_ItemEventNow(iClientH, cp, dwMsgSize - 21);
			return;
		}
		if (memcmp(cp, "/storm ", 7) == 0) 					// m_iAdminLevelStorm + m_bIsAdminCommandEnabled
		{	AdminOrder_SummonStorm(iClientH, cp, dwMsgSize - 21);
			return;
		}
		if (memcmp(cp, "/weather", 8) == 0) 				// m_iAdminLevelWeather
		{	AdminOrder_Weather(iClientH, cp, dwMsgSize - 21); 
			return; 
		}	
		if (memcmp(cp, "/thunder", 8) == 0) 				// m_iAdminLevelWeather
		{	AdminOrder_Thunder(iClientH, cp, dwMsgSize - 21); 
			return; 
		}	
		if (memcmp(cp, "/setstatus ", 11) == 0) 			// m_iAdminLevelSetStatus
		{	AdminOrder_SetStatus(iClientH, cp, dwMsgSize - 21);
			return;	
		}	
		if (memcmp(cp, "/goto ", 6) == 0)					// m_iAdminLevelGoto
		{	AdminOrder_GoTo(iClientH, cp, dwMsgSize - 21);
			return;
		}
		if (memcmp(cp, "/monstercount", 13) == 0)			// m_iAdminLevelMonsterCount
		{	AdminOrder_MonsterCount(iClientH,cp,dwMsgSize - 21);
			return;
		}
		if (memcmp(cp, "/setforcerecalltime ", 20) == 0)	// m_iAdminLevelSetRecallTime
		{	AdminOrder_SetForceRecallTime(iClientH, cp, dwMsgSize - 21);
			return;
		}
		if (   (memcmp(cp, "/unsummonboss", 13) == 0)		// Kill all DD and up.
			|| (memcmp(cp, "/clearboss", 10) == 0))			// m_iAdminLevelUnsummonBoss
		{	AdminOrder_UnsummonBoss(iClientH);
			return;
		}
		if (   (memcmp(cp, "/unsummonnpc", 12) == 0)		// Kill all mobs except merchants
			|| (memcmp(cp, "/clearnpc", 9) == 0))			// m_iAdminLevelClearNpc
		{	AdminOrder_ClearNpc(iClientH);
			return;
		}
		if (memcmp(cp,"/time ", 6) == 0) 					// m_iAdminLevelTime
		{	AdminOrder_Time(iClientH, cp, dwMsgSize - 21);
				return;
		}
        if (   (memcmp(cp, "/send ", 5) == 0)
			|| (memcmp(cp, "/push ", 5) == 0)) 				// m_iAdminLevelPushPlayer
		{	AdminOrder_Pushplayer(iClientH, cp, dwMsgSize -21);
			return;
		}
		if (memcmp(cp, "/checkstatus ", 13) == 0) 			// m_iAdminLevelCheckStatus
		{	AdminOrder_CheckStatus(iClientH,cp, dwMsgSize - 21);
			return;
		}
		if (   (memcmp(cp, "/cleanmap", 9) == 0)
			|| (memcmp(cp, "/clearmap", 9) == 0))			// m_iAdminLevelCleanMap
		{	AdminOrder_CleanMap(iClientH, cp, dwMsgSize);
			return;
		}
		if (   (memcmp(cp, "/cleanbumps", 11) == 0)
			|| (memcmp(cp, "/clearbumps", 11) == 0))			// m_iAdminLevelCleanMap
		{	AdminOrder_CleanBumps(iClientH, cp, dwMsgSize);
			return;
		}

// Adds by Snoopy: /setpkmode, /setmaptype, /readmapinfo, /setmapmobnum, /popoenabled ...
		if (memcmp(cp, "/setpkmode ", 11) == 0) 			// m_iAdminLevelSetPkMode + m_bIsAdminCommandEnabled
		{	AdminOrder_SetPkMode(iClientH, cp, dwMsgSize - 21);
			return;	
		}
		if (memcmp(cp, "/setmaptype ", 12) == 0) 			// m_iAdminLevelSetMapType + m_bIsAdminCommandEnabled
		{	AdminOrder_SetMapType(iClientH, cp, dwMsgSize - 21);
			return;	
		}	
		if (memcmp(cp, "/setdroptype ", 13) == 0) 			// m_iAdminLevelSetMapType + m_bIsAdminCommandEnabled
		{	AdminOrder_DropType(iClientH, cp, dwMsgSize - 21);
			return;	
		}	
		if (memcmp(cp, "/setmapmobnum ", 14) == 0) 			// m_iAdminLevelMapMobNum + m_bIsAdminCommandEnabled
		{	AdminOrder_MapMobNum(iClientH, cp, dwMsgSize - 21);
			return;	
		}	
		if (memcmp(cp, "/popoenabled ", 13) == 0) 			// m_iAdminLevelPopoEnabled + m_bIsAdminCommandEnabled
		{	AdminOrder_PopoEnabled(iClientH, cp, dwMsgSize - 21);
			return;	
		}
		if (memcmp(cp, "/test ", 6) == 0) 					// SNOOPY: Added /test for Admins 4+
		{	AdminOrder_Test(iClientH, cp, dwMsgSize - 21);
			return;	
		}	
		if (memcmp(cp, "/start ", 7) == 0) 					// m_iAdminLevelShutdown + m_bIsAdminCommandEnabled
		{	AdminOrder_StartServer(iClientH, cp, dwMsgSize - 21);
			return;	
		}	
		if (memcmp(cp, "/setxprate ", 11) == 0) 			// m_iAdminLevelSpecialEvents + m_bIsAdminCommandEnabled
		{	AdminOrder_SetXPRate(iClientH, cp, dwMsgSize - 21);//m_pMapList[iMapIndex]->m_iXPRate
			return;	
		}	
		if (memcmp(cp, "/setextradrop ", 14) == 0) 			// m_iAdminLevelSpecialEvents + m_bIsAdminCommandEnabled
		{	AdminOrder_SetExtraDrop(iClientH, cp, dwMsgSize - 21);//m_pMapList[iMapIndex]->m_iXPRate
			return;	
		}	
		if (memcmp(cp, "/setbossrate ", 13) == 0) 			// m_iAdminLevelSpecialEvents + m_bIsAdminCommandEnabled
		{	AdminOrder_SetBossAdjust(iClientH, cp, dwMsgSize - 21);//m_pMapList[iMapIndex]->m_iXPRate
			return;	
		}	
		if (   (memcmp(cp, "/reloadmap", 10) == 0) 			// m_iAdminLevelShutdown + m_bIsAdminCommandEnabled			
			&& (m_pClientList[iClientH]->m_iAdminUserLevel >= m_iAdminLevelShutdown))
		{	for (i = 0; i < DEF_MAXMAPS; i++) 
			{	if (m_pMapList[i] != NULL) 
				{	__bReadMapInfo(i);
			}	}	
			wsprintf(G_cTxt,"GM Order(%-10s): /reloadmap", m_pClientList[iClientH]->m_cCharName);
			bSendMsgToLS(MSGID_GAMEMASTERLOG, iClientH, FALSE, G_cTxt);	
			return;	
		}
		if (   (memcmp(cp, "/logpits", 7) == 0) // m_iAdminLevelShutdown + m_bIsAdminCommandEnabled			
			&& (m_pClientList[iClientH]->m_iAdminUserLevel >= m_iAdminLevelShutdown))
		{	for (int iMapIndex = 0; iMapIndex< DEF_MAXMAPS; iMapIndex++) 
			{	if (   (m_pMapList[iMapIndex] != NULL) 
					&& (iMapIndex == m_pClientList[iClientH]->m_cMapIndex))
				{	for (i = 0; i < DEF_MAXSPOTMOBGENERATOR; i++) 	
					{	if (m_pMapList[iMapIndex]->m_stSpotMobGenerator[i].bDefined == TRUE)
						{	wsprintf(G_cTxt, "Random pit n°%d in %s (%d,%d). Type(%d) Mob(%d) MaxMobs(%d) CurMobs(%d)"
							, i
							, m_pMapList[iMapIndex]->m_cName
							, (m_pMapList[iMapIndex]->m_stSpotMobGenerator[i].rcRect.left + m_pMapList[iMapIndex]->m_stSpotMobGenerator[i].rcRect.right)/2
							, (m_pMapList[iMapIndex]->m_stSpotMobGenerator[i].rcRect.top + m_pMapList[iMapIndex]->m_stSpotMobGenerator[i].rcRect.bottom)/2
							, m_pMapList[iMapIndex]->m_stSpotMobGenerator[i].cType
							, m_pMapList[iMapIndex]->m_stSpotMobGenerator[i].iMobType 
							, m_pMapList[iMapIndex]->m_stSpotMobGenerator[i].iMaxMobs
							, m_pMapList[iMapIndex]->m_stSpotMobGenerator[i].iCurMobs);
							PutLogList(G_cTxt);				
			}	}	}	}	
			wsprintf(G_cTxt,"GM Order(%-10s): /logpits", m_pClientList[iClientH]->m_cCharName);
			bSendMsgToLS(MSGID_GAMEMASTERLOG, iClientH, FALSE, G_cTxt);	
			return;	
		}

// Special Events: Crusade, Apocalypse, Heldenian.==> m_iAdminLevelSpecialEvents + m_bIsAdminCommandEnabled
		if (memcmp(cp, "/begincrusadetotalwar ", 22) == 0) 		
		{	if (   (m_pClientList[iClientH]->m_iAdminUserLevel >= m_iAdminLevelSpecialEvents) 
				&& (m_pClientList[iClientH]->m_bIsAdminCommandEnabled == TRUE))
			{	wsprintf(cTemp, "GM Order(%-10s): /begincrusadetotalwar", m_pClientList[iClientH]->m_cCharName);
				bSendMsgToLS(MSGID_GAMEMASTERLOG, iClientH, FALSE, cTemp);
				GlobalStartCrusadeMode();
			}return;
		}		
		if (memcmp(cp, "/endcrusadetotalwar ", 20) == 0) 
		{	if (   (m_pClientList[iClientH]->m_iAdminUserLevel >= m_iAdminLevelSpecialEvents) 
				&& (m_pClientList[iClientH]->m_bIsAdminCommandEnabled == TRUE))
			{	wsprintf(cTemp, "GM Order(%-10s): /endcrusadetotalwar", m_pClientList[iClientH]->m_cCharName);
				bSendMsgToLS(MSGID_GAMEMASTERLOG, iClientH, FALSE, cTemp);
				ManualEndCrusadeMode(0);
			}return;
		}		
		if (memcmp(cp, "/beginapocalypse ", 17) == 0) // SNOOPY reactivated these function
		{	if (   (m_pClientList[iClientH]->m_iAdminUserLevel >= m_iAdminLevelSpecialEvents)
				&& (m_pClientList[iClientH]->m_bIsAdminCommandEnabled == TRUE)) 
			{	wsprintf(cTemp, "GM Order(%-10s): /beginapocalypse", m_pClientList[iClientH]->m_cCharName);
				bSendMsgToLS(MSGID_GAMEMASTERLOG, iClientH, FALSE, cTemp);
				GlobalStartApocalypseMode(iClientH, 0);
			}return;
		}
		if (memcmp(cp, "/openapocalypsegate ", 20) == 0)
		{	if (   (m_pClientList[iClientH]->m_iAdminUserLevel >= m_iAdminLevelSpecialEvents) 
				&& (m_pClientList[iClientH]->m_bIsAdminCommandEnabled == TRUE)) 
			{	wsprintf(cTemp, "GM Order(%-10s): /openapocalypsegate", m_pClientList[iClientH]->m_cCharName);
				bSendMsgToLS(MSGID_GAMEMASTERLOG, iClientH, FALSE, cTemp);
				GlobalStartApocalypseMode(iClientH, 1);
			}return;
		}
		if (memcmp(cp, "/closeapocalypsegate ", 21) == 0)
		{	if (   (m_pClientList[iClientH]->m_iAdminUserLevel >= m_iAdminLevelSpecialEvents)
				&& (m_pClientList[iClientH]->m_bIsAdminCommandEnabled == TRUE))  
			{	wsprintf(cTemp, "GM Order(%-10s): /closeapocalypsegate", m_pClientList[iClientH]->m_cCharName);
				bSendMsgToLS(MSGID_GAMEMASTERLOG, iClientH, FALSE, cTemp);
				GlobalStartApocalypseMode(iClientH, 2);
			}return;
		}
		if (memcmp(cp, "/endapocalypse", 14) == 0)
		{	if (   (m_pClientList[iClientH]->m_iAdminUserLevel >= m_iAdminLevelSpecialEvents ) 	
				&& (m_pClientList[iClientH]->m_bIsAdminCommandEnabled == TRUE)) 
			{	wsprintf(cTemp, "GM Order(%-10s): /endapocalypse", m_pClientList[iClientH]->m_cCharName);
				bSendMsgToLS(MSGID_GAMEMASTERLOG, iClientH, FALSE, cTemp);
				GlobalEndApocalypseMode(iClientH);
			}return;
		}		
		if (memcmp(cp, "/beginheldenian ", 16) == 0)	//m_iAdminLevelSpecialEvents
		{	wsprintf(cTemp, "GM Order(%-10s): /beginheldenian", m_pClientList[iClientH]->m_cCharName);
			bSendMsgToLS(MSGID_GAMEMASTERLOG, iClientH, FALSE, cTemp);
			ManualStartHeldenianMode(iClientH, cp, dwMsgSize - 21); 
			return;
		}		
		if (memcmp(cp, "/endheldenian ", 14) == 0)		//m_iAdminLevelSpecialEvents
		{	wsprintf(cTemp, "GM Order(%-10s): /endheldenian", m_pClientList[iClientH]->m_cCharName);
			bSendMsgToLS(MSGID_GAMEMASTERLOG, iClientH, FALSE, cTemp);
			ManualEndHeldenianMode(iClientH, cp, dwMsgSize - 21);
			return;
		}	
		if (memcmp(cp, "/beginavatarwar ", 16) == 0) 		
		{	if (   (m_pClientList[iClientH]->m_iAdminUserLevel >= m_iAdminLevelSpecialEvents) 
				&& (m_pClientList[iClientH]->m_bIsAdminCommandEnabled == TRUE))
			{	wsprintf(cTemp, "GM Order(%-10s): /beginavatarwar", m_pClientList[iClientH]->m_cCharName);
				bSendMsgToLS(MSGID_GAMEMASTERLOG, iClientH, FALSE, cTemp);
				GlobalStartAvatarMode();
			}return;
		}		
		if (memcmp(cp, "/endavatarwar ", 14) == 0) 
		{	if (   (m_pClientList[iClientH]->m_iAdminUserLevel >= m_iAdminLevelSpecialEvents) 
				&& (m_pClientList[iClientH]->m_bIsAdminCommandEnabled == TRUE))
			{	wsprintf(cTemp, "GM Order(%-10s): /endavatarwar", m_pClientList[iClientH]->m_cCharName);
				bSendMsgToLS(MSGID_GAMEMASTERLOG, iClientH, FALSE, cTemp);
				ManualEndAvatarMode(0);
			}return;
		}	
		return;
	}

	pData[dwMsgSize-1] = NULL;
	// SNOOPY: designed non corean confuse language		
	if ((m_pClientList[iClientH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_CONFUSE ] == 1)/* && (iDice(1,3) != 2)*/) {
		// Confuse Language
		cp = (char *)(pData + DEF_INDEX2_MSGTYPE + 17);		
		while (*cp != NULL) {
			if ((cp[0] != NULL) /*&& (cp[0] != ' ')*/ && (cp[1] != NULL)/*&& (cp[1] != ' ')*/) 
			{	switch (iDice(1,12)) {
				case 1:	memcpy(cp, "ma", 2); break;
				case 2:	memcpy(cp, "fo", 2); break;
				case 3:	memcpy(cp, "ru", 2); break;
				case 4:	memcpy(cp, "be", 2); break;
				case 5:	memcpy(cp, "xy", 2); break;
				case 6:	memcpy(cp, "ce", 2); break;
				case 7:	memcpy(cp, "li", 2); break;
				case 8:	memcpy(cp, "re", 2); break;
				case 9:	memcpy(cp, "su", 2); break;
				case 10:memcpy(cp, "to", 2); break;
				case 11:memcpy(cp, "ju", 2); break;
				case 12:memcpy(cp, "de", 2); break;
				}
				if (cp[1] != ' ')
				switch (iDice(1,12)) {
				case 1:	
				case 2:	
				case 3:	
				case 4:	
				case 5:	break;
				case 6:	memcpy(cp, "a ", 2); break;
				case 7:	
				case 8:	memcpy(cp, "e ", 2); break;
				case 9:	memcpy(cp, "i ", 2); break;
				case 10:memcpy(cp, "o ", 2); break;
				case 11:memcpy(cp, "u ", 2); break;
				case 12:memcpy(cp, "y ", 2); break;
				}	
				if (cp[0] != ' ')
				switch (iDice(1,12)) {
				case 1:	
				case 2:	
				case 3:	
				case 4:	
				case 5:	break;
				case 6:	memcpy(cp, " c", 2); break;
				case 7:	
				case 8:	memcpy(cp, " s", 2); break;
				case 9:	memcpy(cp, " t", 2); break;
				case 10:memcpy(cp, " l", 2); break;
				case 11:memcpy(cp, " r", 2); break;
				case 12:memcpy(cp, " n", 2); break;
				}				
				cp += 2;
			}
			else cp++; 
		}
	}		
	cp = (char *)(pData + DEF_INDEX2_MSGTYPE + 17);	
	if ((cSendMode == NULL) && (m_pClientList[iClientH]->m_iWhisperPlayerIndex != -1)) 
	{	cSendMode = 20;		
		if (*cp == '#') cSendMode = NULL;
		if (m_pClientList[iClientH]->m_iTimeLeft_ShutUp > 0) cSendMode = NULL;
	}
	wp = (WORD *)(pData + DEF_INDEX2_MSGTYPE);
	*wp = (WORD)iClientH;
	cp = (char *)(pData + DEF_INDEX2_MSGTYPE + 16);
	*cp = cSendMode;
	if (cSendMode != 20) 
	{	for (i = 1; i < DEF_MAXCLIENTS; i++)
		if (   (m_pClientList[i] != NULL) 
			&& (m_pClientList[i]->m_bIsInitComplete == TRUE))
		{	switch (cSendMode) {
			case NULL: // Normal Chat				
				if (   (m_pClientList[i]->m_cMapIndex == m_pClientList[iClientH]->m_cMapIndex) 
					&& (m_pClientList[i]->m_sX > m_pClientList[iClientH]->m_sX - 10) 
					&& (m_pClientList[i]->m_sX < m_pClientList[iClientH]->m_sX + 10) 
					&& (m_pClientList[i]->m_sY > m_pClientList[iClientH]->m_sY - 7) 
					&& (m_pClientList[i]->m_sY < m_pClientList[iClientH]->m_sY + 7) ) 
				{	if (m_bIsCrusadeMode == TRUE)		// Avatar: Chat not seen by ennemy
					{	if (   (m_pClientList[iClientH]->m_cSide != 0) && (m_pClientList[i]->m_cSide != 0) 
							&& (m_pClientList[i]->m_cSide != m_pClientList[iClientH]->m_cSide) ) break;
					}
					if (   (m_bIsAvatarMode == TRUE)	// Avatar: Chat not seen by ennemy 
						&& (m_iPLmapIndex != -1))	
					{	if (   (m_pClientList[iClientH]->m_cSide != 0) && (m_pClientList[i]->m_cSide != 0) 
							&& (m_pClientList[i]->m_cSide != m_pClientList[iClientH]->m_cSide) ) break;
					}
					if (   (m_bIsHeldenianMode == TRUE)		// Heldenian: Chat not seen by ennemi
						&& ((m_iBTFieldMapIndex != -1)||(m_iGodHMapIndex != -1)))
					{	if (   (m_pClientList[iClientH]->m_cSide != 0) && (m_pClientList[i]->m_cSide != 0) 
							&& (m_pClientList[i]->m_cSide != m_pClientList[iClientH]->m_cSide) ) break;
					} 
					iRet = m_pClientList[i]->m_pXSock->iSendMsg(pData, dwMsgSize);
				}
				break;					
			case 1: // Green chat: Take into account possible Guild members from other city
				if ( (memcmp(m_pClientList[i]->m_cGuildName, m_pClientList[iClientH]->m_cGuildName, 20) == 0) 
					&&	 (memcmp(m_pClientList[i]->m_cGuildName, "NONE", 4) != 0) ) 					
				{	if (m_bIsCrusadeMode == TRUE)			// Crusade: Green chat not seen by ennemy
					{	if (   (m_pClientList[iClientH]->m_cSide != 0) && (m_pClientList[i]->m_cSide != 0) 
							&& (m_pClientList[i]->m_cSide != m_pClientList[iClientH]->m_cSide) ) break;
					} 
					if (   (m_bIsAvatarMode == TRUE)	// Avatar: Chat not seen by ennemy 
						&& (m_iPLmapIndex != -1))	
					{	if (   (m_pClientList[iClientH]->m_cSide != 0) && (m_pClientList[i]->m_cSide != 0) 
							&& (m_pClientList[i]->m_cSide != m_pClientList[iClientH]->m_cSide) ) break;
					}
					if (   (m_bIsHeldenianMode == TRUE) // Heldenian: Green Chat not seen by ennemi
							&& ((m_iBTFieldMapIndex != -1)||(m_iGodHMapIndex != -1)))
					{	if (   (m_pClientList[iClientH]->m_cSide != 0) && (m_pClientList[i]->m_cSide != 0) 
							&& (m_pClientList[i]->m_cSide != m_pClientList[iClientH]->m_cSide) ) break;
					} 					
					iRet = m_pClientList[i]->m_pXSock->iSendMsg(pData, dwMsgSize);
				}
				break;					
			case 2:  // Red player Chat
				if (m_bIsCrusadeMode == TRUE)			// Crusade: Red chat not seen by ennemy
				{	if (   (m_pClientList[iClientH]->m_cSide != 0) && (m_pClientList[i]->m_cSide != 0) 
						&& (m_pClientList[i]->m_cSide != m_pClientList[iClientH]->m_cSide) ) break;
				} 
				if (   (m_bIsAvatarMode == TRUE)	// Avatar: Chat not seen by ennemy 
					&& (m_iPLmapIndex != -1))	
				{	if (   (m_pClientList[iClientH]->m_cSide != 0) && (m_pClientList[i]->m_cSide != 0) 
						&& (m_pClientList[i]->m_cSide != m_pClientList[iClientH]->m_cSide) ) break;
				}
				if (   (m_bIsHeldenianMode == TRUE)		// Heldenian: Red Chat not seen by ennemi
						&& ((m_iBTFieldMapIndex != -1)||(m_iGodHMapIndex != -1)))
				{	if (   (m_pClientList[iClientH]->m_cSide != 0) && (m_pClientList[i]->m_cSide != 0) 
						&& (m_pClientList[i]->m_cSide != m_pClientList[iClientH]->m_cSide) ) break;
				} 					
				iRet = m_pClientList[i]->m_pXSock->iSendMsg(pData, dwMsgSize);
				break;
			case 10: // GM Light Green Chat			
				iRet = m_pClientList[i]->m_pXSock->iSendMsg(pData, dwMsgSize);
				break;					
			case 3: // Blue
				if ( (m_pClientList[i]->m_cSide == m_pClientList[iClientH]->m_cSide) ) 
					iRet = m_pClientList[i]->m_pXSock->iSendMsg(pData, dwMsgSize);
				break;
			case 4: // Yellow
				if (m_bIsCrusadeMode == TRUE)			// Crusade: Yellow chat not seen by ennemy
				{	if (   (m_pClientList[iClientH]->m_cSide != 0) && (m_pClientList[i]->m_cSide != 0) 
						&& (m_pClientList[i]->m_cSide != m_pClientList[iClientH]->m_cSide) ) break;
				} 
				if (   (m_bIsAvatarMode == TRUE)	// Avatar: Chat not seen by ennemy 
					&& (m_iPLmapIndex != -1))	
				{	if (   (m_pClientList[iClientH]->m_cSide != 0) && (m_pClientList[i]->m_cSide != 0) 
						&& (m_pClientList[i]->m_cSide != m_pClientList[iClientH]->m_cSide) ) break;
				}
				if (   (m_bIsHeldenianMode == TRUE)		// Heldenian: Yellow chat not seen by ennemi
						&& ((m_iBTFieldMapIndex != -1)||(m_iGodHMapIndex != -1)))
				{	if (   (m_pClientList[iClientH]->m_cSide != 0) && (m_pClientList[i]->m_cSide != 0) 
						&& (m_pClientList[i]->m_cSide != m_pClientList[iClientH]->m_cSide) ) break;
				} 
				if (   (m_pClientList[i]->m_iPartyID != NULL) 
					&& (m_pClientList[i]->m_iPartyID == m_pClientList[iClientH]->m_iPartyID) ) 
					iRet = m_pClientList[i]->m_pXSock->iSendMsg(pData, dwMsgSize);
				break;
			}				
			switch (iRet) {
			case DEF_XSOCKEVENT_QUENEFULL:
			case DEF_XSOCKEVENT_SOCKETERROR:
			case DEF_XSOCKEVENT_CRITICALERROR:
			case DEF_XSOCKEVENT_SOCKETCLOSED:
				//DeleteClient(i, TRUE, TRUE);
				break;
		}	}
	}else 
	{	iRet = m_pClientList[iClientH]->m_pXSock->iSendMsg(pData, dwMsgSize);	
		if (m_pClientList[iClientH]->m_iWhisperPlayerIndex == 10000) 
		{	ZeroMemory(cBuffer, sizeof(cBuffer));
			cp = (char *)cBuffer;
			*cp = GSM_WHISFERMSG;
			cp++;
			memcpy(cp, m_pClientList[iClientH]->m_cWhisperPlayerName, 10);
			cp += 10;
			wp = (WORD *)cp;
			*wp = (WORD)dwMsgSize;
			cp += 2;
			memcpy(cp, pData, dwMsgSize);
			cp += dwMsgSize;
			bStockMsgToGateServer(cBuffer, dwMsgSize+13);
			switch (m_bLogChatOption){ // Log when sending to another server
			case 1: // Chat Logs only from players
				if (m_pClientList[iClientH]->m_iAdminUserLevel == 0)
				{	ZeroMemory(cTemp,sizeof(cTemp));
					wsprintf(cTemp,"Player Whisper    PC(%-10s) to PC(%-10s):\"%s\"", m_pClientList[iClientH]->m_cCharName, m_pClientList[iClientH]->m_cWhisperPlayerName, pData+21);
					bSendMsgToLS(MSGID_GAMEMASTERLOG,iClientH, FALSE,cTemp);
				}break;
			case 2: // Chat Logs only from GM
				if (m_pClientList[iClientH]->m_iAdminUserLevel != 0)
				{	ZeroMemory(cTemp,sizeof(cTemp));
					wsprintf(cTemp,"GM Whisper        PC(%-10s) to PC(%-10s):\"%s\"", m_pClientList[iClientH]->m_cCharName, m_pClientList[iClientH]->m_cWhisperPlayerName, pData+21);
					bSendMsgToLS(MSGID_GAMEMASTERLOG,iClientH, FALSE,cTemp);
				}break;
			case 3: // Chat logs of all
				if (m_pClientList[iClientH]->m_iAdminUserLevel != 0)
				{	ZeroMemory(cTemp,sizeof(cTemp));
					wsprintf(cTemp,"GM Whisper        PC(%-10s) to PC(%-10s):\"%s\"", m_pClientList[iClientH]->m_cCharName, m_pClientList[iClientH]->m_cWhisperPlayerName, pData+21);
					bSendMsgToLS(MSGID_GAMEMASTERLOG,iClientH, FALSE,cTemp);
				}else
				{	ZeroMemory(cTemp,sizeof(cTemp));
					wsprintf(cTemp,"Player Whisper    PC(%-10s) to PC(%-10s):\"%s\"", m_pClientList[iClientH]->m_cCharName, m_pClientList[iClientH]->m_cWhisperPlayerName, pData+21);
					bSendMsgToLS(MSGID_GAMEMASTERLOG,iClientH, FALSE,cTemp);
				}break;
			case 4:	// Chat logs of none
				break;
			}
		}else
		{	if (   (m_pClientList[ m_pClientList[iClientH]->m_iWhisperPlayerIndex ] != NULL) 
				&& (strcmp(m_pClientList[iClientH]->m_cWhisperPlayerName, m_pClientList[ m_pClientList[iClientH]->m_iWhisperPlayerIndex ]->m_cCharName) == 0))
			{	iRet = m_pClientList[m_pClientList[iClientH]->m_iWhisperPlayerIndex]->m_pXSock->iSendMsg(pData, dwMsgSize);	
				switch (m_bLogChatOption){		// Log when sending in same server
				case 1: // Chat Logs of only players
					if (m_pClientList[m_pClientList[iClientH]->m_iWhisperPlayerIndex]->m_iAdminUserLevel == 0)
					{	ZeroMemory(cTemp,sizeof(cTemp));
						wsprintf(cTemp,"Player Whisper    PC(%-10s) to PC(%-10s):\"%s\"", m_pClientList[iClientH]->m_cCharName, m_pClientList[iClientH]->m_cWhisperPlayerName, pData+21);
						bSendMsgToLS(MSGID_GAMEMASTERLOG,iClientH, FALSE,cTemp);
					}break;
				case 2: // Chat Logs only destinated to GM
					if (m_pClientList[m_pClientList[iClientH]->m_iWhisperPlayerIndex]->m_iAdminUserLevel != 0)
					{	ZeroMemory(cTemp,sizeof(cTemp));
						wsprintf(cTemp,"Player Whisper    GM(%-10s) to PC(%-10s):\"%s\"", m_pClientList[iClientH]->m_cCharName, m_pClientList[iClientH]->m_cWhisperPlayerName, pData+21);
						bSendMsgToLS(MSGID_GAMEMASTERLOG,iClientH, FALSE,cTemp);
					}break;
				case 3: // Chat logs of all
					if (m_pClientList[m_pClientList[iClientH]->m_iWhisperPlayerIndex]->m_iAdminUserLevel != 0)
					{	ZeroMemory(cTemp,sizeof(cTemp));
						wsprintf(cTemp,"Player Whisper    GM(%-10s) to PC(%-10s):\"%s\"", m_pClientList[iClientH]->m_cCharName, m_pClientList[iClientH]->m_cWhisperPlayerName, pData+21);
						bSendMsgToLS(MSGID_GAMEMASTERLOG,iClientH, FALSE,cTemp);
					}else
					{	ZeroMemory(cTemp,sizeof(cTemp));
						wsprintf(cTemp,"Player Whisper    PC(%-10s) to PC(%-10s):\"%s\"", m_pClientList[iClientH]->m_cCharName, m_pClientList[iClientH]->m_cWhisperPlayerName, pData+21);
						bSendMsgToLS(MSGID_GAMEMASTERLOG,iClientH, FALSE,cTemp);
					}break;
				case 4:	// Chat logs of none
					break;
		}	}	}
		switch (iRet) {
		case DEF_XSOCKEVENT_QUENEFULL:
		case DEF_XSOCKEVENT_SOCKETERROR:
		case DEF_XSOCKEVENT_CRITICALERROR:
		case DEF_XSOCKEVENT_SOCKETCLOSED:
			//DeleteClient(i, TRUE, TRUE);
			break;
	}	}
}

void CGame::ChatMsgHandlerGSM(int iMsgType, int iV1, char * pName, char * pData, DWORD dwMsgSize)
{register int i, iRet;
 DWORD * dwp;
 WORD * wp;
 short * sp;
 char * cp, cTemp[256], cSendMode = NULL;
 int iClientH = 0;
	ZeroMemory(cTemp, sizeof(cTemp));	
	dwp = (DWORD *)cTemp;
	*dwp = MSGID_COMMAND_CHATMSG;	
	wp  = (WORD *)(cTemp + DEF_INDEX2_MSGTYPE);
	*wp = NULL;
	cp  = (char *)(cTemp + DEF_INDEX2_MSGTYPE + 2);
	sp  = (short *)cp;
	*sp = NULL;
	cp += 2;
	sp  = (short *)cp;
	*sp = NULL;
	cp += 2;	
	memcpy(cp, pName, 10);
	cp += 10;
	*cp = (char)iMsgType;
	cp++;
	memcpy(cp, pData, dwMsgSize);
	cp += dwMsgSize;
	switch (iMsgType) {
	case 0: // Normal Chat added here by Snoopy (for false character chat initiated by server (Taming in progress)...)
		for (i = 1; i < DEF_MAXCLIENTS; i++)
		if ((m_pClientList[i] != NULL) && (memcmp(m_pClientList[i]->m_cCharName, pName, 10) == 0) ) 
		{	iClientH = i; break;
		}
		if (iClientH == 0) break;
		if (m_pClientList[iClientH] == NULL) break;
		for (i = 1; i < DEF_MAXCLIENTS; i++)
			if (   (m_pClientList[i] != NULL) 
				&& (m_pClientList[i]->m_bIsInitComplete == TRUE) 
				&& (m_pClientList[i]->m_cMapIndex == m_pClientList[iClientH]->m_cMapIndex)
				&& (m_pClientList[i]->m_sX > m_pClientList[iClientH]->m_sX - 10) 
				&& (m_pClientList[i]->m_sX < m_pClientList[iClientH]->m_sX + 10)
				&& (m_pClientList[i]->m_sY > m_pClientList[iClientH]->m_sY - 7)
				&& (m_pClientList[i]->m_sY < m_pClientList[iClientH]->m_sY + 7) ) 
			{	iRet = m_pClientList[i]->m_pXSock->iSendMsg(cTemp, dwMsgSize +22); // Not working for self
			}
			break;
	case 1:	// Green (guild)
		for (i = 1; i < DEF_MAXCLIENTS; i++)
		if (m_pClientList[i] != NULL) 
		{	if (m_pClientList[i]->m_bIsInitComplete == FALSE) break;
			if ( (m_pClientList[i]->m_iGuildGUID == iV1) && (m_pClientList[i]->m_iGuildGUID != 0)) 
			{	iRet = m_pClientList[i]->m_pXSock->iSendMsg(cTemp, dwMsgSize +22);
			}
		}
		break;

	case 2:  // red
	case 10: // Light Green (GM)
		for (i = 1; i < DEF_MAXCLIENTS; i++)
		if (m_pClientList[i] != NULL) 
		{	iRet = m_pClientList[i]->m_pXSock->iSendMsg(cTemp, dwMsgSize +22);
		}
		break;
	}
}

/////////////////////////////////////////////////////////////////////////////////////
//  int CGame::iClientMotion_Attack_Handler(int iClientH, short sX, short sY, short dX, short dY, short wType, char cDir, WORD wTargetObjectID, DWORD dwClientTime, DWORD dwMsgTime, BOOL bResponse, BOOL bIsDash, BOOL bIsServerInitiated)
//  description			:: controls player attack
//	return value		:: int
//  last updated		:: October 29, 2004; 8:06 PM; Hypnotoad
//  commentary			:: - contains attack hack detection
//						   - added checks for Firebow and Directionbow to see if player is m_bIsInsideWarehouse, m_bIsInsideWizardTower 
//						   - added ability to attack moving object
//						   - fixed attack unmoving object
/////////////////////////////////////////////////////////////////////////////////////
int CGame::iClientMotion_Attack_Handler(int iClientH, short sX, short sY, short dX, short dY, short wType, char cDir, WORD wTargetObjectID, DWORD dwClientTime, DWORD dwMsgTime, BOOL bResponse, BOOL bIsDash, BOOL bIsServerInitiated)
{char cData[100];
 DWORD * dwp;//, dwTime;
 WORD  * wp;
 int     iRet, iExp, tdX = 0, tdY = 0, i;
 short   sOwner, sAbsX, sAbsY;
 char    cOwnerType;
 BOOL    bNearAttack = FALSE, var_AC = FALSE, bDirArrowNotTgt;
 int	iWeaponFamilly; // by Snoopy
 short sItemIndex;
 int tX, tY, iErr, iStX, iStY;

	if (m_pClientList[iClientH] == NULL) return 0;
	if ((cDir <= 0) || (cDir > 8))       return 0;
	if (m_pClientList[iClientH]->m_bIsInitComplete == FALSE) return 0;
	if (m_pClientList[iClientH]->m_bIsKilled == TRUE) return 0;

	//dwTime = timeGetTime();
	if ((wTargetObjectID != NULL) && (wType != 2)) // not bow
	{	if (wTargetObjectID < DEF_MAXCLIENTS) 
		{	if (m_pClientList[wTargetObjectID] != NULL) 
			{	tdX = m_pClientList[wTargetObjectID]->m_sX;
				tdY = m_pClientList[wTargetObjectID]->m_sY;
			}
		}else if ( (wTargetObjectID > 10000) && (wTargetObjectID < (10000 + DEF_MAXNPCS)) ) 
		{	if (m_pNpcList[wTargetObjectID - 10000] != NULL) 
			{	tdX = m_pNpcList[wTargetObjectID - 10000]->m_sX;
				tdY = m_pNpcList[wTargetObjectID - 10000]->m_sY;
			}
		}
		m_pMapList[ m_pClientList[iClientH]->m_cMapIndex ]->GetOwner(&sOwner, &cOwnerType, dX, dY);
		if(sOwner == (wTargetObjectID - 10000))	// Target is Character
		{	tdX = m_pNpcList[sOwner]->m_sX;
			dX = tdX;
			tdY = m_pNpcList[sOwner]->m_sY;
			dY = tdY;
			bNearAttack = FALSE;
			var_AC = TRUE;
		}
		if (var_AC != TRUE) 						// Target is npc, or has moved
		{	if ((tdX == dX) && (tdY == dY)) 
			{	bNearAttack = FALSE;	
			}else if ((abs(tdX - dX) <= 1) && (abs(tdY - dY) <= 1)) 
			{	dX = tdX;
				dY = tdY;
				bNearAttack = TRUE;					// The npc has moved a bit ( will do 1/2 damage )
			}
			// Snoopy added this to be sure No 1/2 damage attacks on biggest npcs
			if (cOwnerType == DEF_OWNERTYPE_NPC) {
				if (m_pNpcList[sOwner]->m_cArea >0) bNearAttack = FALSE;
	}	}	}
	if ((dX < 0) || (dX >= m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_sSizeX) ||
		(dY < 0) || (dY >= m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_sSizeY)) return 0;
	if ((sX != m_pClientList[iClientH]->m_sX) || (sY != m_pClientList[iClientH]->m_sY)) return 2; // Anti Sniffer hack

	if (m_pMapList[m_pClientList[iClientH]->m_cMapIndex] != NULL) 
	{	iStX = m_pClientList[iClientH]->m_sX / 20;
		iStY = m_pClientList[iClientH]->m_sY / 20;
		m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_stTempSectorInfo[iStX][iStY].iPlayerActivity++;
		switch (m_pClientList[iClientH]->m_cSide) {
		case 1: m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_stTempSectorInfo[iStX][iStY].iAresdenActivity++; break;
		case 2: m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_stTempSectorInfo[iStX][iStY].iElvineActivity++;  break;
		case 4: m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_stTempSectorInfo[iStX][iStY].iExecutorActivity++;break;
		case 0:
		default: m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_stTempSectorInfo[iStX][iStY].iNeutralActivity++; break;
		}
	}

	sItemIndex = m_pClientList[iClientH]->m_sItemEquipmentStatus[ DEF_EQUIPPOS_TWOHAND ];
	if (sItemIndex != -1) 
	{	iWeaponFamilly = 2;				// TWOHAND
	}else
	{	sItemIndex = m_pClientList[iClientH]->m_sItemEquipmentStatus[ DEF_EQUIPPOS_RHAND ];	
		if (sItemIndex != -1)
		{	if (m_pClientList[iClientH]->m_sUsingWeaponSkill == 9)
			{	iWeaponFamilly   = 9;	// Fencing
			}else iWeaponFamilly = 1;	// RHAND
		}else iWeaponFamilly     = 0;	// OpenHand
	}
	if (sItemIndex != -1)
	{	if (m_pClientList[iClientH]->m_pItemList[sItemIndex] == NULL) return 0;
		if (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sIDnum == 845)  // StormBlade
		{	iWeaponFamilly = 845;	// StormBlade
		}
	}
	sAbsX = abs(sX - dX);
	sAbsY = abs(sY - dY);
	if ((wType != 2) && (wType < 20)) // skip the attack if moved away, except if crit. (Snoopy add for single hand weapons)
	{	if (var_AC == FALSE) //target is Npc or has moved
		{	switch (iWeaponFamilly) {
			default:
			case 0: // normal for openHand
			case 1: // Normal reach for 1hd weapons
			case 2: // Normal reach for 2hd weapons
				if ((sAbsX > 1) || (sAbsY > 1)) wType = 0; // cancels attack
				break;
			case 9: // Fencing, extended reach
				if ((sAbsX > 2) || (sAbsY > 2)) wType = 0; // cancels attack
				break;
			case 845: 
				if ((sAbsX > 4) || (sAbsY > 4)) wType = 0; // cancels attack
				break;
			}
		}else
		{	cDir = m_Misc.cGetNextMoveDir(sX, sY, dX, dY);
			if ((m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->bCheckFlySpaceAvailable(sX, sY, cDir, sOwner)) != FALSE)
				wType = 0; // cancels attack
		}
	}
	if ((iWeaponFamilly = 845) && (wType != 0) && (m_pClientList[iClientH]->m_IsPeaceMode == FALSE))
	{	bRegisterDelayEvent(DEF_DELAYEVENTTYPE_STORMBLADE, NULL, dwMsgTime + 500, iClientH, DEF_OWNERTYPE_PLAYER
			, m_pClientList[iClientH]->m_cMapIndex, dX, dY, 0, 0, 0);
	}
	ClearSkillUsingStatus(iClientH);
	m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->ClearOwner(0, iClientH, DEF_OWNERTYPE_PLAYER, sX, sY);
	m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->SetOwner(iClientH, DEF_OWNERTYPE_PLAYER, sX, sY);
	m_pClientList[iClientH]->m_cDir = cDir;
	iExp = 0;
	m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetOwner(&sOwner, &cOwnerType, dX, dY);		
	if (sOwner != NULL) // no 2 attacks possible in less than 100ms (server side,
	// changed m_dwRecentAttackTime to use client time...
	{	if ((wType != 0) && ((dwClientTime - m_pClientList[iClientH]->m_dwRecentAttackTime) > 200))  
		{	if (   (m_pClientList[iClientH]->m_pIsProcessingAllowed == FALSE) && (m_pClientList[iClientH]->m_bIsInsideWarehouse == FALSE) 
				&& (m_pClientList[iClientH]->m_bIsInsideWizardTower == FALSE) ) 
			{	sItemIndex = m_pClientList[iClientH]->m_sItemEquipmentStatus[DEF_EQUIPPOS_TWOHAND];
				if (sItemIndex != -1 && m_pClientList[iClientH]->m_pItemList[sItemIndex] != NULL) 
				{	if(m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sIDnum == 874) // Directional bow
					{	for(i = 1; i < 12; i++)// Arrows on the way
						{	iErr = 0;					
							m_Misc.GetPoint2(sX, sY, dX, dY, &tX, &tY, &iErr, i);
							if ((dX==tX) && (dY==tY))	bDirArrowNotTgt = FALSE;
							else  bDirArrowNotTgt = TRUE;
							m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetOwner(&sOwner, &cOwnerType, tX, tY);
							iExp += iCalculateAttackEffect(sOwner, cOwnerType, iClientH, DEF_OWNERTYPE_PLAYER, tX, tY, wType, bNearAttack, bIsDash, bDirArrowNotTgt, FALSE); // 1
							if (wType>=20)
							{	m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetOwner(&sOwner, &cOwnerType, tX+1, tY);
								iExp += iCalculateAttackEffect(sOwner, cOwnerType, iClientH, DEF_OWNERTYPE_PLAYER, tX+1, tY, wType, bNearAttack, bIsDash, TRUE, FALSE); // 1
								m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetOwner(&sOwner, &cOwnerType, tX-1, tY);
								iExp += iCalculateAttackEffect(sOwner, cOwnerType, iClientH, DEF_OWNERTYPE_PLAYER, tX-1, tY, wType, bNearAttack, bIsDash, TRUE, FALSE); // 1
								m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetOwner(&sOwner, &cOwnerType, tX, tY+1);
								iExp += iCalculateAttackEffect(sOwner, cOwnerType, iClientH, DEF_OWNERTYPE_PLAYER, tX, tY+1, wType, bNearAttack, bIsDash, TRUE, FALSE); // 1
								m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetOwner(&sOwner, &cOwnerType, tX, tY-1);
								iExp += iCalculateAttackEffect(sOwner, cOwnerType, iClientH, DEF_OWNERTYPE_PLAYER, tX, tY-1, wType, bNearAttack, bIsDash, TRUE, FALSE); // 1
							}
						//	if ( (abs(tX - dX) <= 1) && (abs(tY - dY) <= 1)) break;
						}
						// Arrow on target
						//	m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetOwner(&sOwner, &cOwnerType, dX, dY);
						//	iExp += iCalculateAttackEffect(sOwner, cOwnerType, iClientH, DEF_OWNERTYPE_PLAYER, dX, dY, wType, bNearAttack, bIsDash, FALSE, FALSE); // 0
					}else if(m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sIDnum == 873) // Firebow
					{	if (m_pClientList[iClientH]->m_IsPeaceMode == FALSE)
						{	//if (m_bHeldenianWarInitiated != TRUE) 
							{	iAddDynamicObjectList(iClientH, DEF_OWNERTYPE_PLAYER_INDIRECT, DEF_DYNAMICOBJECT_FIRE3, m_pClientList[iClientH]->m_cMapIndex, dX, dY, (iDice(1,7)+3)*1000, 8);
							}							
							// Firebow "normal" damage
							iExp += iCalculateAttackEffect(sOwner, cOwnerType, iClientH, DEF_OWNERTYPE_PLAYER, dX, dY, wType, bNearAttack, bIsDash, FALSE, FALSE); // 0
						}
					}else if(m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sIDnum == 936) // StormBow
					{	if (m_pClientList[iClientH]->m_IsPeaceMode == FALSE) 
						{	//if (m_bHeldenianWarInitiated != TRUE) 
							{	if ((wType>= 20)||(iDice(1,3)==2))
									iAddDynamicObjectList(iClientH, DEF_OWNERTYPE_PLAYER_INDIRECT, DEF_DYNAMICOBJECT_ICESTORM, m_pClientList[iClientH]->m_cMapIndex, dX, dY, (iDice(1,7)+3)*1000, 8);
							}							
							// Stormbow "normal" damage
							iExp += iCalculateAttackEffect(sOwner, cOwnerType, iClientH, DEF_OWNERTYPE_PLAYER, dX, dY, wType, bNearAttack, bIsDash, FALSE, FALSE); // 0
						}
					}else // 2hands weapon damage
					{	iExp += iCalculateAttackEffect(sOwner, cOwnerType, iClientH, DEF_OWNERTYPE_PLAYER, dX, dY, wType, bNearAttack, bIsDash, FALSE, FALSE); // 0
					}
				}else // Single hand weapon damage
				{	iExp += iCalculateAttackEffect(sOwner, cOwnerType, iClientH, DEF_OWNERTYPE_PLAYER, dX, dY, wType, bNearAttack, bIsDash, FALSE, FALSE); // 0
				}
			}else // Misc impossibilities against Fire/direction bows -> "normal" damge for those weapons
			{	iExp += iCalculateAttackEffect(sOwner, cOwnerType, iClientH, DEF_OWNERTYPE_PLAYER, dX, dY, wType, bNearAttack, bIsDash, FALSE, FALSE); // 0
			}
			if (m_pClientList[iClientH] == NULL) return 0;
			m_pClientList[iClientH]->m_dwRecentAttackTime = dwClientTime;
		}
	}else _CheckMiningAction(iClientH, dX, dY);
	if (iExp != 0) {
		GetExp(iClientH, iExp, TRUE);
	}
	if (bResponse == TRUE) {
		dwp  = (DWORD *)(cData + DEF_INDEX4_MSGID);
		*dwp = MSGID_RESPONSE_MOTION;
		wp   = (WORD *)(cData + DEF_INDEX2_MSGTYPE);
		*wp  = DEF_OBJECTMOTION_ATTACK_CONFIRM;	
		iRet = m_pClientList[iClientH]->m_pXSock->iSendMsg(cData, 6);
		switch (iRet) {
		case DEF_XSOCKEVENT_QUENEFULL:
		case DEF_XSOCKEVENT_SOCKETERROR:
		case DEF_XSOCKEVENT_CRITICALERROR:
		case DEF_XSOCKEVENT_SOCKETCLOSED:
			DeleteClient(iClientH, TRUE, TRUE);
			return 0;
		}
	}
	return 1;
}

char CGame::cGetNextMoveDir(short sX, short sY, short dstX, short dstY, char cMapIndex, char cTurn, int * pError)
{
 register char  cDir, cTmpDir;
 register int   aX, aY, dX, dY;
 register int   i, iResX, iResY;

	if ((sX == dstX) && (sY == dstY)) return 0;

	dX = sX;
	dY = sY;
 
	if ((abs(dX - dstX) <= 1) && (abs(dY - dstY) <= 1)) {
		iResX = dstX;
		iResY = dstY;
	}else m_Misc.GetPoint(dX, dY, dstX, dstY, &iResX, &iResY, pError);

	cDir = m_Misc.cGetNextMoveDir(dX, dY, iResX, iResY);

	if (cTurn == 0)
	for (i = cDir; i <= cDir + 7;i++) {
		cTmpDir = i;
		if (cTmpDir > 8) cTmpDir -= 8;
		aX = _tmp_cTmpDirX[cTmpDir];
		aY = _tmp_cTmpDirY[cTmpDir];
		if (m_pMapList[cMapIndex]->bGetMoveable(dX + aX, dY + aY) == TRUE) return cTmpDir;
	}

	if (cTurn == 1)
	for (i = cDir; i >= cDir - 7;i--) {
		cTmpDir = i;
		if (cTmpDir < 1) cTmpDir += 8;
		aX = _tmp_cTmpDirX[cTmpDir];
		aY = _tmp_cTmpDirY[cTmpDir];
		if (m_pMapList[cMapIndex]->bGetMoveable(dX + aX, dY + aY) == TRUE) return cTmpDir;
	}

	return 0;
}


char _tmp_cEmptyPosX[] = { 0, 1, 1, 0, -1, -1, -1, 0 ,1, 2, 2, 2, 2, 1, 0, -1, -2, -2, -2, -2, -2, -1, 0, 1, 2 };
char _tmp_cEmptyPosY[] = { 0, 0, 1, 1, 1, 0, -1, -1, -1, -1, 0, 1, 2, 2, 2, 2, 2, 1, 0, -1, -2, -2, -2, -2, -2 };

BOOL CGame::bGetEmptyPosition(short * pX, short * pY, char cMapIndex)
{register int i;
 short sX, sY;	
	for (i = 0; i < 25; i++) 
	if ( (m_pMapList[cMapIndex]->bGetMoveable(*pX + _tmp_cEmptyPosX[i], *pY + _tmp_cEmptyPosY[i]) == TRUE) &&
		 (m_pMapList[cMapIndex]->bGetIsTeleport(*pX + _tmp_cEmptyPosX[i], *pY + _tmp_cEmptyPosY[i]) == FALSE) ) {
		sX = *pX + _tmp_cEmptyPosX[i];
		sY = *pY + _tmp_cEmptyPosY[i];	
		*pX = sX;
		*pY = sY;
		return TRUE;
	}
	GetMapInitialPoint(cMapIndex, &sX, &sY);
	*pX = sX;
	*pY = sY;
	return FALSE;
}

void CGame::NpcBehavior_Move(int iNpcH)
{char  cDir;
 short sX, sY, dX, dY, absX, absY;
 short sTarget, sDistance;
 char  cTargetType;	
	if (m_pNpcList[iNpcH] == NULL) return;
	if (m_pNpcList[iNpcH]->m_bIsKilled == TRUE) return;
	if (   (m_pNpcList[iNpcH]->m_bIsSummoned == TRUE) 
		&& (m_pNpcList[iNpcH]->m_iSummonControlMode == 1)) return;

	// Tammed mobs
	if (   (m_pNpcList[iNpcH]->m_dwTamingTime != 0) 
		&& (m_pNpcList[iNpcH]->m_iSummonControlMode == 1)) return;

	if (m_pNpcList[iNpcH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_HOLDOBJECT ] != 0) return;
	switch (m_pNpcList[iNpcH]->m_cActionLimit) {
	case 2: // fixed merchants
	case 3: // dummy
	case 5: // struct sade crops
	case 8: // Heldenian gates
		m_pNpcList[iNpcH]->m_cBehavior          = DEF_BEHAVIOR_STOP;
		m_pNpcList[iNpcH]->m_sBehaviorTurnCount = 0;	
		return;
	}	
	int iStX, iStY;
	if (m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex] != NULL) 
	{	iStX = m_pNpcList[iNpcH]->m_sX / 20;
		iStY = m_pNpcList[iNpcH]->m_sY / 20;
		m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->m_stTempSectorInfo[iStX][iStY].iMonsterActivity++;  
	}
	m_pNpcList[iNpcH]->m_sBehaviorTurnCount++;
	if (m_pNpcList[iNpcH]->m_sBehaviorTurnCount > 5) 
	{	m_pNpcList[iNpcH]->m_sBehaviorTurnCount = 0;		
		absX = abs(m_pNpcList[iNpcH]->m_vX - m_pNpcList[iNpcH]->m_sX);
		absY = abs(m_pNpcList[iNpcH]->m_vY - m_pNpcList[iNpcH]->m_sY);		
		if ((absX <= 2)	&& (absY <= 2)) 
		{	CalcNextWayPointDestination(iNpcH);
		}
		m_pNpcList[iNpcH]->m_vX = m_pNpcList[iNpcH]->m_sX;
		m_pNpcList[iNpcH]->m_vY = m_pNpcList[iNpcH]->m_sY;
	}
	TargetSearch(iNpcH, &sTarget, &cTargetType);				
	if (sTarget != NULL) 
	{	if (m_pNpcList[iNpcH]->m_dwActionTime < 1000) 
		{	if (iDice(1,3) == 3) 
			{	m_pNpcList[iNpcH]->m_cBehavior          = DEF_BEHAVIOR_ATTACK;
				m_pNpcList[iNpcH]->m_sBehaviorTurnCount = 0;		
				m_pNpcList[iNpcH]->m_iTargetIndex = sTarget;
				m_pNpcList[iNpcH]->m_cTargetType  = cTargetType;
				return;
			}
		}else 
		{	m_pNpcList[iNpcH]->m_cBehavior          = DEF_BEHAVIOR_ATTACK;
			m_pNpcList[iNpcH]->m_sBehaviorTurnCount = 0;		
			m_pNpcList[iNpcH]->m_iTargetIndex = sTarget;
			m_pNpcList[iNpcH]->m_cTargetType  = cTargetType;
			return;
		}
	}
	if ((m_pNpcList[iNpcH]->m_bIsMaster == TRUE) && (iDice(1,3) == 2)) return;	
	if (m_pNpcList[iNpcH]->m_cMoveType == DEF_MOVETYPE_FOLLOW) 
	{	sX = m_pNpcList[iNpcH]->m_sX;
		sY = m_pNpcList[iNpcH]->m_sY;
		switch (m_pNpcList[iNpcH]->m_cFollowOwnerType) {
		case DEF_OWNERTYPE_PLAYER_FREE: // Waiting for someone to control him
				m_pNpcList[iNpcH]->m_cMoveType = DEF_MOVETYPE_RANDOM;
				m_pNpcList[iNpcH]->m_iFollowOwnerIndex = NULL;
				return;
		case DEF_OWNERTYPE_PLAYER_WAITING: // Waiting for a character de reconnect, should be useless, here for safety
				m_pNpcList[iNpcH]->m_iFollowOwnerIndex = NULL;
				m_pNpcList[iNpcH]->m_cMoveType		   = DEF_MOVETYPE_RANDOM;
				return;
		case DEF_OWNERTYPE_PLAYER:
			if (m_pClientList[m_pNpcList[iNpcH]->m_iFollowOwnerIndex] == NULL) // Should not happen, because removeFromTarget should be called before
			{	m_pNpcList[iNpcH]->m_cFollowOwnerType  = DEF_OWNERTYPE_PLAYER_WAITING;
				m_pNpcList[iNpcH]->m_iFollowOwnerIndex = NULL;
				m_pNpcList[iNpcH]->m_dwSummonWaitTime  = timeGetTime();
				m_pNpcList[iNpcH]->m_cMoveType		   = DEF_MOVETYPE_RANDOM;
				return;
			}
			dX = m_pClientList[m_pNpcList[iNpcH]->m_iFollowOwnerIndex]->m_sX;
			dY = m_pClientList[m_pNpcList[iNpcH]->m_iFollowOwnerIndex]->m_sY;
			break;
		case DEF_OWNERTYPE_NPC:
			if (m_pNpcList[m_pNpcList[iNpcH]->m_iFollowOwnerIndex] == NULL) 
			{	m_pNpcList[iNpcH]->m_cMoveType = DEF_MOVETYPE_RANDOM;
				m_pNpcList[iNpcH]->m_iFollowOwnerIndex = NULL;
				m_pNpcList[iNpcH]->m_cFollowOwnerType  = NULL;
				return;
			}			
			dX = m_pNpcList[m_pNpcList[iNpcH]->m_iFollowOwnerIndex]->m_sX;
			dY = m_pNpcList[m_pNpcList[iNpcH]->m_iFollowOwnerIndex]->m_sY;
			break;
		}
		if (abs(sX - dX) >= abs(sY - dY)) 
			 sDistance = abs(sX - dX);
		else sDistance = abs(sY - dY);
		if (sDistance >= 3) 
		{	cDir = cGetNextMoveDir(sX, sY, dX, dY, m_pNpcList[iNpcH]->m_cMapIndex, m_pNpcList[iNpcH]->m_cTurn, &m_pNpcList[iNpcH]->m_tmp_iError);
			if (cDir == 0) 
			{}else 
			{	dX = m_pNpcList[iNpcH]->m_sX + _tmp_cTmpDirX[cDir];
				dY = m_pNpcList[iNpcH]->m_sY + _tmp_cTmpDirY[cDir];
				m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->ClearOwner(3, iNpcH, DEF_OWNERTYPE_NPC, m_pNpcList[iNpcH]->m_sX, m_pNpcList[iNpcH]->m_sY);
				m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->SetOwner(iNpcH, DEF_OWNERTYPE_NPC, dX, dY);
				m_pNpcList[iNpcH]->m_sX   = dX;
				m_pNpcList[iNpcH]->m_sY   = dY;
				m_pNpcList[iNpcH]->m_cDir = cDir;
				SendEventToNearClient_TypeA(iNpcH, DEF_OWNERTYPE_NPC, MSGID_EVENT_MOTION, DEF_OBJECTMOVE, NULL, NULL, NULL);
			}
		}
	}else 
	{	cDir = cGetNextMoveDir(m_pNpcList[iNpcH]->m_sX, m_pNpcList[iNpcH]->m_sY, 
			                   m_pNpcList[iNpcH]->m_dX, m_pNpcList[iNpcH]->m_dY, 
				     	       m_pNpcList[iNpcH]->m_cMapIndex, m_pNpcList[iNpcH]->m_cTurn, &m_pNpcList[iNpcH]->m_tmp_iError);
		if (cDir == 0) 		
		{	if (iDice(1,10) == 3) CalcNextWayPointDestination(iNpcH);
		}else 
		{	dX = m_pNpcList[iNpcH]->m_sX + _tmp_cTmpDirX[cDir];
			dY = m_pNpcList[iNpcH]->m_sY + _tmp_cTmpDirY[cDir];
			m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->ClearOwner(4, iNpcH, DEF_OWNERTYPE_NPC, m_pNpcList[iNpcH]->m_sX, m_pNpcList[iNpcH]->m_sY);
			m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->SetOwner(iNpcH, DEF_OWNERTYPE_NPC, dX, dY);
			m_pNpcList[iNpcH]->m_sX   = dX;
			m_pNpcList[iNpcH]->m_sY   = dY;
			m_pNpcList[iNpcH]->m_cDir = cDir;
			SendEventToNearClient_TypeA(iNpcH, DEF_OWNERTYPE_NPC, MSGID_EVENT_MOTION, DEF_OBJECTMOVE, NULL, NULL, NULL);
		}
	}
}
void CGame::FarTargetSearch(int iNpcH, short * pTarget, char * pTargetType)
{register int ix, iy, iPKCount;
 register short sX, sY, rX, rY, dX, dY;
 short sOwner, sTargetOwner, sDistance, sTempDistance;
 char  cOwnerType, cTargetType, cTargetSide = 10;
 int   iInv = 0;
	sTargetOwner = NULL;
	cTargetType  = NULL;
	sDistance    = 0;
	sX = m_pNpcList[iNpcH]->m_sX;
	sY = m_pNpcList[iNpcH]->m_sY;
	rX = m_pNpcList[iNpcH]->m_sX - m_pNpcList[iNpcH]->m_iAttackRange;
	rY = m_pNpcList[iNpcH]->m_sY - m_pNpcList[iNpcH]->m_iAttackRange;	
	for (ix = rX; ix < rX + m_pNpcList[iNpcH]->m_iAttackRange*2 + 1; ix++)
	for (iy = rY; iy < rY + m_pNpcList[iNpcH]->m_iAttackRange*2 + 1; iy++) 		
	{	m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->GetOwner(&sOwner, &cOwnerType, ix, iy);
		if (sOwner != NULL) 			
		{	if ((sOwner == iNpcH) && (cOwnerType == DEF_OWNERTYPE_NPC))							goto SKIP_SEARCH;
			iPKCount = 0;	
			switch (cOwnerType) {
			case DEF_OWNERTYPE_PLAYER:
				if (m_pClientList[sOwner] == NULL) 
				{	m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->ClearOwner(5, sOwner, DEF_OWNERTYPE_PLAYER, ix, iy);
				}else  
				{	if (m_pClientList[sOwner]->m_iAdminUserLevel != 0)							goto SKIP_SEARCH;
					if (   (m_pClientList[sOwner]->m_cMagicEffectStatus[DEF_MAGICTYPE_REFLEXION] == 2)
						&& (iDice(1,18) <= (m_pNpcList[iNpcH]->m_cMagicLevel+3)) )				goto SKIP_SEARCH;
					dX = m_pClientList[sOwner]->m_sX;
					dY = m_pClientList[sOwner]->m_sY;
					cTargetSide = m_pClientList[sOwner]->m_cSide;
					iPKCount    = m_pClientList[sOwner]->m_iPKCount;
					iInv        = m_pClientList[sOwner]->m_cMagicEffectStatus[ DEF_MAGICTYPE_INVISIBILITY ];
				}
				break;
			case DEF_OWNERTYPE_NPC:
				if (m_pNpcList[sOwner] == NULL) // Remove tile owner if wrong					
				{	m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->ClearOwner(6, sOwner, DEF_OWNERTYPE_NPC, ix, iy);
				}else 
				{	dX = m_pNpcList[sOwner]->m_sX;
					dY = m_pNpcList[sOwner]->m_sY;
					cTargetSide = m_pNpcList[sOwner]->m_cSide;
					iPKCount    = 0;
					iInv        = m_pNpcList[sOwner]->m_cMagicEffectStatus[ DEF_MAGICTYPE_INVISIBILITY ];
					if (m_pNpcList[iNpcH]->m_sType == 21) 	// Guards will not target if player arround 					
					{	if (_iCalcPlayerNum(m_pNpcList[sOwner]->m_cMapIndex, dX, dY, 2) != 0) 
						{	sOwner     = NULL;
							cOwnerType = NULL;
				}	}	}
				break;
			}						
			if (m_pNpcList[iNpcH]->m_cSide < 10) 
			{	if ((cTargetSide == 0)||(cTargetSide == 3)) 
				{	if (   (iPKCount == 0) || (m_pNpcList[iNpcH]->m_cSide != 4))					goto SKIP_SEARCH;
				}else 
				{   if ((m_pNpcList[iNpcH]->m_cSide == cTargetSide) && (iPKCount == 0))				goto SKIP_SEARCH;
					if (m_pNpcList[iNpcH]->m_cSide == 0)											goto SKIP_SEARCH;
					if ((m_pNpcList[iNpcH]->m_cSide == 3) && (iPKCount == 0) && (cTargetSide < 4))	goto SKIP_SEARCH;
					if ((m_pNpcList[iNpcH]->m_cSide == 4) && (cTargetSide == 10))					goto SKIP_SEARCH;
				}
			}else // n°10 mobs
			{	if ((cOwnerType == DEF_OWNERTYPE_NPC) && (cTargetSide == 0))						goto SKIP_SEARCH;
				if ((cOwnerType == DEF_OWNERTYPE_NPC) && (cTargetSide == 4))						goto SKIP_SEARCH;
				if (cTargetSide == m_pNpcList[iNpcH]->m_cSide)										goto SKIP_SEARCH;
			}
			if ((iInv != 0) && (m_pNpcList[iNpcH]->m_cSpecialAbility != 1))							goto SKIP_SEARCH;
			if (abs(sX - dX) >= abs(sY - dY)) 
				 sTempDistance = abs(sX - dX);
			else sTempDistance = abs(sY - dY);
			if (sTempDistance >	sDistance) // Looks for the closest target
			{	sDistance = sTempDistance;
				sTargetOwner = sOwner;
				cTargetType  = cOwnerType;
				if (   (sTempDistance == m_pNpcList[iNpcH]->m_iAttackRange)
					&& (iDice(1,4) == 2)) // 1/4 chance to take this else look for another one in rsame range
				{	*pTarget     = sTargetOwner;
					*pTargetType = cTargetType;
					return;
			}	}
SKIP_SEARCH:;	
	}	}
	*pTarget     = sTargetOwner;
	*pTargetType = cTargetType;
	return;
}

void CGame::TargetSearch(int iNpcH, short * pTarget, char * pTargetType)
{register int ix, iy, iPKCount;
 register short sX, sY, rX, rY, dX, dY;
 short sOwner, sTargetOwner, sDistance, sTempDistance;
 char  cOwnerType, cTargetType, cTargetSide = 10;
 int   iInv = 0;
	sTargetOwner = NULL;
	cTargetType  = NULL;
	sDistance    = 100;
	sX = m_pNpcList[iNpcH]->m_sX;
	sY = m_pNpcList[iNpcH]->m_sY;
	rX = m_pNpcList[iNpcH]->m_sX - m_pNpcList[iNpcH]->m_cTargetSearchRange;
	rY = m_pNpcList[iNpcH]->m_sY - m_pNpcList[iNpcH]->m_cTargetSearchRange;	
	for (ix = rX; ix < rX + m_pNpcList[iNpcH]->m_cTargetSearchRange*2 + 1; ix++)
	for (iy = rY; iy < rY + m_pNpcList[iNpcH]->m_cTargetSearchRange*2 + 1; iy++) 		
	{	m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->GetOwner(&sOwner, &cOwnerType, ix, iy);
		if (sOwner != NULL) 			
		{	if ((sOwner == iNpcH) && (cOwnerType == DEF_OWNERTYPE_NPC)) goto SKIP_SEARCH;// Do not find self ! 
			iPKCount = 0;											// Was break; (do not search below the mob !)		
			switch (cOwnerType) {
			case DEF_OWNERTYPE_PLAYER:
				if (m_pClientList[sOwner] == NULL) 
				{	m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->ClearOwner(5, sOwner, DEF_OWNERTYPE_PLAYER, ix, iy);
				}else  
				{	// Do no target GM 
					if (m_pClientList[sOwner]->m_iAdminUserLevel != 0) goto SKIP_SEARCH;
					// BloodyMantle spell
					if (   (m_pClientList[sOwner]->m_cMagicEffectStatus[DEF_MAGICTYPE_REFLEXION] == 2)
						&& (iDice(1,18) <= (m_pNpcList[iNpcH]->m_cMagicLevel+3)) ) goto SKIP_SEARCH;
					dX = m_pClientList[sOwner]->m_sX;
					dY = m_pClientList[sOwner]->m_sY;
					cTargetSide = m_pClientList[sOwner]->m_cSide;
					iPKCount    = m_pClientList[sOwner]->m_iPKCount;
					iInv        = m_pClientList[sOwner]->m_cMagicEffectStatus[ DEF_MAGICTYPE_INVISIBILITY ];
				}
				break;

			case DEF_OWNERTYPE_NPC:
				if (m_pNpcList[sOwner] == NULL) // Remove tile owner if wrong					
				{	m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->ClearOwner(6, sOwner, DEF_OWNERTYPE_NPC, ix, iy);
				}else 
				{	dX = m_pNpcList[sOwner]->m_sX;
					dY = m_pNpcList[sOwner]->m_sY;
					cTargetSide = m_pNpcList[sOwner]->m_cSide;
					iPKCount    = 0;
					iInv        = m_pNpcList[sOwner]->m_cMagicEffectStatus[ DEF_MAGICTYPE_INVISIBILITY ];
					if (m_pNpcList[iNpcH]->m_sType == 21) 	// Guards will not target if player arround 					
					{	if (_iCalcPlayerNum(m_pNpcList[sOwner]->m_cMapIndex, dX, dY, 2) != 0) 
						{	sOwner     = NULL;
							cOwnerType = NULL;
				}	}	}
				break;
			}
			
			// SNOOPY: Added definition for a "3" side npc:
			// 3 sided npcs will attack monsters but neither Ares nor Elvines nor Travellers not type 3 npcs
				
			if (m_pNpcList[iNpcH]->m_cSide < 10) 
			{	// npc side -1 to 9 will not attack Travellers or n°3 nps (unless they're criminals as well)
				if ((cTargetSide == 0)||(cTargetSide == 3)) 
				{	// npc side -1 to 9 will attack Criminal from n°3 npc or Traveller side	
					// npc side 4       will attack side 3 guards
					if (   (iPKCount == 0)
						|| (m_pNpcList[iNpcH]->m_cSide != 4)) goto SKIP_SEARCH;
				}else 
				{   // dont attack same side unless criminals
					if ((m_pNpcList[iNpcH]->m_cSide == cTargetSide) && (iPKCount == 0)) goto SKIP_SEARCH;
					// Neutral npc will never attack (unless Travelers criminals above)
					if (m_pNpcList[iNpcH]->m_cSide == 0) goto SKIP_SEARCH;
					// n°3 npcs will never attack 0,1,2,3 unless criminals
					if ((m_pNpcList[iNpcH]->m_cSide == 3) && (iPKCount == 0) && (cTargetSide < 4)) goto SKIP_SEARCH;
					// n°4 monsters will never attack 10 
					if ((m_pNpcList[iNpcH]->m_cSide == 4) && (cTargetSide == 10)) goto SKIP_SEARCH;

				}
			}else 
			{	// monsters will not attack Travellers if a master monster is here
				if ((cOwnerType == DEF_OWNERTYPE_NPC) && (cTargetSide == 0)) goto SKIP_SEARCH;
				// n°10 monster will not attack n°4 monsters
				if ((cOwnerType == DEF_OWNERTYPE_NPC) && (cTargetSide == 4)) goto SKIP_SEARCH;
				// Don't attack same side
				if (cTargetSide == m_pNpcList[iNpcH]->m_cSide) goto SKIP_SEARCH;
			}
/* Old routine
			if (m_pNpcList[iNpcH]->m_cSide < 10) {
				// npc side -1 to 9 will not attack Travellers (unless they're crimals as well)
				if (cTargetSide == 0) {
					if (iPKCount == 0) goto SKIP_SEARCH;
				}	else { // Side
					if ((iPKCount == 0) && (cTargetSide == m_pNpcList[iNpcH]->m_cSide)) goto SKIP_SEARCH;
					//
					if (m_pNpcList[iNpcH]->m_cSide == 0) goto SKIP_SEARCH;
				}
			}else {
				// 
				if ((cOwnerType == DEF_OWNERTYPE_NPC) && (cTargetSide == 0)) goto SKIP_SEARCH;
				if (cTargetSide == m_pNpcList[iNpcH]->m_cSide) goto SKIP_SEARCH;
			}*/
			//  INVISIBILITY
			if ((iInv != 0) && (m_pNpcList[iNpcH]->m_cSpecialAbility != 1)) goto SKIP_SEARCH;
			if (abs(sX - dX) >= abs(sY - dY)) 
				 sTempDistance = abs(sX - dX);
			else sTempDistance = abs(sY - dY);
			if (sTempDistance <	sDistance) // Looks for the closest target
			{	sDistance = sTempDistance;
				sTargetOwner = sOwner;
				cTargetType  = cOwnerType;
			}
SKIP_SEARCH:;	
	}	}
	*pTarget     = sTargetOwner;
	*pTargetType = cTargetType;
	return;
}

void CGame::NpcBehavior_Attack(int iNpcH)
{
 int   iMagicType;
 short sX, sY, dX, dY;
 char  cDir;
 short sTarget;
 char cTargetType;
 DWORD dwTime = timeGetTime();
	if (m_pNpcList[iNpcH] == NULL) return;
 	if (m_pNpcList[iNpcH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_HOLDOBJECT ] != 0) return;
	if (m_pNpcList[iNpcH]->m_bIsKilled == TRUE) return;	
	switch (m_pNpcList[iNpcH]->m_cActionLimit) {
	case 2: // fixed merchants
	case 3: // Dummy
	case 4:	// EnergySphere
	case 6: // moving merchant
	case 8: // Heldenian gate
		return;
		break;
	case 5: // Fixed but attacking
		if (m_pNpcList[iNpcH]->m_iBuildCount > 0) return;
		break;
	}
	int iStX, iStY;
	if (m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex] != NULL) {
		iStX = m_pNpcList[iNpcH]->m_sX / 20;
		iStY = m_pNpcList[iNpcH]->m_sY / 20;
		m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->m_stTempSectorInfo[iStX][iStY].iMonsterActivity++;  
	}
	if (m_pNpcList[iNpcH]->m_sBehaviorTurnCount == 0) 
		m_pNpcList[iNpcH]->m_iAttackCount = 0;
	m_pNpcList[iNpcH]->m_sBehaviorTurnCount++;
	if (m_pNpcList[iNpcH]->m_sBehaviorTurnCount > 20)		// Every 20 BehaviorTurn, move, but if someone hits the mob before
	{	m_pNpcList[iNpcH]->m_sBehaviorTurnCount = 0;		// another target is selected, will return to current target
		if ((m_pNpcList[iNpcH]->m_bIsPermAttackMode == FALSE))
			m_pNpcList[iNpcH]->m_cBehavior    = DEF_BEHAVIOR_MOVE;
		return;
	}
	sX = m_pNpcList[iNpcH]->m_sX;
	sY = m_pNpcList[iNpcH]->m_sY;	
	switch (m_pNpcList[iNpcH]->m_cTargetType) {
	case DEF_OWNERTYPE_PLAYER:
		if (m_pClientList[m_pNpcList[iNpcH]->m_iTargetIndex] == NULL) 
		{	m_pNpcList[iNpcH]->m_sBehaviorTurnCount = 0;
			m_pNpcList[iNpcH]->m_cBehavior    = DEF_BEHAVIOR_MOVE;
			return;
		}
		// Stop attack if Reflexion aura....Intelligence of npc is his MagicLevel
		if (   (m_pClientList[m_pNpcList[iNpcH]->m_iTargetIndex]->m_cMagicEffectStatus[DEF_MAGICTYPE_REFLEXION] == 2)
			&& (iDice(1,15) < m_pNpcList[iNpcH]->m_cMagicLevel))
		{	m_pNpcList[iNpcH]->m_sBehaviorTurnCount = 0;
			m_pNpcList[iNpcH]->m_cBehavior    = DEF_BEHAVIOR_FLEE;
			return;
		}
		dX = m_pClientList[m_pNpcList[iNpcH]->m_iTargetIndex]->m_sX;
		dY = m_pClientList[m_pNpcList[iNpcH]->m_iTargetIndex]->m_sY;
		break;
	
	case DEF_OWNERTYPE_NPC:
		if (m_pNpcList[m_pNpcList[iNpcH]->m_iTargetIndex] == NULL) 
		{	m_pNpcList[iNpcH]->m_sBehaviorTurnCount = 0;
			m_pNpcList[iNpcH]->m_cBehavior    = DEF_BEHAVIOR_MOVE;
			return;
		}
		dX = m_pNpcList[m_pNpcList[iNpcH]->m_iTargetIndex]->m_sX;
		dY = m_pNpcList[m_pNpcList[iNpcH]->m_iTargetIndex]->m_sY;
		break;
	}
	if (   (m_pNpcList[iNpcH]->m_cBravery < 30) // Skip for mobs with high Bravery (30+ is not possible)
		&& (m_pNpcList[iNpcH]->m_cActionLimit == 0)
		&& (m_pNpcList[iNpcH]->m_bIsPermAttackMode == FALSE) 
		&& (iGetDangerValue(iNpcH, dX, dY) > m_pNpcList[iNpcH]->m_cBravery)  ) 
	{	m_pNpcList[iNpcH]->m_sBehaviorTurnCount = 0;		
		m_pNpcList[iNpcH]->m_cBehavior          = DEF_BEHAVIOR_FLEE;
		return;
	}
	if (   (m_pNpcList[iNpcH]->m_iHP <= m_pNpcList[iNpcH]->m_cBravery) 
		&& (iDice(1,m_pNpcList[iNpcH]->m_cBravery) <= 3)
		&& (m_pNpcList[iNpcH]->m_cActionLimit == 0)
		&& (m_pNpcList[iNpcH]->m_bIsPermAttackMode == FALSE) ) 
	{	m_pNpcList[iNpcH]->m_sBehaviorTurnCount = 0;		
		m_pNpcList[iNpcH]->m_cBehavior          = DEF_BEHAVIOR_FLEE;
		return;
	}
 
	if ((abs(sX - dX) <= 1) && (abs(sY - dY) <= 1)) 		
	{	// Target is close from attacker
		cDir = m_Misc.cGetNextMoveDir(sX, sY, dX, dY);
		if (cDir == 0) return;
		m_pNpcList[iNpcH]->m_cDir = cDir;
		if (m_pNpcList[iNpcH]->m_cActionLimit == 5) 
		{	switch (m_pNpcList[iNpcH]->m_sType) {
			case 89: // AGT
				SendEventToNearClient_TypeA(iNpcH, DEF_OWNERTYPE_NPC, MSGID_EVENT_MOTION, DEF_OBJECTATTACK, dX, dY, 1); 
				m_pNpcList[iNpcH]->m_iMagicHitRatio = 1000;
				NpcMagicHandler(iNpcH, dX, dY, 61);
				break;
			case 87: // CT
				SendEventToNearClient_TypeA(iNpcH, DEF_OWNERTYPE_NPC, MSGID_EVENT_MOTION, DEF_OBJECTATTACK, dX, dY, 2); 
				iCalculateAttackEffect(m_pNpcList[iNpcH]->m_iTargetIndex, m_pNpcList[iNpcH]->m_cTargetType, iNpcH, DEF_OWNERTYPE_NPC, dX, dY, 2, FALSE, FALSE, FALSE, FALSE);
				break;				
			case 36: // Crossbow Guard Tower: 
				SendEventToNearClient_TypeA(iNpcH, DEF_OWNERTYPE_NPC, MSGID_EVENT_MOTION, DEF_OBJECTATTACK, m_pNpcList[iNpcH]->m_sX + _tmp_cTmpDirX[cDir], m_pNpcList[iNpcH]->m_sY + _tmp_cTmpDirY[cDir], 2); // È°
				iCalculateAttackEffect(m_pNpcList[iNpcH]->m_iTargetIndex, m_pNpcList[iNpcH]->m_cTargetType, iNpcH, DEF_OWNERTYPE_NPC, dX, dY, 2, FALSE, FALSE, FALSE, FALSE);
				break;
			case 37: // Cannon Guard Tower: 
				SendEventToNearClient_TypeA(iNpcH, DEF_OWNERTYPE_NPC, MSGID_EVENT_MOTION, DEF_OBJECTATTACK, dX, dY, 1); 
				m_pNpcList[iNpcH]->m_iMagicHitRatio = 1000;
				NpcMagicHandler(iNpcH, dX, dY, 61);
				break;
			}
		}else 
		{	SendEventToNearClient_TypeA(iNpcH, DEF_OWNERTYPE_NPC, MSGID_EVENT_MOTION, DEF_OBJECTATTACK, m_pNpcList[iNpcH]->m_sX + _tmp_cTmpDirX[cDir], m_pNpcList[iNpcH]->m_sY + _tmp_cTmpDirY[cDir], 1); 
			iCalculateAttackEffect(m_pNpcList[iNpcH]->m_iTargetIndex, m_pNpcList[iNpcH]->m_cTargetType, iNpcH, DEF_OWNERTYPE_NPC, dX, dY, 1, FALSE, FALSE, FALSE, FALSE);
		}
		m_pNpcList[iNpcH]->m_iAttackCount++; 
		if ((m_pNpcList[iNpcH]->m_bIsPermAttackMode == FALSE) && (m_pNpcList[iNpcH]->m_cActionLimit == 0)) 
		{	switch (m_pNpcList[iNpcH]->m_iAttackStrategy) { // m_cActionLimit +1 will never flee
			case DEF_ATTACKAI_EXCHANGEATTACK: // runner
				m_pNpcList[iNpcH]->m_sBehaviorTurnCount = 0;		
				m_pNpcList[iNpcH]->m_cBehavior          = DEF_BEHAVIOR_FLEE;
				break;
			case DEF_ATTACKAI_TWOBYONEATTACK: // 1/2 runner
				if (m_pNpcList[iNpcH]->m_iAttackCount >= 2) 
				{	m_pNpcList[iNpcH]->m_sBehaviorTurnCount = 0;		
					m_pNpcList[iNpcH]->m_cBehavior          = DEF_BEHAVIOR_FLEE;
				}
				break;
			case DEF_ATTACKAI_FOURBYONEATTACK: // 1/4 runner
				if (m_pNpcList[iNpcH]->m_iAttackCount >= 4) 
				{	m_pNpcList[iNpcH]->m_sBehaviorTurnCount = 0;		
					m_pNpcList[iNpcH]->m_cBehavior          = DEF_BEHAVIOR_FLEE;
				}
				break;
			case DEF_ATTACKAI_MAGEKILLER:
				if (m_pNpcList[iNpcH]->m_iAttackCount >= 4) 
				{	FarTargetSearch(iNpcH, &sTarget, &cTargetType); 			
					if (sTarget != NULL) 
					{	m_pNpcList[iNpcH]->m_iTargetIndex = sTarget;
						m_pNpcList[iNpcH]->m_cTargetType  = cTargetType;
						m_pNpcList[iNpcH]->m_sBehaviorTurnCount = 0;
					}else {} // Dont change		
				}
				break;
			case DEF_ATTACKAI_CHANGING:
				if (m_pNpcList[iNpcH]->m_iHP <= m_pNpcList[iNpcH]->m_iHitDice)
					m_pNpcList[iNpcH]->m_iAttackStrategy = iDice(1,12);
				break;
			}
		}
	}else  // Target is not close from attacker
	{	cDir = m_Misc.cGetNextMoveDir(sX, sY, dX, dY);
		if (cDir == 0) return;
		m_pNpcList[iNpcH]->m_cDir = cDir;					
		// npc Magic
		if (   (m_pNpcList[iNpcH]->m_cMagicLevel > 0) && (iDice(1,2) == 1) 
			&& (abs(sX - dX) <= 9) && (abs(sY - dY) <= 7)) 
		{	iMagicType = -1;
			switch (m_pNpcList[iNpcH]->m_cMagicLevel) { 
			case 1:
				if (m_pMagicConfigList[0]->m_sValue1 <= m_pNpcList[iNpcH]->m_iMana) 
					iMagicType = 0; // Magic Missile
				break;

			case 2:
				if (m_pMagicConfigList[10]->m_sValue1 <= m_pNpcList[iNpcH]->m_iMana) 
					iMagicType = 10; // EBolt
				else if (m_pMagicConfigList[0]->m_sValue1 <= m_pNpcList[iNpcH]->m_iMana) 
					iMagicType = 0;
				break;

			case 3: // Orc-Mage
				if (m_pMagicConfigList[20]->m_sValue1 <= m_pNpcList[iNpcH]->m_iMana) 
					iMagicType = 20; // FireBall
				else if (m_pMagicConfigList[10]->m_sValue1 <= m_pNpcList[iNpcH]->m_iMana) 
					iMagicType = 10; // EBolt
				break;

			case 4:
				if (m_pMagicConfigList[30]->m_sValue1 <= m_pNpcList[iNpcH]->m_iMana) 
					iMagicType = 30; // Fire-Strike
				else if (m_pMagicConfigList[37]->m_sValue1 <= m_pNpcList[iNpcH]->m_iMana) 
					iMagicType = 37; // Lightning-Arrow
				else if (m_pMagicConfigList[20]->m_sValue1 <= m_pNpcList[iNpcH]->m_iMana) 
					iMagicType = 20; // FireBall
				else if (m_pMagicConfigList[10]->m_sValue1 <= m_pNpcList[iNpcH]->m_iMana) 
					iMagicType = 10; // EBolt
				break;

			case 5: // Plant, Cyclops
				if (m_pMagicConfigList[43]->m_sValue1 <= m_pNpcList[iNpcH]->m_iMana) 
					iMagicType = 43; // Lightning 
				else if (m_pMagicConfigList[30]->m_sValue1 <= m_pNpcList[iNpcH]->m_iMana) 
					iMagicType = 30; // Fire-Strike
				else if (m_pMagicConfigList[37]->m_sValue1 <= m_pNpcList[iNpcH]->m_iMana) 
					iMagicType = 37; // Lightning-Arrow
				else if (m_pMagicConfigList[20]->m_sValue1 <= m_pNpcList[iNpcH]->m_iMana) 
					iMagicType = 20; // FireBall
				else if (m_pMagicConfigList[10]->m_sValue1 <= m_pNpcList[iNpcH]->m_iMana) 
					iMagicType = 10; // EBolt
				break;

			case 6: // Tentocle, Liche
				if (m_pMagicConfigList[51]->m_sValue1 <= m_pNpcList[iNpcH]->m_iMana) 
					iMagicType = 51; // Lightning-Bolt
				else if (m_pMagicConfigList[43]->m_sValue1 <= m_pNpcList[iNpcH]->m_iMana) 
					iMagicType = 43; // Lightning
				else if (m_pMagicConfigList[30]->m_sValue1 <= m_pNpcList[iNpcH]->m_iMana) 
					iMagicType = 30; // Fire-Strike
				else if (m_pMagicConfigList[37]->m_sValue1 <= m_pNpcList[iNpcH]->m_iMana) 
					iMagicType = 37; // Lightning-Arrow
				else if (m_pMagicConfigList[20]->m_sValue1 <= m_pNpcList[iNpcH]->m_iMana) 
					iMagicType = 20; // FireBall
				else if (m_pMagicConfigList[10]->m_sValue1 <= m_pNpcList[iNpcH]->m_iMana) 
					iMagicType = 10; // EBolt
				break;

			case 7: // Dragon, Fire-Wyvern, MasterMage-Orc , LightWarBeatle, GHK, GHKABS, TK, BG
				    // Sor, Gagoyle, Demon
				if ((m_pMagicConfigList[70]->m_sValue1 <= m_pNpcList[iNpcH]->m_iMana) && (iDice(1,5) == 3)) 
					iMagicType = 70; // Bloody-Shock-Wave
				else if (m_pMagicConfigList[61]->m_sValue1 <= m_pNpcList[iNpcH]->m_iMana) 
					iMagicType = 61; // Mass-Fire-Strike
				else if (m_pMagicConfigList[60]->m_sValue1 <= m_pNpcList[iNpcH]->m_iMana) 
					iMagicType = 60; // Energy-Strike
				else if (m_pMagicConfigList[51]->m_sValue1 <= m_pNpcList[iNpcH]->m_iMana) 
					iMagicType = 51; // Lightning-Bolt
				else if (m_pMagicConfigList[43]->m_sValue1 <= m_pNpcList[iNpcH]->m_iMana) 
					iMagicType = 43; // Lightning
				break;

			case 8: // Unicorn, Centaurus
				if ((m_pMagicConfigList[35]->m_sValue1 <= m_pNpcList[iNpcH]->m_iMana) && (iDice(1,3) == 2)) 
					iMagicType = 35; // Paralyze
				else if (m_pMagicConfigList[60]->m_sValue1 <= m_pNpcList[iNpcH]->m_iMana) 
					iMagicType = 60; // Energy-Strike
				else if (m_pMagicConfigList[51]->m_sValue1 <= m_pNpcList[iNpcH]->m_iMana) 
					iMagicType = 51; // Lightning-Bolt
				else if (m_pMagicConfigList[43]->m_sValue1 <= m_pNpcList[iNpcH]->m_iMana) 
					iMagicType = 43; // Lightning
				break;

			case 9: // Tigerworm
				if ((m_pMagicConfigList[74]->m_sValue1 <= m_pNpcList[iNpcH]->m_iMana) && (iDice(1,3) == 2)) 
					iMagicType = 74; // Lightning-Strike
				break;

			// SNOOPY: Added some chance for ChillWind, even if they can use Magic during close combat.
			case 10: // Frost, Nizie
				if ((m_pMagicConfigList[45]->m_sValue1 <= m_pNpcList[iNpcH]->m_iMana) && (iDice(1,10) == 2)) 
					iMagicType = 45; // Chill-Wind
				break;

			// SNOOPY: Added some chance for ChillWind
			case 11: // Ice-Golem
				if ((m_pMagicConfigList[45]->m_sValue1 <= m_pNpcList[iNpcH]->m_iMana) && (iDice(1,5) == 2)) 
					iMagicType = 45; // Chill-Wind
				break;

			case 12: // Wyvern
				if ((m_pMagicConfigList[91]->m_sValue1 <= m_pNpcList[iNpcH]->m_iMana) && (iDice(1,3) == 2)) 
					iMagicType = 91; // Blizzard (mass blizzard)
				else if (m_pMagicConfigList[63]->m_sValue1 <= m_pNpcList[iNpcH]->m_iMana) 
					iMagicType = 63; // Mass-Chill-Wind
				break;

			case 13: // Abaddon
				if ((m_pMagicConfigList[96]->m_sValue1 <= m_pNpcList[iNpcH]->m_iMana) && (iDice(1,3) == 2)) 
					iMagicType = 96; // Earth Shock Wave
				else if (m_pMagicConfigList[81]->m_sValue1 <= m_pNpcList[iNpcH]->m_iMana) 
					iMagicType = 81; // Meteor Strike
				break;
			}
			if (iMagicType != -1) 		// npc IA: Spell? Attack?				
			{	if (m_pNpcList[iNpcH]->m_iAILevel >= 2) 
				{	switch (m_pNpcList[iNpcH]->m_cTargetType) {
					case DEF_OWNERTYPE_PLAYER:
						if (m_pClientList[m_pNpcList[iNpcH]->m_iTargetIndex]->m_cMagicEffectStatus[ DEF_MAGICTYPE_PROTECT ] == 2) {
							if ((abs(sX - dX) > m_pNpcList[iNpcH]->m_iAttackRange) || (abs(sY - dY) > m_pNpcList[iNpcH]->m_iAttackRange)) {
								m_pNpcList[iNpcH]->m_sBehaviorTurnCount = 0;
								m_pNpcList[iNpcH]->m_cBehavior    = DEF_BEHAVIOR_MOVE;
								return;
							}else goto NBA_CHASE;
						}
						if ((iMagicType == 35) && (m_pClientList[m_pNpcList[iNpcH]->m_iTargetIndex]->m_cMagicEffectStatus[ DEF_MAGICTYPE_HOLDOBJECT ] != 0)) goto NBA_CHASE;
						break;

					case DEF_OWNERTYPE_NPC:
						if (m_pNpcList[m_pNpcList[iNpcH]->m_iTargetIndex]->m_cMagicEffectStatus[ DEF_MAGICTYPE_PROTECT ] == 2) {
							if ((abs(sX - dX) > m_pNpcList[iNpcH]->m_iAttackRange) || (abs(sY - dY) > m_pNpcList[iNpcH]->m_iAttackRange)) {
								m_pNpcList[iNpcH]->m_sBehaviorTurnCount = 0;
								m_pNpcList[iNpcH]->m_cBehavior    = DEF_BEHAVIOR_MOVE;
								return;
							}else goto NBA_CHASE;
						}
						if ((iMagicType == 35) && (m_pNpcList[m_pNpcList[iNpcH]->m_iTargetIndex]->m_cMagicEffectStatus[ DEF_MAGICTYPE_HOLDOBJECT ] != 0)) goto NBA_CHASE;
						break;
				}	}				
				SendEventToNearClient_TypeA(iNpcH, DEF_OWNERTYPE_NPC, MSGID_EVENT_MOTION, DEF_OBJECTATTACK, m_pNpcList[iNpcH]->m_sX + _tmp_cTmpDirX[cDir], m_pNpcList[iNpcH]->m_sY + _tmp_cTmpDirY[cDir], 1); 
				NpcMagicHandler(iNpcH, dX, dY, iMagicType);
				m_pNpcList[iNpcH]->m_dwTime = dwTime + 2000; 
				return;
		}	}
		// MagicLevel -10 for guards....
		if ((m_pNpcList[iNpcH]->m_cMagicLevel < 0) && (iDice(1,2) == 1) &&
			(abs(sX - dX) <= 9) && (abs(sY - dY) <= 7)) {
			iMagicType = -1;
			if (m_pMagicConfigList[43]->m_sValue1 <= m_pNpcList[iNpcH]->m_iMana) 
				iMagicType = 43; // Lightning
			else if (m_pMagicConfigList[37]->m_sValue1 <= m_pNpcList[iNpcH]->m_iMana) 
				iMagicType = 37; // Lightning-Arrow
			else if (m_pMagicConfigList[0]->m_sValue1 <= m_pNpcList[iNpcH]->m_iMana) 
				iMagicType = 0; // Magic Missile

			if (iMagicType != -1) {
				SendEventToNearClient_TypeA(iNpcH, DEF_OWNERTYPE_NPC, MSGID_EVENT_MOTION, DEF_OBJECTATTACK, m_pNpcList[iNpcH]->m_sX + _tmp_cTmpDirX[cDir], m_pNpcList[iNpcH]->m_sY + _tmp_cTmpDirY[cDir], 1); // 1 : Ä®µîÀÇ ±ÙÁ¢¹«±â·Î °ø°ÝÇÏ´Â ÀÇ¹Ì 
				NpcMagicHandler(iNpcH, dX, dY, iMagicType);
				m_pNpcList[iNpcH]->m_dwTime = dwTime + 2000; 
				return;
			}
		}
		// Target is not close to attacker, but in range
		if (   (m_pNpcList[iNpcH]->m_iAttackRange > 1)  
			&& (abs(sX - dX) <= m_pNpcList[iNpcH]->m_iAttackRange) 
			&& (abs(sY - dY) <= m_pNpcList[iNpcH]->m_iAttackRange)) 						
		{	cDir = m_Misc.cGetNextMoveDir(sX, sY, dX, dY);
			if (cDir == 0) return;
			m_pNpcList[iNpcH]->m_cDir = cDir;
			if (m_pNpcList[iNpcH]->m_cActionLimit == 5) 
			{	switch (m_pNpcList[iNpcH]->m_sType) {
				case 89: // AGT
					SendEventToNearClient_TypeA(iNpcH, DEF_OWNERTYPE_NPC, MSGID_EVENT_MOTION, DEF_OBJECTATTACK, dX, dY, 1); 
					m_pNpcList[iNpcH]->m_iMagicHitRatio = 1000;
					NpcMagicHandler(iNpcH, dX, dY, 61);
					break;
				case 87: // CT
					SendEventToNearClient_TypeA(iNpcH, DEF_OWNERTYPE_NPC, MSGID_EVENT_MOTION, DEF_OBJECTATTACK, dX, dY, 2); 
					iCalculateAttackEffect(m_pNpcList[iNpcH]->m_iTargetIndex, m_pNpcList[iNpcH]->m_cTargetType, iNpcH, DEF_OWNERTYPE_NPC, dX, dY, 2, FALSE, FALSE, FALSE, FALSE);
					break;
				case 36: // Crossbow Guard Tower
					SendEventToNearClient_TypeA(iNpcH, DEF_OWNERTYPE_NPC, MSGID_EVENT_MOTION, DEF_OBJECTATTACK, dX, dY, 2); 
					iCalculateAttackEffect(m_pNpcList[iNpcH]->m_iTargetIndex, m_pNpcList[iNpcH]->m_cTargetType, iNpcH, DEF_OWNERTYPE_NPC, dX, dY, 2, FALSE, FALSE, FALSE, FALSE);
					break;
				case 37: // Cannon Guard Tower: ¸
					SendEventToNearClient_TypeA(iNpcH, DEF_OWNERTYPE_NPC, MSGID_EVENT_MOTION, DEF_OBJECTATTACK, dX, dY, 1); 
					m_pNpcList[iNpcH]->m_iMagicHitRatio = 1000;
					NpcMagicHandler(iNpcH, dX, dY, 61);
					break;
				}
			}else 
			{	switch (m_pNpcList[iNpcH]->m_sType) {
				case 51: // v2.05 Catapult:
					SendEventToNearClient_TypeA(iNpcH, DEF_OWNERTYPE_NPC, MSGID_EVENT_MOTION, DEF_OBJECTATTACK, dX, dY, 1); 
					m_pNpcList[iNpcH]->m_iMagicHitRatio = 1000;
					NpcMagicHandler(iNpcH, dX, dY, 61);
					break;

				case 54: // Dark Elf: 
				case 84: // Master Elf: 
					SendEventToNearClient_TypeA(iNpcH, DEF_OWNERTYPE_NPC, MSGID_EVENT_MOTION, DEF_OBJECTATTACK, dX, dY, 2);
					iCalculateAttackEffect(m_pNpcList[iNpcH]->m_iTargetIndex, m_pNpcList[iNpcH]->m_cTargetType, iNpcH, DEF_OWNERTYPE_NPC, dX, dY, 2, FALSE, FALSE, FALSE, FALSE);
					break;
				
				case 63: // Frost
				case 79: // Nizie
					switch (m_pNpcList[iNpcH]->m_cTargetType) {
					case DEF_OWNERTYPE_PLAYER:
						if (m_pClientList[m_pNpcList[iNpcH]->m_iTargetIndex] == NULL) goto NBA_BREAK1;
						if ((m_pMagicConfigList[57]->m_sValue1 <= m_pNpcList[iNpcH]->m_iMana) && (iDice(1,3) == 2)) 
							NpcMagicHandler(iNpcH, dX, dY, 57);
						if (m_pClientList[m_pNpcList[iNpcH]->m_iTargetIndex] == NULL) goto NBA_BREAK1;
						// 1/3 change of IceStrike you, but always frozing you
						if (   (m_pClientList[m_pNpcList[iNpcH]->m_iTargetIndex]->m_iHP > 0)  
							&& (bCheckResistingIceSuccess(-1, m_pNpcList[iNpcH]->m_iTargetIndex, DEF_OWNERTYPE_PLAYER, m_pNpcList[iNpcH]->m_iMagicHitRatio/8) == FALSE)) 
						{	if (m_pClientList[m_pNpcList[iNpcH]->m_iTargetIndex]->m_cMagicEffectStatus[ DEF_MAGICTYPE_ICE ] == 0) 
							{	m_pClientList[m_pNpcList[iNpcH]->m_iTargetIndex]->m_cMagicEffectStatus[ DEF_MAGICTYPE_ICE ] = 1;
								SetIceFlag(m_pNpcList[iNpcH]->m_iTargetIndex, DEF_OWNERTYPE_PLAYER, TRUE);
								bRegisterDelayEvent(DEF_DELAYEVENTTYPE_MAGICRELEASE, DEF_MAGICTYPE_ICE, dwTime + (5*1000), 
									                m_pNpcList[iNpcH]->m_iTargetIndex, DEF_OWNERTYPE_PLAYER, NULL, NULL, NULL, 1, NULL, NULL);
								SendNotifyMsg(NULL, m_pNpcList[iNpcH]->m_iTargetIndex, DEF_NOTIFY_MAGICEFFECTON, DEF_MAGICTYPE_ICE, 1, NULL, NULL);
						}	}
						break;

					case DEF_OWNERTYPE_NPC:
						if (m_pNpcList[m_pNpcList[iNpcH]->m_iTargetIndex] == NULL) goto NBA_BREAK1;
						if ((m_pMagicConfigList[57]->m_sValue1 <= m_pNpcList[iNpcH]->m_iMana) && (iDice(1,3) == 2)) 
							NpcMagicHandler(iNpcH, dX, dY, 57);
						if (m_pNpcList[m_pNpcList[iNpcH]->m_iTargetIndex] == NULL) goto NBA_BREAK1;
						if (   (m_pNpcList[m_pNpcList[iNpcH]->m_iTargetIndex]->m_iHP > 0) 
							&& (bCheckResistingIceSuccess(-1, m_pNpcList[iNpcH]->m_iTargetIndex, DEF_OWNERTYPE_NPC, m_pNpcList[iNpcH]->m_iMagicHitRatio/8) == FALSE)) 
						{	if (m_pNpcList[m_pNpcList[iNpcH]->m_iTargetIndex]->m_cMagicEffectStatus[ DEF_MAGICTYPE_ICE ] == 0) 
							{	m_pNpcList[m_pNpcList[iNpcH]->m_iTargetIndex]->m_cMagicEffectStatus[ DEF_MAGICTYPE_ICE ] = 1;
								SetIceFlag(m_pNpcList[iNpcH]->m_iTargetIndex, DEF_OWNERTYPE_NPC, TRUE);
								bRegisterDelayEvent(DEF_DELAYEVENTTYPE_MAGICRELEASE, DEF_MAGICTYPE_ICE, dwTime + (5*1000), 
								                    m_pNpcList[iNpcH]->m_iTargetIndex, DEF_OWNERTYPE_NPC, NULL, NULL, NULL, 1, NULL, NULL);
						}	}
						break;
					}	
					break;

				case 97: // Fire Elemental
						if (m_pNpcList[m_pNpcList[iNpcH]->m_iTargetIndex] == NULL) goto NBA_BREAK1;
						if ((m_pMagicConfigList[57]->m_sValue1 <= m_pNpcList[iNpcH]->m_iMana) && (iDice(1,7) == 2)) 
							iAddDynamicObjectList(iNpcH, DEF_OWNERTYPE_NPC, DEF_DYNAMICOBJECT_FIRE3, m_pNpcList[iNpcH]->m_cMapIndex, dX, dY, (iDice(1,7)+3)*1000, 8);
						break;

				case 53: // Beholder: Frosing you
				case 65: // IceGolem
				case 99: // Ice Elemental
					switch (m_pNpcList[iNpcH]->m_cTargetType) {
					case DEF_OWNERTYPE_PLAYER:
						if (m_pClientList[m_pNpcList[iNpcH]->m_iTargetIndex] == NULL) goto NBA_BREAK1;
						if (   (m_pClientList[m_pNpcList[iNpcH]->m_iTargetIndex]->m_iHP > 0) 
							&& (bCheckResistingIceSuccess(-1, m_pNpcList[iNpcH]->m_iTargetIndex, DEF_OWNERTYPE_PLAYER, m_pNpcList[iNpcH]->m_iMagicHitRatio/8) == FALSE)) 
						{	if (m_pClientList[m_pNpcList[iNpcH]->m_iTargetIndex]->m_cMagicEffectStatus[ DEF_MAGICTYPE_ICE ] == 0) 
							{	m_pClientList[m_pNpcList[iNpcH]->m_iTargetIndex]->m_cMagicEffectStatus[ DEF_MAGICTYPE_ICE ] = 2;
								SetIceFlag(m_pNpcList[iNpcH]->m_iTargetIndex, DEF_OWNERTYPE_PLAYER, TRUE);
								bRegisterDelayEvent(DEF_DELAYEVENTTYPE_MAGICRELEASE, DEF_MAGICTYPE_ICE, dwTime + (5*1000), 
									                m_pNpcList[iNpcH]->m_iTargetIndex, DEF_OWNERTYPE_PLAYER, NULL, NULL, NULL, 1, NULL, NULL);
								SendNotifyMsg(NULL, m_pNpcList[iNpcH]->m_iTargetIndex, DEF_NOTIFY_MAGICEFFECTON, DEF_MAGICTYPE_ICE, 1, NULL, NULL);						
						}	}
						break;

					case DEF_OWNERTYPE_NPC:
						if (m_pNpcList[m_pNpcList[iNpcH]->m_iTargetIndex] == NULL) goto NBA_BREAK1;
						if (   (m_pNpcList[m_pNpcList[iNpcH]->m_iTargetIndex]->m_iHP > 0) 
							&& (bCheckResistingIceSuccess(-1, m_pNpcList[iNpcH]->m_iTargetIndex, DEF_OWNERTYPE_NPC, m_pNpcList[iNpcH]->m_iMagicHitRatio/8) == FALSE)) 
						{	if (m_pNpcList[m_pNpcList[iNpcH]->m_iTargetIndex]->m_cMagicEffectStatus[ DEF_MAGICTYPE_ICE ] == 0) 
							{	m_pNpcList[m_pNpcList[iNpcH]->m_iTargetIndex]->m_cMagicEffectStatus[ DEF_MAGICTYPE_ICE ] = 2;
								SetIceFlag(m_pNpcList[iNpcH]->m_iTargetIndex, DEF_OWNERTYPE_NPC, TRUE);
								bRegisterDelayEvent(DEF_DELAYEVENTTYPE_MAGICRELEASE, DEF_MAGICTYPE_ICE, dwTime + (5*1000), 
								                    m_pNpcList[iNpcH]->m_iTargetIndex, DEF_OWNERTYPE_NPC, NULL, NULL, NULL, 1, NULL, NULL);
						}	}
						break;
					}
NBA_BREAK1:;
					SendEventToNearClient_TypeA(iNpcH, DEF_OWNERTYPE_NPC, MSGID_EVENT_MOTION, DEF_OBJECTATTACK, dX, dY, 20); // 20: ÇÊ»ì±â
					iCalculateAttackEffect(m_pNpcList[iNpcH]->m_iTargetIndex, m_pNpcList[iNpcH]->m_cTargetType, iNpcH, DEF_OWNERTYPE_NPC, dX, dY, 20, FALSE, FALSE, FALSE, FALSE);
					break;
							
				default:
					SendEventToNearClient_TypeA(iNpcH, DEF_OWNERTYPE_NPC, MSGID_EVENT_MOTION, DEF_OBJECTATTACK, dX, dY, 20); // 20: ÇÊ»ì±â 
					iCalculateAttackEffect(m_pNpcList[iNpcH]->m_iTargetIndex, m_pNpcList[iNpcH]->m_cTargetType, iNpcH, DEF_OWNERTYPE_NPC, dX, dY, 20, FALSE, FALSE, FALSE, FALSE);
					break;
				}
			}
			m_pNpcList[iNpcH]->m_iAttackCount++;			
			if ((m_pNpcList[iNpcH]->m_bIsPermAttackMode == FALSE) && (m_pNpcList[iNpcH]->m_cActionLimit == 0)) {
				switch (m_pNpcList[iNpcH]->m_iAttackStrategy) { // ActionLimit 1 means never runner mob
				case DEF_ATTACKAI_EXCHANGEATTACK:
					m_pNpcList[iNpcH]->m_sBehaviorTurnCount = 0;		
					m_pNpcList[iNpcH]->m_cBehavior          = DEF_BEHAVIOR_FLEE;
					break;			
				case DEF_ATTACKAI_TWOBYONEATTACK:
					if (m_pNpcList[iNpcH]->m_iAttackCount >= 2) 
					{	m_pNpcList[iNpcH]->m_sBehaviorTurnCount = 0;		
						m_pNpcList[iNpcH]->m_cBehavior          = DEF_BEHAVIOR_FLEE;
					}
					break;		
				case DEF_ATTACKAI_FOURBYONEATTACK:
					if (m_pNpcList[iNpcH]->m_iAttackCount >= 4) 
					{	m_pNpcList[iNpcH]->m_sBehaviorTurnCount = 0;		
						m_pNpcList[iNpcH]->m_cBehavior          = DEF_BEHAVIOR_FLEE;
					}
					break;	
				case DEF_ATTACKAI_MAGEKILLER:
					if (m_pNpcList[iNpcH]->m_iAttackCount >= 4) 
					{	FarTargetSearch(iNpcH, &sTarget, &cTargetType); 			
						if (sTarget != NULL) 
						{	m_pNpcList[iNpcH]->m_iTargetIndex = sTarget;
							m_pNpcList[iNpcH]->m_cTargetType  = cTargetType;
							m_pNpcList[iNpcH]->m_sBehaviorTurnCount = 0;
						}else {} // Dont change		
					}
					break;		
			}	}
			return;
		}

NBA_CHASE:;		
		if (m_pNpcList[iNpcH]->m_cActionLimit > 1) return;
		m_pNpcList[iNpcH]->m_iAttackCount = 0;
		{	// Follow
			cDir = cGetNextMoveDir(sX, sY, dX, dY,m_pNpcList[iNpcH]->m_cMapIndex, m_pNpcList[iNpcH]->m_cTurn, &m_pNpcList[iNpcH]->m_tmp_iError);
			if (cDir == 0) {
				return;
			}
			dX = m_pNpcList[iNpcH]->m_sX + _tmp_cTmpDirX[cDir];
			dY = m_pNpcList[iNpcH]->m_sY + _tmp_cTmpDirY[cDir];
			m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->ClearOwner(9, iNpcH, DEF_OWNERTYPE_NPC, m_pNpcList[iNpcH]->m_sX, m_pNpcList[iNpcH]->m_sY);
			m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->SetOwner(iNpcH, DEF_OWNERTYPE_NPC, dX, dY);
			m_pNpcList[iNpcH]->m_sX   = dX;
			m_pNpcList[iNpcH]->m_sY   = dY;
			m_pNpcList[iNpcH]->m_cDir = cDir;
			SendEventToNearClient_TypeA(iNpcH, DEF_OWNERTYPE_NPC, MSGID_EVENT_MOTION, DEF_OBJECTMOVE, NULL, NULL, NULL);
		}
	}
}
/*****************************************************************************************************
**							  Follower mode functions:												**
**	bSetNpcFollowMode:	After creating a mob, gives him a master...									**
**  RemoveFromTarget:   If target or master Killed/TP/deco/Invi, check follow mode					**
**  ReleaseFollowMode:  Check if a killed npc had followers, and free them							**
**  iRecoverFollowers:  Restore follow mode after a client has disconnected the connected again		**
**  iGetFollowerNumber: Counts the follower numbers to prevent too much summons						**
*****************************************************************************************************/
BOOL CGame::bSetNpcFollowMode(char * pName, char * pFollowName, char cFollowOwnerType)
{register int i, iIndex, iMapIndex, iFollowIndex;
 char cTmpName[11], cFollowSide;
	ZeroMemory(cTmpName, sizeof(cTmpName));// Snoopy: added m_cFollowOwnerCharName
	iIndex		 = -1;
	iMapIndex    = -1;
	iFollowIndex = -1;
	for (i = 1; i < DEF_MAXNPCS; i++)
	if ((m_pNpcList[i] != NULL) && (memcmp(m_pNpcList[i]->m_cName, pName, 5) == 0) ) 
	{	iIndex = i;
		iMapIndex = m_pNpcList[i]->m_cMapIndex;
		goto NEXT_STEP_SNFM1;
	}
	if (iIndex == -1) return FALSE;

NEXT_STEP_SNFM1:;
	switch (cFollowOwnerType) {
	case DEF_OWNERTYPE_NPC:
		for (i = 1; i < DEF_MAXNPCS; i++)
		if ((m_pNpcList[i] != NULL) && (memcmp(m_pNpcList[i]->m_cName, pFollowName, 5) == 0) ) 
		{	if (m_pNpcList[i]->m_cMapIndex != iMapIndex) return FALSE;
			m_pNpcList[iIndex]->m_cMoveType			= DEF_MOVETYPE_FOLLOW;
			m_pNpcList[iIndex]->m_cFollowOwnerType  = DEF_OWNERTYPE_NPC;
			m_pNpcList[iIndex]->m_iFollowOwnerIndex = i;
			ZeroMemory(m_pNpcList[i]->m_cFollowOwnerCharName,sizeof(m_pNpcList[i]->m_cFollowOwnerCharName));
			m_pNpcList[iIndex]->m_cSide             = m_pNpcList[i]->m_cSide;
			return TRUE;
		}
		break;
	
	case DEF_OWNERTYPE_PLAYER:
		for (i = 1; i < DEF_MAXCLIENTS; i++)
		if ((m_pClientList[i] != NULL) && (memcmp(m_pClientList[i]->m_cCharName, pFollowName, 10) == 0) ) 
		{	if (m_pClientList[i]->m_cMapIndex != iMapIndex) return FALSE;
			iFollowIndex = i;
			cFollowSide = m_pClientList[i]->m_cSide;
			m_pNpcList[iIndex]->m_cMoveType			= DEF_MOVETYPE_FOLLOW;
			m_pNpcList[iIndex]->m_cFollowOwnerType  = DEF_OWNERTYPE_PLAYER;
			m_pNpcList[iIndex]->m_iFollowOwnerIndex = i;
			strcpy(m_pNpcList[iIndex]->m_cFollowOwnerCharName, m_pClientList[i]->m_cCharName);
			m_pNpcList[iIndex]->m_cSide             = m_pClientList[i]->m_cSide;
			return TRUE;
		}
		break;
	}
	return FALSE;
}
void CGame::RemoveFromTarget(short sTargetH, char cTargetType, int iCode, int iAttackerH, char cAttackerType)
// Used into deleteclient(), ClientKilled(), deleteNpc(), npcKilled(), invisibility, Teleport
{ register int i;
	//renew crusade summons duration	
	// Somebody from guild invied => renew summon duration !
	//  "   "     "     "  killed/teleported/deco 
	if ((m_bIsCrusadeMode == TRUE) && (cTargetType == DEF_OWNERTYPE_PLAYER))
	{	DWORD dwTime = timeGetTime();
		for (i = 0; i < DEF_MAXNPCS; i++)
		if (m_pNpcList[i] != NULL) 
		{	if (   (m_pNpcList[i]->m_iGuildGUID != NULL) 				 
				&& (m_pClientList[sTargetH]->m_iGuildGUID == m_pNpcList[i]->m_iGuildGUID)) 			
			{	if (m_pNpcList[i]->m_cActionLimit < 2)	
				{	m_pNpcList[i]->m_bIsSummoned = TRUE;		
					m_pNpcList[i]->m_dwSummonedTime = dwTime;	
	}	}	}	}

	// If master was killed or deco set follower mode
	if ((cTargetType  == DEF_OWNERTYPE_PLAYER) && (iCode == NULL))// not DEF_MAGICTYPE_INVISIBILITY neither DEF_MAGICTYPE_TELEPORT
	{	for (i = 0; i < DEF_MAXNPCS; i++)
		if (m_pNpcList[i] != NULL) 
		{	if (   (m_pNpcList[i]->m_bIsSummoned		== TRUE) 
				&& (m_pNpcList[i]->m_bIsKilled			== FALSE) 
				&& (m_pNpcList[i]->m_cFollowOwnerType	== DEF_OWNERTYPE_PLAYER) 
				&& (m_pNpcList[i]->m_iFollowOwnerIndex	== sTargetH))
			{	// Client suposed to be disconnected and not dead.
				if (   (m_pClientList[sTargetH] != NULL)
					&& (m_pClientList[sTargetH]->m_bIsKilled == FALSE))
				{	// All Summons will live only 1 minute in ths case
					// other summons will live for standard time				
					m_pNpcList[i]->m_cFollowOwnerType  = DEF_OWNERTYPE_PLAYER_WAITING;	
					m_pNpcList[i]->m_iFollowOwnerIndex = NULL;	
					m_pNpcList[i]->m_dwSummonWaitTime  = timeGetTime();
					m_pNpcList[i]->m_cMoveType		   = DEF_MOVETYPE_RANDOM;
				}
				// Client is dead
				else if ( (m_bIsHeldenianMode == TRUE)
						&& (m_pMapList[m_pNpcList[i]->m_cMapIndex] != NULL)
						&& (m_pMapList[m_pNpcList[i]->m_cMapIndex]->m_bIsHeldenianMap == 1))
				{	switch (m_cHeldenianSummonMode) {
					case 0: // Mode 0, default, Kill the summon
						NpcKilledHandler(NULL, NULL, i, 0);
						break;
					case 1: // Mode 1: Summon will wait for his own master	
						//SetSummonMobAction(iClientH, 2, dwMsgSize - 21, cp);
						m_pNpcList[i]->m_cFollowOwnerType  = DEF_OWNERTYPE_PLAYER_WAITING;	
						m_pNpcList[i]->m_iFollowOwnerIndex = NULL;
						m_pNpcList[i]->m_dwSummonWaitTime  = timeGetTime();
						m_pNpcList[i]->m_cMoveType		   = DEF_MOVETYPE_RANDOM;
						// Summon tries to avenge his master
						if ((iAttackerH != NULL) && (cAttackerType != NULL))
						{	m_pNpcList[i]->m_iSummonControlMode = 0;
							m_pNpcList[i]->m_cBehavior          = DEF_BEHAVIOR_ATTACK;
							m_pNpcList[i]->m_sBehaviorTurnCount = 0;		
							m_pNpcList[i]->m_iTargetIndex       = iAttackerH;
							m_pNpcList[i]->m_cTargetType        = cAttackerType;
							m_pNpcList[i]->m_bIsPermAttackMode  = TRUE;
						}
						break;
					case 2: // Mode 3: Summon can be taken over by anybody else
						m_pNpcList[i]->m_cFollowOwnerType  = DEF_OWNERTYPE_PLAYER_FREE;	
						m_pNpcList[i]->m_iFollowOwnerIndex = NULL;			
						ZeroMemory(m_pNpcList[i]->m_cFollowOwnerCharName,sizeof(m_pNpcList[i]->m_cFollowOwnerCharName));
						// Summon tries to avenge his master
						if ((iAttackerH != NULL) && (cAttackerType != NULL))
						{	m_pNpcList[i]->m_iSummonControlMode = 0;
							m_pNpcList[i]->m_cBehavior          = DEF_BEHAVIOR_ATTACK;
							m_pNpcList[i]->m_sBehaviorTurnCount = 0;		
							m_pNpcList[i]->m_iTargetIndex       = iAttackerH;
							m_pNpcList[i]->m_cTargetType        = cAttackerType;
							m_pNpcList[i]->m_bIsPermAttackMode  = TRUE;
						}
						break;
					}
				}else //Dead client, not Heldenian
				{	m_pNpcList[i]->m_cFollowOwnerType	= 0;	// No regain control possible
					m_pNpcList[i]->m_iFollowOwnerIndex	= NULL;
					m_pNpcList[i]->m_cMoveType		    = DEF_MOVETYPE_RANDOM;
					m_pNpcList[i]->m_cBehavior			= DEF_BEHAVIOR_MOVE;
					ZeroMemory(m_pNpcList[i]->m_cFollowOwnerCharName,sizeof(m_pNpcList[i]->m_cFollowOwnerCharName));
					// Summon tries to avenge his master
					if ((iAttackerH != NULL) && (cAttackerType != NULL))
					{	m_pNpcList[i]->m_iSummonControlMode = 0;
						m_pNpcList[i]->m_cBehavior          = DEF_BEHAVIOR_ATTACK;
						m_pNpcList[i]->m_sBehaviorTurnCount = 0;		
						m_pNpcList[i]->m_iTargetIndex       = iAttackerH;
						m_pNpcList[i]->m_cTargetType        = cAttackerType;
						m_pNpcList[i]->m_bIsPermAttackMode  = TRUE;				
				}	}
			}
			// Tamed mobs
			else if ( (m_pNpcList[i]->m_dwTamingTime != 0) // For tamed mobs
					&& (m_pNpcList[i]->m_bIsSummoned		== FALSE)
					&& (m_pNpcList[i]->m_bIsKilled			== FALSE) 
					&& (m_pNpcList[i]->m_cFollowOwnerType	== DEF_OWNERTYPE_PLAYER) 
					&& (m_pNpcList[i]->m_iFollowOwnerIndex	== sTargetH))
			{	// Client suposed to be disconnected and not dead.
				if (   (m_pClientList[sTargetH] != NULL)
					&& (m_pClientList[sTargetH]->m_bIsKilled == FALSE))
				{	// All Summons will live only 1 minute in ths case
					// other summons will live for standard time				
					m_pNpcList[i]->m_cFollowOwnerType  = DEF_OWNERTYPE_PLAYER_WAITING;	
					m_pNpcList[i]->m_iFollowOwnerIndex = NULL;	
					m_pNpcList[i]->m_dwSummonWaitTime  = timeGetTime();
					m_pNpcList[i]->m_cMoveType		   = DEF_MOVETYPE_RANDOM;
				}else// Client is dead
				{	m_pNpcList[i]->m_cFollowOwnerType	= 0;	// No regain control possible
					m_pNpcList[i]->m_iFollowOwnerIndex	= NULL;
					m_pNpcList[i]->m_cMoveType		    = DEF_MOVETYPE_RANDOM;
					m_pNpcList[i]->m_cBehavior			= DEF_BEHAVIOR_MOVE;
					ZeroMemory(m_pNpcList[i]->m_cFollowOwnerCharName,sizeof(m_pNpcList[i]->m_cFollowOwnerCharName));				
					// Summon tries to avenge his master
					if ((iAttackerH != NULL) && (cAttackerType != NULL))
					{	m_pNpcList[i]->m_iSummonControlMode = 0;
						m_pNpcList[i]->m_cBehavior          = DEF_BEHAVIOR_ATTACK;
						m_pNpcList[i]->m_sBehaviorTurnCount = 0;		
						m_pNpcList[i]->m_iTargetIndex       = iAttackerH;
						m_pNpcList[i]->m_cTargetType        = cAttackerType;
						m_pNpcList[i]->m_bIsPermAttackMode  = TRUE;
	}	}	}	}	}

	// Stop attack the disapeared/dead/teleported/deco target
	for (i = 0; i < DEF_MAXNPCS; i++)
	if (m_pNpcList[i] != NULL) 
	{	if (   (m_pNpcList[i]->m_iTargetIndex == sTargetH)  
			&& (m_pNpcList[i]->m_cTargetType == cTargetType)) 			
		{	switch (iCode) { 
			case DEF_MAGICTYPE_INVISIBILITY:
				if (m_pNpcList[i]->m_cSpecialAbility != 1) 
				{	m_pNpcList[i]->m_cBehavior	  = DEF_BEHAVIOR_MOVE;
					m_pNpcList[i]->m_iTargetIndex = NULL;
					m_pNpcList[i]->m_cTargetType  = NULL;
				}
				break;
			case DEF_MAGICTYPE_TELEPORT:
			default:
				m_pNpcList[i]->m_cBehavior    = DEF_BEHAVIOR_MOVE;
				m_pNpcList[i]->m_iTargetIndex = NULL;
				m_pNpcList[i]->m_cTargetType  = NULL;
				break;
	}	}	}
}
// Npc master (sOwner) is dead, so free his followers 
void CGame::ReleaseFollowMode(short sOwnerH)
{register int i;
	for (i = 0; i < DEF_MAXNPCS; i++)
	if ((i != sOwnerH) && (m_pNpcList[i] != NULL)) 
	{	if (   (m_pNpcList[i]->m_cMoveType         == DEF_MOVETYPE_FOLLOW)
			&& (m_pNpcList[i]->m_cFollowOwnerType  == DEF_OWNERTYPE_NPC) 
			&& (m_pNpcList[i]->m_iFollowOwnerIndex == sOwnerH)) 			
		{	m_pNpcList[i]->m_cMoveType = DEF_MOVETYPE_RANDOMWAYPOINT;
			m_pNpcList[i]->m_iFollowOwnerIndex = 0;
			m_pNpcList[i]->m_cFollowOwnerType  = 0;
}	}	}


// SNOOPY: reconnecting clients will recover summons 
void CGame::iRecoverFollowers(int  iClientH, BOOL bControlAll)
{	if (m_pClientList[iClientH] == NULL) return;
 register int i, iTotal;
 char  cKillerMsg[128];	
	iTotal = 0;
	for (i = 1; i < DEF_MAXNPCS; i++) 
	if (   (m_pNpcList[i] != NULL) 
		&& (m_pNpcList[i]->m_cFollowOwnerType > 7)	// Reduce cases to process
		&& ((m_pNpcList[i]->m_bIsSummoned	  == TRUE) || (m_pNpcList[i]->m_dwTamingTime != 0))
		&& (m_pNpcList[i]->m_bIsKilled		  == FALSE))
	{	switch (m_pNpcList[i]->m_cFollowOwnerType) {
		case DEF_OWNERTYPE_PLAYER_FREE: // Anybody can take control
			if (   (bControlAll == TRUE)
				&& (m_pNpcList[i]->m_cSide == m_pClientList[iClientH]->m_cSide))
			{	m_pNpcList[i]->m_iFollowOwnerIndex	= iClientH;
				m_pNpcList[i]->m_cFollowOwnerType	= DEF_OWNERTYPE_PLAYER;
				m_pNpcList[i]->m_cMoveType			= DEF_MOVETYPE_FOLLOW;
				strcpy(m_pNpcList[i]->m_cFollowOwnerCharName, m_pClientList[iClientH]->m_cCharName);
				//Tell client				
				ZeroMemory(cKillerMsg, sizeof(cKillerMsg));		
				wsprintf(cKillerMsg, "A %s soldier accepted to follow you.",m_pNpcList[i]->m_cNpcName );
				ShowClientMsg(iClientH,  "Mobilize",cKillerMsg);
			}
			break;
		case DEF_OWNERTYPE_PLAYER_WAITING:
			if (strcmp(m_pNpcList[i]->m_cFollowOwnerCharName, m_pClientList[iClientH]->m_cCharName) == 0)
			{	m_pNpcList[i]->m_iFollowOwnerIndex	= iClientH;
				m_pNpcList[i]->m_cFollowOwnerType	= DEF_OWNERTYPE_PLAYER;
				m_pNpcList[i]->m_cMoveType			= DEF_MOVETYPE_FOLLOW;
				//Tell client				
				ZeroMemory(cKillerMsg, sizeof(cKillerMsg));	
				if ( (m_bIsHeldenianMode == TRUE)
					&& (m_pMapList[m_pNpcList[i]->m_cMapIndex] != NULL)
					&& (m_pMapList[m_pNpcList[i]->m_cMapIndex]->m_bIsHeldenianMap == 1))
				{	wsprintf(cKillerMsg, "Recovered control of a %s soldier.",m_pNpcList[i]->m_cNpcName );
					ShowClientMsg(iClientH,  "Mobilize",cKillerMsg);
				}else
				{	wsprintf(cKillerMsg, "Recovered control of a %s summon.",m_pNpcList[i]->m_cNpcName );
					ShowClientMsg(iClientH,  "Summons",cKillerMsg);
			}	}
			break;
	}	}
	return ;
}
int CGame::iGetFollowerNumber(short sOwnerH, char cOwnerType)
{register int i, iTotal;
	iTotal = 0;
	for (i = 1; i < DEF_MAXNPCS; i++) 
	if ( (m_pNpcList[i] != NULL) && (m_pNpcList[i]->m_cMoveType == DEF_MOVETYPE_FOLLOW) ) 
	{	if ((m_pNpcList[i]->m_cFollowOwnerType == cOwnerType) && (m_pNpcList[i]->m_iFollowOwnerIndex == sOwnerH)
			/*&& (m_pNpcList[i]->m_bIsKilled != TRUE)*/) // a tester dans NpcKilledHandler d'abord
			iTotal++;
	}
	return iTotal;
}

void CGame::NpcKilledHandler(short sAttackerH, char cAttackerType, int iNpcH, short sDamage)
{
 short  sAttackerWeapon;
 int    * ip, i, iQuestIndex, iExp, iConstructionPoint, iWarContribution;
 double dTmp1, dTmp2, dTmp3;
 char   * cp, cData[120], cQuestRemain;

	if (m_pNpcList[iNpcH] == NULL) return;
	m_pNpcList[iNpcH]->m_cBehavior = DEF_BEHAVIOR_DEAD; // moved here by Snoopy

	if (m_pNpcList[iNpcH]->m_cActionLimit == 4) // safety in case of destroyed EnergySphere to allow another ES creation
	{	m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->m_iCurEnergySphereGoalPointIndex = -1;
	}
	if (m_pNpcList[iNpcH]->m_bIsKilled == TRUE) return;

	m_pNpcList[iNpcH]->m_bIsKilled = TRUE;
	m_pNpcList[iNpcH]->m_iHP = 0;
	m_pNpcList[iNpcH]->m_iLastDamage = sDamage;

	RemoveFromTarget(iNpcH, DEF_OWNERTYPE_NPC);
	ReleaseFollowMode(iNpcH); 
	m_pNpcList[iNpcH]->m_cFollowOwnerType  = NULL; // Snoopy's add
	m_pNpcList[iNpcH]->m_iFollowOwnerIndex = NULL; // Snoopy's add

	m_pNpcList[iNpcH]->m_iTargetIndex = NULL;
	m_pNpcList[iNpcH]->m_cTargetType  = NULL;
	if ((cAttackerType == DEF_OWNERTYPE_PLAYER) && (m_pClientList[sAttackerH] != NULL))
	{	sAttackerWeapon = ((m_pClientList[sAttackerH]->m_sAppr2 & 0x0FF0) >> 4);	
	}else sAttackerWeapon = 1;
	SendEventToNearClient_TypeA(iNpcH, DEF_OWNERTYPE_NPC, MSGID_EVENT_MOTION, DEF_OBJECTDYING, sDamage, sAttackerWeapon, NULL);
	m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->ClearOwner(10, iNpcH, DEF_OWNERTYPE_NPC, m_pNpcList[iNpcH]->m_sX, m_pNpcList[iNpcH]->m_sY);
	m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->SetDeadOwner(iNpcH, DEF_OWNERTYPE_NPC, m_pNpcList[iNpcH]->m_sX, m_pNpcList[iNpcH]->m_sY);
	//m_pNpcList[iNpcH]->m_cBehavior = DEF_BEHAVIOR_DEAD;
	m_pNpcList[iNpcH]->m_sBehaviorTurnCount = 0;
	m_pNpcList[iNpcH]->m_dwDeadTime = timeGetTime();
	if (m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->m_cType == DEF_MAPTYPE_NOPENALTY_NOREWARD) return;
	
	NpcDeadItemGenerator(iNpcH, sAttackerH, cAttackerType);

	if (   (cAttackerType == DEF_OWNERTYPE_PLAYER)
		&& (m_pClientList[sAttackerH] != NULL)  // Snoopy: Added normal XP for killing ennemy summons
		&& ((m_pNpcList[iNpcH]->m_bIsSummoned != TRUE) || ((m_pClientList[sAttackerH]->m_cSide != m_pNpcList[iNpcH]->m_cSide))) )		 
	{	iExp = (m_pNpcList[iNpcH]->m_iExp/3);
		if (m_pNpcList[iNpcH]->m_iNoDieRemainExp > 0)
			iExp += m_pNpcList[iNpcH]->m_iNoDieRemainExp;
		// SNOOPY: Now Adding weapon bonus XP (20%) added after party bonus
		if ((m_pClientList[sAttackerH]->m_iAddExp != NULL) && ( m_iXPBonusType < 2))  
		{	dTmp1 = (double)m_pClientList[sAttackerH]->m_iAddExp;
			dTmp2 = (double)iExp;
			dTmp3 = (dTmp1/100.0f)*dTmp2;
			iExp += (int)dTmp3;
		}		
		if (m_bIsCrusadeMode == TRUE) //  1/3
		{	if (iExp > 10) iExp = iExp/3;
		}
		GetExp(sAttackerH, iExp, TRUE);
		iQuestIndex = m_pClientList[sAttackerH]->m_iQuest;
		if (iQuestIndex != NULL) {
			if (m_pQuestConfigList[iQuestIndex] != NULL) 
			{	switch (m_pQuestConfigList[iQuestIndex]->m_iType) {
				case DEF_QUESTTYPE_MONSTERHUNT:
					if (   (m_pClientList[sAttackerH]->m_bQuestMatchFlag_Loc == TRUE) 
						&& (m_pQuestConfigList[iQuestIndex]->m_iTargetType == m_pNpcList[iNpcH]->m_sType)
						&& (m_pNpcList[iNpcH]->m_bIsSummoned == FALSE)	
						// Only master quest can be done on own tamed mobs
						&& ((m_pNpcList[iNpcH]->m_dwTamingTime == 0) || (m_pNpcList[iNpcH]->m_iFollowOwnerIndex == sAttackerH))
						
						)  // Prevents making quests on summons
					{	m_pClientList[sAttackerH]->m_iCurQuestCount++;
						cQuestRemain = (m_pQuestConfigList[m_pClientList[sAttackerH]->m_iQuest]->m_iMaxCount - m_pClientList[sAttackerH]->m_iCurQuestCount);
						SendNotifyMsg(NULL, sAttackerH, DEF_NOTIFY_QUESTCOUNTER, cQuestRemain, NULL, NULL, NULL);
						_bCheckIsQuestCompleted(sAttackerH);
					}
					break;
	}	}	}	}
	// 
	if ((cAttackerType == DEF_OWNERTYPE_PLAYER) && (m_pClientList[sAttackerH] != NULL)) 
	{	switch (m_pNpcList[iNpcH]->m_sType) {
		case 32: // Unicorn => reputation -5 
			m_pClientList[sAttackerH]->m_iRating -= 5;
			if (m_pClientList[sAttackerH]->m_iRating < -10000) m_pClientList[sAttackerH]->m_iRating = -10000;
			if (m_pClientList[sAttackerH]->m_iRating >  10000) m_pClientList[sAttackerH]->m_iRating = 10000;
			AdjustClientDropRate(sAttackerH);
			wsprintf(G_cTxt, "(!) %s has been killed by %s(Lvl%d)\t(-5 Rep->%d)\t%s(%d %d)\tIP(%s)"
				, m_pNpcList[iNpcH]->m_cNpcName
				, m_pClientList[sAttackerH]->m_cCharName
				, m_pClientList[sAttackerH]->m_iLevel
				, m_pClientList[sAttackerH]->m_iRating
				, m_pClientList[sAttackerH]->m_cMapName
				, m_pClientList[sAttackerH]->m_sX
				, m_pClientList[sAttackerH]->m_sY
				, m_pClientList[sAttackerH]->m_cIPaddress);
			PutLogList(G_cTxt);	
			PutLogFileList(G_cTxt);	
			break;

		case 33:
			break;
		case 81: // Abaddon
			for (i = 1; i < DEF_MAXCLIENTS; i++) 
			{	if (m_pClientList[i] != NULL) 		
				{	SendNotifyMsg(sAttackerH, i, DEF_NOTIFY_ABADDONKILLED, NULL, NULL, NULL, NULL,NULL,NULL,NULL,NULL,NULL,NULL, NULL);		
			}	}
		case 49: // Hellclaw
		case 50: // Tigerworm
		case 66: // Wyvern
		case 73: // Fire-Wyvern
			// Log some npc killings...
			wsprintf(G_cTxt, "(!) %s has been killed by %s(Lvl%d)\t%s(%d %d)\tIP(%s)"
				, m_pNpcList[iNpcH]->m_cNpcName
				, m_pClientList[sAttackerH]->m_cCharName
				, m_pClientList[sAttackerH]->m_iLevel
				, m_pClientList[sAttackerH]->m_cMapName
				, m_pClientList[sAttackerH]->m_sX
				, m_pClientList[sAttackerH]->m_sY
				, m_pClientList[sAttackerH]->m_cIPaddress);
			PutLogList(G_cTxt);	
			PutLogFileList(G_cTxt);	
			break;
	}	}	
	// Contribution when your summons kill...
	if (   (m_bHeldenianWarInitiated == TRUE) 
		&& (m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->m_bIsHeldenianMap == TRUE)) 
	{	if (   (cAttackerType == DEF_OWNERTYPE_NPC)
			&& (m_pNpcList[sAttackerH] != NULL)
			&& (m_pNpcList[sAttackerH]->m_bIsSummoned		== TRUE)
			&& (m_pNpcList[sAttackerH]->m_cFollowOwnerType  == DEF_OWNERTYPE_PLAYER)
			&& (m_pNpcList[sAttackerH]->m_bIsKilled			== FALSE)	
			&& (m_pClientList[m_pNpcList[sAttackerH]->m_iFollowOwnerIndex] != NULL) 
			&& (m_pClientList[m_pNpcList[sAttackerH]->m_iFollowOwnerIndex]->m_bIsKilled == FALSE)) 
		{	m_pClientList[m_pNpcList[sAttackerH]->m_iFollowOwnerIndex]->m_iWarContribution += m_pNpcList[iNpcH]->m_iHitDice;
	}	}

	if(m_pNpcList[iNpcH]->m_sType == 64) m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->bRemoveCropsTotalSum();
	if(m_pNpcList[iNpcH]->m_sType == 91) // Remove bloqued area
	{	for(short sx1 = (m_pNpcList[iNpcH]->m_sX - 1); sx1 <= m_pNpcList[iNpcH]->m_sX + 1; sx1++)
		for(short sy1 = (m_pNpcList[iNpcH]->m_sY - 1); sy1 <= m_pNpcList[iNpcH]->m_sY + 1; sy1++)
		{	m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->SetTempMoveAllowedFlag(sx1, sy1, TRUE);	
	}	}
	if (m_bIsCrusadeMode == TRUE)// Crusade
	{	iConstructionPoint = 0;
		switch (m_pNpcList[iNpcH]->m_sType) {
		case 1:  iConstructionPoint = 50;   iWarContribution = 100;   break; // Mercenaries
		case 2:  iConstructionPoint = 50;   iWarContribution = 100;   break;
		case 3:  iConstructionPoint = 50;   iWarContribution = 100;   break;
		case 4:  iConstructionPoint = 50;   iWarContribution = 100;   break;
		case 5:  iConstructionPoint = 50;   iWarContribution = 100;   break;
		case 6:  iConstructionPoint = 50;   iWarContribution = 100;   break;	
		case 36: iConstructionPoint = 700;  iWarContribution = 4000;  break; // AGT
		case 37: iConstructionPoint = 700;  iWarContribution = 4000;  break; // CGT
		case 38: iConstructionPoint = 500;  iWarContribution = 2000;  break; // ManaColector
		case 39: iConstructionPoint = 500;  iWarContribution = 2000;  break; // DT
		case 40: iConstructionPoint = 1500; iWarContribution = 5000;  break; // EnergyShieldGenerator
		case 41: iConstructionPoint = 5000; iWarContribution = 10000; break; // GMS
		case 43: iConstructionPoint = 500;  iWarContribution = 1000;  break; // LWB
		case 44: iConstructionPoint = 1000; iWarContribution = 2000;  break; // GHK
		case 45: iConstructionPoint = 1500; iWarContribution = 3000;  break; // GHKABS
		case 46: iConstructionPoint = 1000; iWarContribution = 2000;  break; // TK
		case 47: iConstructionPoint = 1500; iWarContribution = 3000;  break; // BK
		}
		if (iConstructionPoint != 0)
		{	switch (cAttackerType) {
			case DEF_OWNERTYPE_PLAYER:
				if (m_pClientList[sAttackerH] == NULL) break;
				if (m_pClientList[sAttackerH]->m_cSide != m_pNpcList[iNpcH]->m_cSide) 
				{	m_pClientList[sAttackerH]->m_iConstructionPoint += iConstructionPoint;
					m_pClientList[sAttackerH]->m_iWarContribution   += iWarContribution;
					if (m_pClientList[sAttackerH]->m_iConstructionPoint > DEF_MAXCONSTRUCTIONPOINT) 
						m_pClientList[sAttackerH]->m_iConstructionPoint = DEF_MAXCONSTRUCTIONPOINT;
					if (m_pClientList[sAttackerH]->m_iWarContribution > DEF_MAXWARCONTRIBUTION)
						m_pClientList[sAttackerH]->m_iWarContribution = DEF_MAXWARCONTRIBUTION;					
					if (m_pClientList[sAttackerH]->m_iWarContribution >= 256*128)
						SendNotifyMsg(NULL, sAttackerH, DEF_NOTIFY_CONSTRUCTIONPOINT, m_pClientList[sAttackerH]->m_iConstructionPoint, (m_pClientList[sAttackerH]->m_iWarContribution %(256*128)), 1, NULL);
					//printf(G_cTxt, "Construction Complete: PC(%s) - WarContribution +%d - "
					wsprintf(G_cTxt, "Enemy Npc Killed     : PC(%s) - WarContribution +%d(%d) - WarSummon +%d(%d)"
						, m_pClientList[sAttackerH]->m_cCharName
						, iWarContribution
						, m_pClientList[sAttackerH]->m_iWarContribution
						, iConstructionPoint
						, m_pClientList[sAttackerH]->m_iConstructionPoint);
					PutLogList(G_cTxt);
					PutLogEventFileList(G_cTxt);
					SendNotifyMsg(NULL, sAttackerH, DEF_NOTIFY_CONSTRUCTIONPOINT, m_pClientList[sAttackerH]->m_iConstructionPoint, m_pClientList[sAttackerH]->m_iWarContribution, NULL, NULL);
				}else 
				{	m_pClientList[sAttackerH]->m_iWarContribution   -= (iWarContribution*2);
					if (m_pClientList[sAttackerH]->m_iWarContribution < 0)
						m_pClientList[sAttackerH]->m_iWarContribution = 0;
					wsprintf(G_cTxt, "Friendly Npc Killed  : PC(%s) - WarContribution -%d"
						, m_pClientList[sAttackerH]->m_cCharName
						, iWarContribution*2);
					PutLogList(G_cTxt);
					PutLogEventFileList(G_cTxt);
					SendNotifyMsg(NULL, sAttackerH, DEF_NOTIFY_CONSTRUCTIONPOINT, m_pClientList[sAttackerH]->m_iConstructionPoint, m_pClientList[sAttackerH]->m_iWarContribution, NULL, NULL);
				}
				break;

			case DEF_OWNERTYPE_NPC:
				if (m_pNpcList[sAttackerH] == NULL) break;
				if (m_pNpcList[sAttackerH]->m_iGuildGUID != NULL) 
				{	if (m_pNpcList[sAttackerH]->m_cSide != m_pNpcList[iNpcH]->m_cSide) 
					{	for (i = 1; i < DEF_MAXCLIENTS; i++)
						if (   (m_pClientList[i] != NULL) && (m_pClientList[i]->m_iGuildGUID == m_pNpcList[sAttackerH]->m_iGuildGUID) 
							&& (m_pClientList[i]->m_iCrusadeDuty == 3)) 
						{	m_pClientList[i]->m_iConstructionPoint += iConstructionPoint;
							if (m_pClientList[i]->m_iConstructionPoint > DEF_MAXCONSTRUCTIONPOINT) 
								m_pClientList[i]->m_iConstructionPoint = DEF_MAXCONSTRUCTIONPOINT;
							wsprintf(G_cTxt, "Enemy Npc Killed     : by Npc - WarSummon +%d"
								, iConstructionPoint);
							PutLogList(G_cTxt);
							PutLogEventFileList(G_cTxt);
							SendNotifyMsg(NULL, i, DEF_NOTIFY_CONSTRUCTIONPOINT, m_pClientList[i]->m_iConstructionPoint, m_pClientList[i]->m_iWarContribution, NULL, NULL);
							goto NKH_GOTOPOINT1;
						}				
						ZeroMemory(cData, sizeof(cData));
						cp = (char *)cData;
						*cp = GSM_CONSTRUCTIONPOINT;
						cp++;
						ip = (int*)cp;
						*ip = m_pNpcList[sAttackerH]->m_iGuildGUID;
						cp += 4;
						ip = (int*)cp;
						*ip = iConstructionPoint;
						cp += 4;
						bStockMsgToGateServer(cData, 9);
				}	}
				break;
	}	}	}

NKH_GOTOPOINT1:;
	// Explosive 
	if (m_pNpcList[iNpcH]->m_cSpecialAbility == 7) 
	{	m_pNpcList[iNpcH]->m_iMana = 100;
		m_pNpcList[iNpcH]->m_iMagicHitRatio = 100;
		NpcMagicHandler(iNpcH, m_pNpcList[iNpcH]->m_sX, m_pNpcList[iNpcH]->m_sY, 30); 
	}else if (m_pNpcList[iNpcH]->m_cSpecialAbility == 8) // Critical Explosive
	{	m_pNpcList[iNpcH]->m_iMana = 200;
		m_pNpcList[iNpcH]->m_iMagicHitRatio = 200;
		NpcMagicHandler(iNpcH, m_pNpcList[iNpcH]->m_sX, m_pNpcList[iNpcH]->m_sY, 61); 
	}
	if (   (m_bIsHeldenianMode == TRUE) && (m_cHeldenianType == 1) 
		&& (m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->m_bIsHeldenianMap == TRUE) ) 
	{	if ((m_pNpcList[iNpcH]->m_sType == 87) || (m_pNpcList[iNpcH]->m_sType == 89)) 
		{	if (m_pNpcList[iNpcH]->m_cSide == 1) 
			{	m_iHeldenianAresdenLeftTower--;
				if (m_cHeldenianFirstDestroyedTowerWinner == 0)  m_cHeldenianFirstDestroyedTowerWinner = 2;
				wsprintf(G_cTxt, "Aresden Tower Broken, Left TOWER %d", m_iHeldenianAresdenLeftTower);
				PutLogList(G_cTxt);
				UpdateHeldenianStatus(-1);
				if (m_iHeldenianAresdenLeftTower == 0)	HeldenianVictoryNow(2);				
			}else if (m_pNpcList[iNpcH]->m_cSide == 2) 
			{	m_iHeldenianElvineLeftTower--;
				if (m_cHeldenianFirstDestroyedTowerWinner == 0)  m_cHeldenianFirstDestroyedTowerWinner = 1;
				wsprintf(G_cTxt, "Elvine Tower Broken, Left TOWER %d", m_iHeldenianElvineLeftTower);
				PutLogList(G_cTxt);
				UpdateHeldenianStatus(-1);
				if (m_iHeldenianElvineLeftTower == 0)	HeldenianVictoryNow(1);	
	}	}	}
}

int CGame::iGetDangerValue(int iNpcH, short dX, short dY)
{register int ix, iy, iDangerValue;
 short sOwner, sDOType;
 char  cOwnerType;
 DWORD dwRegisterTime;
	if (m_pNpcList[iNpcH] == NULL) return FALSE;
	iDangerValue = 0;
	for (ix = dX - 2; ix <= dX + 2; ix++)
	for (iy = dY - 2; iy <= dY + 2; iy++) {
		m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->GetOwner(&sOwner, &cOwnerType, ix, iy);	
		m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->bGetDynamicObject( ix, iy, &sDOType, &dwRegisterTime );		
		if (sDOType == 1)  iDangerValue++;	// Fire
		if (sDOType == 8)  iDangerValue++;	// IceStorm
		if (sDOType == 11) iDangerValue++;	// POISON
		if (sDOType == 14) iDangerValue++;	// FireBow
		switch (cOwnerType) {
		case NULL:
			break;
		case DEF_OWNERTYPE_PLAYER:
			if (m_pClientList[sOwner] == NULL) break;
			if (m_pNpcList[iNpcH]->m_cSide != m_pClientList[sOwner]->m_cSide) 
				 iDangerValue++;
			else iDangerValue--;
			break;
		case DEF_OWNERTYPE_NPC:
			if (m_pNpcList[sOwner] == NULL) break;
			if (m_pNpcList[iNpcH]->m_cSide != m_pNpcList[sOwner]->m_cSide) 
				 iDangerValue++;
			else iDangerValue--;
			break;	
	}	}
	return iDangerValue;
}

void CGame::NpcBehavior_Flee(int iNpcH)
{char cDir;
 short sX, sY, dX, dY;
 short sTarget;
 char  cTargetType;
	if (m_pNpcList[iNpcH] == NULL) return;
	if (m_pNpcList[iNpcH]->m_bIsKilled == TRUE) return;
	m_pNpcList[iNpcH]->m_sBehaviorTurnCount++;
	switch (m_pNpcList[iNpcH]->m_iAttackStrategy) {
	case DEF_ATTACKAI_EXCHANGEATTACK:  
	case DEF_ATTACKAI_TWOBYONEATTACK: 
		if (m_pNpcList[iNpcH]->m_sBehaviorTurnCount >= 2) 
		{	m_pNpcList[iNpcH]->m_cBehavior          = DEF_BEHAVIOR_ATTACK;
			m_pNpcList[iNpcH]->m_sBehaviorTurnCount = 0;
			return;
		}
		break;
	case DEF_ATTACKAI_FOURBYONEATTACK: 
		if (m_pNpcList[iNpcH]->m_sBehaviorTurnCount >= 4) 
		{	m_pNpcList[iNpcH]->m_cBehavior          = DEF_BEHAVIOR_ATTACK;
			m_pNpcList[iNpcH]->m_sBehaviorTurnCount = 0;
			return;
		}
		break;	
	default:
		if (iDice(1,2) == 1) NpcRequestAssistance(iNpcH);
		break;
	}
	if (m_pNpcList[iNpcH]->m_sBehaviorTurnCount > 10) {
		m_pNpcList[iNpcH]->m_sBehaviorTurnCount = 0;	
		m_pNpcList[iNpcH]->m_cBehavior          = DEF_BEHAVIOR_MOVE;
		m_pNpcList[iNpcH]->m_tmp_iError         = 0;
		if (m_pNpcList[iNpcH]->m_iHP <= 3) 
		{	m_pNpcList[iNpcH]->m_iHP += iDice(1, m_pNpcList[iNpcH]->m_iHitDice); 
			if (m_pNpcList[iNpcH]->m_iHP <= 0) m_pNpcList[iNpcH]->m_iHP = 1;
		}
		return;
	}
	// SNOOPY: Buggy here if TargetSearchfunction returns a faultly target
	// server will crash ! (added "else return")
	TargetSearch(iNpcH, &sTarget, &cTargetType);				
	if (sTarget != NULL) 
	{	m_pNpcList[iNpcH]->m_iTargetIndex = sTarget;
		m_pNpcList[iNpcH]->m_cTargetType  = cTargetType;
	}else return;

	sX = m_pNpcList[iNpcH]->m_sX;
	sY = m_pNpcList[iNpcH]->m_sY;
	switch (m_pNpcList[iNpcH]->m_cTargetType) {
	case DEF_OWNERTYPE_PLAYER:
		dX = m_pClientList[m_pNpcList[iNpcH]->m_iTargetIndex]->m_sX;
		dY = m_pClientList[m_pNpcList[iNpcH]->m_iTargetIndex]->m_sY;
		break;
	case DEF_OWNERTYPE_NPC:
		dX = m_pNpcList[m_pNpcList[iNpcH]->m_iTargetIndex]->m_sX;
		dY = m_pNpcList[m_pNpcList[iNpcH]->m_iTargetIndex]->m_sY;
		break;
	}
	dX = sX - (dX - sX);
	dY = sY - (dY - sY);
	cDir = cGetNextMoveDir(sX, sY, dX, dY, m_pNpcList[iNpcH]->m_cMapIndex, m_pNpcList[iNpcH]->m_cTurn, &m_pNpcList[iNpcH]->m_tmp_iError);
	if (cDir == 0) 
	{}else 
	{	dX = m_pNpcList[iNpcH]->m_sX + _tmp_cTmpDirX[cDir];
		dY = m_pNpcList[iNpcH]->m_sY + _tmp_cTmpDirY[cDir];
		m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->ClearOwner(11, iNpcH, DEF_OWNERTYPE_NPC, m_pNpcList[iNpcH]->m_sX, m_pNpcList[iNpcH]->m_sY);
		m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->SetOwner(iNpcH, DEF_OWNERTYPE_NPC, dX, dY);
		m_pNpcList[iNpcH]->m_sX   = dX;
		m_pNpcList[iNpcH]->m_sY   = dY;
		m_pNpcList[iNpcH]->m_cDir = cDir;
		SendEventToNearClient_TypeA(iNpcH, DEF_OWNERTYPE_NPC, MSGID_EVENT_MOTION, DEF_OBJECTMOVE, NULL, NULL, NULL);
	}
}

void CGame::MsgProcess()
{
 char   * pData, cFrom, cKey;
 DWORD    dwMsgSize, * dwpMsgID, dwMsgTime;
 WORD   * wpMsgType, * wp;
 int      i, iClientH;
 //char   m_msgBuff[DEF_MSGBUFFERSIZE+1];
 DWORD  dwTime = timeGetTime();

	if ((m_bF5pressed == TRUE) && (m_bF1pressed == TRUE)) 
	{	PutLogList("(XXX) RELOADING CONFIGS MANUALY... [F1] + [F5]");
		m_bF5pressed = FALSE;
		m_bF1pressed = FALSE;
		if (m_iTotalClients > 0)
		{	_iForcePlayerDisconect(15);	
			bRegisterDelayEvent(DEF_DELAYEVENTTYPE_RESTART_SERVER, 0, dwTime + 2000 ,0, 0, NULL, NULL, NULL, 0, NULL, NULL);
		}else
		{	PutLogList("(!) CONFIGS RELOADING NOW...");
			bInit();
			return;
		}
	}
	if ((m_bF1pressed == TRUE) && (m_bF4pressed == TRUE) && (m_bOnExitProcess == FALSE)) 
	{	m_cShutDownCode      = 2;
		m_bOnExitProcess     = TRUE;
		m_bF4pressed = FALSE;
		m_bF1pressed = FALSE;
		m_dwExitProcessTime  = timeGetTime();
		PutLogList("(!) GAME SERVER SHUTDOWN PROCESS BEGIN(by Local command)!!!");
		bSendMsgToLS(MSGID_GAMESERVERSHUTDOWNED, NULL);
		return;		
	}
	
	ZeroMemory(m_pMsgBuffer, DEF_MSGBUFFERSIZE+1);
	pData = (char *) m_pMsgBuffer;
	m_iCurMsgs = 0;
	while (bGetMsgQuene(&cFrom, pData, &dwMsgSize, &iClientH, &cKey, &dwMsgTime) == TRUE) 
	{	m_iCurMsgs++;
		if (m_iCurMsgs > m_iMaxMsgs) m_iMaxMsgs = m_iCurMsgs;
		switch (cFrom) {
		case DEF_MSGFROM_GATESERVER:
			dwpMsgID   = (DWORD *)(pData + DEF_INDEX4_MSGID);
			wpMsgType  = (WORD *)(pData + DEF_INDEX2_MSGTYPE);

			switch (*dwpMsgID) {
			// New 07/05/2004
			case MSGID_PARTYOPERATION:
				PartyOperationResultHandler(pData);
				break;

			case MSGID_SERVERSTOCKMSG:
				//DbgWnd->AddEventMsg("RECV -> DEF_MSGFROM_GATESERVER -> MSGID_SERVERSTOCKMSG");
				ServerStockMsgHandler(pData);
				break;
									
			case MSGID_SENDSERVERSHUTDOWNMSG:
				//DbgWnd->AddEventMsg("RECV -> DEF_MSGFROM_GATESERVER -> MSGID_SENDSERVERSHUTDOWNMSG");
				wp = (WORD *)(pData + DEF_INDEX2_MSGTYPE + 2);
				switch (*wp) {
				case 1:
					PutLogList("(!) Send server shutdown announcement - 1.");
					for (i = 1; i < DEF_MAXCLIENTS; i++)
					if ((m_pClientList[i] != NULL) && (m_pClientList[i]->m_bIsInitComplete == TRUE)) {
						SendNotifyMsg(NULL, i, DEF_NOTIFY_SERVERSHUTDOWN, 1, NULL, NULL, NULL);
					}
					break;
				
				case 2:
					PutLogList("(!) Send server shutdown announcement - 2.");
					for (i = 1; i < DEF_MAXCLIENTS; i++)
					if ((m_pClientList[i] != NULL) && (m_pClientList[i]->m_bIsInitComplete == TRUE)) {
						SendNotifyMsg(NULL, i, DEF_NOTIFY_SERVERSHUTDOWN, 2, NULL, NULL, NULL);
					}
					break;
				}
				bSendMsgToLS(MSGID_SENDSERVERSHUTDOWNMSG, NULL, NULL); 
				break;
			
			case MSGID_GAMESERVERSHUTDOWNED:
				//DbgWnd->AddEventMsg("RECV -> DEF_MSGFROM_GATESERVER -> MSGID_GAMESERVERSHUTDOWNED");
				m_cShutDownCode      = 1;
				m_bOnExitProcess     = TRUE;
				m_dwExitProcessTime  = timeGetTime();
				PutLogList("(!) GAME SERVER SHUTDOWN PROCESS BEGIN(by Global command)!!!");
				bSendMsgToLS(MSGID_GAMESERVERSHUTDOWNED, NULL);				
				break;
			
			case MSGID_TOTALGAMESERVERCLIENTS:
				// This msg is generated by Gate
				wp = (WORD *)(pData + DEF_INDEX2_MSGTYPE + 2);
				m_iTotalGameServerClients = (int)*wp;
				if (m_iTotalGameServerClients > m_iTotalGameServerMaxClients) 
					m_iTotalGameServerMaxClients = m_iTotalGameServerClients;
				break;
			
			case MSGID_RESPONSE_REGISTERGAMESERVER:
				//DbgWnd->AddEventMsg("RECV -> DEF_MSGFROM_GATESERVER -> MSGID_RESPONSE_REGISTERGAMESERVER");
				switch (*wpMsgType) {
				case DEF_MSGTYPE_CONFIRM:
					//DbgWnd->AddEventMsg("RECV -> DEF_MSGFROM_GATESERVER -> MSGID_RESPONSE_REGISTERGAMESERVER -> DEF_MSGTYPE_CONFIRM");
					PutLogList("(<<<G) Game Server registration to Gate - Success!");
					m_bIsGateSockAvailable = TRUE;
					break;

				case DEF_MSGTYPE_REJECT:
					//DbgWnd->AddEventMsg("RECV -> DEF_MSGFROM_GATESERVER -> MSGID_RESPONSE_REGISTERGAMESERVER -> DEF_MSGTYPE_REJECT");
					PutLogList("(!!!G) Game Server registration to Gate - Fail!");
					PutLogList(" ");
					PutLogList("(!!!) STOPPED!");
					break;
				}				
				//wsprintf(G_cTxt, "%d %d %d %d %d %d %d", (int)m_bIsGameStarted, (int)m_bIsItemAvailable, m_bIsNpcAvailable, (int)m_bIsGateSockAvailable, (int)m_bIsLogSockAvailable, (int)m_bIsMagicAvailable, (int)m_bIsSkillAvailable);
				//PutLogList(G_cTxt);
				/*	if ((m_bIsGameStarted == FALSE) && (m_bIsItemAvailable == TRUE) && 
					(m_bIsNpcAvailable == TRUE) && (m_bIsGateSockAvailable == TRUE) &&
					(m_bIsLogSockAvailable == TRUE) && (m_bIsMagicAvailable == TRUE) &&
					(m_bIsSkillAvailable == TRUE) && (m_bIsPortionAvailable == TRUE) &&
					(m_bIsQuestAvailable == TRUE) ) {
					SendMessage(m_hWnd, WM_USER_STARTGAMESIGNAL, NULL, NULL); 
					m_bIsGameStarted = TRUE;
				} */
				break;
			}
			break;
		
		case DEF_MSGFROM_CLIENT:
			// 1st: log out corrupted packets from client
			// ici, rajouter un check sur les clients qui viennent juste d'être éffacés.
			if (m_pClientList[iClientH] == NULL)// Remember erased clients	
			{	if (iClientH != NULL)
				{	for (i = 0; i < DEF_MAXCLIENTS; i++) 
					{	if (   (iClientH == m_stOldClientList[i].iClientH)
							&& (dwTime > (m_stOldClientList[i].m_dwDeleteTime - 10*1000))  // give 10 sec to prevent DW overflow
							&& (dwTime < (m_stOldClientList[i].m_dwDeleteTime + 30*1000))) // erased less than 30 sec ago
						{	wsprintf(G_cTxt, "Outdated message:  PC(%s) - PC disconnected %d ms ago."
								, m_stOldClientList[i].m_cCharName
								, dwTime - m_stOldClientList[i].m_dwDeleteTime);
							goto OUTDATED_PROUVED;						
				}	}	}

				wsprintf(G_cTxt, "Corrupt message received! (From unknown client):");	
OUTDATED_PROUVED:		
				PutHackLogFileList(G_cTxt);
				PutHackLogFileList(m_pMsgBuffer);
				return;	
			}
			m_pClientList[iClientH]->m_iConnectionCheck++;
			// Delete client if reaching 256+ messages without connection check, 
			// and too much missing connection checks as well
			if (m_pClientList[iClientH]->m_iConnectionCheck == m_iClientConnectionCheckMaxNumber *8)  
			{	if ((dwMsgTime - m_pClientList[iClientH]->dwEventTimeConnectionCheck) > (m_iClientConnectionCheckTime*8))
				{	wsprintf(G_cTxt, "Cn check:  PC(%s) (Gap=%4d) (nb:%3d)            - CCM missing, forbidden task on client's PC? (Disc.) \tIP(%s)"					
						, m_pClientList[iClientH]->m_cCharName
						, dwMsgTime - m_pClientList[iClientH]->dwEventTimeConnectionCheck
						, m_pClientList[iClientH]->m_iConnectionCheck
						, m_pClientList[iClientH]->m_cIPaddress);
					PutHackLogFileList(G_cTxt);
					//	Show in red on client!
					ZeroMemory(m_cBugText, sizeof(m_cBugText));
					wsprintf(m_cBugText, "HACK SUSPICTION:  CCM missing, forbidden task on PC: %s"
						, m_pClientList[iClientH]->m_cCharName
						, m_pClientList[iClientH]->m_cIPaddress);
					DeleteClient(iClientH, TRUE, TRUE);
					m_iBugWarning = 1;
					break;
			}	}

			dwpMsgID = (DWORD *)(pData + DEF_INDEX4_MSGID);
			if ((m_pClientList[iClientH]->m_cDelayedDeco != 0)
				&& (*dwpMsgID != MSGID_COMMAND_CHECKCONNECTION))				
			{	break; // If the player is on a delayed deco, do not process msg
			}
			switch (*dwpMsgID) { // 84148741
						
			case MSGID_REQUEST_RESURRECTPLAYER_YES:
				m_pClientList[iClientH]->m_cMsgCount[1] +=1;
				RequestResurrectPlayer(iClientH, TRUE);
				break;

			case MSGID_REQUEST_RESURRECTPLAYER_NO:
				m_pClientList[iClientH]->m_cMsgCount[1] +=1;
				RequestResurrectPlayer(iClientH, FALSE);
				break;

			case MSGID_REQUEST_SELLITEMLIST:
				m_pClientList[iClientH]->m_cMsgCount[2] +=1;
				RequestSellItemListHandler(iClientH, pData);
				break;
			
			case MSGID_REQUEST_RESTART:
				m_pClientList[iClientH]->m_cMsgCount[1] +=1;
				RequestRestartHandler(iClientH);
				break;

			case MSGID_REQUEST_PANNING:
				m_pClientList[iClientH]->m_cMsgCount[1] +=1;
				iRequestPanningMapDataRequest(iClientH, pData);
				break;

			case MSGID_REQUEST_NOTICEMENT:
				m_pClientList[iClientH]->m_cMsgCount[3] +=1;
				RequestNoticementHandler(iClientH, pData);
				break;
			
			case MSGID_BWM_COMMAND_SHUTUP:
				m_pClientList[iClientH]->m_cMsgCount[4] +=1;
				//_BWM_Command_Shutup(pData);
				wsprintf(G_cTxt,"Crash attempt: PC(%s) Sent MSGID_BWM_COMMAND_SHUTUP. \tIP(%s)"
					, m_pClientList[iClientH]->m_cCharName
					, m_pClientList[iClientH]->m_cIPaddress );
				DeleteClient(iClientH, TRUE, TRUE);
				PutLogList(G_cTxt);
				PutHackLogFileList(G_cTxt);	
				ZeroMemory(m_cBugText, sizeof(m_cBugText));
				wsprintf(m_cBugText, "SERVER UNDER ATTACK: %s Sent MSGID_BWM_COMMAND_SHUTUP"
					, m_pClientList[iClientH]->m_cCharName);
				m_iBugWarning = 1;
				break;
			
			case MSGID_BWM_INIT:
				m_pClientList[iClientH]->m_cMsgCount[1] +=1;
				//_BWM_Init(iClientH, pData);
				wsprintf(G_cTxt,"Crash attempt: PC(%s) Sent MSGID_BWM_INIT . \tIP(%s)"
					, m_pClientList[iClientH]->m_cCharName
					, m_pClientList[iClientH]->m_cIPaddress );
				DeleteClient(iClientH, TRUE, TRUE);
				PutLogList(G_cTxt);
				PutHackLogFileList(G_cTxt);	
				ZeroMemory(m_cBugText, sizeof(m_cBugText));
				wsprintf(m_cBugText, "SERVER UNDER ATTACK: %s Sent MSGID_BWM_INIT"
					, m_pClientList[iClientH]->m_cCharName);
				m_iBugWarning = 1;
				break;
			
			case MSGID_REQUEST_SETITEMPOS:
				m_pClientList[iClientH]->m_cMsgCount[7] +=1;
				_SetItemPos(iClientH, pData);
				// This one can be sent many times in case of bag reorganisation
				// and risk of counting too many in m_iConnectionCheck
				m_pClientList[iClientH]->m_iConnectionCheck--;
				break;
			
			case MSGID_ADMINUSER:
				m_pClientList[iClientH]->m_cMsgCount[1] +=1;
				RequestAdminUserMode(iClientH, pData);
				break;
			
			case MSGID_REQUEST_FULLOBJECTDATA: 
				// This one can be sent many times in case of a GM sumoning lot of creature => Lag
				// and risk of counting too many in m_iConnectionCheck
				m_pClientList[iClientH]->m_iConnectionCheck--;
				m_pClientList[iClientH]->m_cMsgCount[5] +=1;
				RequestFullObjectData(iClientH, pData);
				break;
			
			case MSGID_REQUEST_RETRIEVEITEM:
				m_pClientList[iClientH]->m_cMsgCount[6] +=1;
				RequestRetrieveItemHandler(iClientH, pData);
				break;

			case MSGID_REQUEST_CIVILRIGHT:
				m_pClientList[iClientH]->m_cMsgCount[1] +=1;
				RequestCivilRightHandler(iClientH, pData);
				break;

			case MSGID_REQUEST_TELEPORT:
				m_pClientList[iClientH]->m_cMsgCount[1] +=1;
				RequestTeleportHandler(iClientH, pData);
				break;

			case MSGID_REQUEST_INITPLAYER:
				m_pClientList[iClientH]->m_cMsgCount[1] +=1;
				RequestInitPlayerHandler(iClientH, pData, cKey);
				break;

			case MSGID_REQUEST_INITDATA:
				m_pClientList[iClientH]->m_cMsgCount[1] +=1;
				if (m_pClientList[iClientH]->m_cInitProgress == 1) 
					RequestInitDataHandler(iClientH, pData, cKey);
				else 
				{	wsprintf(G_cTxt,"Crash attempt: PC(%s) Sent MSGID_REQUEST_INITDATA before MSGID_REQUEST_INITPLAYER. \tIP(%s)"
						, m_pClientList[iClientH]->m_cCharName
						, m_pClientList[iClientH]->m_cIPaddress );
					DeleteClient(iClientH, TRUE, TRUE);
					PutLogList(G_cTxt);
					PutHackLogFileList(G_cTxt);	
					ZeroMemory(m_cBugText, sizeof(m_cBugText));
					wsprintf(m_cBugText, "SERVER UNDER ATTACK: %s Sent MSGID_REQUEST_INITDATA before MSGID_REQUEST_INITPLAYER"
						, m_pClientList[iClientH]->m_cCharName);
					m_iBugWarning = 1;
				}	
				break;

			case MSGID_COMMAND_COMMON:
				m_pClientList[iClientH]->m_cMsgCount[8] +=1;
				ClientCommonHandler(iClientH, pData, dwMsgTime); // Common handler includes many sub-cases
				break;

			case MSGID_COMMAND_MOTION: // Includes time, so will be checked for DS attack
				m_pClientList[iClientH]->m_cMsgCount[9] +=1;
				ClientMotionHandler(iClientH, pData, dwMsgTime); // Motion handler includes many sub-cases
				break;

			case MSGID_COMMAND_CHECKCONNECTION:// Includes time, so will be checked for DS attack
				// will check and reset m_pClientList[iClientH]->m_cMsgCount[xx] +=1;
				CheckConnectionHandler(iClientH, pData, cKey, dwMsgTime);
				break;

			case MSGID_COMMAND_CHATMSG://
				m_pClientList[iClientH]->m_cMsgCount[4] +=1;
				ChatMsgHandler(iClientH, pData, dwMsgSize);
				break;

			case MSGID_REQUEST_CREATENEWGUILD:
				m_pClientList[iClientH]->m_cMsgCount[1] +=1;
				RequestCreateNewGuildHandler(iClientH, pData, dwMsgSize);
				break;

			case MSGID_REQUEST_DISBANDGUILD:
				m_pClientList[iClientH]->m_cMsgCount[1] +=1;
				RequestDisbandGuildHandler(iClientH, pData, dwMsgSize);
				break;

			case MSGID_REQUEST_FIGHTZONE_RESERVE:
				m_pClientList[iClientH]->m_cMsgCount[1] +=1;
				FightzoneReserveHandler(iClientH, pData, dwMsgSize);
				break;

			case MSGID_LEVELUPSETTINGS:
				m_pClientList[iClientH]->m_cMsgCount[1] +=1;
				LevelUpSettingsHandler(iClientH, pData, dwMsgSize);
				break;

			case MSGID_STATECHANGEPOINT:
				m_pClientList[iClientH]->m_cMsgCount[1] +=1;
				StateChangeHandler(iClientH, pData, dwMsgSize);
				break;

			case MSGID_REQUEST_TELEPORT_LIST:		// 0x0EA03202
				m_pClientList[iClientH]->m_cMsgCount[1] +=1;
				RequestTeleportListHandler(iClientH, pData, dwMsgSize);
				break;

			case MSGID_REQUEST_CHARGED_TELEPORT:	// 0x0EA03204
				m_pClientList[iClientH]->m_cMsgCount[1] +=1;
				RequestChargedTeleportHandler(iClientH, pData, dwMsgSize);
				break;

			case MSGID_REQUEST_HELDENIAN_TP_LIST:	// 0x0EA03206
				m_pClientList[iClientH]->m_cMsgCount[1] +=1;
				RequestHeldenianTeleportList(iClientH, pData, dwMsgSize);
				break;
			case MSGID_REQUEST_HELDENIAN_TP:		// 0x0EA03208
				m_pClientList[iClientH]->m_cMsgCount[1] +=1;
				RequestHeldenianTeleportNow(iClientH, pData, dwMsgSize);
				break;

			case MSGID_REQUEST_HELDENIAN_SCROLL:
				m_pClientList[iClientH]->m_cMsgCount[1] +=1;
				RequestHeldenianScroll(iClientH, pData, dwMsgSize);
				break;

			case MSGID_REQUEST_ANGEL: // Angels by Snoopy...
				m_pClientList[iClientH]->m_cMsgCount[1] +=1;
				GetAngelHandler(iClientH, pData, dwMsgSize);
				break;

			default:
				if (m_pClientList[iClientH] != NULL)  // Snoopy: Anti-crash check !
				{	wsprintf(G_cTxt,"Unknown message received: (0x%.8X) PC(%s) - (Delayed). \tIP(%s)"
						, *dwpMsgID
						, m_pClientList[iClientH]->m_cCharName
						, m_pClientList[iClientH]->m_cIPaddress );
					DelayedDeleteClient(iClientH, TRUE, TRUE);	
				}else
				{	wsprintf(G_cTxt,"Unknown message received: (0x%.8X) PC(unknown).", *dwpMsgID);
				}
				PutLogList(G_cTxt);
				PutHackLogFileList(G_cTxt);	
				PutHackLogFileList(m_pMsgBuffer);		
				break;
			}	
			break;

		case DEF_MSGFROM_LOGSERVER:
			dwpMsgID   = (DWORD *)(pData + DEF_INDEX4_MSGID);
			wpMsgType  = (WORD *)(pData + DEF_INDEX2_MSGTYPE);

			switch (*dwpMsgID) {
			case MSGID_REQUEST_CHECKACCOUNTPASSWORD:
				RequestCheckAccountPasswordHandler(pData, dwMsgSize);
				break;
			
			case MSGID_REQUEST_FORCEDISCONECTACCOUNT:
				//PutLogList("RECV -> DEF_MSGFROM_LOGSERVER -> MSGID_REQUEST_FORCEDISCONECTACCOUNT");				
				wpMsgType  = (WORD *)(pData + DEF_INDEX2_MSGTYPE);
				ForceDisconnectAccount((char *)(pData + DEF_INDEX2_MSGTYPE + 2), *wpMsgType);
				break;
			
			case MSGID_RESPONSE_SAVEPLAYERDATA_REPLY:
				//DbgWnd->AddEventMsg("RECV -> DEF_MSGFROM_LOGSERVER -> MSGID_RESPONSE_SAVEPLAYERDATA_REPLY");
				ResponseSavePlayerDataReplyHandler(pData, dwMsgSize);
				break;
			
			case MSGID_GUILDNOTIFY:
				GuildNotifyHandler(pData, dwMsgSize);
				break;
			
			case MSGID_RESPONSE_DISBANDGUILD:
				ResponseDisbandGuildHandler(pData, dwMsgSize);
				break;

			case MSGID_RESPONSE_CREATENEWGUILD:
				ResponseCreateNewGuildHandler(pData, dwMsgSize);
				break;
			
			case MSGID_RESPONSE_REGISTERGAMESERVER:
				switch (*wpMsgType) {
				case DEF_MSGTYPE_CONFIRM:
					PutLogList("(<<<W) Game Server registration to WorldServer - Success!");	
					m_bIsLogSockAvailable = TRUE;
					break;
				case DEF_MSGTYPE_REJECT:
					PutLogList("(!!!W) Game Server registration to WorldServer - Fail!");
					break;
				}		
				if (m_bIsBuildItemAvailable == FALSE) 
				{	PutLogList(" ");
					PutLogList("(!!!) STOPPED! Build-Item configuration error.");
				}								
				if (m_bIsItemAvailable == FALSE) 
				{	PutLogList(" ");
					PutLogList("(!!!) STOPPED! Item configuration error.");
				}				
				if (m_bIsNpcAvailable == FALSE) 
				{	PutLogList(" ");
					PutLogList("(!!!) STOPPED! Npc configuration error.");
				}
				if (m_bIsMagicAvailable == FALSE) 
				{	PutLogList(" ");
					PutLogList("(!!!) STOPPED! MAGIC configuration error.");
				}
				if (m_bIsSkillAvailable == FALSE) 
				{	PutLogList(" ");
					PutLogList("(!!!) STOPPED! SKILL configuration error.");
				}
				if (m_bIsQuestAvailable == FALSE) 
				{	PutLogList(" ");
					PutLogList("(!!!) STOPPED! QUEST configuration error.");
				}
				if (m_bIsPortionAvailable == FALSE) 
				{	PutLogList(" ");
					PutLogList("(!!!) STOPPED! POTION configuration error.");
				}
				//wsprintf(G_cTxt, "%d %d %d %d %d %d %d", (int)m_bIsGameStarted, (int)m_bIsItemAvailable, m_bIsNpcAvailable, (int)m_bIsGateSockAvailable, (int)m_bIsLogSockAvailable, (int)m_bIsMagicAvailable, (int)m_bIsSkillAvailable);
				//PutLogList(G_cTxt);
				/*
				if ((m_bIsGameStarted == FALSE) && (m_bIsItemAvailable == TRUE) && 
					(m_bIsNpcAvailable == TRUE) && (m_bIsGateSockAvailable == TRUE) &&
					(m_bIsLogSockAvailable == TRUE) && (m_bIsMagicAvailable == TRUE) &&
					(m_bIsSkillAvailable == TRUE) && (m_bIsPortionAvailable == TRUE) &&
					(m_bIsQuestAvailable == TRUE) ) {
					SendMessage(m_hWnd, WM_USER_STARTGAMESIGNAL, NULL, NULL); 
					m_bIsGameStarted = TRUE;
				}
				*/
				break;

			case MSGID_RESPONSE_PLAYERDATA:
				//DbgWnd->AddEventMsg("RECV -> DEF_MSGFROM_LOGSERVER -> MSGID_RESPONSE_PLAYERDATA");
				ResponsePlayerDataHandler(pData, dwMsgSize);
				break;

			case MSGID_BUILDITEMCONFIGURATIONCONTENTS:
				//DbgWnd->AddEventMsg("RECV -> DEF_MSGFROM_LOGSERVER -> MSGID_BUILDITEMCONFIGURATIONCONTENTS");
				// Build Item contents
				PutLogList("(!) BUILD-ITEM configuration contents received. Now decoding...");
				m_bIsBuildItemAvailable = _bDecodeBuildItemConfigFileContents((char *)(pData + DEF_INDEX2_MSGTYPE + 2), dwMsgSize);
				break;
			
			case MSGID_ITEMCONFIGURATIONCONTENTS:
				//DbgWnd->AddEventMsg("RECV -> DEF_MSGFROM_LOGSERVER -> MSGID_ITEMCONFIGURATIONCONTENTS");
				PutLogList("(!) ITEM configuration contents received. Now decoding...");
				m_bIsItemAvailable = _bDecodeItemConfigFileContents((char *)(pData + DEF_INDEX2_MSGTYPE + 2), dwMsgSize);
				break;

			case MSGID_NPCCONFIGURATIONCONTENTS:
				//DbgWnd->AddEventMsg("RECV -> DEF_MSGFROM_LOGSERVER -> MSGID_NPCCONFIGURATIONCONTENTS");
				PutLogList("(!) NPC configuration contents received. Now decoding...");
				m_bIsNpcAvailable = _bDecodeNpcConfigFileContents((char *)(pData + DEF_INDEX2_MSGTYPE + 2), dwMsgSize);
				break;
			
			case MSGID_MAGICCONFIGURATIONCONTENTS:
				//DbgWnd->AddEventMsg("RECV -> DEF_MSGFROM_LOGSERVER -> MSGID_MAGICCONFIGURATIONCONTENTS");
				PutLogList("(!) MAGIC configuration contents received. Now decoding...");
				m_bIsMagicAvailable = _bDecodeMagicConfigFileContents((char *)(pData + DEF_INDEX2_MSGTYPE + 2), dwMsgSize);
				break;

			case MSGID_SKILLCONFIGURATIONCONTENTS:
				//DbgWnd->AddEventMsg("RECV -> DEF_MSGFROM_LOGSERVER -> MSGID_SKILLCONFIGURATIONCONTENTS");
				PutLogList("(!) SKILL configuration contents received. Now decoding...");
				m_bIsSkillAvailable = _bDecodeSkillConfigFileContents((char *)(pData + DEF_INDEX2_MSGTYPE + 2), dwMsgSize);
				break;

			case MSGID_QUESTCONFIGURATIONCONTENTS:
				//DbgWnd->AddEventMsg("RECV -> DEF_MSGFROM_LOGSERVER -> MSGID_QUESTCONFIGURATIONCONTENTS");
				PutLogList("(!) QUEST configuration contents received. Now decoding...");
				m_bIsQuestAvailable = _bDecodeQuestConfigFileContents((char *)(pData + DEF_INDEX2_MSGTYPE + 2), dwMsgSize);
				break;

			case MSGID_PORTIONCONFIGURATIONCONTENTS:
				//DbgWnd->AddEventMsg("RECV -> DEF_MSGFROM_LOGSERVER -> MSGID_PORTIONCONFIGURATIONCONTENTS");
				PutLogList("(!) POTION configuration contents received. Now decoding...");
				m_bIsPortionAvailable = _bDecodePortionConfigFileContents((char *)(pData + DEF_INDEX2_MSGTYPE + 2), dwMsgSize);
				break;

			case MSGID_DUPITEMIDFILECONTENTS:
				//DbgWnd->AddEventMsg("RECV -> DEF_MSGFROM_LOGSERVER -> MSGID_DUPITEMIDFILECONTENTS");
				PutLogList("(!) DupItemID file contents received. Now decoding...");
				_bDecodeDupItemIDFileContents((char *)(pData + DEF_INDEX2_MSGTYPE + 2), dwMsgSize);
				break;

			case MSGID_NOTICEMENTFILECONTENTS:
				//DbgWnd->AddEventMsg("RECV -> DEF_MSGFROM_LOGSERVER -> MSGID_NOTICEMENTFILECONTENTS");
				PutLogList("(!) Noticement file contents received. Now decoding...");
				_bDecodeNoticementFileContents((char *)(pData + DEF_INDEX2_MSGTYPE + 2), dwMsgSize);
				break;
			}
			break;
		}
	}
}

// Snoopy: added Time (SocketEventime)
BOOL CGame::bPutMsgQuene(char cFrom, char * pData, DWORD dwMsgSize, int iIndex, char cKey, DWORD dwMsgTime)
{
	/*
	HANDLE hMutex;
	
	hMutex = OpenMutex(MUTEX_ALL_ACCESS, FALSE, m_cServerName);
	if (hMutex != NULL) return FALSE; // Â¹Ã‚Ã…Ã˜Â½ÂºÂ°Â¡ Â»Ã½Â¼ÂºÂµÃ‡Â¾Ã® Ã€Ã–Â´Ã™. Â¾Ã®ÂµÃ°Â¼Â±Â°Â¡ Ã…Â¥Â¸Â¦ ÃÂ¶Ã€Ã›ÃÃŸÃ€ÃŒÂ´Ã™. Â±Ã—Â³Ã‰ Â¸Â®Ã…Ã 

	hMutex = CreateMutex(NULL, FALSE, m_cServerName);
	*/
	if (m_pMsgQuene[m_iQueneTail] != NULL) return FALSE; 
	m_pMsgQuene[m_iQueneTail] = new class CMsg;

	if (m_pMsgQuene[m_iQueneTail] == NULL) return FALSE;
	if (m_pMsgQuene[m_iQueneTail]->bPut(cFrom, pData, dwMsgSize, iIndex, cKey, dwMsgTime) == FALSE) return FALSE;
	m_iQueneTail++;
	if (m_iQueneTail >= DEF_MSGQUENESIZE) m_iQueneTail = 0;
	//ReleaseMutex(hMutex);
	return TRUE;
}

// Snoopy: added Time (SocketEventime)
BOOL CGame::bGetMsgQuene(char * pFrom, char * pData, DWORD * pMsgSize, int * pIndex, char * pKey, DWORD * pTime)
{	/*
	HANDLE hMutex;	
	hMutex = OpenMutex(MUTEX_ALL_ACCESS, FALSE, m_cServerName);
	if (hMutex != NULL) return FALSE; 
	hMutex = CreateMutex(NULL, FALSE, m_cServerName);
	*/
	if (m_pMsgQuene[m_iQueneHead] == NULL) return FALSE;
	m_pMsgQuene[m_iQueneHead]->Get(pFrom, pData, pMsgSize, pIndex, pKey, pTime);
	delete m_pMsgQuene[m_iQueneHead];
	m_pMsgQuene[m_iQueneHead] = NULL;
	m_iQueneHead++;
	if (m_iQueneHead >= DEF_MSGQUENESIZE) m_iQueneHead = 0;
	//ReleaseMutex(hMutex);
	return TRUE;
}


void CGame::ClientCommonHandler(int iClientH, char * pData, DWORD dwMsgTime)
{
 WORD * wp, wCommand;
 short * sp, sX, sY; 
 int   * ip, iV1, iV2, iV3, iV4;
 DWORD dwClientTime;
 char  * cp, cDir, * pString;
 //Added by SNOOPY
 BOOL bUnused;
	
	if (m_pClientList[iClientH] == NULL) return;
	if (m_pClientList[iClientH]->m_bIsInitComplete == FALSE) return;
	if (m_pClientList[iClientH]->m_bIsKilled == TRUE) return;

	wp = (WORD *)(pData + DEF_INDEX2_MSGTYPE);
	wCommand = *wp;
	cp = (char *)(pData + DEF_INDEX2_MSGTYPE + 2);
	sp = (short *)cp;
	sX = *sp;
	cp += 2;
	sp = (short *)cp;
	sY = *sp;
	cp += 2;
	cDir = *cp;
	cp++;
 	ip = (int *)cp;
	iV1 = *ip;
	cp += 4;
	ip = (int *)cp;
	iV2 = *ip;
	cp += 4;
	ip = (int *)cp;
	iV3 = *ip;
	cp += 4;
	pString = cp;
	// Can be Time sent by client if not a string + iV4
	ip = (int *)cp;
	dwClientTime = *ip;
	cp += 30;
	ip = (int *)cp;
	iV4 = *ip;
	cp += 4;	
	switch (wCommand) {
	// New 15/05/2004
	case DEF_COMMONTYPE_REQ_CREATESLATE:
		ReqCreateSlateHandler(iClientH, pData);
		break;
// 2.06 - by KLKS
	case DEF_COMMONTYPE_REQUEST_HUNTMODE:
		RequestChangePlayMode(iClientH);
		break;

	case DEF_COMMONTYPE_SETGUILDTELEPORTLOC:
		RequestSetGuildTeleportLocHandler(iClientH, iV1, iV2, m_pClientList[iClientH]->m_iGuildGUID, "middleland");
		break;

	case DEF_COMMONTYPE_SETGUILDCONSTRUCTLOC:
		RequestSetGuildConstructLocHandler(iClientH, iV1, iV2, m_pClientList[iClientH]->m_iGuildGUID, pString);
		break;
	
	case DEF_COMMONTYPE_GUILDTELEPORT:
		RequestGuildTeleportHandler(iClientH);
		break;
	
	case DEF_COMMONTYPE_SUMMONWARUNIT:
		RequestSummonWarUnitHandler(iClientH, sX, sY, iV1, iV2, iV3);
		break;
	
	case DEF_COMMONTYPE_REQUEST_HELP:
		RequestHelpHandler(iClientH);
		break;
	
	case DEF_COMMONTYPE_REQUEST_MAPSTATUS:
		MapStatusHandler(iClientH, iV1, pString);
		break;

	case DEF_COMMONTYPE_REQUEST_SELECTCRUSADEDUTY:
		SelectCrusadeDutyHandler(iClientH, iV1);
		break;
	
	case DEF_COMMONTYPE_REQUEST_CANCELQUEST:
		CancelQuestHandler(iClientH);
		break;
	
	case DEF_COMMONTYPE_REQUEST_ACTIVATESPECABLTY:
		ActivateSpecialAbilityHandler(iClientH);
		break;
	
	case DEF_COMMONTYPE_REQUEST_JOINPARTY:
		JoinPartyHandler(iClientH, iV1, pString);
		break;
	
	case DEF_COMMONTYPE_GETMAGICABILITY:
		GetMagicAbilityHandler(iClientH);
		break;

	case DEF_COMMONTYPE_BUILDITEM:
		BuildItemHandler(iClientH, pData);
		break;
	
	case DEF_COMMONTYPE_QUESTACCEPTED:
		QuestAcceptedHandler(iClientH);
		break;
	
	case DEF_COMMONTYPE_CANCELEXCHANGEITEM:
		CancelExchangeItem(iClientH);
		break;
	
	case DEF_COMMONTYPE_CONFIRMEXCHANGEITEM:
		ConfirmExchangeItem(iClientH);
		break;
	
	case DEF_COMMONTYPE_SETEXCHANGEITEM:
		SetExchangeItem(iClientH, iV1, iV2);
		break;
	
	case DEF_COMMONTYPE_REQ_GETHEROMANTLE:
		GetHeroMantleHandler(iClientH, iV1, pString);
		break;
	
	case DEF_COMMONTYPE_REQ_GETOCCUPYFLAG:
		GetOccupyFlagHandler(iClientH);  // buy an occupy flag at commander hall
		break;

	case DEF_COMMONTYPE_REQ_SETDOWNSKILLINDEX:
		SetDownSkillIndexHandler(iClientH, iV1);
		break;

	case DEF_COMMONTYPE_TALKTONPC:// works for client, but for npc it returns middleland
		NpcTalkHandler(iClientH, iV1);
		break;
	
	case DEF_COMMONTYPE_REQ_CREATEPORTION:
		ReqCreatePortionHandler(iClientH, pData);
		break;

	// Crafting
	case DEF_COMMONTYPE_CRAFTITEM:
		ReqCreateCraftingHandler(iClientH, pData);
		break;
	
	case DEF_COMMONTYPE_REQ_GETFISHTHISTIME:
		ReqGetFishThisTimeHandler(iClientH);
		break;
	
	case DEF_COMMONTYPE_REQ_REPAIRITEMCONFIRM:
		ReqRepairItemCofirmHandler(iClientH, iV1, pString);
		break;
	
	case DEF_COMMONTYPE_REQ_REPAIRITEM:
		ReqRepairItemHandler(iClientH, iV1, iV2, pString);
		break;
	
	case DEF_COMMONTYPE_REQ_SELLITEMCONFIRM:
		ReqSellItemConfirmHandler(iClientH, iV1, iV2, pString);
		break;
	
	case DEF_COMMONTYPE_REQ_SELLITEM:
		ReqSellItemHandler(iClientH, iV1, iV2, iV3, pString);
		break;
	
	case DEF_COMMONTYPE_REQ_USESKILL:
		UseSkillHandler(iClientH, iV1, iV2, iV3);
		break;
	
	case DEF_COMMONTYPE_REQ_USEITEM:
		UseItemHandler(iClientH, iV1, iV2, iV3, iV4, dwMsgTime);
		break;
	
	case DEF_COMMONTYPE_REQ_GETREWARDMONEY:
		GetRewardMoneyHandler(iClientH);
		break;

	case DEF_COMMONTYPE_ITEMDROP:
		DropItemHandler(iClientH, iV1, iV2, pString, TRUE);
		break;
	
	case DEF_COMMONTYPE_EQUIPITEM:
		bEquipItemHandler(iClientH, iV1);
		break;

	case DEF_COMMONTYPE_REQ_PURCHASEITEM:
		RequestPurchaseItemHandler(iClientH, pString, iV1);
		break;

	case DEF_COMMONTYPE_REQ_STUDYMAGIC:
		RequestStudyMagicHandler(iClientH, pString, bUnused);
		break;

	case DEF_COMMONTYPE_REQ_TRAINSKILL:
		//RequestTrainSkillHandler(iClientH, pString);
		break;

	case DEF_COMMONTYPE_GIVEITEMTOCHAR:
		GiveItemHandler(iClientH, cDir, iV1, iV2, iV3, iV4, pString);
		break;

	case DEF_COMMONTYPE_EXCHANGEITEMTOCHAR:
		ExchangeItemHandler(iClientH, cDir, iV1, iV2, iV3, iV4, pString);
		break;

	case DEF_COMMONTYPE_JOINGUILDAPPROVE:
		JoinGuildApproveHandler(iClientH, pString);
		break;
	
	case DEF_COMMONTYPE_JOINGUILDREJECT:
		JoinGuildRejectHandler(iClientH, pString);
		break;

	case DEF_COMMONTYPE_DISMISSGUILDAPPROVE:
		DismissGuildApproveHandler(iClientH, pString);
		break;

	case DEF_COMMONTYPE_DISMISSGUILDREJECT:
		DismissGuildRejectHandler(iClientH, pString);
		break;

	case DEF_COMMONTYPE_RELEASEITEM:
		ReleaseItemHandler(iClientH, iV1, TRUE);
		break;

	case DEF_COMMONTYPE_TOGGLECOMBATMODE:
		ToggleCombatModeHandler(iClientH);
		break;

	case DEF_COMMONTYPE_MAGIC:
		if (iClientCommon_Spell_Handler(iClientH, (short)iV1, (short)iV2, dwClientTime, dwMsgTime, (short)(iV3 - 100)) == 1)
			PlayerMagicHandler(iClientH, iV1, iV2, (iV3 - 100), FALSE, NULL, dwClientTime, dwMsgTime);
		break;

	case DEF_COMMONTYPE_TOGGLESAFEATTACKMODE:
		ToggleSafeAttackModeHandler(iClientH);
		break;

	case DEF_COMMONTYPE_REQ_GETFIGHTZONETICKET:
		GetFightzoneTicketHandler(iClientH);
		break;

	case DEF_COMMONTYPE_UPGRADEITEM:	// Upgrade Item
		RequestItemUpgradeHandler(iClientH,iV1);
		break;

	case DEF_COMMONTYPE_REQGUILDNAME:
		RequestGuildNameHandler(iClientH, iV1, iV2);
		break;

	case DEF_COMMONTYPE_REQUEST_ACCEPTJOINPARTY:
		RequestAcceptJoinPartyHandler(iClientH, iV1);
		break;

	default:
		wsprintf(G_cTxt,"Unknown COMMONTYPE message received: (0x%.8X) PC(%s). \tIP(%s)"
			, wCommand
			, m_pClientList[iClientH]->m_cCharName
			, m_pClientList[iClientH]->m_cIPaddress );
		PutLogList(G_cTxt);
		break;
	}
}

void CGame::DropItemHandler(int iClientH, short sItemIndex, int iAmount, char * pItemName, BOOL bByPlayer)
{	class CItem * pItem;
	if (m_pClientList[iClientH] == NULL) return;
	if (m_pClientList[iClientH]->m_bIsOnWaitingProcess == TRUE) return;
	if ((m_bAdminSecurity == TRUE) && (m_pClientList[iClientH]->m_iAdminUserLevel > 0)) return;
	if (m_pClientList[iClientH]->m_bIsInitComplete == FALSE) return;
	if ((sItemIndex < 0) || (sItemIndex >= DEF_MAXITEMS)) return;
	if (m_pClientList[iClientH]->m_pItemList[sItemIndex] == NULL) return;
	if ((iAmount != -1) && (iAmount < 0)) return;

	if ( ( (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cItemType == DEF_ITEMTYPE_CONSUME) 
		|| (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cItemType == DEF_ITEMTYPE_ARROW) ) 
		&& (iAmount == -1) ) 
	{	iAmount = m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_dwCount;
	}
	if (memcmp(m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cName, pItemName, 20) != 0) return;

	if ( ( (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cItemType == DEF_ITEMTYPE_CONSUME) 
		|| (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cItemType == DEF_ITEMTYPE_ARROW) ) 
		&& (((int)m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_dwCount - iAmount) > 0) ) 
	{	pItem = new class CItem;
		if (_bInitItemAttr(pItem, m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cName) == FALSE) 
		{	delete pItem;
			return;
		}else 
		{	if (iAmount <= 0) 
			{	delete pItem;
				return;
			}
			pItem->m_dwCount = (DWORD)iAmount;
		}
		if ((DWORD)iAmount > m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_dwCount) 
		{	delete pItem;
			return;
		}
		m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_dwCount -= iAmount;
		SetItemCount(iClientH, sItemIndex, m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_dwCount);
		m_pMapList[ m_pClientList[iClientH]->m_cMapIndex ]->bSetItem(m_pClientList[iClientH]->m_sX, 
				m_pClientList[iClientH]->m_sY, pItem);
		if ( bByPlayer == TRUE ) // Volonteer drop
			_bItemLog(DEF_ITEMLOG_DROP, iClientH, (int) -1, pItem);
		else 
			_bItemLog(DEF_ITEMLOG_LOST, iClientH, (int) -1, pItem);
		SendEventToNearClient_TypeB(MSGID_EVENT_COMMON, DEF_COMMONTYPE_ITEMDROP, m_pClientList[iClientH]->m_cMapIndex,
			m_pClientList[iClientH]->m_sX, m_pClientList[iClientH]->m_sY,  
			pItem->m_sSprite, pItem->m_sSpriteFrame, pItem->m_cItemColor); // v1.4 color

		SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_DROPITEMFIN_COUNTCHANGED, sItemIndex, iAmount, NULL, NULL);
	}else // non stackable item
	{	ReleaseItemHandler(iClientH, sItemIndex, TRUE);
		if ( m_pClientList[iClientH]->m_bIsItemEquipped[sItemIndex] == TRUE)
			SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_ITEMRELEASED, m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cEquipPos, sItemIndex, NULL, NULL);

		if (   (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectType == DEF_ITEMEFFECTTYPE_ALTERITEMDROP)
			&& (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_wCurLifeSpan == 0)) 
		{	delete m_pClientList[iClientH]->m_pItemList[sItemIndex];
			m_pClientList[iClientH]->m_pItemList[sItemIndex] = NULL;
		}else 
		{	m_pMapList[ m_pClientList[iClientH]->m_cMapIndex ]->bSetItem(m_pClientList[iClientH]->m_sX, 
				m_pClientList[iClientH]->m_sY, 
				m_pClientList[iClientH]->m_pItemList[sItemIndex]);
			if ( bByPlayer == TRUE ) // Volonteer drop
				_bItemLog(DEF_ITEMLOG_DROP, iClientH, (int) -1, m_pClientList[iClientH]->m_pItemList[sItemIndex]);
			else 
				_bItemLog(DEF_ITEMLOG_LOST, iClientH, (int) -1, m_pClientList[iClientH]->m_pItemList[sItemIndex]);
			SendEventToNearClient_TypeB(MSGID_EVENT_COMMON, DEF_COMMONTYPE_ITEMDROP, m_pClientList[iClientH]->m_cMapIndex,
				m_pClientList[iClientH]->m_sX, m_pClientList[iClientH]->m_sY,  
				m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sSprite, 
				m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sSpriteFrame, 
				m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cItemColor); //v1.4 color
			// avatar: DEF_ITEMEFFECTTYPE_EVENT_ITEMDROP
			if (   (m_bIsAvatarMode == TRUE)
				&& (m_iPLmapIndex != -1)
				&& (m_iAvatarMessenger == iClientH)
				&& (m_pClientList[m_iAvatarMessenger]->m_cMapIndex == m_iPLmapIndex) 
				&& (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectType == DEF_ITEMEFFECTTYPE_EVENT_ITEMDROP))
			{	DWORD dwGUID;
				memcpy(& dwGUID, &m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemSpecEffectValue1, 4);
				if (dwGUID == m_dwAvatarGUID)
				{	RelicDrop(iClientH, m_pClientList[iClientH]->m_pItemList[sItemIndex]);
		}	}	}
		m_pClientList[iClientH]->m_pItemList[sItemIndex] = NULL;
		m_pClientList[iClientH]->m_bIsItemEquipped[sItemIndex] = FALSE;
		SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_DROPITEMFIN_ERASEITEM, sItemIndex, iAmount, NULL, NULL);
		m_pClientList[iClientH]->m_cArrowIndex = _iGetArrowItemIndex(iClientH);
	}
	iCalcTotalWeight(iClientH);
}

/////////////////////////////////////////////////////////////////////////////////////
//  int CGame::iClientMotion_GetItem_Handler(int iClientH, short sX, short sY, char cDir)
//  description			:: check if player is dropping item or picking up item
//  last updated		:: October 29, 2004; 7:12 PM; Hypnotoad
//	return value		:: int
/////////////////////////////////////////////////////////////////////////////////////
int CGame::iClientMotion_GetItem_Handler(int iClientH, short sX, short sY, char cDir)
{
 DWORD * dwp;
 WORD  * wp;
 char  * cp;
 short * sp, sRemainItemSprite, sRemainItemSpriteFrame;
 char  cRemainItemColor, cData[100];
 int   iRet, iEraseReq;
 class CItem * pItem;

	if (m_pClientList[iClientH] == NULL) return 0;
	if ((cDir <= 0) || (cDir > 8))       return 0;
	if (m_pClientList[iClientH]->m_bIsKilled == TRUE) return 0;
	if (m_pClientList[iClientH]->m_bIsInitComplete == FALSE) return 0;

	if ((sX != m_pClientList[iClientH]->m_sX) || (sY != m_pClientList[iClientH]->m_sY)) return 2;

	int iStX, iStY;
	if (m_pMapList[m_pClientList[iClientH]->m_cMapIndex] != NULL) 
	{	iStX = m_pClientList[iClientH]->m_sX / 20;
		iStY = m_pClientList[iClientH]->m_sY / 20;
		m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_stTempSectorInfo[iStX][iStY].iPlayerActivity++;
		switch (m_pClientList[iClientH]->m_cSide) {
		case 1: m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_stTempSectorInfo[iStX][iStY].iAresdenActivity++; break;
		case 2: m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_stTempSectorInfo[iStX][iStY].iElvineActivity++;  break;
		case 4: m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_stTempSectorInfo[iStX][iStY].iExecutorActivity++;break;
		case 0: 
		default: m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_stTempSectorInfo[iStX][iStY].iNeutralActivity++; break;
		}
	}

	ClearSkillUsingStatus(iClientH);

	m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->ClearOwner(0, iClientH, DEF_OWNERTYPE_PLAYER, sX, sY);
	m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->SetOwner(iClientH, DEF_OWNERTYPE_PLAYER, sX, sY);

	if (m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->pCheckBombItem(sX, sY))
	//if (TRUE)
	{	goto CLIENT_CONFIRM_MOVE;	// Don't try to catch a bomb !
	}
	pItem = m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->pGetItem(sX, sY, &sRemainItemSprite, &sRemainItemSpriteFrame, &cRemainItemColor);
	if (pItem != NULL) 
	{	if (_bAddClientItemList(iClientH, pItem, &iEraseReq) == TRUE) 
		{	_bItemLog(DEF_ITEMLOG_GET, iClientH, NULL, pItem);
			dwp  = (DWORD *)(cData + DEF_INDEX4_MSGID);
			*dwp = MSGID_NOTIFY;
			wp   = (WORD *)(cData + DEF_INDEX2_MSGTYPE);
			*wp  = DEF_NOTIFY_ITEMOBTAINED;			
			cp = (char *)(cData + DEF_INDEX2_MSGTYPE + 2);
			*cp = 1;
			cp++;
			memcpy(cp, pItem->m_cName, 20);
			cp += 20;
			dwp  = (DWORD *)cp;
			*dwp = pItem->m_dwCount;
			cp += 4;
			*cp = pItem->m_cItemType;
			cp++;
			*cp = pItem->m_cEquipPos;
			cp++;
			*cp = (char)0;
			cp++;
			sp  = (short *)cp;
			*sp = pItem->m_sLevelLimit;
			cp += 2;
			*cp = pItem->m_cGenderLimit;
			cp++;
			wp = (WORD *)cp;
			*wp = pItem->m_wCurLifeSpan;
			cp += 2;			 
			wp = (WORD *)cp;
			*wp = pItem->m_wWeight;
			cp += 2;
			sp  = (short *)cp;
			*sp = pItem->m_sSprite;
			cp += 2;
			sp  = (short *)cp;
			*sp = pItem->m_sSpriteFrame;
			cp += 2;
			*cp = pItem->m_cItemColor;
			cp++;
			*cp = (char)pItem->m_sItemSpecEffectValue2;
			cp++;			
			dwp = (DWORD *)cp;
			*dwp = pItem->m_dwAttribute;
			cp += 4;
			if (iEraseReq == 1) delete pItem;

			SendEventToNearClient_TypeB(MSGID_EVENT_COMMON, DEF_COMMONTYPE_SETITEM, m_pClientList[iClientH]->m_cMapIndex,
				                        m_pClientList[iClientH]->m_sX, m_pClientList[iClientH]->m_sY,
				                        sRemainItemSprite, sRemainItemSpriteFrame, cRemainItemColor);

			iRet = m_pClientList[iClientH]->m_pXSock->iSendMsg(cData, 53);						
			switch (iRet) {
			case DEF_XSOCKEVENT_QUENEFULL:
			case DEF_XSOCKEVENT_SOCKETERROR:
			case DEF_XSOCKEVENT_CRITICALERROR:
			case DEF_XSOCKEVENT_SOCKETCLOSED:
				DeleteClient(iClientH, TRUE, TRUE);
				return 0;
			}
		}else 
		{
			m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->bSetItem(sX, sY, pItem);			
			dwp  = (DWORD *)(cData + DEF_INDEX4_MSGID);
			*dwp = MSGID_NOTIFY;
			wp   = (WORD *)(cData + DEF_INDEX2_MSGTYPE);
			*wp  = DEF_NOTIFY_CANNOTCARRYMOREITEM;			
			iRet = m_pClientList[iClientH]->m_pXSock->iSendMsg(cData, 6);
			switch (iRet) {
			case DEF_XSOCKEVENT_QUENEFULL:
			case DEF_XSOCKEVENT_SOCKETERROR:
			case DEF_XSOCKEVENT_CRITICALERROR:
			case DEF_XSOCKEVENT_SOCKETCLOSED:
				DeleteClient(iClientH, TRUE, TRUE);
				return 0;
			}
		}	
	}
CLIENT_CONFIRM_MOVE:;
	dwp  = (DWORD *)(cData + DEF_INDEX4_MSGID);
	*dwp = MSGID_RESPONSE_MOTION;
	wp   = (WORD *)(cData + DEF_INDEX2_MSGTYPE);
	*wp  = DEF_OBJECTMOTION_CONFIRM;

	iRet = m_pClientList[iClientH]->m_pXSock->iSendMsg(cData, 6);
	switch (iRet) {
	case DEF_XSOCKEVENT_QUENEFULL:
	case DEF_XSOCKEVENT_SOCKETERROR:
	case DEF_XSOCKEVENT_CRITICALERROR:
	case DEF_XSOCKEVENT_SOCKETCLOSED:
		DeleteClient(iClientH, TRUE, TRUE);
		return 0;
	}
	return 1;
}

BOOL CGame::_bAddClientItemList(int iClientH, class CItem * pItem, int * pDelReq)
{register int i;
	if (m_pClientList[iClientH] == NULL) return FALSE;
	if (pItem == NULL) return FALSE;
	// "Boom" item, can't be taken if burning
	// Used here, will show a "cannot carry....", but other ways may crash the client.
	// In fact you can test the item only after, it has been removed from ground....
	if (   (pItem->m_sItemEffectType == DEF_ITEMEFFECTTYPE_BOMB) 
		&& (pItem->m_sSprite == 16)
		&& (pItem->m_sSpriteFrame == 20))
	{	return FALSE;	
	}

	if ((pItem->m_cItemType == DEF_ITEMTYPE_CONSUME) || (pItem->m_cItemType == DEF_ITEMTYPE_ARROW)) 
	{	if ((m_pClientList[iClientH]->m_iCurWeightLoad + iGetItemWeight(pItem, pItem->m_dwCount)) > (DWORD)_iCalcMaxLoad(iClientH)) 
			return FALSE;
	}else 
	{	if ((m_pClientList[iClientH]->m_iCurWeightLoad + iGetItemWeight(pItem, 1)) > (DWORD)_iCalcMaxLoad(iClientH)) 
			return FALSE;
  	}	
	if ((pItem->m_cItemType == DEF_ITEMTYPE_CONSUME) || (pItem->m_cItemType == DEF_ITEMTYPE_ARROW)) 
	{	for (i = 0; i < DEF_MAXITEMS; i++)
		if (   (m_pClientList[iClientH]->m_pItemList[i] != NULL) 
			&& (memcmp(m_pClientList[iClientH]->m_pItemList[i]->m_cName, pItem->m_cName, 20) == 0) ) 
		{	m_pClientList[iClientH]->m_pItemList[i]->m_dwCount += pItem->m_dwCount;
			//delete pItem: Means do not create 2nd item because quantity has 
			//              alreaddy been added to existing quantity
			*pDelReq = 1;
			iCalcTotalWeight(iClientH);			
			return TRUE;	
	}	}
	
	for (i = 0; i < DEF_MAXITEMS; i++)
	if (m_pClientList[iClientH]->m_pItemList[i] == NULL) 		
	{	m_pClientList[iClientH]->m_pItemList[i] = pItem;
		m_pClientList[iClientH]->m_ItemPosList[i].x = 40;
		m_pClientList[iClientH]->m_ItemPosList[i].y = 30;
		*pDelReq = 0;
		if (pItem->m_cItemType == DEF_ITEMTYPE_ARROW)
			m_pClientList[iClientH]->m_cArrowIndex = _iGetArrowItemIndex(iClientH);
		if (pItem->m_sItemEffectType == DEF_ITEMEFFECTTYPE_EVENT_ITEMDROP)
		{	RelicGet(iClientH, pItem);
		}		
		iCalcTotalWeight(iClientH);	
		return TRUE;
	}
	return FALSE;
}

BOOL CGame::bEquipItemHandler(int iClientH, short sItemIndex, BOOL bNotify)
{char  cEquipPos; //, cHeroArmorType;
 short sSpeed;
 short sTemp;
 int   iTemp;
// char cInfoString[250];
	if (m_pClientList[iClientH] == NULL) return FALSE;
	if ((sItemIndex < 0) || (sItemIndex >= DEF_MAXITEMS)) return FALSE;
	if (m_pClientList[iClientH]->m_pItemList[sItemIndex] == NULL) return FALSE;
	if (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cItemType != DEF_ITEMTYPE_EQUIP) return FALSE;
	if (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_wCurLifeSpan <= 0)
	{	ReleaseItemHandler(iClientH, sItemIndex, TRUE);
		return FALSE;
	}
	if (   ((m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_dwAttribute & 0x00000001) == NULL)  
		&& (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sLevelLimit > m_pClientList[iClientH]->m_iLevel)) 
	{	ReleaseItemHandler(iClientH, sItemIndex, TRUE);
		return FALSE;
	}	
	// Equiping something removes metamorphosis
	if (m_pClientList[iClientH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_METAMORPHOSIS ] != 0) 
	{	bRemoveFromDelayEventList(iClientH, DEF_OWNERTYPE_PLAYER, DEF_MAGICTYPE_METAMORPHOSIS);
		DWORD 	dwTime = timeGetTime();				
		bRegisterDelayEvent(DEF_DELAYEVENTTYPE_MAGICRELEASE, DEF_MAGICTYPE_METAMORPHOSIS, dwTime, 
							iClientH, DEF_OWNERTYPE_PLAYER, NULL, NULL, NULL, 0, NULL, NULL);
	}
	cEquipPos = m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cEquipPos;
	if (m_pClientList[iClientH]->m_iAdminUserLevel == 0) 
	{	switch (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sIDnum) {
		case 669: // Penitence Giver needs 30 charisma
			if (m_pClientList[iClientH]->m_iCharisma < 30) 
			{	SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_ITEMRELEASED,cEquipPos , sItemIndex, NULL, NULL);
				ReleaseItemHandler(iClientH, sItemIndex, TRUE);
				return FALSE;
			}
			break;
		case 670: // Knight Penitence needs 50 charisma
			if (m_pClientList[iClientH]->m_iCharisma < 50) 
			{	SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_ITEMRELEASED, cEquipPos, sItemIndex, NULL, NULL);
				ReleaseItemHandler(iClientH, sItemIndex, TRUE);
				return FALSE;
			}
			break;
		case 904: // Master Penitence needs 80 charisma
			if (m_pClientList[iClientH]->m_iCharisma < 80) 
			{	SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_ITEMRELEASED, cEquipPos, sItemIndex, NULL, NULL);
				ReleaseItemHandler(iClientH, sItemIndex, TRUE);
				return FALSE;
			}
			break;
		case 25:
		case 26:
		case 27: // Scimitar only for druids
			if (m_pClientList[iClientH]->m_iPriestDruidID != 2) 
			{	SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_ITEMRELEASED, cEquipPos, sItemIndex, NULL, NULL);
				ReleaseItemHandler(iClientH, sItemIndex, TRUE);
				return FALSE;
			}
			break;
		case 321:
		case 322:
		case 323:
		case 324:
		case 325: // SNOOPY: Check for HolySymbol and Priest Spells if applicable
			Set_PriestDruid(iClientH);				
			if (m_pClientList[iClientH]->m_iPriestDruidID != 1) 
			{	if (   (strcmp(m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cName, "cath_1") == 0)
					|| (strcmp(m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cName, "cath_2") == 0))
				{	Become_PriestDruid(iClientH);
			}	}	
			if (m_pClientList[iClientH]->m_iPriestDruidID != 1) 
			{	SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_ITEMRELEASED, cEquipPos, sItemIndex, NULL, NULL);
				ReleaseItemHandler(iClientH, sItemIndex, TRUE);
				return FALSE;
			}else bCheckMagicInt(iClientH);		
			break;
		case 442: // DruidCape
			Set_PriestDruid(iClientH);
			if (m_pClientList[iClientH]->m_iPriestDruidID != 2) 
			{	if ( (strcmp(m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cName, "areuni") == 0)
					|| (strcmp(m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cName, "elvuni") == 0))
				{	Become_PriestDruid(iClientH);
				}
			}
			if (m_pClientList[iClientH]->m_iPriestDruidID != 2) 
			{	SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_ITEMRELEASED, cEquipPos, sItemIndex, NULL, NULL);
				ReleaseItemHandler(iClientH, sItemIndex, TRUE);
				return FALSE;
			}else bCheckMagicInt(iClientH);	
			break;
		case 646: // NecklaceOfBeholder
				SetInvisibilityFlag(iClientH, DEF_OWNERTYPE_PLAYER, FALSE); // Power will be set at iCalculateTotalItemEffect (for player connecting)
				m_pClientList[iClientH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_INVISIBILITY ] = NULL;
				bRemoveFromDelayEventList(iClientH, DEF_OWNERTYPE_PLAYER, DEF_MAGICTYPE_INVISIBILITY);				
			break;
		case 445: // Elven cape		
			if (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_wCurLifeSpan > 101) 
			{	SetInvisibilityFlag(iClientH, DEF_OWNERTYPE_PLAYER, TRUE);	
				RemoveFromTarget(iClientH, DEF_OWNERTYPE_PLAYER, DEF_MAGICTYPE_INVISIBILITY);
				bRemoveFromDelayEventList(iClientH, DEF_OWNERTYPE_PLAYER, DEF_MAGICTYPE_INVISIBILITY);
				m_pClientList[iClientH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_INVISIBILITY ] = (char)1;				
				m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_wCurLifeSpan -= 100;						
				SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_MAGICEFFECTON, DEF_MAGICTYPE_INVISIBILITY, 1, NULL, NULL);
				SendEventToNearClient_TypeB(MSGID_EVENT_COMMON, DEF_COMMONTYPE_MAGIC, m_pClientList[iClientH]->m_cMapIndex,
					m_pClientList[iClientH]->m_sX, m_pClientList[iClientH]->m_sY, m_pClientList[iClientH]->m_sX, m_pClientList[iClientH]->m_sY, 132, m_pClientList[iClientH]->m_sType);
			}
			break;
			
		case 623: // GMShield only for GMs
		case 693: // GMPowerRing only for GMs
			SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_ITEMRELEASED, cEquipPos, sItemIndex, NULL, NULL);
			ReleaseItemHandler(iClientH, sItemIndex, TRUE);
			wsprintf(G_cTxt, "GM Power ring:     PC(%s) - Trying to equip GM reserved item. \tIP(%s)"
				, m_pClientList[iClientH]->m_cCharName
				, m_pClientList[iClientH]->m_cIPaddress);
			PutHackLogFileList(G_cTxt);	
			return FALSE;
			break;
		/*se 700: // DarkKnightHauberkM 
		case 701: // DarkKnightHauberkW
		case 702: // DarkKnightLeggingsM 
		case 703: // DarkKnightLeggingsW
		case 704: // DarkKnightHelm 
		case 705: // DarkKnightArmorM 
		case 706: // DarkKnightArmorW
		case 707: // DarkMageRobeM
		case 708: // DarkMageRobeW*/ 
		case 709: //DarkKnight Blade removed if Aresden or Elvine & not criminal, armors removed by 66 definition
			if (   (m_pClientList[iClientH]->m_iPKCount == 0) 
				&& (m_pClientList[iClientH]->m_iAdminUserLevel <1)
				&& (m_pClientList[iClientH]->m_cSide <3))
			{	SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_ITEMRELEASED, m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cEquipPos, sItemIndex, NULL, NULL);
				ReleaseItemHandler(iClientH, m_pClientList[iClientH]->m_sItemEquipmentStatus[ cEquipPos ], TRUE);
				return FALSE;
			}
			break;
		case 845: // StormBlade
			if ((m_pClientList[iClientH]->m_iInt + m_pClientList[iClientH]->m_iAngelicInt) < 65)
			{	SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_ITEMRELEASED, m_pClientList[iClientH]->m_iSpecialAbilityEquipPos, sItemIndex, NULL, NULL);
				ReleaseItemHandler(iClientH, sItemIndex , TRUE);
				return FALSE;
			}
			if  (m_pClientList[iClientH]->m_cSide == 4) // Forbiden items for Executors
			{	SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_ITEMRELEASED, cEquipPos, sItemIndex, NULL, NULL);
				ReleaseItemHandler(iClientH, sItemIndex, TRUE);
				return FALSE;
			}
			break;
		case 865:
		case 866: //Resurrection wand(MS.10) or Resurrection wand(MS.20)
			if(    ((m_pClientList[iClientH]->m_iInt + m_pClientList[iClientH]->m_iAngelicInt) > 99) 
				&& ((m_pClientList[iClientH]->m_iMag + m_pClientList[iClientH]->m_iAngelicMag) > 99)
				&& (m_pClientList[iClientH]->m_iSpecialAbilityTime < 1))
			{	m_pClientList[iClientH]->m_cMagicMastery[94] = TRUE;
				SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_STATECHANGE_SUCCESS, NULL, NULL, NULL, NULL);
			}else // Can't cast now
			{	SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_SPECIALABILITYSTATUS, 3, NULL, m_pClientList[iClientH]->m_iSpecialAbilityTime, NULL);
			}
			break;
		case 6:  // Eldiniel Hand
		case 7:  // Aresien Hand
		case 19: // Sting-Dart	
		case 20:  // Excalibur
		case 327: // RingInfame
		case 767: // StormBringer
		case 848: // Lightning Blade
		case 897: // PinkLagiShield
		case 898: // PinkTowerShield
			if  (m_pClientList[iClientH]->m_cSide == 4) // Forbiden items for Executors
			{	SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_ITEMRELEASED, cEquipPos, sItemIndex, NULL, NULL);
				ReleaseItemHandler(iClientH, sItemIndex, TRUE);
				return FALSE;
			}
			break;
		default:
			break;	
		}
		if (m_pClientList[iClientH]->m_cSide == 4) // Evil side Character cannot equip any stated item
		{	int dwSWEType  = (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_dwAttribute & 0x00F00000) >> 20;
			if (( dwSWEType != 0) && (cEquipPos != DEF_EQUIPPOS_LHAND)) // but shields
			{	SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_ITEMRELEASED, cEquipPos, sItemIndex, NULL, NULL);
				ReleaseItemHandler(iClientH, sItemIndex, TRUE);
				return FALSE;
	}	}	}
	if (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cGenderLimit != 0) {
		switch (m_pClientList[iClientH]->m_sType) {
		case 1:
		case 2:
		case 3:
			// Male, Sex items
			if (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cGenderLimit != 1) {
			//SNOOPY: added full release functions...
			SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_ITEMRELEASED, m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cEquipPos, sItemIndex, NULL, NULL);
			ReleaseItemHandler(iClientH, m_pClientList[iClientH]->m_sItemEquipmentStatus[ cEquipPos ], TRUE);
			return FALSE;			
			}
			break;
		case 4:
		case 5:
		case 6:
			// Female
			if (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cGenderLimit != 2) {
			SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_ITEMRELEASED, m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cEquipPos, sItemIndex, NULL, NULL);
			ReleaseItemHandler(iClientH, m_pClientList[iClientH]->m_sItemEquipmentStatus[ cEquipPos ], TRUE);
			return FALSE;			
			} 
			break;
	}	}

	if (iGetItemWeight(m_pClientList[iClientH]->m_pItemList[sItemIndex], 1) > (m_pClientList[iClientH]->m_iStr + m_pClientList[iClientH]->m_iAngelicStr)*100) return FALSE;

	cEquipPos = m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cEquipPos;
// SNOOPY: Most items can have special conditions to equip....
	if ((cEquipPos == DEF_EQUIPPOS_BODY) || (cEquipPos == DEF_EQUIPPOS_FOOT) || 
		(cEquipPos == DEF_EQUIPPOS_ARMS) || (cEquipPos == DEF_EQUIPPOS_HEAD) ||
		(cEquipPos == DEF_EQUIPPOS_PANTS) || (cEquipPos == DEF_EQUIPPOS_NECK) || 
		(cEquipPos == DEF_EQUIPPOS_LHAND) || (cEquipPos == DEF_EQUIPPOS_BACK) || 
		(cEquipPos == DEF_EQUIPPOS_RFINGER) || (cEquipPos == DEF_EQUIPPOS_LFINGER))
	{	switch (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectValue4) {
		case 10: // Str 
			if ((m_pClientList[iClientH]->m_iStr + m_pClientList[iClientH]->m_iAngelicStr) < m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectValue5) 
			{	SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_ITEMRELEASED, m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cEquipPos, sItemIndex, NULL, NULL);
				ReleaseItemHandler(iClientH, m_pClientList[iClientH]->m_sItemEquipmentStatus[ cEquipPos ], TRUE);
				return FALSE;
			}
			break;
		case 11: // Dex
			if ((m_pClientList[iClientH]->m_iDex + m_pClientList[iClientH]->m_iAngelicDex) < m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectValue5) 
			{	SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_ITEMRELEASED, m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cEquipPos, sItemIndex, NULL, NULL);
				ReleaseItemHandler(iClientH, m_pClientList[iClientH]->m_sItemEquipmentStatus[ cEquipPos ], TRUE);
				return FALSE;
			}
			break;
		case 12: // Vit
			if (m_pClientList[iClientH]->m_iVit < m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectValue5) 
			{	SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_ITEMRELEASED, m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cEquipPos, sItemIndex, NULL, NULL);
				ReleaseItemHandler(iClientH, m_pClientList[iClientH]->m_sItemEquipmentStatus[ cEquipPos ], TRUE);
				return FALSE;
			}
			break;
		case 13: // Int
			if ((m_pClientList[iClientH]->m_iInt + m_pClientList[iClientH]->m_iAngelicInt) < m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectValue5) 
			{	SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_ITEMRELEASED, m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cEquipPos, sItemIndex, NULL, NULL);
				ReleaseItemHandler(iClientH, m_pClientList[iClientH]->m_sItemEquipmentStatus[ cEquipPos ], TRUE);
				return FALSE;
			}
			break;
		case 14: // Mag
			if ((m_pClientList[iClientH]->m_iMag + m_pClientList[iClientH]->m_iAngelicMag) < m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectValue5) 
			{	SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_ITEMRELEASED, m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cEquipPos, sItemIndex, NULL, NULL);
				ReleaseItemHandler(iClientH, m_pClientList[iClientH]->m_sItemEquipmentStatus[ cEquipPos ], TRUE);
				return FALSE;
			}
			break;
		case 15: // Chr
			if (m_pClientList[iClientH]->m_iCharisma < m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectValue5) 
			{	SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_ITEMRELEASED, m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cEquipPos, sItemIndex, NULL, NULL);
				ReleaseItemHandler(iClientH, m_pClientList[iClientH]->m_sItemEquipmentStatus[ cEquipPos ], TRUE);
				return FALSE;
			}
			break;
		case 16: // Contrib
			if (   (m_pClientList[iClientH]->m_iContribution < m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectValue5)
				&& (m_pClientList[iClientH]->m_iAdminUserLevel == 0)) 
			{	SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_ITEMRELEASED, m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cEquipPos, sItemIndex, NULL, NULL);
				ReleaseItemHandler(iClientH, m_pClientList[iClientH]->m_sItemEquipmentStatus[ cEquipPos ], TRUE);
				return FALSE;
			}
			break;
		case 17: // EK
			if (   (m_pClientList[iClientH]->m_iEnemyKillCount < m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectValue5)
				&& (m_pClientList[iClientH]->m_iAdminUserLevel == 0)) 
			{	SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_ITEMRELEASED, m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cEquipPos, sItemIndex, NULL, NULL);
				ReleaseItemHandler(iClientH, m_pClientList[iClientH]->m_sItemEquipmentStatus[ cEquipPos ], TRUE);
				return FALSE;
			}
			break;
		case 18: // Reputation
			if ((m_pClientList[iClientH]->m_iRating < m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectValue5)
				&& (m_pClientList[iClientH]->m_iAdminUserLevel == 0)) 
			{	SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_ITEMRELEASED, m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cEquipPos, sItemIndex, NULL, NULL);
				ReleaseItemHandler(iClientH, m_pClientList[iClientH]->m_sItemEquipmentStatus[ cEquipPos ], TRUE);
				return FALSE;
			}
			break;
		case 20: // Max Str
			if (((m_pClientList[iClientH]->m_iStr + m_pClientList[iClientH]->m_iAngelicStr ) > m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectValue5)
				&& (m_pClientList[iClientH]->m_iAdminUserLevel == 0)) 
			{	SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_ITEMRELEASED, m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cEquipPos, sItemIndex, NULL, NULL);
				ReleaseItemHandler(iClientH, m_pClientList[iClientH]->m_sItemEquipmentStatus[ cEquipPos ], TRUE);
				return FALSE;
			}
			break;
		case 21: // Max Dex
			if (((m_pClientList[iClientH]->m_iDex + m_pClientList[iClientH]->m_iAngelicDex) > m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectValue5)
				&& (m_pClientList[iClientH]->m_iAdminUserLevel == 0)) 
			{	SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_ITEMRELEASED, m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cEquipPos, sItemIndex, NULL, NULL);
				ReleaseItemHandler(iClientH, m_pClientList[iClientH]->m_sItemEquipmentStatus[ cEquipPos ], TRUE);
				return FALSE;
			}
			break;
		case 22: // Max Vit
			if ((m_pClientList[iClientH]->m_iVit > m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectValue5)
				&& (m_pClientList[iClientH]->m_iAdminUserLevel == 0)) 
			{	SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_ITEMRELEASED, m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cEquipPos, sItemIndex, NULL, NULL);
				ReleaseItemHandler(iClientH, m_pClientList[iClientH]->m_sItemEquipmentStatus[ cEquipPos ], TRUE);
				return FALSE;
			}
			break;
		case 23: // Max Int
			if (   ((m_pClientList[iClientH]->m_iInt + m_pClientList[iClientH]->m_iAngelicInt) > m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectValue5)
				&& (m_pClientList[iClientH]->m_iAdminUserLevel == 0)) 
			{				SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_ITEMRELEASED, m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cEquipPos, sItemIndex, NULL, NULL);
				ReleaseItemHandler(iClientH, m_pClientList[iClientH]->m_sItemEquipmentStatus[ cEquipPos ], TRUE);
				return FALSE;
			}
			break;
		case 24: // Max Mag
			if (   ((m_pClientList[iClientH]->m_iMag + m_pClientList[iClientH]->m_iAngelicMag) > m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectValue5)
				&& (m_pClientList[iClientH]->m_iAdminUserLevel == 0)) 
			{	SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_ITEMRELEASED, m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cEquipPos, sItemIndex, NULL, NULL);
				ReleaseItemHandler(iClientH, m_pClientList[iClientH]->m_sItemEquipmentStatus[ cEquipPos ], TRUE);
				return FALSE;
			}
			break;
		case 25: // Max Chr
			if ((m_pClientList[iClientH]->m_iCharisma > m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectValue5)
				&& (m_pClientList[iClientH]->m_iAdminUserLevel == 0)) {
				SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_ITEMRELEASED, m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cEquipPos, sItemIndex, NULL, NULL);
				ReleaseItemHandler(iClientH, m_pClientList[iClientH]->m_sItemEquipmentStatus[ cEquipPos ], TRUE);
				return FALSE;
			}
			break;
		case 27: // Max EK
			if ((      (m_pClientList[iClientH]->m_iEnemyKillCount    > m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectValue5)
					|| (m_pClientList[iClientH]->m_iCrazyPlayerKiller > m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectValue5))
				&& (m_pClientList[iClientH]->m_iAdminUserLevel == 0)) 
			{	SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_ITEMRELEASED, m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cEquipPos, sItemIndex, NULL, NULL);
				ReleaseItemHandler(iClientH, m_pClientList[iClientH]->m_sItemEquipmentStatus[ cEquipPos ], TRUE);
				return FALSE;
			}
			break;
		case 66: // Only Evil side Player can wear them (or criminals)
			if ((m_pClientList[iClientH]->m_iPKCount == 0)
				&& (m_pClientList[iClientH]->m_iAdminUserLevel == 0)
				&& (m_pClientList[iClientH]->m_cSide <3)){
				SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_ITEMRELEASED, m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cEquipPos, sItemIndex, NULL, NULL);
				ReleaseItemHandler(iClientH, m_pClientList[iClientH]->m_sItemEquipmentStatus[ cEquipPos ], TRUE);
				return FALSE;
			}
			break;
		}
	}

	if (cEquipPos == DEF_EQUIPPOS_TWOHAND) // No 2 hands weapons for druids
	{	if (m_pClientList[iClientH]->m_iPriestDruidID == 2) 
		{	SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_ITEMRELEASED, m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cEquipPos, sItemIndex, NULL, NULL);
			ReleaseItemHandler(iClientH, sItemIndex, TRUE);
			return FALSE;
	}	}

	// Only one special ability item at a time
	if (   (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectType == DEF_ITEMEFFECTTYPE_ATTACK_SPECABLTY) 
		|| (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectType == DEF_ITEMEFFECTTYPE_DEFENSE_SPECABLTY)) 
	{	if ((m_pClientList[iClientH]->m_iSpecialAbilityType != 0)) 
		{	if (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cEquipPos != m_pClientList[iClientH]->m_iSpecialAbilityEquipPos) 
			{	SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_ITEMRELEASED, m_pClientList[iClientH]->m_iSpecialAbilityEquipPos, m_pClientList[iClientH]->m_sItemEquipmentStatus[ m_pClientList[iClientH]->m_iSpecialAbilityEquipPos ], NULL, NULL);
				ReleaseItemHandler(iClientH, m_pClientList[iClientH]->m_sItemEquipmentStatus[ m_pClientList[iClientH]->m_iSpecialAbilityEquipPos ], TRUE);
			}
		}
	}
	if (cEquipPos == DEF_EQUIPPOS_NONE) return FALSE;

	if (cEquipPos == DEF_EQUIPPOS_TWOHAND) 
	{	if ( m_pClientList[iClientH]->m_sItemEquipmentStatus[ cEquipPos ] != -1) 
			ReleaseItemHandler(iClientH, m_pClientList[iClientH]->m_sItemEquipmentStatus[ cEquipPos ], FALSE);
		else 
		{	if ( m_pClientList[iClientH]->m_sItemEquipmentStatus[ DEF_EQUIPPOS_RHAND ] != -1) 
				ReleaseItemHandler(iClientH, m_pClientList[iClientH]->m_sItemEquipmentStatus[ DEF_EQUIPPOS_RHAND ], FALSE);
			if ( m_pClientList[iClientH]->m_sItemEquipmentStatus[ DEF_EQUIPPOS_LHAND ] != -1) 
				ReleaseItemHandler(iClientH, m_pClientList[iClientH]->m_sItemEquipmentStatus[ DEF_EQUIPPOS_LHAND ], FALSE);
		}
	}else 
	{	if ((cEquipPos == DEF_EQUIPPOS_LHAND) || (cEquipPos == DEF_EQUIPPOS_RHAND)) 
		{	if ( m_pClientList[iClientH]->m_sItemEquipmentStatus[ DEF_EQUIPPOS_TWOHAND ] != -1) 
			ReleaseItemHandler(iClientH, m_pClientList[iClientH]->m_sItemEquipmentStatus[ DEF_EQUIPPOS_TWOHAND ], FALSE);
		} 
		if ( m_pClientList[iClientH]->m_sItemEquipmentStatus[ cEquipPos ] != -1) 
				ReleaseItemHandler(iClientH, m_pClientList[iClientH]->m_sItemEquipmentStatus[ cEquipPos ], FALSE);
	}

	if (cEquipPos == DEF_EQUIPPOS_RELEASEALL) //  as SantaSuit
	{	if (m_pClientList[iClientH]->m_sItemEquipmentStatus[ cEquipPos ] != -1) 
		{	ReleaseItemHandler(iClientH, m_pClientList[iClientH]->m_sItemEquipmentStatus[ cEquipPos ], FALSE);
		}
		if(m_pClientList[iClientH]->m_sItemEquipmentStatus[ DEF_EQUIPPOS_HEAD ] != -1)
		{	ReleaseItemHandler(iClientH, m_pClientList[iClientH]->m_sItemEquipmentStatus[ DEF_EQUIPPOS_HEAD ], FALSE);
		}
		if(m_pClientList[iClientH]->m_sItemEquipmentStatus[ DEF_EQUIPPOS_BODY ] != -1)
		{	ReleaseItemHandler(iClientH, m_pClientList[iClientH]->m_sItemEquipmentStatus[ DEF_EQUIPPOS_BODY ], FALSE);
		}
		if(m_pClientList[iClientH]->m_sItemEquipmentStatus[ DEF_EQUIPPOS_ARMS ] != -1)
		{	ReleaseItemHandler(iClientH, m_pClientList[iClientH]->m_sItemEquipmentStatus[ DEF_EQUIPPOS_ARMS ], FALSE);
		}
		if(m_pClientList[iClientH]->m_sItemEquipmentStatus[ DEF_EQUIPPOS_FOOT ] != -1)
		{	ReleaseItemHandler(iClientH, m_pClientList[iClientH]->m_sItemEquipmentStatus[ DEF_EQUIPPOS_FOOT ], FALSE);
		}
		if(m_pClientList[iClientH]->m_sItemEquipmentStatus[ DEF_EQUIPPOS_PANTS ] != -1)
		{	ReleaseItemHandler(iClientH, m_pClientList[iClientH]->m_sItemEquipmentStatus[ DEF_EQUIPPOS_PANTS ], FALSE);
		}
		if(m_pClientList[iClientH]->m_sItemEquipmentStatus[ DEF_EQUIPPOS_BACK ] != -1)
		{	ReleaseItemHandler(iClientH, m_pClientList[iClientH]->m_sItemEquipmentStatus[ DEF_EQUIPPOS_BACK ], FALSE);
		}
	}else // Not DEF_EQUIPPOS_RELEASEALL
	{ 	if (cEquipPos == DEF_EQUIPPOS_HEAD || cEquipPos == DEF_EQUIPPOS_BODY || cEquipPos == DEF_EQUIPPOS_ARMS ||
			cEquipPos == DEF_EQUIPPOS_FOOT || cEquipPos == DEF_EQUIPPOS_PANTS || cEquipPos == DEF_EQUIPPOS_BACK) 
		{	if (m_pClientList[iClientH]->m_sItemEquipmentStatus[ DEF_EQUIPPOS_RELEASEALL ] != -1)
			{	ReleaseItemHandler(iClientH, m_pClientList[iClientH]->m_sItemEquipmentStatus[ DEF_EQUIPPOS_RELEASEALL ], FALSE);
			}
		}
		if ( m_pClientList[iClientH]->m_sItemEquipmentStatus[ cEquipPos ] != -1) 
			ReleaseItemHandler(iClientH, m_pClientList[iClientH]->m_sItemEquipmentStatus[ cEquipPos ], FALSE);
	}
	m_pClientList[iClientH]->m_sItemEquipmentStatus[cEquipPos] = sItemIndex;
	m_pClientList[iClientH]->m_bIsItemEquipped[sItemIndex] = TRUE;

	switch (cEquipPos) {
	case DEF_EQUIPPOS_HEAD: // 3:xx_x 4:xxxx
		sTemp = m_pClientList[iClientH]->m_sAppr3;
		sTemp = sTemp & 0xFF0F;	
		sTemp = sTemp | ((m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cApprValue) << 4);
		m_pClientList[iClientH]->m_sAppr3 = sTemp;
		iTemp = m_pClientList[iClientH]->m_iApprColor;
		iTemp = iTemp & 0xFFFFFFF0; 			
		iTemp = iTemp | ((m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cItemColor));
		m_pClientList[iClientH]->m_iApprColor = iTemp;
		break;

	case DEF_EQUIPPOS_PANTS: // 3:x_xx 4:xxxx
		sTemp = m_pClientList[iClientH]->m_sAppr3;
		sTemp = sTemp & 0xF0FF;	
		sTemp = sTemp | ((m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cApprValue) << 8);
		m_pClientList[iClientH]->m_sAppr3 = sTemp;
		iTemp = m_pClientList[iClientH]->m_iApprColor; 
		iTemp = iTemp & 0xFFFFF0FF; 
		iTemp = iTemp | ((m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cItemColor) << 8);
		m_pClientList[iClientH]->m_iApprColor = iTemp;
		break;

	case DEF_EQUIPPOS_FOOT: // 3:xxxx 4:_xxx
		sTemp = m_pClientList[iClientH]->m_sAppr4;
		sTemp = sTemp & 0x0FFF;
		sTemp = sTemp | ((m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cApprValue) << 12); 
		m_pClientList[iClientH]->m_sAppr4 = sTemp;
		iTemp = m_pClientList[iClientH]->m_iApprColor;
		iTemp = iTemp & 0xFFFFFF0F; 
		iTemp = iTemp | ((m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cItemColor) << 4);
		m_pClientList[iClientH]->m_iApprColor = iTemp;
		break;

	case DEF_EQUIPPOS_BODY: // 3:_xxx 4:xx_x
		sTemp = m_pClientList[iClientH]->m_sAppr3;
		sTemp = sTemp & 0x0FFF;	 
		if (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cApprValue < 100) 
		{	sTemp = sTemp | ((m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cApprValue) << 12);
			m_pClientList[iClientH]->m_sAppr3 = sTemp;
		}else // Appr over 100 may crash the client ???? or put on an invisible armor...
		{	sTemp = sTemp | ((m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cApprValue - 100) << 12);
			m_pClientList[iClientH]->m_sAppr3 = sTemp;
			sTemp = m_pClientList[iClientH]->m_sAppr4;
			sTemp = sTemp | 0x080;	
			m_pClientList[iClientH]->m_sAppr4 = sTemp;
		}
		iTemp = m_pClientList[iClientH]->m_iApprColor; 
		iTemp = iTemp & 0xFF0FFFFF; 
		iTemp = iTemp | ((m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cItemColor) << 20);
		m_pClientList[iClientH]->m_iApprColor = iTemp;
		break;
			
	case DEF_EQUIPPOS_ARMS: // 3:xxx_ 4:xxxx
		sTemp = m_pClientList[iClientH]->m_sAppr3;
		sTemp = sTemp & 0xFFF0;	
		sTemp = sTemp | ((m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cApprValue));
		m_pClientList[iClientH]->m_sAppr3 = sTemp;
		iTemp = m_pClientList[iClientH]->m_iApprColor;
		iTemp = iTemp & 0xFFFFFFFF;  // New 09/05/2004
		iTemp = iTemp | ((m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cItemColor) << 12);
		m_pClientList[iClientH]->m_iApprColor = iTemp;
		break;

	case DEF_EQUIPPOS_LHAND:
		sTemp = m_pClientList[iClientH]->m_sAppr2;
		sTemp = sTemp & 0xFFF0;	
		sTemp = sTemp | ((m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cApprValue));
		m_pClientList[iClientH]->m_sAppr2 = sTemp;
		iTemp = m_pClientList[iClientH]->m_iApprColor; 
		iTemp = iTemp & 0xF0FFFFFF;
		iTemp = iTemp | ((m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cItemColor) << 24);
		m_pClientList[iClientH]->m_iApprColor = iTemp;
		break;

	case DEF_EQUIPPOS_RHAND:
		sTemp = m_pClientList[iClientH]->m_sAppr2;
		sTemp = sTemp & 0xF00F;	
		sTemp = sTemp | ((m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cApprValue) << 4);
		m_pClientList[iClientH]->m_sAppr2 = sTemp;
		iTemp = m_pClientList[iClientH]->m_iApprColor; 
		iTemp = iTemp & 0xFFFFFFF; 
		iTemp = iTemp | ((m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cItemColor) << 28);
		m_pClientList[iClientH]->m_iApprColor = iTemp;
		iTemp = m_pClientList[iClientH]->m_iStatus;
		iTemp = iTemp & 0xFFFFFFF0;
		sSpeed = (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cSpeed);
		// Str
		sSpeed -= ((m_pClientList[iClientH]->m_iStr + m_pClientList[iClientH]->m_iAngelicStr) / 13);
		if (sSpeed < 0) sSpeed = 0;
		if (sSpeed > 15) sSpeed = 15;
		iTemp = iTemp | (int)sSpeed;
		m_pClientList[iClientH]->m_iStatus = iTemp;
		m_pClientList[iClientH]->m_iComboAttackCount = 0;
		break;

	case DEF_EQUIPPOS_TWOHAND:
		sTemp = m_pClientList[iClientH]->m_sAppr2;
		sTemp = sTemp & 0xF00F;	
		sTemp = sTemp | ((m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cApprValue) << 4); 
		m_pClientList[iClientH]->m_sAppr2 = sTemp;
		iTemp = m_pClientList[iClientH]->m_iApprColor; 
		iTemp = iTemp & 0xFFFFFFF; 
		iTemp = iTemp | ((m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cItemColor) << 28);
		m_pClientList[iClientH]->m_iApprColor = iTemp;
		iTemp = m_pClientList[iClientH]->m_iStatus;
		iTemp = iTemp & 0xFFFFFFF0;
		sSpeed = (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cSpeed);
		// Str
		sSpeed -= ((m_pClientList[iClientH]->m_iStr + m_pClientList[iClientH]->m_iAngelicStr) / 13);
		if (sSpeed < 0) sSpeed = 0;
		if (sSpeed > 15) sSpeed = 15;
		iTemp = iTemp | (int)sSpeed;
		m_pClientList[iClientH]->m_iStatus = iTemp;
		m_pClientList[iClientH]->m_iComboAttackCount = 0;
		break;

	case DEF_EQUIPPOS_BACK: // 3:xxxx 4:x_xx
		sTemp = m_pClientList[iClientH]->m_sAppr4;
		sTemp = sTemp & 0xF0FF;	
		sTemp = sTemp | ((m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cApprValue) << 8); 
		m_pClientList[iClientH]->m_sAppr4 = sTemp;
		iTemp = m_pClientList[iClientH]->m_iApprColor;
		iTemp = iTemp & 0xFFF0FFFF; 
		iTemp = iTemp | ((m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cItemColor) << 16);
		m_pClientList[iClientH]->m_iApprColor = iTemp;
		break;

	case DEF_EQUIPPOS_RELEASEALL:
		sTemp = m_pClientList[iClientH]->m_sAppr3;
		sTemp = sTemp & 0x0FFF;	 
		sTemp = sTemp | ((m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cApprValue) << 12); 
		m_pClientList[iClientH]->m_sAppr3 = sTemp;
		iTemp = m_pClientList[iClientH]->m_iApprColor;  
		iTemp = iTemp & 0xFFF0FFFF; 
		m_pClientList[iClientH]->m_iApprColor = iTemp;
		break;
	}

	// Activable weapons
	if (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectType == DEF_ITEMEFFECTTYPE_ATTACK_SPECABLTY) 
	{	m_pClientList[iClientH]->m_sAppr4 = m_pClientList[iClientH]->m_sAppr4 & 0xFFF3;
		switch (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sSpecialEffect) {
		case 0: 
			break;
		case 1: // Xelima red: 0x0004
			m_pClientList[iClientH]->m_sAppr4 = m_pClientList[iClientH]->m_sAppr4 | 0x0004;	
			break;
		case 2: // Ice Bleue: 0x000C
			m_pClientList[iClientH]->m_sAppr4 = m_pClientList[iClientH]->m_sAppr4 | 0x000C;	
			break;
		case 3: // Medusa Green: 0x0008
			m_pClientList[iClientH]->m_sAppr4 = m_pClientList[iClientH]->m_sAppr4 | 0x0008;	
			break;
	}	}
	// Special abilities armors
	if (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectType == DEF_ITEMEFFECTTYPE_DEFENSE_SPECABLTY) 
	{	m_pClientList[iClientH]->m_sAppr4 = m_pClientList[iClientH]->m_sAppr4 & 0xFFFC;
		switch(m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sSpecialEffect){
		case 0:
			break;
		case 50: // Merien Shield
		case 51: // Breack weapon on hit located on the considered armor piece
		case 52: // Merien Plate
			m_pClientList[iClientH]->m_sAppr4 = m_pClientList[iClientH]->m_sAppr4 | 0x0002;
			break;
		case 54: // Blue glowing armor
			m_pClientList[iClientH]->m_sAppr4 = m_pClientList[iClientH]->m_sAppr4 | 0x0003;
			break;
		default:
			if(m_pClientList[iClientH]->m_iAdminUserLevel > 0)
			m_pClientList[iClientH]->m_sAppr4 = m_pClientList[iClientH]->m_sAppr4 | 0x0001;
			// m_sAppr4
			// 0x0001 GM	
			// 0x0002 Green	Glare + sparkle
			// 0x0003 Blue  Glare + sparkle
			break;	
	}	}
	// SNOOPY: Added shining Pink Shields
	if (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectType == DEF_ITEMEFFECTTYPE_DEFENSE) 
	{	if (   (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sIDnum == 998) 
			|| (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sIDnum == 999) ) // Pink Shields
		{	m_pClientList[iClientH]->m_sAppr4 = m_pClientList[iClientH]->m_sAppr4 | 0x0003;	
	}	}
	// SNOOPY: Non activable Glowy weapon
	if (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectType == DEF_ITEMEFFECTTYPE_ATTACK) 
	{	if (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sIDnum == 766)// IceGBH 
		{	m_pClientList[iClientH]->m_sAppr4 = m_pClientList[iClientH]->m_sAppr4 | 0x000C;	
		}	
		if (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sIDnum == 13) // SwordBreaker 
		{	m_pClientList[iClientH]->m_sAppr4 = m_pClientList[iClientH]->m_sAppr4 | 0x0008;	
		}	
	}	
	//cHeroArmorType = _cCheckHeroItemEquipped(iClientH);
	//if (cHeroArmorType != 0x0FFFFFFFF) m_pClientList[iClientH]->m_cHeroArmourBonus = cHeroArmorType;		
	SendEventToNearClient_TypeA(iClientH, DEF_OWNERTYPE_PLAYER, MSGID_EVENT_MOTION, DEF_OBJECTNULLACTION, NULL, NULL, NULL);
	CalcTotalItemEffect(iClientH, sItemIndex, bNotify);
	return TRUE;
}

void CGame::SendEventToNearClient_TypeB(DWORD dwMsgID, WORD wMsgType, char cMapIndex, short sX, short sY, short sV1, short sV2, short sV3, short sV4)
{int i, iRet, iShortCutIndex;
 char  * cp, cData[100];
 DWORD * dwp;//, dwTime;
 WORD * wp;
 short * sp;
 BOOL bFlag;
	ZeroMemory(cData, sizeof(cData));	
	dwp  = (DWORD *)(cData + DEF_INDEX4_MSGID);
	*dwp = dwMsgID;
	wp   = (WORD *)(cData + DEF_INDEX2_MSGTYPE);
	*wp  = wMsgType;	
	cp = (char *)(cData + DEF_INDEX2_MSGTYPE + 2);
	sp  = (short *)cp;
	*sp = sX;
	cp += 2;
	sp  = (short *)cp;
	*sp = sY;
	cp += 2;
	sp  = (short *)cp;
	*sp = sV1;
	cp += 2;
	sp  = (short *)cp;
	*sp = sV2;
	cp += 2;
	sp  = (short *)cp;
	*sp = sV3;
	cp += 2;
	sp  = (short *)cp;
	*sp = sV4;
	cp += 2;
	//dwTime = timeGetTime();
	//for (i = 1; i < DEF_MAXCLIENTS; i++)
	bFlag = TRUE;
	iShortCutIndex = 0;
	while (bFlag == TRUE) {	// DEF_MAXCLIENTS .	
		i = m_iClientShortCut[iShortCutIndex];
		iShortCutIndex++;
		if (i == 0) bFlag = FALSE;
		if ((bFlag == TRUE) && (m_pClientList[i] != NULL)) 
		{	if ( (m_pClientList[i]->m_cMapIndex == cMapIndex) &&
				 (m_pClientList[i]->m_sX >= sX - 10) &&
				 (m_pClientList[i]->m_sX <= sX + 10) &&
				 (m_pClientList[i]->m_sY >= sY - 8 ) &&
				 (m_pClientList[i]->m_sY <= sY + 8 ) ) 
			{	iRet = m_pClientList[i]->m_pXSock->iSendMsg(cData, 18);	
	}	}	}
}

/////////////////////////////////////////////////////////////////////////////////////
//  int CGame::iClientMotion_Stop_Handler(int iClientH, short sX, short sY, char cDir)
//  description			:: checks if player is stopped
//  last updated		:: October 29, 2004; 6:46 PM; Hypnotoad
//	return value		:: int
/////////////////////////////////////////////////////////////////////////////////////
int CGame::iClientMotion_Stop_Handler(int iClientH, short sX, short sY, char cDir)
{char cData[100];
 DWORD * dwp;
 WORD  * wp;
 int     iRet;
 short   sOwnerH;
 char    cOwnerType;	
	if (m_pClientList[iClientH] == NULL) return 0;
	if ((cDir <= 0) || (cDir > 8))       return 0;
	if (m_pClientList[iClientH]->m_bIsKilled == TRUE) return 0;
	if (m_pClientList[iClientH]->m_bIsInitComplete == FALSE) return 0;	
	if ((sX != m_pClientList[iClientH]->m_sX) || (sY != m_pClientList[iClientH]->m_sY)) return 2; // reject mvt

	if (m_pClientList[iClientH]->m_bSkillUsingStatus[19] == TRUE) 
	{	m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, sX, sY);		
		if (sOwnerH != NULL) 
		{	DeleteClient(iClientH, TRUE, TRUE);
			return 0;
		}
	}
	ClearSkillUsingStatus(iClientH);
	int iStX, iStY;
	if (m_pMapList[m_pClientList[iClientH]->m_cMapIndex] != NULL) {
		iStX = m_pClientList[iClientH]->m_sX / 20;
		iStY = m_pClientList[iClientH]->m_sY / 20;
		m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_stTempSectorInfo[iStX][iStY].iPlayerActivity++;
		switch (m_pClientList[iClientH]->m_cSide) {
		case 1: m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_stTempSectorInfo[iStX][iStY].iAresdenActivity++; break;
		case 2: m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_stTempSectorInfo[iStX][iStY].iElvineActivity++;  break;
		case 4: m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_stTempSectorInfo[iStX][iStY].iExecutorActivity++;break;
		case 0:
		default: m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_stTempSectorInfo[iStX][iStY].iNeutralActivity++; break;
		}
	}
	m_pClientList[iClientH]->m_cDir = cDir;	
	m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->ClearOwner(0, iClientH, DEF_OWNERTYPE_PLAYER, sX, sY);
	m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->SetOwner(iClientH, DEF_OWNERTYPE_PLAYER, sX, sY);
	dwp  = (DWORD *)(cData + DEF_INDEX4_MSGID);
	*dwp = MSGID_RESPONSE_MOTION;
	wp   = (WORD *)(cData + DEF_INDEX2_MSGTYPE);
	*wp  = DEF_OBJECTMOTION_CONFIRM;
	iRet = m_pClientList[iClientH]->m_pXSock->iSendMsg(cData, 6);
	switch (iRet) {
	case DEF_XSOCKEVENT_QUENEFULL:
	case DEF_XSOCKEVENT_SOCKETERROR:
	case DEF_XSOCKEVENT_CRITICALERROR:
	case DEF_XSOCKEVENT_SOCKETCLOSED:
		DeleteClient(iClientH, TRUE, TRUE);
		return 0;
	}
	return 1;
}

void CGame::ResponseCreateNewGuildHandler(char * pData, DWORD dwMsgSize)
{register int i;
 WORD  * wp, wResult = DEF_MSGTYPE_REJECT;
 DWORD * dwp;
 char  * cp, cCharName[11], cData[100], cTxt[120];
 int iRet;	
	ZeroMemory(cCharName, sizeof(cCharName));
	cp = (char *)(pData + DEF_INDEX2_MSGTYPE + 2);
	memcpy(cCharName, cp, 10);
	cp += 10;	
	for (i = 1; i < DEF_MAXCLIENTS; i++) 
	if ((m_pClientList[i] != NULL) && (memcmp(m_pClientList[i]->m_cCharName, cCharName, 10) == 0) &&
		(m_pClientList[i]->m_iLevel >= 20) && (m_pClientList[i]->m_iCharisma >= 20)) 		
	{	wp = (WORD *)(pData + DEF_INDEX2_MSGTYPE);
		switch (*wp) {
		case DEF_LOGRESMSGTYPE_CONFIRM:
			wResult = DEF_MSGTYPE_CONFIRM;
			m_pClientList[i]->m_iGuildRank = 0;	
			wsprintf(cTxt, "(!) New guild(%s) creation success! : character(%s)", m_pClientList[i]->m_cGuildName, m_pClientList[i]->m_cCharName);
			PutLogList(cTxt);
			break;
		case DEF_LOGRESMSGTYPE_REJECT:
			wResult = DEF_MSGTYPE_REJECT;
			ZeroMemory(m_pClientList[i]->m_cGuildName, sizeof(m_pClientList[i]->m_cGuildName));
			memcpy(m_pClientList[i]->m_cGuildName, "NONE", 4);
			m_pClientList[i]->m_iGuildRank = -1;  
			m_pClientList[i]->m_iGuildGUID = -1;
			wsprintf(cTxt, "(!) New guild(%s) creation Fail! : character(%s)", m_pClientList[i]->m_cGuildName, m_pClientList[i]->m_cCharName);
			PutLogList(cTxt);
			break;
		}		
		dwp  = (DWORD *)(cData + DEF_INDEX4_MSGID);
		*dwp = MSGID_RESPONSE_CREATENEWGUILD;
		wp   = (WORD *)(cData + DEF_INDEX2_MSGTYPE);
		*wp  = wResult;
		iRet = m_pClientList[i]->m_pXSock->iSendMsg(cData, 6);
		switch (iRet) {
		case DEF_XSOCKEVENT_QUENEFULL:
		case DEF_XSOCKEVENT_SOCKETERROR:
		case DEF_XSOCKEVENT_CRITICALERROR:
		case DEF_XSOCKEVENT_SOCKETCLOSED:
			DeleteClient(i, TRUE, TRUE);
			return;
		}
		return;
	}
	wsprintf(cTxt, "(!)Non-existing player data received from Log server(2): CharName(%s)", cCharName);
	PutLogList(cTxt);
}

void CGame::RequestCreateNewGuildHandler(int iClientH, char * pData, DWORD dwMsgSize)
{char * cp, cGuildName[21], cTxt[120], cData[100];
 DWORD * dwp;
 WORD  * wp;
 int     iRet;
 SYSTEMTIME SysTime;
	if (m_pClientList[iClientH] == NULL) return;
	if (m_pClientList[iClientH]->m_bIsInitComplete == FALSE) return;
	if (m_bIsCrusadeMode == TRUE) return;
	cp = (char *)(pData	+ DEF_INDEX2_MSGTYPE + 2);	
	cp += 10;
	cp += 10;
	cp += 10;	
	ZeroMemory(cGuildName, sizeof(cGuildName));
	memcpy(cGuildName, cp, 20);
	cp += 20;
	if (m_pClientList[iClientH]->m_iGuildRank != -1) 
	{	wsprintf(cTxt, "(!)Cannot create guild! Already guild member.: CharName(%s)", m_pClientList[iClientH]->m_cCharName);
		PutLogList(cTxt);
	}else 
	{	if ( (m_pClientList[iClientH]->m_iLevel < 20) || (m_pClientList[iClientH]->m_iCharisma < 20) 
			 || (memcmp(m_pClientList[iClientH]->m_cLocation, "NONE", 4) == 0)
			 || (    (memcmp(m_pClientList[iClientH]->m_cLocation, m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cLocationName, 10) != 0) 
				  && (!m_bMapModeEquilibrium)
				) ) // SNOOPY: No m_cLocationName in Equilibrium Mode 
		{	ZeroMemory(cData, sizeof(cData));

			dwp  = (DWORD *)(cData + DEF_INDEX4_MSGID);
			*dwp = MSGID_RESPONSE_CREATENEWGUILD;
			wp   = (WORD *)(cData + DEF_INDEX2_MSGTYPE);
			*wp  = DEF_MSGTYPE_REJECT;

			iRet = m_pClientList[iClientH]->m_pXSock->iSendMsg(cData, 6);
			switch (iRet) {
			case DEF_XSOCKEVENT_QUENEFULL:
			case DEF_XSOCKEVENT_SOCKETERROR:
			case DEF_XSOCKEVENT_CRITICALERROR:
			case DEF_XSOCKEVENT_SOCKETCLOSED:
				DeleteClient(iClientH, TRUE, TRUE);
				return;
			}
		}else 
		{	ZeroMemory(m_pClientList[iClientH]->m_cGuildName, sizeof(m_pClientList[iClientH]->m_cGuildName));
			strcpy(m_pClientList[iClientH]->m_cGuildName, cGuildName);			
			//SNOOPY: Changed GuildMaster becomes combatant 
			//ZeroMemory(m_pClientList[iClientH]->m_cLocation, sizeof(m_pClientList[iClientH]->m_cLocation));
			// Guildmaster becomes combatant..
			//strcpy(m_pClientList[iClientH]->m_cLocation, m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cLocationName);
			if (m_pClientList[iClientH]->m_bIsPlayerCivil == TRUE)
			ForceChangePlayMode(iClientH, TRUE);
			// Create GUID
			GetLocalTime(&SysTime);
			m_pClientList[iClientH]->m_iGuildGUID = (int)(SysTime.wYear + SysTime.wMonth + SysTime.wDay + SysTime.wHour + SysTime.wMinute + timeGetTime());
			bSendMsgToLS(MSGID_REQUEST_CREATENEWGUILD, iClientH);
		}
	}
}


void CGame::RequestDisbandGuildHandler(int iClientH, char * pData, DWORD dwMsgSize)
{ char * cp, cGuildName[21], cTxt[120];
	if (m_bIsCrusadeMode == TRUE) return;
	cp = (char *)(pData	+ DEF_INDEX2_MSGTYPE + 2);
	ZeroMemory(cGuildName, sizeof(cGuildName));	
	cp += 10;
	cp += 10;
	cp += 10;	
	memcpy(cGuildName, cp, 20);
	cp += 20;
	if ((m_pClientList[iClientH]->m_iGuildRank != 0) || (memcmp(m_pClientList[iClientH]->m_cGuildName, cGuildName, 20) != 0)) 
	{	wsprintf(cTxt, "(!)Cannot Disband guild! Not guildmaster.: CharName(%s)", m_pClientList[iClientH]->m_cCharName);
		PutLogList(cTxt);
	}else 
	{	bSendMsgToLS(MSGID_REQUEST_DISBANDGUILD, iClientH);
	}
}

void CGame::ResponseDisbandGuildHandler(char * pData, DWORD dwMsgSize)
{register int i;
 WORD  * wp, wResult = DEF_MSGTYPE_REJECT;
 DWORD * dwp;
 char  * cp, cCharName[11], cData[100], cTxt[120];
 int iRet;
	ZeroMemory(cCharName, sizeof(cCharName));
	cp = (char *)(pData + DEF_INDEX2_MSGTYPE + 2);
	memcpy(cCharName, cp, 10);
	cp += 10;
	for (i = 1; i < DEF_MAXCLIENTS; i++) 
	if ((m_pClientList[i] != NULL) && (memcmp(m_pClientList[i]->m_cCharName, cCharName, 10) == 0)) 
	{	wp = (WORD *)(pData + DEF_INDEX2_MSGTYPE);
		switch (*wp) {
		case DEF_LOGRESMSGTYPE_CONFIRM:
			wResult = DEF_MSGTYPE_CONFIRM;
			wsprintf(cTxt, "(!) Disband guild(%s) success! : character(%s)", m_pClientList[i]->m_cGuildName, m_pClientList[i]->m_cCharName);
			PutLogList(cTxt);			
			SendGuildMsg(i,	DEF_NOTIFY_GUILDDISBANDED, NULL, NULL, NULL);
			ZeroMemory(m_pClientList[i]->m_cGuildName, sizeof(m_pClientList[i]->m_cGuildName));
			memcpy(m_pClientList[i]->m_cGuildName, "NONE", 4);
			m_pClientList[i]->m_iGuildRank = -1;
			m_pClientList[i]->m_iGuildGUID = -1;
			break;

		case DEF_LOGRESMSGTYPE_REJECT:
			wResult = DEF_MSGTYPE_REJECT;
			wsprintf(cTxt, "(!) Disband guild(%s) Fail! : character(%s)", m_pClientList[i]->m_cGuildName, m_pClientList[i]->m_cCharName);
			PutLogList(cTxt);
			break;
		}
		dwp  = (DWORD *)(cData + DEF_INDEX4_MSGID);
		*dwp = MSGID_RESPONSE_DISBANDGUILD;
		wp   = (WORD *)(cData + DEF_INDEX2_MSGTYPE);
		*wp  = wResult;
		iRet = m_pClientList[i]->m_pXSock->iSendMsg(cData, 6);
		switch (iRet) {
		case DEF_XSOCKEVENT_QUENEFULL:
		case DEF_XSOCKEVENT_SOCKETERROR:
		case DEF_XSOCKEVENT_CRITICALERROR:
		case DEF_XSOCKEVENT_SOCKETCLOSED:
			DeleteClient(i, TRUE, TRUE);
			return;
		}
		return;
	}
	wsprintf(cTxt, "(!)Non-existing player data received from Log server(2): CharName(%s)", cCharName);
	PutLogList(cTxt);
}

// 05/29/2004 - Hypnotoad - Purchase Dicount updated to take charisma into consideration
void CGame::RequestPurchaseItemHandler(int iClientH, char * pItemName, int iNum)
{
 class CItem * pItem;
 char  * cp, cItemName[21], cData[100];
 short * sp;
 DWORD * dwp, dwGoldCount, dwItemCount;
 WORD  * wp, wTempPrice;
 int   i, iRet, iEraseReq, iGoldWeight, iCost;
 
	if (m_pClientList[iClientH] == NULL) return;
	if (m_pClientList[iClientH]->m_bIsInitComplete == FALSE) return;
	//if ( (memcmp(m_pClientList[iClientH]->m_cLocation, "NONE", 4) != 0) &&
	//	 (memcmp(m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cLocationName, m_pClientList[iClientH]->m_cLocation, 10) != 0) ) return;
	
	// Snoopy in EQUILIBRIUM mode, all merchants works..
	if ((memcmp(m_pClientList[iClientH]->m_cLocation, "NONE", 4) != 0) && (!m_bMapModeEquilibrium)) 
	{	if (memcmp(m_pClientList[iClientH]->m_cLocation, "are", 3) == 0) 
		{	if (   (memcmp(m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cLocationName, "aresden", 7) == 0) 
				|| (memcmp(m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cLocationName, "arefarm", 7) == 0) 
				|| (memcmp(m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cLocationName, "lost", 4) == 0))
			{}else return;
		}
		if (memcmp(m_pClientList[iClientH]->m_cLocation, "elv", 3) == 0) 
		{	if (   (memcmp(m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cLocationName, "elvine", 6) == 0) 
				|| (memcmp(m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cLocationName, "elvfarm", 7) == 0)
				|| (memcmp(m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cLocationName, "lost", 4) == 0))
			{}else return;
	}	}
	
	ZeroMemory(cData, sizeof(cData));	
	ZeroMemory(cItemName, sizeof(cItemName));
	
	// New 18/05/2004
	if (m_pClientList[iClientH]->m_pIsProcessingAllowed == FALSE) return;
	if (memcmp(pItemName, "10Arrows", 8) == 0) 
	{	strcpy(cItemName, "Arrow");
		dwItemCount = 10;
	}else if (memcmp(pItemName, "100Arrows", 9) == 0) 
	{	strcpy(cItemName, "Arrow");
		dwItemCount = 100;
	}else 
	{	memcpy(cItemName, pItemName, 20);
		dwItemCount = 1;
	}	
	for (i = 1; i <= iNum; i++) 
	{	pItem = new class CItem;
		if (_bInitItemAttr(pItem, cItemName) == FALSE) 
		{	delete pItem;
		}else 
		{	if (pItem->m_bIsForSale == FALSE) 
			{	delete pItem;
				return;
			}
			pItem->m_dwCount = dwItemCount;
			// SNOOPY: Added Touch Effect on buyed items (as on v2.191
			pItem->m_sTouchEffectType   = DEF_ITET_ID;
			pItem->m_sTouchEffectValue1 = iDice(1,100000);
			pItem->m_sTouchEffectValue2 = iDice(1,100000);
			if (pItem->m_cItemType == DEF_ITEMTYPE_MATERIAL)
			{	pItem->m_sItemSpecEffectValue2 = iDice (1, 40) +20;
				pItem->m_dwAttribute = 1;
				pItem->m_sItemSpecEffectValue1 = pItem->m_wCurLifeSpan;
			}
			SYSTEMTIME SysTime;
			char cTemp[256];
			GetLocalTime(&SysTime);
			ZeroMemory(cTemp, sizeof(cTemp));
			wsprintf(cTemp, "%d%2d",  (short)SysTime.wMonth, (short)SysTime.wDay);
			pItem->m_sTouchEffectValue3 = atoi(cTemp);
			iCost = pItem->m_wPrice * pItem->m_dwCount;
			dwGoldCount = dwGetItemCount(iClientH, "Gold");

// The momment client is patched: price is not reduced by charisma		
// m_cDiscount is computed at InitPlayerData, including Charisma, Crusade, Heldenian effects...
// Discount Ratio must stay very low or people will use "Merchant" characters
// I want money to be an issue (mandatory to allow Lottery!)
			iCost = (int)(iCost * ((100.0f + (float)m_pClientList[iClientH]->m_cDiscount)/100.0f) );
			if ( dwGoldCount < (DWORD)(iCost) ) 
			{	delete pItem;				
				dwp  = (DWORD *)(cData + DEF_INDEX4_MSGID);
				*dwp = MSGID_NOTIFY;
				wp   = (WORD *)(cData + DEF_INDEX2_MSGTYPE);
				*wp  = DEF_NOTIFY_NOTENOUGHGOLD;
				cp   = (char *)(cData + DEF_INDEX2_MSGTYPE + 2);
				*cp  = -1; 
				cp++;				
				iRet = m_pClientList[iClientH]->m_pXSock->iSendMsg(cData, 7);
				switch (iRet) {
				case DEF_XSOCKEVENT_QUENEFULL:
				case DEF_XSOCKEVENT_SOCKETERROR:
				case DEF_XSOCKEVENT_CRITICALERROR:
				case DEF_XSOCKEVENT_SOCKETCLOSED:
					DeleteClient(iClientH, TRUE, TRUE);
					return;
				}
				return;
			}			
			if (_bAddClientItemList(iClientH, pItem, &iEraseReq) == TRUE) {
				if (m_pClientList[iClientH]->m_iCurWeightLoad < 0) m_pClientList[iClientH]->m_iCurWeightLoad = 0;
				dwp  = (DWORD *)(cData + DEF_INDEX4_MSGID);
				*dwp = MSGID_NOTIFY;
				wp   = (WORD *)(cData + DEF_INDEX2_MSGTYPE);
				*wp  = DEF_NOTIFY_ITEMPURCHASED;
				cp = (char *)(cData + DEF_INDEX2_MSGTYPE + 2);
				*cp = 1;
				cp++;				
				memcpy(cp, pItem->m_cName, 20);
				cp += 20;				
				dwp  = (DWORD *)cp;
				*dwp = pItem->m_dwCount;
				cp += 4;				
				*cp = pItem->m_cItemType;
				cp++;				
				*cp = pItem->m_cEquipPos;
				cp++;				
				*cp = (char)0;
				cp++;				
				sp  = (short *)cp;
				*sp = pItem->m_sLevelLimit;
				cp += 2;				
				*cp = pItem->m_cGenderLimit;
				cp++;				
				wp = (WORD *)cp;
				*wp = pItem->m_wCurLifeSpan;
				cp += 2;				
				wp = (WORD *)cp;
				*wp = pItem->m_wWeight;
				cp += 2;				
				sp  = (short *)cp;
				*sp = pItem->m_sSprite;
				cp += 2;				
				sp  = (short *)cp;
				*sp = pItem->m_sSpriteFrame;
				cp += 2;
				*cp = pItem->m_cItemColor;
				cp++;				
				wp  = (WORD *)cp;
				*wp = (iCost);
				wTempPrice = (iCost);
				cp += 2;				
				if (iEraseReq == 1) delete pItem;				
				iRet = m_pClientList[iClientH]->m_pXSock->iSendMsg(cData, 48);				
				iGoldWeight = SetItemCount(iClientH, "Gold", dwGoldCount - wTempPrice);
				iCalcTotalWeight(iClientH);
				m_stCityStatus[m_pClientList[iClientH]->m_cSide].iFunds += wTempPrice;					
				switch (iRet) {
				case DEF_XSOCKEVENT_QUENEFULL:
				case DEF_XSOCKEVENT_SOCKETERROR:
				case DEF_XSOCKEVENT_CRITICALERROR:
				case DEF_XSOCKEVENT_SOCKETCLOSED:
					DeleteClient(iClientH, TRUE, TRUE);
					return;
				}
			}else 
			{	delete pItem;
				iCalcTotalWeight(iClientH);
				dwp  = (DWORD *)(cData + DEF_INDEX4_MSGID);
				*dwp = MSGID_NOTIFY;
				wp   = (WORD *)(cData + DEF_INDEX2_MSGTYPE);
				*wp  = DEF_NOTIFY_CANNOTCARRYMOREITEM;				
				iRet = m_pClientList[iClientH]->m_pXSock->iSendMsg(cData, 6);
				switch (iRet) {
				case DEF_XSOCKEVENT_QUENEFULL:
				case DEF_XSOCKEVENT_SOCKETERROR:
				case DEF_XSOCKEVENT_CRITICALERROR:
				case DEF_XSOCKEVENT_SOCKETCLOSED:
					DeleteClient(iClientH, TRUE, TRUE);
					return;
 	}	}	}	}
}

void CGame::GiveItemHandler(int iClientH, short sItemIndex, int iAmount, short dX, short dY, WORD wObjectID, char * pItemName)
{register int iRet, iEraseReq;
 short * sp, sOwnerH;
 char  * cp, cOwnerType, cData[100], cCharName[21];
 DWORD * dwp;
 WORD  * wp;
 class CItem * pItem;

	if (m_pClientList[iClientH] == NULL) return;
	if (m_pClientList[iClientH]->m_bIsOnWaitingProcess == TRUE) return;
	if ((m_bAdminSecurity == TRUE) && (m_pClientList[iClientH]->m_iAdminUserLevel > 0)) return;
	if (m_pClientList[iClientH]->m_bIsInitComplete == FALSE) return;
	if (m_pClientList[iClientH]->m_pItemList[sItemIndex] == NULL) return;
	if ((sItemIndex < 0) || (sItemIndex >= DEF_MAXITEMS)) return;
	if (iAmount <= 0) return;

	if (memcmp(m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cName, pItemName, 20) != 0) 
	{	PutLogList("GiveItemHandler - Not matching Item name");
		return;
	}
	ZeroMemory(cCharName, sizeof(cCharName));
	if ( ( (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cItemType == DEF_ITEMTYPE_CONSUME) ||
		   (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cItemType == DEF_ITEMTYPE_ARROW) ) &&
		 (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_dwCount > (DWORD)iAmount) ) 
	{	pItem = new class CItem;
		if (_bInitItemAttr(pItem, m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cName) == FALSE) 
		{	delete pItem;
			return;
		}else 
		{	pItem->m_dwCount = iAmount;
		}

		m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_dwCount -= iAmount;
		SetItemCount(iClientH, sItemIndex, m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_dwCount);		
		m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, dX, dY);		
		if (wObjectID != NULL) 
		{ 	if (wObjectID < 10000) 
			{	if ((wObjectID > 0) && (wObjectID < DEF_MAXCLIENTS)) 
				{	if (m_pClientList[wObjectID] != NULL) 
					{	if ((WORD)sOwnerH != wObjectID) sOwnerH = NULL;
				}	}
			}else 	// NPC
			{	if ((wObjectID - 10000 > 0) && (wObjectID - 10000 < DEF_MAXNPCS)) 
				{	if (m_pNpcList[wObjectID - 10000] != NULL) 
					{	if ((WORD)sOwnerH != (wObjectID - 10000)) sOwnerH = NULL;
		}	}	}	}
		// Snoopy: Bock attemps to give item to a far character.
		if (   ((abs (m_pClientList[iClientH]->m_sX) - dX)>5) 
			|| ((abs (m_pClientList[iClientH]->m_sY) - dY)>5))
		{	sOwnerH = NULL;
		}
		if (sOwnerH == NULL) 
		{	m_pMapList[ m_pClientList[iClientH]->m_cMapIndex ]->bSetItem(m_pClientList[iClientH]->m_sX, m_pClientList[iClientH]->m_sY, pItem);
			_bItemLog(DEF_ITEMLOG_DROP, iClientH, NULL, pItem);
			SendEventToNearClient_TypeB(MSGID_EVENT_COMMON, DEF_COMMONTYPE_ITEMDROP, m_pClientList[iClientH]->m_cMapIndex,
				                        m_pClientList[iClientH]->m_sX, m_pClientList[iClientH]->m_sY,  
				                        pItem->m_sSprite, pItem->m_sSpriteFrame, pItem->m_cItemColor);
		}else 
		{	if (cOwnerType == DEF_OWNERTYPE_PLAYER) 
			{	memcpy(cCharName, m_pClientList[sOwnerH]->m_cCharName, 10);
				if (sOwnerH == iClientH) 
				{	delete pItem;
					return;
				}				
				if (_bAddClientItemList(sOwnerH, pItem, &iEraseReq) == TRUE) 
				{	dwp  = (DWORD *)(cData + DEF_INDEX4_MSGID);
					*dwp = MSGID_NOTIFY;
					wp   = (WORD *)(cData + DEF_INDEX2_MSGTYPE);
					*wp  = DEF_NOTIFY_ITEMOBTAINED;				
					cp = (char *)(cData + DEF_INDEX2_MSGTYPE + 2);
					//  Amount
					*cp = 1;
					cp++;					
					memcpy(cp, pItem->m_cName, 20);
					cp += 20;
					dwp  = (DWORD *)cp;
					*dwp = pItem->m_dwCount;
					cp += 4;
					*cp = pItem->m_cItemType;
					cp++;
					*cp = pItem->m_cEquipPos;
					cp++;
					*cp = (char)0; 
					cp++;
					sp  = (short *)cp;
					*sp = pItem->m_sLevelLimit;
					cp += 2;	
					*cp = pItem->m_cGenderLimit;
					cp++;
					wp = (WORD *)cp;
					*wp = pItem->m_wCurLifeSpan;
					cp += 2;		
					wp = (WORD *)cp;
					*wp = pItem->m_wWeight;
					cp += 2;
					sp  = (short *)cp;
					*sp = pItem->m_sSprite;
					cp += 2;
					sp  = (short *)cp;
					*sp = pItem->m_sSpriteFrame;
					cp += 2;
					*cp = pItem->m_cItemColor;
					cp++;
					*cp = (char)pItem->m_sItemSpecEffectValue2; // v1.41 
					cp++;					
					dwp = (DWORD *)cp;
					*dwp = pItem->m_dwAttribute;
					cp += 4;
					/*
					*cp = (char)(pItem->m_dwAttribute & 0x00000001); // Custom-ItemÃ€ÃŽÃÃ¶Ã€Ã‡ Â¿Â©ÂºÃŽ 
					cp++;
					*/
					if (iEraseReq == 1) delete pItem;

					iRet = m_pClientList[sOwnerH]->m_pXSock->iSendMsg(cData, 53);
					switch (iRet) {
					case DEF_XSOCKEVENT_QUENEFULL:
					case DEF_XSOCKEVENT_SOCKETERROR:
					case DEF_XSOCKEVENT_CRITICALERROR:
					case DEF_XSOCKEVENT_SOCKETCLOSED:
						DeleteClient(sOwnerH, TRUE, TRUE);
						break;
					}
					SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_GIVEITEMFIN_COUNTCHANGED, sItemIndex, iAmount, NULL, cCharName);
				}else 	// Unable to give item to the player
				{	m_pMapList[ m_pClientList[iClientH]->m_cMapIndex ]->bSetItem(m_pClientList[iClientH]->m_sX, 
							                                                     m_pClientList[iClientH]->m_sY, 
																			     pItem);
					_bItemLog(DEF_ITEMLOG_DROP, iClientH, NULL, pItem);	
					SendEventToNearClient_TypeB(MSGID_EVENT_COMMON, DEF_COMMONTYPE_ITEMDROP, m_pClientList[iClientH]->m_cMapIndex,
							                    m_pClientList[iClientH]->m_sX, m_pClientList[iClientH]->m_sY,  
								                pItem->m_sSprite, pItem->m_sSpriteFrame, pItem->m_cItemColor);
					dwp  = (DWORD *)(cData + DEF_INDEX4_MSGID);
					*dwp = MSGID_NOTIFY;
					wp   = (WORD *)(cData + DEF_INDEX2_MSGTYPE);
					*wp  = DEF_NOTIFY_CANNOTCARRYMOREITEM;			
					iRet = m_pClientList[sOwnerH]->m_pXSock->iSendMsg(cData, 6);
					switch (iRet) {
					case DEF_XSOCKEVENT_QUENEFULL:
					case DEF_XSOCKEVENT_SOCKETERROR:
					case DEF_XSOCKEVENT_CRITICALERROR:
					case DEF_XSOCKEVENT_SOCKETCLOSED:
						DeleteClient(sOwnerH, TRUE, TRUE);
						break;
					}
					SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_CANNOTGIVEITEM, sItemIndex, iAmount, NULL, cCharName);
				}	
			}else // Give item to NPC
			{	memcpy(cCharName, m_pNpcList[sOwnerH]->m_cNpcName, 20);
				if (memcmp(m_pNpcList[sOwnerH]->m_cNpcName, "Howard", 6) == 0) // Bank NPC
				{	if (bSetItemToBankItem(iClientH, pItem) == FALSE) 
					{	SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_CANNOTITEMTOBANK, NULL, NULL, NULL, NULL);
						m_pMapList[ m_pClientList[iClientH]->m_cMapIndex ]->bSetItem(m_pClientList[iClientH]->m_sX, m_pClientList[iClientH]->m_sY, pItem);
						_bItemLog(DEF_ITEMLOG_DROP, iClientH, NULL, pItem);
						SendEventToNearClient_TypeB(MSGID_EVENT_COMMON, DEF_COMMONTYPE_ITEMDROP, m_pClientList[iClientH]->m_cMapIndex,
								                    m_pClientList[iClientH]->m_sX, m_pClientList[iClientH]->m_sY,  
									                pItem->m_sSprite, pItem->m_sSpriteFrame, pItem->m_cItemColor); // v1.4 color
					}
		   		}else  // Other NPC 
				{	m_pMapList[ m_pClientList[iClientH]->m_cMapIndex ]->bSetItem(m_pClientList[iClientH]->m_sX, m_pClientList[iClientH]->m_sY, pItem);
					_bItemLog(DEF_ITEMLOG_DROP, iClientH, NULL, pItem);
						SendEventToNearClient_TypeB(MSGID_EVENT_COMMON, DEF_COMMONTYPE_ITEMDROP, m_pClientList[iClientH]->m_cMapIndex,
							                    m_pClientList[iClientH]->m_sX, m_pClientList[iClientH]->m_sY,  
								                pItem->m_sSprite, pItem->m_sSpriteFrame, pItem->m_cItemColor); 
		}	}	}
	}else  // Single item (not arrow or stackable item)
	{	ReleaseItemHandler(iClientH, sItemIndex, TRUE);
		if (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cItemType == DEF_ITEMTYPE_ARROW) 
			m_pClientList[iClientH]->m_cArrowIndex = -1;
				m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, dX, dY); 
		if (wObjectID != NULL) 
		{ 	if (wObjectID < 10000) 
			{	if ((wObjectID > 0) && (wObjectID < DEF_MAXCLIENTS)) 
				{	if (m_pClientList[wObjectID] != NULL) 
					{	if ((WORD)sOwnerH != wObjectID) sOwnerH = NULL;				
				}	}
			}else 	// NPC			
			{	if ((wObjectID - 10000 > 0) && (wObjectID - 10000 < DEF_MAXNPCS)) 
				{	if (m_pNpcList[wObjectID - 10000] != NULL) 
					{	if ((WORD)sOwnerH != (wObjectID - 10000)) sOwnerH = NULL;
		}	}	}	}
		// Snoopy: Bock attemps to give item to a far character.
		if (   ((abs (m_pClientList[iClientH]->m_sX) - dX)>5) 
			|| ((abs (m_pClientList[iClientH]->m_sY) - dY)>5))
		{	sOwnerH = NULL;
		}
		// avatar: DEF_ITEMEFFECTTYPE_EVENT_ITEMDROP
		if (   (m_bIsAvatarMode == TRUE)
			&& (m_iPLmapIndex != -1)
			&& (m_iAvatarMessenger == iClientH)
			&& (m_pClientList[m_iAvatarMessenger]->m_cMapIndex == m_iPLmapIndex) 
			&& (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectType == DEF_ITEMEFFECTTYPE_EVENT_ITEMDROP))
		{	DWORD dwGUID;
			memcpy(& dwGUID, &m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemSpecEffectValue1, 4);
			if (dwGUID == m_dwAvatarGUID)
			{	RelicDrop(iClientH, m_pClientList[iClientH]->m_pItemList[sItemIndex]);
				sOwnerH = NULL;
		}	}
		if (sOwnerH == NULL) 
		{	m_pMapList[ m_pClientList[iClientH]->m_cMapIndex ]->bSetItem(m_pClientList[iClientH]->m_sX, 
			                                                             m_pClientList[iClientH]->m_sY, 
																	     m_pClientList[iClientH]->m_pItemList[sItemIndex]);
			_bItemLog(DEF_ITEMLOG_DROP, iClientH, NULL, m_pClientList[iClientH]->m_pItemList[sItemIndex]);
			SendEventToNearClient_TypeB(MSGID_EVENT_COMMON, DEF_COMMONTYPE_ITEMDROP, m_pClientList[iClientH]->m_cMapIndex,
				                        m_pClientList[iClientH]->m_sX, m_pClientList[iClientH]->m_sY,  
				                        m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sSprite, 
								        m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sSpriteFrame, 
										m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cItemColor); // v1.4 color
			SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_DROPITEMFIN_ERASEITEM, sItemIndex, iAmount, NULL, NULL);
		}else  // Give to player
		{	if (cOwnerType == DEF_OWNERTYPE_PLAYER) 
			{	memcpy(cCharName, m_pClientList[sOwnerH]->m_cCharName, 10);
				pItem = m_pClientList[iClientH]->m_pItemList[sItemIndex];
				if (pItem->m_sIDnum == 88) 	// Guild ticket
				{	if ((m_pClientList[iClientH]->m_iGuildRank == -1) && 
						(memcmp(m_pClientList[iClientH]->m_cLocation, "NONE", 4) != 0) &&
						(memcmp(m_pClientList[iClientH]->m_cLocation, m_pClientList[sOwnerH]->m_cLocation, 10) == 0) &&
						(m_pClientList[sOwnerH]->m_iGuildRank == 0) ) 
					{	SendNotifyMsg(iClientH, sOwnerH, DEF_NOTIFY_QUERY_JOINGUILDREQPERMISSION, NULL, NULL, NULL, NULL);
						SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_GIVEITEMFIN_ERASEITEM, sItemIndex, 1, NULL, cCharName);
						_bItemLog(DEF_ITEMLOG_DEPLETE, iClientH,(int) -1, pItem);
						goto REMOVE_ITEM_PROCEDURE;
				}	}
				// Guild Removal Ticket
				if ((m_bIsCrusadeMode == FALSE) && (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sIDnum == 89)) 
				{	if (   (memcmp(m_pClientList[iClientH]->m_cGuildName, m_pClientList[sOwnerH]->m_cGuildName, 20) == 0) 
						&& (m_pClientList[iClientH]->m_iGuildRank != -1) 
						&& (m_pClientList[sOwnerH]->m_iGuildRank == 0) ) 
					{	SendNotifyMsg(iClientH, sOwnerH, DEF_NOTIFY_QUERY_DISMISSGUILDREQPERMISSION, NULL, NULL, NULL, NULL);
						SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_GIVEITEMFIN_ERASEITEM, sItemIndex, 1, NULL, cCharName);
						_bItemLog(DEF_ITEMLOG_DEPLETE, iClientH,(int) -1, pItem);
						goto REMOVE_ITEM_PROCEDURE;				
				}	}
				if (_bAddClientItemList(sOwnerH, pItem, &iEraseReq) == TRUE) 
				{	_bItemLog(DEF_ITEMLOG_GIVE, iClientH, sOwnerH, pItem);
					dwp  = (DWORD *)(cData + DEF_INDEX4_MSGID);
					*dwp = MSGID_NOTIFY;
					wp   = (WORD *)(cData + DEF_INDEX2_MSGTYPE);
					*wp  = DEF_NOTIFY_ITEMOBTAINED;				
					cp = (char *)(cData + DEF_INDEX2_MSGTYPE + 2);
					*cp = 1;
					cp++;
					memcpy(cp, pItem->m_cName, 20);
					cp += 20;
					dwp  = (DWORD *)cp;
					*dwp = pItem->m_dwCount;
					cp += 4;
					*cp = pItem->m_cItemType;
					cp++;
					*cp = pItem->m_cEquipPos;
					cp++;
					*cp = (char)0; //
					cp++;
					sp  = (short *)cp;
					*sp = pItem->m_sLevelLimit;
					cp += 2;	
					*cp = pItem->m_cGenderLimit;
					cp++;
					wp = (WORD *)cp;
					*wp = pItem->m_wCurLifeSpan;
					cp += 2;		
					wp = (WORD *)cp;
					*wp = pItem->m_wWeight;
					cp += 2;
					sp  = (short *)cp;
					*sp = pItem->m_sSprite;
					cp += 2;
					sp  = (short *)cp;
					*sp = pItem->m_sSpriteFrame;
					cp += 2;
					*cp = pItem->m_cItemColor;
					cp++;
					*cp = (char)pItem->m_sItemSpecEffectValue2; // v1.41 
					cp++;					
					dwp = (DWORD *)cp;
					*dwp = pItem->m_dwAttribute;
					cp += 4;
					/*
					*cp = (char)(pItem->m_dwAttribute & 0x00000001); // Custom-ItemÃ€ÃŽÃÃ¶Ã€Ã‡ Â¿Â©ÂºÃŽ 
					cp++;
					*/
					if (iEraseReq == 1) delete pItem;
					iRet = m_pClientList[sOwnerH]->m_pXSock->iSendMsg(cData, 53);
					switch (iRet) {
					case DEF_XSOCKEVENT_QUENEFULL:
					case DEF_XSOCKEVENT_SOCKETERROR:
					case DEF_XSOCKEVENT_CRITICALERROR:
					case DEF_XSOCKEVENT_SOCKETCLOSED:
						DeleteClient(sOwnerH, TRUE, TRUE);
						break;
					}
				}else  // Unable to give item to player, drop it
				{	m_pMapList[ m_pClientList[iClientH]->m_cMapIndex ]->bSetItem(m_pClientList[iClientH]->m_sX, 
							                                                     m_pClientList[iClientH]->m_sY, 
																			     m_pClientList[iClientH]->m_pItemList[sItemIndex]);
					_bItemLog(DEF_ITEMLOG_DROP, iClientH, NULL, m_pClientList[iClientH]->m_pItemList[sItemIndex]);					 
					SendEventToNearClient_TypeB(MSGID_EVENT_COMMON, DEF_COMMONTYPE_ITEMDROP, m_pClientList[iClientH]->m_cMapIndex,
							                    m_pClientList[iClientH]->m_sX, m_pClientList[iClientH]->m_sY,  
								                m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sSprite, 
										        m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sSpriteFrame, 
												m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cItemColor); 
					dwp  = (DWORD *)(cData + DEF_INDEX4_MSGID);
					*dwp = MSGID_NOTIFY;
					wp   = (WORD *)(cData + DEF_INDEX2_MSGTYPE);
					*wp  = DEF_NOTIFY_CANNOTCARRYMOREITEM;
			
					iRet = m_pClientList[sOwnerH]->m_pXSock->iSendMsg(cData, 6);
					switch (iRet) {
					case DEF_XSOCKEVENT_QUENEFULL:
					case DEF_XSOCKEVENT_SOCKETERROR:
					case DEF_XSOCKEVENT_CRITICALERROR:
					case DEF_XSOCKEVENT_SOCKETCLOSED:
						DeleteClient(sOwnerH, TRUE, TRUE);
						break;
					}
					ZeroMemory(cCharName, sizeof(cCharName));
				}
			}else  // Give item to NPC
			{	memcpy(cCharName, m_pNpcList[sOwnerH]->m_cNpcName, 20);
				if (memcmp(m_pNpcList[sOwnerH]->m_cNpcName, "Howard", 6) == 0) 
				{	if (bSetItemToBankItem(iClientH, sItemIndex) == FALSE) 
					{	SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_CANNOTITEMTOBANK, NULL, NULL, NULL, NULL);
						m_pMapList[ m_pClientList[iClientH]->m_cMapIndex ]->bSetItem(m_pClientList[iClientH]->m_sX, 
						                                                         	 m_pClientList[iClientH]->m_sY, 
							                                                         m_pClientList[iClientH]->m_pItemList[sItemIndex]);						
						_bItemLog(DEF_ITEMLOG_DROP, iClientH, NULL, m_pClientList[iClientH]->m_pItemList[sItemIndex]);						
						SendEventToNearClient_TypeB(MSGID_EVENT_COMMON, DEF_COMMONTYPE_ITEMDROP, m_pClientList[iClientH]->m_cMapIndex,
							                        m_pClientList[iClientH]->m_sX, m_pClientList[iClientH]->m_sY,  
							                        m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sSprite, 
							                        m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sSpriteFrame, 
													m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cItemColor); // v1.4 color
					}
				}else if (memcmp(m_pNpcList[sOwnerH]->m_cNpcName, "Kennedy", 7) == 0) 
				{	if ((m_bIsCrusadeMode == FALSE) && (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sIDnum == 89)) 
					{	if ((m_pClientList[iClientH]->m_iGuildRank != 0) && (m_pClientList[iClientH]->m_iGuildRank != -1)) 
						{	SendNotifyMsg(iClientH, iClientH, DEF_COMMONTYPE_DISMISSGUILDAPPROVE, NULL, NULL, NULL, NULL);
							ZeroMemory(m_pClientList[iClientH]->m_cGuildName, sizeof(m_pClientList[iClientH]->m_cGuildName));
							memcpy(m_pClientList[iClientH]->m_cGuildName, "NONE", 4);
							m_pClientList[iClientH]->m_iGuildRank = -1;
							m_pClientList[iClientH]->m_iGuildGUID = -1;
							SendEventToNearClient_TypeA(iClientH, DEF_OWNERTYPE_PLAYER, MSGID_EVENT_MOTION, DEF_OBJECTNULLACTION, NULL, NULL, NULL);
							m_pClientList[iClientH]->m_iExp -= 300;
							if (m_pClientList[iClientH]->m_iExp < 0) m_pClientList[iClientH]->m_iExp = 0;
							SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_EXP, NULL, NULL, NULL, NULL);
						}
						delete m_pClientList[iClientH]->m_pItemList[sItemIndex];
					}else 
					{	m_pMapList[ m_pClientList[iClientH]->m_cMapIndex ]->bSetItem(m_pClientList[iClientH]->m_sX, 
							                                                     m_pClientList[iClientH]->m_sY, 
																			     m_pClientList[iClientH]->m_pItemList[sItemIndex]);

						_bItemLog(DEF_ITEMLOG_DROP, iClientH, NULL, m_pClientList[iClientH]->m_pItemList[sItemIndex]);
						SendEventToNearClient_TypeB(MSGID_EVENT_COMMON, DEF_COMMONTYPE_ITEMDROP, m_pClientList[iClientH]->m_cMapIndex,
							                    m_pClientList[iClientH]->m_sX, m_pClientList[iClientH]->m_sY,  
								                m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sSprite, 
										        m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sSpriteFrame, 
												m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cItemColor); // v1.4 color
						ZeroMemory(cCharName, sizeof(cCharName));
					}
				}else 
				{	m_pMapList[ m_pClientList[iClientH]->m_cMapIndex ]->bSetItem(m_pClientList[iClientH]->m_sX, 
							                                                     m_pClientList[iClientH]->m_sY, 
																			     m_pClientList[iClientH]->m_pItemList[sItemIndex]);
					_bItemLog(DEF_ITEMLOG_DROP, iClientH, NULL, m_pClientList[iClientH]->m_pItemList[sItemIndex]);
					SendEventToNearClient_TypeB(MSGID_EVENT_COMMON, DEF_COMMONTYPE_ITEMDROP, m_pClientList[iClientH]->m_cMapIndex,
							                    m_pClientList[iClientH]->m_sX, m_pClientList[iClientH]->m_sY,  
								                m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sSprite, 
										        m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sSpriteFrame, 
												m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cItemColor); // v1.4 color
					ZeroMemory(cCharName, sizeof(cCharName));
			}	}
			SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_GIVEITEMFIN_ERASEITEM, sItemIndex, iAmount, NULL, cCharName);
		}
REMOVE_ITEM_PROCEDURE:;
		if (m_pClientList[iClientH] == NULL) return;
		m_pClientList[iClientH]->m_pItemList[sItemIndex] = NULL;
		m_pClientList[iClientH]->m_bIsItemEquipped[sItemIndex] = FALSE;
		m_pClientList[iClientH]->m_cArrowIndex = _iGetArrowItemIndex(iClientH);
	}
	iCalcTotalWeight(iClientH);
}

void CGame::SendNotifyMsg(int iFromH, int iToH, WORD wMsgType, DWORD sV1, DWORD sV2, DWORD sV3, char * pString, DWORD sV4, DWORD sV5, DWORD sV6, DWORD sV7, DWORD sV8, DWORD sV9, char * pString2)
{
 char cData[1000];
 DWORD * dwp;
 WORD  * wp;
 char  * cp;
 short * sp;
 int   * ip, iRet = 0, i;	
	if (m_pClientList[iToH] == NULL) return;
	ZeroMemory(cData, sizeof(cData));
	dwp  = (DWORD *)(cData + DEF_INDEX4_MSGID);
	*dwp = MSGID_NOTIFY;
	wp   = (WORD *)(cData + DEF_INDEX2_MSGTYPE);			   
	*wp  = wMsgType;
	cp = (char *)(cData	+ DEF_INDEX2_MSGTYPE + 2);
	switch (wMsgType) {

	case DEF_NOTIFY_AVATAR:
		ip  = (int *)cp;
		*ip = sV1;
		cp += 4;
		ip  = (int *)cp;
		*ip = sV2;
		cp += 4;
		ip  = (int *)cp;
		*ip = sV3;
		cp += 4;
		if (pString != NULL) memcpy(cp,pString,10);
		//else  memset( cp, '*', 10 );
		cp += 10;
		ip  = (int *)cp;
		*ip = sV4;		
		cp += 4;
		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 32);
		break;

	case DEF_NOTIFY_HELDENIANCOUNT:
		wp  = (WORD *)cp;
		*wp = (WORD)sV1;
		cp += 2;
		wp  = (WORD *)cp;
		*wp = (WORD)sV2;
		cp += 2;
		wp  = (WORD *)cp;
		*wp = (WORD)sV3;
		cp += 2;
		wp  = (WORD *)cp;
		*wp = (WORD)sV4;		
		cp += 2;
		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 14);
		break;
	
	case DEF_NOTIFY_NOMOREAGRICULTURE:
	case DEF_NOTIFY_AGRICULTURESKILLLIMIT:
	case DEF_NOTIFY_AGRICULTURENOAREA:
		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 6);
		break;

	case DEF_NOTIFY_SPAWNEVENT:	// New 18/05/2004
		*cp = (char)sV3;   // Mob's type
		cp++;
		wp  = (WORD *)cp; // Snoopy fixed bug, was short 
		*wp = (WORD)sV1;
		cp += 2;
		wp  = (WORD *)cp;
		*wp = (WORD)sV2;
		cp += 2;
		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 11);
		break;

	case DEF_NOTIFY_QUESTCOUNTER:
		ip  = (int *)cp;
		*ip = sV1;
		cp += 4;
		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 24);
		break;
	
	case DEF_NOTIFY_APOCGATECLOSE:
	case DEF_NOTIFY_APOCGATEOPEN:
		ip  = (int *)cp;
		*ip = sV1;
		cp += 4;
		ip  = (int *)cp;
		*ip = sV2;
		cp += 4;
		memcpy(cp,pString,10);
		cp += 10;
		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 24);
		break;

	case DEF_NOTIFY_ABADDONKILLED:
		memcpy(cp, m_pClientList[iFromH]->m_cCharName, 10);
		cp += 10;
		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 16);
		break;

	case DEF_NOTIFY_APOCFORCERECALLPLAYERS:
	case DEF_NOTIFY_APOCGATESTARTMSG:
	case DEF_NOTIFY_APOCGATEENDMSG:
	case DEF_NOTIFY_NORECALL:
		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 6);
		break;
	
	case DEF_NOTIFY_FORCERECALLTIME:
		wp  = (WORD *)cp;
		*wp = (WORD)sV1;
		cp += 2;
		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 8);
		break;

	case DEF_NOTIFY_MONSTERCOUNT:	//0xB4E2, 0xBEB
	case DEF_NOTIFY_SLATE_STATUS:
	case DEF_NOTIFY_HELDENIANVICTORY: //0x0BEB
		wp  = (WORD *)cp;
		*wp = (WORD)sV1;
		cp += 2;
		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 8);
		break;
	
	case DEF_NOTIFY_HELDENIANTELEPORT:	// 0x0BE6
	case DEF_NOTIFY_HELDENIANEND:		// 0x0BE7
	case DEF_NOTIFY_0BE8:				// 0x0BE8
	case DEF_NOTIFY_RESURRECTPLAYER:    
	case DEF_NOTIFY_SLATE_EXP:
	case DEF_NOTIFY_SLATE_MANA:
	case DEF_NOTIFY_SLATE_INVINCIBLE:
		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 6);
		break;

	case DEF_NOTIFY_SLATE_CREATEFAIL:
		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 6);
		break;

	case DEF_NOTIFY_SLATE_CREATESUCCESS:
		dwp  = (DWORD *)cp;
		*dwp = sV1;
		cp += 4;
		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 10);
		break;
	
	case DEF_NOTIFY_PARTY:// New 07/05/2004: Party Notify Msg's
		switch(sV1) {
		case 4:
		case 6:
			wp = (WORD *)cp;
			*wp = (WORD)sV1;
			cp += 2;
			wp = (WORD *)cp;
			*wp = (WORD)sV2;
			cp += 2;
			wp = (WORD *)cp;
			*wp = (WORD)sV3;
			cp += 2;
			memcpy(cp,pString,10);
			cp += 10;
			iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 22);
			break;
		case 5:
			wp = (WORD *)cp;
			*wp = (WORD)sV1;
			cp += 2;
			wp = (WORD *)cp;
			*wp = (WORD)sV2;
			cp += 2;
			wp = (WORD *)cp;
			*wp = (WORD)sV3;
			cp += 2;
			memcpy(cp, pString, sV3 * 11);
			cp += sV3 * 11;
			iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 12 + (sV3 * 11));
			break;
		default:
			wp = (WORD *)cp;
			*wp = (WORD)sV1;
			cp += 2;
			wp = (WORD *)cp;
			*wp = (WORD)sV2;
			cp += 2;
			wp = (WORD *)cp;
			*wp = (WORD)sV3;
			cp += 2;
			wp = (WORD *)cp;
			*wp = (WORD)sV4;
			cp += 2;
			iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 14);
				break;
		}
		break;

	case DEF_NOTIFY_REQGUILDNAMEANSWER:
		wp  = (WORD *)cp;
		*wp = (WORD)sV1;
		cp += 2;
		wp  = (WORD *)cp;
		*wp = (WORD)sV2;
		cp += 2;
		memcpy(cp, pString, 20);
		cp += 20;
		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 30);
		break;

	case DEF_NOTIFY_ITEMUPGRADEFAIL:	// Upgrade Notify Msg's
		sp  = (short *)cp;
		*sp = (short)sV1;
		cp += 2;
		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData,8);
		break;

	case DEF_NOTIFY_ITEMATTRIBUTECHANGE:
	case DEF_NOTIFY_GIZONITEMUPGRADELEFT:
		sp  = (short *)cp;
		*sp = sV1;
		cp += 2;
		dwp = (DWORD *)cp;
		*dwp = sV2;
		cp += 4;
		dwp = (DWORD *)cp;
		*dwp = sV3;
		cp += 4;
		dwp = (DWORD *)cp;
		*dwp = sV4;
		cp += 4;
		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData,20);
		break;

	case DEF_NOTIFY_GIZONITEMCHANGE:
		sp = (short *)cp;
		*sp = (short)sV1;
		cp += 2;
		*cp = (char)sV2;
		cp++;
		sp = (short *)cp;
		*sp = (short)sV3;
		cp += 2;
		sp = (short *)cp;
		*sp = (short)sV4;
		cp += 2;
		sp = (short *)cp;
		*sp = (short)sV5;
		cp += 2;
		*cp = (char)sV6;
		cp++;
		*cp = (char)sV7;
		cp++;
		dwp = (DWORD *)cp;
		*dwp = sV8;
		cp += 4;
		memcpy(cp,pString,20);
		cp += 20;
		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData,41);
		break;

	case DEF_NOTIFY_CHANGEPLAYMODE:// 2.06 - by KLKS
		memcpy(cp,pString,10);
		cp += 10;
		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData,16);
		break;

	case DEF_NOTIFY_TCLOC:
		wp  = (WORD *)cp;
		*wp = (WORD)sV1;
		cp += 2;
		wp  = (WORD *)cp;
		*wp = (WORD)sV2;
		cp += 2;		
		memcpy(cp, pString, 10);
		cp += 10;
		wp  = (WORD *)cp;
		*wp = (WORD)sV4;
		cp += 2;
		wp  = (WORD *)cp;
		*wp = (WORD)sV5;
		cp += 2;		
		memcpy(cp, pString2, 10);
		cp += 10;
		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 34);
		break;	
	
	case DEF_NOTIFY_GRANDMAGICRESULT://New 11/05/2004
		wp  = (WORD *)cp;
		*wp = (WORD)sV1;
		cp += 2;
		wp  = (WORD *)cp;
		*wp = (WORD)sV2;
		cp += 2;
		wp  = (WORD *)cp;
		*wp = (WORD)sV3;
		cp += 2;
		memcpy(cp, pString, 10);
		cp += 10;
		wp  = (WORD *)cp;
		*wp = (WORD)sV4;
		cp += 2;
		if (sV9 > 0) 
		{	memcpy(cp,pString2,(sV9*2)+2);
			cp += (sV9*2)+2;
		}else
		{	sp = (short *)cp;
			*sp = 0;
			cp += 2;
		}
		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, (sV9*2)+26);
		break;
	
	case DEF_NOTIFY_MAPSTATUSNEXT:
		memcpy(cp, pString, sV1);
		cp += sV1;
		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 6+sV1);
		break;

	case DEF_NOTIFY_MAPSTATUSLAST:
		memcpy(cp, pString, sV1);
		cp += sV1;
		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 6+sV1);
		break;
	
	case DEF_NOTIFY_LOCKEDMAP:
		sp = (short *)cp;
		*sp = (short)sV1;
		cp += 2;
		memcpy(cp, pString, 10);
		cp += 10;
		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 18);
		break;
	
	case DEF_NOTIFY_BUILDITEMSUCCESS:
	case DEF_NOTIFY_BUILDITEMFAIL:		
		if (sV1 >= 0) 
		{	sp = (short *)cp;
			*sp = (short)sV1;
			cp += 2;
		}else 
		{	sp = (short *)cp;
			*sp = (short)sV1 + 10000;
			cp += 2;
		}
		sp = (short *)cp;
		*sp = (short)sV2;
		cp += 2;
		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 10);
		break;
		
	case DEF_NOTIFY_HELP:
	case DEF_NOTIFY_QUESTREWARD:
		sp = (short *)cp;
		*sp = (short)sV1; // sWho
		cp += 2;
		sp = (short *)cp;
		*sp = (short)sV2; // sFlag
		cp += 2;
		ip = (int *)cp;
		*ip = (int)sV3;   // sAmount
		cp += 4;		
		memcpy(cp, pString, 20);
		cp += 20;
		ip = (int *)cp;   // item nbe
		*ip = (int)sV4;   // New contributio
		cp += 4;				
		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 38);
		break;
		
	case DEF_NOTIFY_CANNOTCONSTRUCT:
	case DEF_NOTIFY_METEORSTRIKECOMING:
	case DEF_NOTIFY_METEORSTRIKEHIT:
	case DEF_NOTIFY_HELPFAILED:
	case DEF_NOTIFY_SPECIALABILITYENABLED:
	case DEF_NOTIFY_FORCEDISCONN:
	case DEF_NOTIFY_OBSERVERMODE:
	case DEF_NOTIFY_QUESTCOMPLETED:
	case DEF_NOTIFY_QUESTABORTED:
		sp = (short *)cp;
		*sp = (short)sV1;
		cp += 2;
		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 8);
		break;
	
	case DEF_NOTIFY_QUESTCONTENTS:
		sp = (short *)cp;
		*sp = (short)sV1;
		cp += 2;		
		sp = (short *)cp;
		*sp = (short)sV2;
		cp += 2;
		sp = (short *)cp;
		*sp = (short)sV3;
		cp += 2;
		sp = (short *)cp;
		*sp = (short)sV4;
		cp += 2;
		sp = (short *)cp;
		*sp = (short)sV5;
		cp += 2;
		sp = (short *)cp;
		*sp = (short)sV6;
		cp += 2;
		sp = (short *)cp;
		*sp = (short)sV7;
		cp += 2;
		sp = (short *)cp;
		*sp = (short)sV8;
		cp += 2;
		sp = (short *)cp;
		*sp = (short)sV9;
		cp += 2;
		if (pString2 != NULL) memcpy(cp, pString2, 20);
		cp += 20;	
		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 44);
		break;
		
	case DEF_NOTIFY_ENERGYSPHERECREATED:
	case DEF_NOTIFY_ITEMCOLORCHANGE:
		sp = (short *)cp;
		*sp = (short)sV1;
		cp += 2;
		sp = (short *)cp;
		*sp = (short)sV2;
		cp += 2;
		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 10);
		break;	

	case DEF_NOTIFY_NOMORECRUSADESTRUCTURE:
	case DEF_NOTIFY_EXCHANGEITEMCOMPLETE:
	case DEF_NOTIFY_CANCELEXCHANGEITEM:
		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 6);
		break;
	
	case DEF_NOTIFY_SETEXCHANGEITEM:
		sp = (short *)cp;
		*sp = (short)sV1;
		cp += 2;
		sp = (short *)cp;
		*sp = (short)sV2;
		cp += 2;
		sp = (short *)cp;
		*sp = (short)sV3;
		cp += 2;
		ip = (int *)cp;
		*ip = (int)sV4;
		cp += 4;
		*cp = (char)sV5;
		cp++;
		sp = (short *)cp;
		*sp = (short)sV6;
		cp += 2;
		sp = (short *)cp;
		*sp = (short)sV7;
		cp += 2;
		sp = (short *)cp;
		*sp = (short)sV8;
		cp += 2;
		memcpy(cp, pString, 20);
		cp += 20;		
		memcpy(cp, m_pClientList[iFromH]->m_cCharName, 10);
		cp += 10;
		dwp  = (DWORD *)cp;
		*dwp = (DWORD)sV9;
		cp += 4;
		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 57);
		break;
	
	case DEF_NOTIFY_OPENEXCHANGEWINDOW:
		sp = (short *)cp;
		*sp = (short)sV1;
		cp += 2;
		sp = (short *)cp;
		*sp = (short)sV2;
		cp += 2;
		sp = (short *)cp;
		*sp = (short)sV3;
		cp += 2;
		ip = (int *)cp;
		*ip = (int)sV4;
		cp += 4;
		*cp = (char)sV5;
		cp++;
		sp = (short *)cp;
		*sp = (short)sV6;
		cp += 2;
		sp = (short *)cp;
		*sp = (short)sV7;
		cp += 2;
		sp = (short *)cp;
		*sp = (short)sV8;
		cp += 2;
		memcpy(cp, pString, 20);
		cp += 20;
		memcpy(cp, m_pClientList[iFromH]->m_cCharName, 10);
		cp += 10;
		dwp  = (DWORD *)cp;
		*dwp = (DWORD)sV9;
		cp += 4;		
		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 57);
		break;
	
	case DEF_NOTIFY_NOTFLAGSPOT:
		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 6);
		break;
	
	case DEF_NOTIFY_ITEMPOSLIST:
		for (i = 0; i < DEF_MAXITEMS; i++) 
		{	sp = (short *)cp;
			*sp = (short)m_pClientList[iToH]->m_ItemPosList[i].x;
			cp += 2;
			sp = (short *)cp;
			*sp = (short)m_pClientList[iToH]->m_ItemPosList[i].y;
			cp += 2;
		}
		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 6 + DEF_MAXITEMS*4);
		break;
	
	case DEF_NOTIFY_ENEMYKILLS:
		ip  = (int *)cp;
		*ip = (int)sV1;
		cp += 4;
		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 10);
		break;
	
	case DEF_NOTIFY_CRUSADE:
		ip = (int *)cp;
		*ip = (int)sV1;
		cp += 4;
		ip = (int *)cp;
		*ip = (int)sV2;
		cp += 4;
		ip = (int *)cp;
		*ip = (int)sV3;
		cp += 4;
		ip = (int *)cp;
		*ip = (int)sV4;
		cp += 4;
		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 22);
		break;

	case DEF_NOTIFY_CONSTRUCTIONPOINT:
	case DEF_NOTIFY_SPECIALABILITYSTATUS:
	case DEF_NOTIFY_DAMAGEMOVE:
		sp = (short *)cp;
		*sp = (short)sV1;
		cp += 2;
		sp = (short *)cp;
		*sp = (short)sV2;
		cp += 2;
		sp = (short *)cp;
		*sp = (short)sV3;
		cp += 2;
		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 12);
		break;

	case DEF_NOTIFY_DOWNSKILLINDEXSET:
	case DEF_NOTIFY_RESPONSE_CREATENEWPARTY:
		sp = (short *)cp;
		*sp = (short)sV1;
		cp += 2;
		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 8);
		break;
	
	case DEF_NOTIFY_ADMINIFO:
		switch (sV1) {
		case 1:	// NPC
			ip  = (int *)cp;
			//*ip	= m_pNpcList[sV2]->m_iHP;
			//cp += 4;			
			//ip  = (int *)cp;
			//*ip	= m_pNpcList[sV2]->m_iDefenseRatio;
			//cp += 4;
			//ip  = (int *)cp;
			*ip	= m_pNpcList[sV2]->m_bIsSummoned;
			cp += 4;
			ip  = (int *)cp;
			*ip	= m_pNpcList[sV2]->m_cActionLimit;
			cp += 4;
			ip  = (int *)cp;
			*ip	= m_pNpcList[sV2]->m_iHitDice;
			cp += 4;
			dwp  = (DWORD *)cp; // v1.4
			*dwp = m_pNpcList[sV2]->m_dwDeadTime;
			cp += 4;
			dwp  = (DWORD *)cp; 
			*dwp = m_pNpcList[sV2]->m_dwRegenTime;
			cp += 4;
			ip  = (int *)cp; 
			*ip	= (int)m_pNpcList[sV2]->m_bIsKilled;
			cp += 4;
			iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 26 + 12);
			break;
		}
		break;

	case DEF_NOTIFY_HELDENIANSTART:
	case DEF_NOTIFY_NPCTALK:
		sp = (short *)cp;
		*sp = (short)sV1;
		cp += 2;		
		sp = (short *)cp;
		*sp = (short)sV2;
		cp += 2;
		sp = (short *)cp;
		*sp = (short)sV3;
		cp += 2;
		sp = (short *)cp;
		*sp = (short)sV4;
		cp += 2;
		sp = (short *)cp;
		*sp = (short)sV5;
		cp += 2;		
		sp = (short *)cp;
		*sp = (short)sV6;
		cp += 2;		
		sp = (short *)cp;
		*sp = (short)sV7;
		cp += 2;		
		sp = (short *)cp;
		*sp = (short)sV8;
		cp += 2;		
		sp = (short *)cp;
		*sp = (short)sV9;
		cp += 2;
		if (pString != NULL) memcpy(cp, pString, 20);
		cp += 20;
		if (pString2 != NULL) memcpy(cp, pString2, 20);
		cp += 20;
		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 64);
		break;

	// Crafting
	case DEF_NOTIFY_CRAFTING_FAIL:		//reversed by Snoopy: 0x0BF1:
		ip  = (int *)cp;
		*ip = (int)sV1;
		cp += 4;
		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 10);
		break;

	case DEF_NOTIFY_CRAFTING_SUCCESS:		//reversed by Snoopy: 0x0BF0

	case DEF_NOTIFY_PORTIONSUCCESS:
	case DEF_NOTIFY_LOWPORTIONSKILL:
	case DEF_NOTIFY_PORTIONFAIL:
	case DEF_NOTIFY_NOMATCHINGPORTION:
		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 6);
		break;
	
	case DEF_NOTIFY_SUPERATTACKLEFT:
		sp = (short *)cp;
		*sp = m_pClientList[iToH]->m_iSuperAttackLeft;
		cp += 2;
		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 8);
		break;
	
	case DEF_NOTIFY_SAFEATTACKMODE:
		*cp = m_pClientList[iToH]->m_bIsSafeAttackMode;
		cp++;
		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 7);
		break;
	
	case DEF_NOTIFY_QUERY_JOINPARTY:
	case DEF_NOTIFY_IPACCOUNTINFO:
		strcpy(cp, pString);
		cp += strlen(pString);
		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 6 + strlen(pString) + 1);
		break;
	
	case DEF_NOTIFY_REWARDGOLD:
		dwp = (DWORD *)cp;
		*dwp = m_pClientList[iToH]->m_iRewardGold;
		cp += 4;
		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 10);
		break;
	
	case DEF_NOTIFY_SERVERSHUTDOWN:
		*cp = (char)sV1;
		cp++;
		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 7);
		break;

	case DEF_NOTIFY_GLOBALATTACKMODE:
	case DEF_NOTIFY_WHETHERCHANGE:
		*cp = (char)sV1;
		cp++;
		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 7);
		break;
		
	case DEF_NOTIFY_FISHCANCELED:
	case DEF_NOTIFY_FISHSUCCESS:
	case DEF_NOTIFY_FISHFAIL:
		wp  = (WORD *)cp;
		*wp = (WORD)sV1;
		cp += 2;
		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 8);
		break;

	case DEF_NOTIFY_DEBUGMSG:
		wp  = (WORD *)cp;
		*wp = (WORD)sV1;
		cp += 2;
		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 8);
		break;

	case DEF_NOTIFY_FISHCHANCE:
		wp  = (WORD *)cp;
		*wp = (WORD)sV1;
		cp += 2;				
		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 8);
		break;

	case DEF_NOTIFY_ENERGYSPHEREGOALIN:
	case DEF_NOTIFY_EVENTFISHMODE:
		wp  = (WORD *)cp;
		*wp = (WORD)sV1;
		cp += 2;
		wp  = (WORD *)cp;
		*wp = (WORD)sV2;
		cp += 2;
		wp  = (WORD *)cp;
		*wp = (WORD)sV3;
		cp += 2;
		memcpy(cp, pString, 20);
		cp += 20;
		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 32);
		break;

	case DEF_NOTIFY_NOTICEMSG:
		memcpy(cp, pString, strlen(pString));
		cp += strlen(pString);
		*cp = NULL;
		cp++;
		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, strlen(pString) + 7);
		break;

	case DEF_NOTIFY_CANNOTRATING:
		wp  = (WORD *)cp;
		*wp = (WORD)sV1;
		cp += 2;
		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 8);
		break;

	case DEF_NOTIFY_RATINGPLAYER:
		*cp = (char)sV1;
		cp++;
		memcpy(cp, pString, 10);
		cp += 10;
		ip = (int *)cp;
		*ip = m_pClientList[iToH]->m_iRating;
		cp += 4;
		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 22);
		break;

	case DEF_NOTIFY_ADMINUSERLEVELLOW:
		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 6);
		break;

	case DEF_NOTIFY_PLAYERSHUTUP:
		wp  = (WORD *)cp;
		*wp = (WORD)sV1;
		cp += 2;
		memcpy(cp, pString, 10);
		cp += 10;
		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 19);
		break;
	
	case DEF_NOTIFY_TIMECHANGE:
		*cp = (char)sV1;
		cp++;
		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 7);
		break;

	case DEF_NOTIFY_TOBERECALLED:
		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 6);
		break;

	case DEF_NOTIFY_HUNGER:
		*cp = (char)sV1;
		cp++;

		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 7);
		break;

	case DEF_NOTIFY_PLAYERPROFILE:
		if (strlen(pString) > 100) 
		{	memcpy(cp, pString, 100);
			cp += 100;
		}else 
		{	memcpy(cp, pString, strlen(pString));
			cp += strlen(pString);
		}
		*cp = NULL;
		cp++;
		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 7 + strlen(pString));
		break;

	case DEF_NOTIFY_WHISPERMODEON:	// New 10/05/2004 Changed
	case DEF_NOTIFY_WHISPERMODEOFF:
	case DEF_NOTIFY_PLAYERNOTONGAME:
		memcpy(cp, pString, 10);
		cp += 10;
		memcpy(cp, "          ", 10);
		cp += 10;
		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 27);
		break;

	case DEF_NOTIFY_PLAYERONGAME:	// New 15/05/2004 Changed
		memcpy(cp, pString, 10);
		cp += 10;
		if (pString[0] != 0) 
		{	memcpy(cp, pString2, 14);
			cp += 14;
		}
		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 31);
		break;
		
	case DEF_NOTIFY_ITEMSOLD:// New 06/05/2004
	case DEF_NOTIFY_ITEMREPAIRED:
		dwp = (DWORD *)cp;
		*dwp = (DWORD)sV1;
		cp += 4;
		dwp = (DWORD *)cp;
		*dwp = (DWORD)sV2;
		cp += 4;
		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 14);
		break;
	
	case DEF_NOTIFY_REPAIRITEMPRICE:// New 06/05/2004
	case DEF_NOTIFY_SELLITEMPRICE:
		dwp = (DWORD *)cp;
		*dwp = (DWORD)sV1;
		cp += 4;
		dwp = (DWORD *)cp;
		*dwp = (DWORD)sV2;
		cp += 4;
		dwp = (DWORD *)cp;
		*dwp = (DWORD)sV3;
		cp += 4;
		dwp = (DWORD *)cp;
		*dwp = (DWORD)sV4;
		cp += 4;
		memcpy(cp, pString, 20);
		cp += 20;		
		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 42);
		break;

	case DEF_NOTIFY_CANNOTREPAIRITEM:
	case DEF_NOTIFY_CANNOTSELLITEM:
		wp = (WORD *)cp;
		*wp = (WORD)sV1;
		cp += 2;
		wp = (WORD *)cp;
		*wp = (WORD)sV2;
		cp += 2;
		memcpy(cp, pString, 20);
		cp += 20;		
		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 30);
		break;
	
	case DEF_NOTIFY_SHOWMAP:
		wp  = (WORD *)cp;
		*wp = (WORD)sV1;
		cp += 2;		
		wp  = (WORD *)cp;  //  (0 aresden, 1 elvine, 3 middleland...)
		*wp = (WORD)sV2;
		cp += 2;	
		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 10);
		break;
	
	case DEF_NOTIFY_SKILLUSINGEND:
		wp  = (WORD *)cp; 
		*wp = (WORD)sV1;
		cp += 2;
		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 8);
		break;
	
	case DEF_NOTIFY_TOTALUSERS:
		wp  = (WORD *)cp;    
		*wp = (WORD)m_iTotalGameServerClients; //_iGetTotalClients();
		cp += 2;
		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 8);
		break;
	
	case DEF_NOTIFY_MAGICEFFECTOFF:
	case DEF_NOTIFY_MAGICEFFECTON:
		wp  = (WORD *)cp; 
		*wp = (WORD)sV1;
		cp += 2;		
		dwp  = (DWORD *)cp;
		*dwp = (DWORD)sV2;
		cp += 4;
		dwp  = (DWORD *)cp; 
		*dwp = (DWORD)sV3;
		cp += 4;		
		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 16);
		break;
	
	case DEF_NOTIFY_CANNOTITEMTOBANK:
		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 6);
		break;
	
/*	case DEF_NOTIFY_SERVERCHANGE:
		memcpy(cp, m_pClientList[iToH]->m_cMapName, 10);
		cp += 10;	
		// World Server
		memcpy(cp, m_cLogServerAddr, 15);
		cp += 15;
		ip = (int *)cp;
		*ip = m_iLogServerPort;
		cp += 4;
		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 16 +19);
		break;*/

	case DEF_NOTIFY_SERVERCHANGE:
		memcpy(cp, m_pClientList[iToH]->m_cMapName, 10);
		cp += 10;	
		// World Server connection across hgservers, behind router problem
		// ArchAngel fix
		if (m_iGameServerMode == 1) // Mode = 1 is LAN or ROUTER (behind router)
            if (memcmp(m_cLogServerAddr, m_cGameServerAddr, 15) == 0)
				memcpy(cp, m_cGameServerAddrExternal, 15);
			else
				memcpy(cp, m_cLogServerAddr, 15);
		else // mode = 2 INTERNET
			memcpy(cp, m_cLogServerAddr, 15);
		cp += 15;
		ip = (int *)cp;
		*ip = m_iLogServerPort;
		cp += 4;
		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 16 +19);
		break;
	case DEF_NOTIFY_SKILL:
		wp  = (WORD *)cp;
		*wp = (WORD)sV1;
		cp += 2;		
		wp  = (WORD *)cp;
		*wp = (WORD)sV2;
		cp += 2;
		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 10);
		break;

	case DEF_NOTIFY_SETITEMCOUNT:
		wp  = (WORD *)cp; 
		*wp = (WORD)sV1;
		cp += 2;		
		dwp  = (DWORD *)cp;
		*dwp = (DWORD)sV2;
		cp += 4;				
		*cp = (char)sV3;
		cp++;		
		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 13);
		break;

	case DEF_NOTIFY_ITEMDEPLETED_ERASEITEM:
		wp  = (WORD *)cp;
		*wp = (WORD)sV1;
		cp += 2;		
		wp = (WORD *)cp;
		*wp = (WORD)sV2;
		cp += 2;		
		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 10);
		break;

	case DEF_NOTIFY_DROPITEMFIN_COUNTCHANGED:
		wp  = (WORD *)cp;
		*wp = (WORD)sV1;
		cp += 2;
		ip  = (int *)cp;
		*ip = (int)sV2;
		cp += 4;		
		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 12);
		break;

	case DEF_NOTIFY_DROPITEMFIN_ERASEITEM:
		wp  = (WORD *)cp;
		*wp = (WORD)sV1;
		cp += 2;
		ip  = (int *)cp;
		*ip = (int)sV2;
		cp += 4;		
		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 12);
		break;
		
	case DEF_NOTIFY_CANNOTGIVEITEM:
	case DEF_NOTIFY_GIVEITEMFIN_COUNTCHANGED:
		wp  = (WORD *)cp;
		*wp = (WORD)sV1;
		cp += 2;
		ip  = (int *)cp;
		*ip = (int)sV2;
		cp += 4;		
		memcpy(cp, pString, 20);
		cp += 20;		
		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 32);
		break;

	case DEF_NOTIFY_GIVEITEMFIN_ERASEITEM:
		wp  = (WORD *)cp;
		*wp = (WORD)sV1;
		cp += 2;
		ip  = (int *)cp;
		*ip = (int)sV2;
		cp += 4;		
		memcpy(cp, pString, 20);
		cp += 20;
		
		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 32);
		break;

	case DEF_NOTIFY_ENEMYKILLREWARD:
		dwp  = (DWORD *)cp;
		*dwp = (DWORD)m_pClientList[iToH]->m_iExp;
		cp += 4;
		dwp  = (DWORD *)cp;
		*dwp = (DWORD)m_pClientList[iToH]->m_iEnemyKillCount;
		cp += 4;
		memcpy(cp, m_pClientList[sV1]->m_cCharName, 10);
		cp += 10;
		memcpy(cp, m_pClientList[sV1]->m_cGuildName, 20);
		cp += 20;
		sp  = (short *)cp;
		*sp = (short)m_pClientList[sV1]->m_iGuildRank;
		cp += 2;
		sp  = (short *)cp;
		*sp = (short)m_pClientList[iToH]->m_iWarContribution;
		cp += 2;		
		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 48);
		break;

	case DEF_NOTIFY_PKCAPTURED:
		// PKcount
		wp  = (WORD *)cp;
		*wp = (WORD)sV1;
		cp += 2;
		wp  = (WORD *)cp;
		*wp = (WORD)sV2;
		cp += 2;
		memcpy(cp, pString, 10);
		cp += 10;
		dwp  = (DWORD *)cp;
		*dwp = (DWORD)m_pClientList[iToH]->m_iRewardGold;
		cp += 4;
		dwp  = (DWORD *)cp;
		*dwp = m_pClientList[iToH]->m_iExp;
		cp += 4;		
		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 28);
		break;

	case DEF_NOTIFY_PKPENALTY:
		// PK 
		dwp  = (DWORD *)cp;
		*dwp = (DWORD)m_pClientList[iToH]->m_iExp;
		cp += 4;
		dwp  = (DWORD *)cp;
		*dwp = (DWORD)m_pClientList[iToH]->m_iStr;
		cp += 4;
		dwp  = (DWORD *)cp;
		*dwp = (DWORD)m_pClientList[iToH]->m_iVit;
		cp += 4;
		dwp  = (DWORD *)cp;
		*dwp = (DWORD)m_pClientList[iToH]->m_iDex;
		cp += 4;
		dwp  = (DWORD *)cp;
		*dwp = (DWORD)m_pClientList[iToH]->m_iInt;
		cp += 4;
		dwp  = (DWORD *)cp;
		*dwp = (DWORD)m_pClientList[iToH]->m_iMag;
		cp += 4;
		dwp  = (DWORD *)cp;
		*dwp = (DWORD)m_pClientList[iToH]->m_iCharisma;
		cp += 4;
		dwp  = (DWORD *)cp;
		*dwp = (DWORD)m_pClientList[iToH]->m_iPKCount;
		cp += 4;

		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 38);
		break;
	
	case DEF_NOTIFY_TRAVELERLIMITEDLEVEL:
	case DEF_NOTIFY_LIMITEDLEVEL:
		dwp  = (DWORD *)cp;
		*dwp = (DWORD)m_pClientList[iToH]->m_iExp;
		cp += 4;
		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 10);
		break;
	
	case DEF_NOTIFY_ITEMRELEASED:
	case DEF_NOTIFY_ITEMLIFESPANEND:
		sp  = (short *)cp;
		*sp = (short)sV1;
		cp += 2;
		sp = (short *)cp;
		*sp = (short)sV2;
		cp += 2;
		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 10);
		break;
	
	case DEF_NOTIFY_KILLED:
		if (pString == NULL) memset(cp, 0x00, 20);
		else memcpy(cp, pString, 20);
		cp += 20;
		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 26);
		break;
	
	case DEF_NOTIFY_EXP:
		dwp  = (DWORD *)cp;
		*dwp = (DWORD)m_pClientList[iToH]->m_iExp;
		cp += 4;
		ip = (int *)cp;
		*ip = m_pClientList[iToH]->m_iRating;
		cp += 4;
		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 14);
		break;

	case DEF_NOTIFY_HP:
		dwp  = (DWORD *)cp;
		*dwp = (DWORD)m_pClientList[iToH]->m_iHP;
		cp += 4;
		dwp  = (DWORD *)cp;
		*dwp = (DWORD)m_pClientList[iToH]->m_iMP; 
		cp += 4;
		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 14);
		break;

	case DEF_NOTIFY_MP:
		dwp  = (DWORD *)cp;
		*dwp = (DWORD)m_pClientList[iToH]->m_iMP;
		cp += 4;
		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 10);
		break;

	case DEF_NOTIFY_SP:
		dwp  = (DWORD *)cp;
		*dwp = (DWORD)m_pClientList[iToH]->m_iSP;
		cp += 4;
		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 10);
		break;

	case DEF_NOTIFY_CHARISMA:
		dwp  = (DWORD *)cp;
		*dwp = (DWORD)m_pClientList[iToH]->m_iCharisma;
		cp += 4;
		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 10);
		break;

		//MOG Fixes
	case DEF_NOTIFY_STATECHANGE_FAILED:		// 2003-04-14 .korean buttplugs
	case DEF_NOTIFY_SETTING_FAILED:
		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 6);
		break;

	case DEF_NOTIFY_STATECHANGE_SUCCESS:	// 2003-04-14 . wtf korean junk
		{	int i;
			for (i = 0; i < DEF_MAXMAGICTYPE; i++) 
			{	*cp = m_pClientList[iToH]->m_cMagicMastery[i];
				cp++;
			}
			for (i = 0; i < DEF_MAXSKILLTYPE; i++) 
			{	*cp = m_pClientList[iToH]->m_cSkillMastery[i];
				cp++;
			}
			iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 6 + DEF_MAXMAGICTYPE + DEF_MAXSKILLTYPE);
		}
		break;

	case DEF_NOTIFY_SETTING_SUCCESS: //unused in v3.51
	case DEF_NOTIFY_LEVELUP:
		ip  = (int *)cp;
		*ip = m_pClientList[iToH]->m_iLevel;
		cp += 4;
		ip   = (int *)cp;
		*ip  = m_pClientList[iToH]->m_iStr;		
		cp  += 4;
		ip   = (int *)cp;
		*ip  = m_pClientList[iToH]->m_iVit;								
		cp  += 4;
		ip   = (int *)cp;
		*ip  = m_pClientList[iToH]->m_iDex;			
		cp  += 4;
		ip   = (int *)cp;
		*ip  = m_pClientList[iToH]->m_iInt;					
		cp  += 4;
		ip   = (int *)cp;
		*ip  = m_pClientList[iToH]->m_iMag;						
		cp  += 4;
		ip   = (int *)cp;
		*ip  = m_pClientList[iToH]->m_iCharisma;
		cp  += 4;
		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 34);
		break;

	//case DEF_NOTIFY_LEVELUP: removed
	case DEF_NOTIFY_QUERY_DISMISSGUILDREQPERMISSION:
	case DEF_NOTIFY_QUERY_JOINGUILDREQPERMISSION:
	case DEF_NOTIFY_CANNOTJOINMOREGUILDSMAN:		
		memcpy(cp, m_pClientList[iFromH]->m_cCharName, 10);
		cp += 10;
		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 16);
		break;

	case DEF_COMMONTYPE_JOINGUILDAPPROVE:
		if (m_pClientList[iFromH] != NULL)
			 memcpy(cp, m_pClientList[iFromH]->m_cGuildName, 20);
		else memcpy(cp, "?", 1);
		cp += 20;
		sp  = (short *)cp;
		*sp = DEF_GUILDSTARTRANK;
		cp += 2;		
		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 28);
		break;

	case DEF_COMMONTYPE_JOINGUILDREJECT:			
    case DEF_COMMONTYPE_DISMISSGUILDAPPROVE:		
    case DEF_COMMONTYPE_DISMISSGUILDREJECT:
		if (m_pClientList[iFromH] != NULL)
			 memcpy(cp, m_pClientList[iFromH]->m_cGuildName, 20);
		else memcpy(cp, "?", 1);
		cp += 20;
		sp  = (short *)cp;
		*sp = DEF_GUILDSTARTRANK;
		cp += 2;
		memcpy(cp, m_pClientList[iToH]->m_cLocation, 10);
		cp += 10;
		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 38);
		break;

	case DEF_NOTIFY_GUILDDISBANDED:		
		memcpy(cp, pString, 20);
		cp += 20;
		memcpy(cp, m_pClientList[iToH]->m_cLocation, 10);
		cp += 10;	  
		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 36);
		break;

	case DEF_NOTIFY_FIGHTZONERESERVE:
		ip = (int *)cp;
		*ip = (int )sV1;
		cp += 4;
		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 10);
		break; 

	case DEF_NOTIFY_NOGUILDMASTERLEVEL:
		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 6);
		break;

	case DEF_NOTIFY_CANNOTBANGUILDMAN:
		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 6);
		break;
	}

	switch (iRet) {
	case DEF_XSOCKEVENT_QUENEFULL:
	case DEF_XSOCKEVENT_SOCKETERROR:
	case DEF_XSOCKEVENT_CRITICALERROR:
	case DEF_XSOCKEVENT_SOCKETCLOSED:
		//DeleteClient(iToH, TRUE, TRUE);
		return;
	}
}

void CGame::JoinGuildApproveHandler(int iClientH, char * pName)
{register int i;
 BOOL bIsExist = FALSE;
	if (m_pClientList[iClientH] == NULL) return;
	if (m_pClientList[iClientH]->m_bIsInitComplete == FALSE) return;
		for (i = 1; i < DEF_MAXCLIENTS; i++) 
	if ((m_pClientList[i] != NULL) && (memcmp(m_pClientList[i]->m_cCharName, pName, 10) == 0)) {
		if (memcmp(m_pClientList[i]->m_cLocation, m_pClientList[iClientH]->m_cLocation, 10) != 0) return;
		ZeroMemory(m_pClientList[i]->m_cGuildName, sizeof(m_pClientList[i]->m_cGuildName));
		strcpy(m_pClientList[i]->m_cGuildName, m_pClientList[iClientH]->m_cGuildName);
		m_pClientList[i]->m_iGuildGUID = m_pClientList[iClientH]->m_iGuildGUID;
		ZeroMemory(m_pClientList[i]->m_cLocation, sizeof(m_pClientList[i]->m_cLocation));
		strcpy(m_pClientList[i]->m_cLocation, m_pClientList[iClientH]->m_cLocation);
		m_pClientList[i]->m_iGuildRank = DEF_GUILDSTARTRANK; 		
		SendNotifyMsg(iClientH, i, DEF_COMMONTYPE_JOINGUILDAPPROVE, NULL, NULL, NULL, NULL);
		SendEventToNearClient_TypeA(iClientH, DEF_OWNERTYPE_PLAYER, MSGID_EVENT_MOTION, DEF_OBJECTNULLACTION, NULL, NULL, NULL);
		SendGuildMsg(i, DEF_NOTIFY_NEWGUILDSMAN, NULL, NULL, NULL);
		bSendMsgToLS(MSGID_REQUEST_UPDATE_NEWGUILDSMAN, i);
		return;
	}
}

void CGame::JoinGuildRejectHandler(int iClientH, char * pName)
{register int i;
	if (m_pClientList[iClientH] == NULL) return;
	if (m_pClientList[iClientH]->m_bIsInitComplete == FALSE) return;
	for (i = 1; i < DEF_MAXCLIENTS; i++) 
	if ((m_pClientList[i] != NULL) && (memcmp(m_pClientList[i]->m_cCharName, pName, 10) == 0)) {
		SendNotifyMsg(iClientH, i, DEF_COMMONTYPE_JOINGUILDREJECT, NULL, NULL, NULL, NULL);
		return;
	}
}

void CGame::DismissGuildApproveHandler(int iClientH, char * pName)
{register int i;
	if (m_pClientList[iClientH] == NULL) return;
	if (m_pClientList[iClientH]->m_bIsInitComplete == FALSE) return;
	for (i = 1; i < DEF_MAXCLIENTS; i++) 
	if ((m_pClientList[i] != NULL) && (memcmp(m_pClientList[i]->m_cCharName, pName, 10) == 0)) {
		bSendMsgToLS(MSGID_REQUEST_UPDATE_DELGUILDSMAN, i);
		SendGuildMsg(i, DEF_NOTIFY_DISMISSGUILDSMAN, NULL, NULL, NULL);
		ZeroMemory(m_pClientList[i]->m_cGuildName, sizeof(m_pClientList[i]->m_cGuildName));
		strcpy(m_pClientList[i]->m_cGuildName, "NONE");
		m_pClientList[i]->m_iGuildRank = -1; 
		m_pClientList[i]->m_iGuildGUID = -1;
		SendNotifyMsg(iClientH, i, DEF_COMMONTYPE_DISMISSGUILDAPPROVE, NULL, NULL, NULL, NULL);
		SendEventToNearClient_TypeA(iClientH, DEF_OWNERTYPE_PLAYER, MSGID_EVENT_MOTION, DEF_OBJECTNULLACTION, NULL, NULL, NULL);
		return;
	}
}

void CGame::DismissGuildRejectHandler(int iClientH, char * pName)
{ register int i;
	if (m_pClientList[iClientH] == NULL) return;
	if (m_pClientList[iClientH]->m_bIsInitComplete == FALSE) return;
	for (i = 1; i < DEF_MAXCLIENTS; i++) 
	if ((m_pClientList[i] != NULL) && (memcmp(m_pClientList[i]->m_cCharName, pName, 10) == 0)) {
		SendNotifyMsg(iClientH, i, DEF_COMMONTYPE_DISMISSGUILDREJECT, NULL, NULL, NULL, NULL);
		return;
	}
}

DWORD CGame::dwGetItemCount(int iClientH, char * pName)
{ register int i;
 char cTmpName[21];
	if (m_pClientList[iClientH] == NULL) return NULL;	
	ZeroMemory(cTmpName, sizeof(cTmpName));
	strcpy(cTmpName, pName);
	for (i = 0; i < DEF_MAXITEMS; i++)
	if ((m_pClientList[iClientH]->m_pItemList[i] != NULL) && (memcmp(m_pClientList[iClientH]->m_pItemList[i]->m_cName, cTmpName, 20) == 0)) {
		return m_pClientList[iClientH]->m_pItemList[i]->m_dwCount;
	}
	return 0;
}

int CGame::SetItemCount(int iClientH, char * pItemName, DWORD dwCount)
{register int i;
 char cTmpName[21];
 WORD wWeight;	
	if (m_pClientList[iClientH] == NULL) return -1;
	ZeroMemory(cTmpName, sizeof(cTmpName));
	strcpy(cTmpName, pItemName);
	for (i = 0; i < DEF_MAXITEMS; i++)
	if ((m_pClientList[iClientH]->m_pItemList[i] != NULL) && (memcmp(m_pClientList[iClientH]->m_pItemList[i]->m_cName, cTmpName, 20) == 0)) 
	{	wWeight = iGetItemWeight(m_pClientList[iClientH]->m_pItemList[i], 1);// m_pClientList[iClientH]->m_pItemList[i]->m_wWeight;
		if (dwCount == 0) 
		{	ItemDepleteHandler(iClientH, i, FALSE);
		}else 
		{	m_pClientList[iClientH]->m_pItemList[i]->m_dwCount = dwCount;
			SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_SETITEMCOUNT, i, dwCount, (char)TRUE, NULL);
		}		
		return wWeight;
	}
	return -1;
}

int CGame::SetItemCount(int iClientH, int iItemIndex, DWORD dwCount)
{ WORD wWeight;	
	if (m_pClientList[iClientH] == NULL) return -1;
	if (m_pClientList[iClientH]->m_pItemList[iItemIndex] == NULL) return -1;	
	wWeight = iGetItemWeight(m_pClientList[iClientH]->m_pItemList[iItemIndex], 1);
	if (dwCount == 0) 
	{	ItemDepleteHandler(iClientH, iItemIndex, FALSE);
	}else 
	{	m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwCount = dwCount;
		SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_SETITEMCOUNT, iItemIndex, dwCount, (char)TRUE, NULL);
	}		
	return wWeight;	
}

void CGame::ClientKilledHandler(int iClientH, int iAttackerH, char cAttackerType, short sDamage)
{	char  * cp, cAttackerName[21], cData[120];
	char  cKillerMsg[128];	
	short sAttackerWeapon;
	int   * ip, i, iExH;
	int iCapeIndex;
	BOOL  bIsSAattacked = FALSE;
	if (m_pClientList[iClientH] == NULL) return;
	if (m_pClientList[iClientH]->m_bIsInitComplete == FALSE) return;
	m_pClientList[iClientH]->m_iHP = 0;
 	if (m_pClientList[iClientH]->m_bIsKilled == TRUE) return;
	m_pClientList[iClientH]->m_bIsKilled = TRUE;
	if (memcmp(m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cName, "fight", 5) == 0) 
	{	m_pClientList[iClientH]->m_dwFightzoneDeadTime = timeGetTime();
		wsprintf(G_cTxt, "Fightzone Dead Time: %d", m_pClientList[iClientH]->m_dwFightzoneDeadTime);
		PutLogEventFileList(G_cTxt);
		PutLogList(G_cTxt);
	}

// Remove Polymorph	
	if (m_pClientList[iClientH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_POLYMORPH ] != 0)
	{	m_pClientList[iClientH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_POLYMORPH ] = 0;
		m_pClientList[iClientH]->m_sType = m_pClientList[iClientH]->m_sOriginalType;
		// Unequip armors if sex no longer allows it
		for ( i = 0; i < DEF_MAXITEMS; i++) 
		{	if (   (m_pClientList[iClientH]->m_pItemList[i] != NULL)										
				&& (m_pClientList[iClientH]->m_bIsItemEquipped[i]) )	
			{	if (bEquipItemHandler(iClientH, i, TRUE) == FALSE)  
				{	CalcTotalItemEffect(iClientH, i, false);// if an item was removed compute Total item effect
	}	}	}	}	

// Snoopy: Remove all magic effects and flags
	for (i = 0; i < DEF_MAXMAGICEFFECTS; i++) 
		m_pClientList[iClientH]->m_cMagicEffectStatus[i]	= 0;

	SetDefenseShieldFlag(iClientH, DEF_OWNERTYPE_PLAYER, FALSE);
	SetMagicProtectionFlag(iClientH, DEF_OWNERTYPE_PLAYER, FALSE);
	SetProtectionFromArrowFlag(iClientH, DEF_OWNERTYPE_PLAYER, FALSE);
	SetIllusionMovementFlag(iClientH, DEF_OWNERTYPE_PLAYER, FALSE);
	SetIllusionFlag(iClientH, DEF_OWNERTYPE_PLAYER, FALSE);
	SetInhibitionCastingFlag(iClientH, DEF_OWNERTYPE_PLAYER, FALSE);
	SetPoisonFlag(iClientH, DEF_OWNERTYPE_PLAYER, FALSE);
	SetIceFlag(iClientH, DEF_OWNERTYPE_PLAYER, FALSE);
	SetBerserkFlag(iClientH, DEF_OWNERTYPE_PLAYER, FALSE);
	SetInvisibilityFlag(iClientH, DEF_OWNERTYPE_PLAYER, FALSE);
	SetConfusionFlag(iClientH, DEF_OWNERTYPE_PLAYER, FALSE);
	SetMetamorphosisFlag(iClientH, DEF_OWNERTYPE_PLAYER, FALSE);
	SetReflexionFlag(iClientH, DEF_OWNERTYPE_PLAYER, FALSE);
	SetSlateFlag(iClientH, DEF_NOTIFY_SLATECLEAR, FALSE);

	if (m_pClientList[iClientH]->m_bIsExchangeMode == TRUE) 
	{	iExH = m_pClientList[iClientH]->m_iExchangeH;
		_ClearExchangeStatus(iExH); 
		_ClearExchangeStatus(iClientH);
	}
	RemoveFromTarget(iClientH, DEF_OWNERTYPE_PLAYER, NULL, iAttackerH, cAttackerType);
	
	ZeroMemory(cAttackerName, sizeof(cAttackerName));
	ZeroMemory(cKillerMsg, sizeof(cKillerMsg));		
	switch (cAttackerType) {
	case DEF_OWNERTYPE_PLAYER_INDIRECT: // 3
		if (m_pClientList[iAttackerH] != NULL)
		{	memcpy(cAttackerName, m_pClientList[iAttackerH]->m_cCharName, 10);	
			if ((m_bIsCrusadeMode == FALSE) && (m_cKillerIndicator >  0))
			{	wsprintf(cKillerMsg, "A spell from %s finished you!", m_pClientList[iAttackerH]->m_cCharName);
				ShowClientMsg(iClientH,  "Killed",cKillerMsg);
			}else if ((m_bIsCrusadeMode == TRUE)  && (m_cKillerIndicator == 2))
			{	wsprintf(cKillerMsg, "A spell from (%d) finished you!", iAttackerH);
				ShowClientMsg(iClientH,  "Killed",cKillerMsg);
		}	}
		break;
	case DEF_OWNERTYPE_PLAYER:
		if (m_pClientList[iAttackerH] != NULL)
		{	memcpy(cAttackerName, m_pClientList[iAttackerH]->m_cCharName, 10);		
			if ((m_bIsCrusadeMode == FALSE) && (m_cKillerIndicator >  0))	
			{	wsprintf(cKillerMsg, "You have been annihilated by %s.", m_pClientList[iAttackerH]->m_cCharName);
				ShowClientMsg(iClientH,  "Killed",cKillerMsg);
			}else if ((m_bIsCrusadeMode == TRUE)  && (m_cKillerIndicator == 2))	
			{	wsprintf(cKillerMsg, "You have been annihilated by (%d).", iAttackerH);
				ShowClientMsg(iClientH,  "Killed",cKillerMsg);
		}	}	
		break;
	case DEF_OWNERTYPE_NPC:
		if (m_pNpcList[iAttackerH] != NULL)
		{	//memcpy(cAttackerName, m_pNpcList[iAttackerH]->m_cNpcName, 20);	
			ZeroMemory(cAttackerName, sizeof(cAttackerName)); // mob => no npc name
			if (   ((m_bIsCrusadeMode == FALSE) && (m_cKillerIndicator >  0))
				|| ((m_bIsCrusadeMode == TRUE)  && (m_cKillerIndicator == 2)))
			{	wsprintf(cKillerMsg, "You have been slaughtered by %s.", m_pNpcList[iAttackerH]->m_cNpcName);
				ShowClientMsg(iClientH,  "Killed",cKillerMsg);
		}	}	
		break ;
	default:
		break;
	}
	// Client use of cAttackerName has been removed in 3.51
	// I use only in case of a player (client will detect a name and laugth about your death)
	SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_KILLED, NULL, NULL, NULL, cAttackerName); 
	if ((cAttackerType == DEF_OWNERTYPE_PLAYER) && (m_pClientList[iAttackerH] != NULL))	
		sAttackerWeapon = ((m_pClientList[iAttackerH]->m_sAppr2 & 0x0FF0) >> 4);	
	else sAttackerWeapon = 1;
	SendEventToNearClient_TypeA(iClientH, DEF_OWNERTYPE_PLAYER, MSGID_EVENT_MOTION, DEF_OBJECTDYING, sDamage, sAttackerWeapon, NULL);
	m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->ClearOwner(12, iClientH, DEF_OWNERTYPE_PLAYER, m_pClientList[iClientH]->m_sX, m_pClientList[iClientH]->m_sY);
	m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->SetDeadOwner(iClientH, DEF_OWNERTYPE_PLAYER, m_pClientList[iClientH]->m_sX, m_pClientList[iClientH]->m_sY);

	// No PK point/penalty possible if map Type prevents it
	if (   (m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cType == DEF_MAPTYPE_NOPENALTY_NOREWARD) 
		|| (m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cType == DEF_MAPTYPE_NOPCDROP_NOPK))
	{	_bPKLog(DEF_PKLOG_SAFEMAP, iAttackerH, iClientH, NULL);
		return;
	}
	if (   (m_bHeldenianWarInitiated == TRUE) 
		&& (m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_bIsHeldenianMap == TRUE)) 
	{	if (m_pClientList[iClientH]->m_cSide == 1) 
		{	m_iHeldenianAresdenDead++;
		}else if (m_pClientList[iClientH]->m_cSide == 2) 
		{	m_iHeldenianElvineDead++;
		}
		UpdateHeldenianStatus(-1);
		// Contribution when your summons kill...
		if (   (cAttackerType == DEF_OWNERTYPE_NPC)
			&& (m_pNpcList[iAttackerH] != NULL)
			&& (m_pNpcList[iAttackerH]->m_bIsSummoned		== TRUE)
			&& (m_pNpcList[iAttackerH]->m_cFollowOwnerType  == DEF_OWNERTYPE_PLAYER)
			&& (m_pNpcList[iAttackerH]->m_bIsKilled			== FALSE)	
			&& (m_pClientList[m_pNpcList[iAttackerH]->m_iFollowOwnerIndex] != NULL) 
			&& (m_pClientList[m_pNpcList[iAttackerH]->m_iFollowOwnerIndex]->m_bIsKilled == FALSE)) 
		{	m_pClientList[m_pNpcList[iAttackerH]->m_iFollowOwnerIndex]->m_iWarContribution += m_pClientList[iClientH]->m_iLevel;
		}
	}
	if (cAttackerType == DEF_OWNERTYPE_PLAYER) 
	{	if (m_pClientList[iAttackerH] == NULL) return; 
		if (iAttackerH == iClientH) 
		{	_bPKLog(DEF_PKLOG_BYSELF, iAttackerH, iClientH, NULL);
			return;
		}		
		switch (m_pClientList[iAttackerH]->m_iSpecialAbilityType) {
		case 1:
		case 2:
		case 3:
		case 4:
		case 5:
			bIsSAattacked = TRUE;
			break;
		}
		// CrasyPlayerKillers 
		if (   (m_bIsCrusadeMode == FALSE)					// Not at crusade time
			&& (m_bHeldenianWarInitiated == FALSE)			// Not if Heldenian war has begun (even out of Heldenian maps)
			&& (m_pMapList[m_pClientList[iAttackerH]->m_cMapIndex]->m_cType != DEF_MAPTYPE_NOPCDROP_NOPK)
			&& (m_pClientList[iClientH]->m_cSide !=4)		// Not for killing Executor
			&& (m_pClientList[iClientH]->m_iPKCount == 0))	// Not for Killing a criminal
		{	m_pClientList[iAttackerH]->m_iCrazyPlayerKiller ++;
			if ((m_pClientList[iClientH]->m_iCrazyPlayerKiller*2) < m_pClientList[iAttackerH]->m_iCrazyPlayerKiller)
			{	m_pClientList[iClientH]->m_bKilledByPlayerKiller = TRUE;
				m_pClientList[iClientH]->m_iCrazyPlayerKiller --;
				if (m_pClientList[iClientH]->m_iCrazyPlayerKiller < 0) 
					m_pClientList[iClientH]->m_iCrazyPlayerKiller = 0;
				m_pClientList[iAttackerH]->m_iCrazyPlayerKiller ++; // One more for killing a more peacefull guy
			}
			if (m_pClientList[iClientH]->m_cSide == m_pClientList[iAttackerH]->m_cSide ) 
			{	m_pClientList[iAttackerH]->m_iCrazyPlayerKiller ++;  // One extra point for PK
			}
		}
		// SNOOPY replaced routine for evil side
		switch (m_pClientList[iClientH]->m_cSide) {
		case 0: // Victim is traveller
			if (m_pClientList[iClientH]->m_iPKCount == 0) 
			{	ApplyPKpenalty(iAttackerH, iClientH);
			}else // Prim when killing a criminal
			{	PK_KillRewardHandler(iAttackerH, iClientH);
			}
			break;
		case 1: 
		case 2: // Victim is citizen
			if (m_pClientList[iAttackerH]->m_cSide == 0) 
			{	if (m_pClientList[iClientH]->m_iPKCount == 0) 
				{	// Considered killed by crasyPlayerKiller
					m_pClientList[iClientH]->m_bKilledByPlayerKiller = TRUE;
					ApplyPKpenalty(iAttackerH, iClientH);
				}
			}else
			{	iCapeIndex = m_pClientList[iClientH]->m_sItemEquipmentStatus[ DEF_EQUIPPOS_BACK ];
				if (   (iCapeIndex != -1) 
					&& (m_bIsCrusadeMode == FALSE)
					&& (m_bHeldenianWarInitiated == FALSE) ) 
				{	iCapeIndex = m_pClientList[iClientH]->m_pItemList[iCapeIndex]->m_sIDnum;
				}
				if (   (m_pClientList[iClientH]->m_cSide == m_pClientList[iAttackerH]->m_cSide ) 
					|| (iCapeIndex == 440) ) // Kill White cape is the same as killing friend
				{	if (m_pClientList[iClientH]->m_iPKCount == 0) 
					{	// Considered killed by crasyPlayerKiller
						m_pClientList[iClientH]->m_bKilledByPlayerKiller = TRUE;
						ApplyPKpenalty(iAttackerH, iClientH);
					}else // Prim when killing a criminal
					{	PK_KillRewardHandler(iAttackerH, iClientH);
					}
				}else // EK
				{	EnemyKillRewardHandler(iAttackerH, iClientH);
			}	}
			break;
		case 4: // Victim is evil side
			if (m_pClientList[iAttackerH]->m_cSide != 4)
			{	EnemyKillRewardHandler(iAttackerH, iClientH);
			}
			break;
		}
		if (m_pClientList[iClientH]->m_iPKCount > 0) // Criminal never considered killed by crasyPlayerKillers			
		{	m_pClientList[iClientH]->m_bKilledByPlayerKiller = FALSE;
		}				
		if (m_pClientList[iClientH]->m_iPKCount == 0) // Innocent			
		{	if (memcmp(m_pClientList[iAttackerH]->m_cLocation, "NONE", 4) == 0) 
			{	// Compute XP had been removed
				//m_pClientList[iClientH]->m_iExp -= iDice(1, 100);
				//if (m_pClientList[iClientH]->m_iExp < 0) m_pClientList[iClientH]->m_iExp = 0;
				//SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_EXP, NULL, NULL, NULL, NULL);
			}else 
			{	if (memcmp(m_pClientList[iAttackerH]->m_cLocation, m_pClientList[iClientH]->m_cLocation, 10) == 0) 
				{	//m_pClientList[iClientH]->m_iExp -= iDice(1, 100);
					//if (m_pClientList[iClientH]->m_iExp < 0) m_pClientList[iClientH]->m_iExp = 0;
					//SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_EXP, NULL, NULL, NULL, NULL);
				}else 
				{	ApplyCombatKilledPenalty(iClientH, 2, bIsSAattacked);
				}
			}
		}else if ((m_pClientList[iClientH]->m_iPKCount >= 1) && (m_pClientList[iClientH]->m_iPKCount <= 3)) 
		{	// Criminal 
			ApplyCombatKilledPenalty(iClientH, 3, bIsSAattacked);
		}else if ((m_pClientList[iClientH]->m_iPKCount >= 4) && (m_pClientList[iClientH]->m_iPKCount <= 11)) 
		{	// Murderer 
			ApplyCombatKilledPenalty(iClientH, 6, bIsSAattacked);
		}else if ((m_pClientList[iClientH]->m_iPKCount >= 12)) 
		{	// Slaughterer 
			ApplyCombatKilledPenalty(iClientH, 12, bIsSAattacked);
		}
	}else if (cAttackerType == DEF_OWNERTYPE_NPC) 
	{	// ,SNOOPY: Corrected log here NULL <-> iClientH
		_bPKLog(DEF_PKLOG_BYNPC, NULL, iClientH, cAttackerName) ;
		if (m_pClientList[iClientH]->m_iPKCount == 0) // Innocent
		{	ApplyCombatKilledPenalty(iClientH, 1, bIsSAattacked);
		}else if ((m_pClientList[iClientH]->m_iPKCount >= 1) && (m_pClientList[iClientH]->m_iPKCount <= 3)) 
		{	// Criminal 
			ApplyCombatKilledPenalty(iClientH, 3, bIsSAattacked);
		}else if ((m_pClientList[iClientH]->m_iPKCount >= 4) && (m_pClientList[iClientH]->m_iPKCount <= 11)) 
		{	// Murderer 
			ApplyCombatKilledPenalty(iClientH, 6, bIsSAattacked);
		}else if ((m_pClientList[iClientH]->m_iPKCount >= 12)) 
		{	// Slaughterer 
			ApplyCombatKilledPenalty(iClientH, 12, bIsSAattacked);
		}
		if (m_pNpcList[iAttackerH] == NULL) return; // Added check here
		// Crusade's NPC only have a GUildGUID
		if (m_pNpcList[iAttackerH]->m_iGuildGUID != NULL) 						
		{	if (m_pNpcList[iAttackerH]->m_cSide != m_pClientList[iClientH]->m_cSide) 
			{	for (i = 1; i < DEF_MAXCLIENTS; i++)
				if (   (m_pClientList[i] != NULL) && (m_pClientList[i]->m_iGuildGUID == m_pNpcList[iAttackerH]->m_iGuildGUID) 
					&& (m_pClientList[i]->m_iCrusadeDuty == 3)) 
				{	m_pClientList[i]->m_iConstructionPoint += (m_pClientList[iClientH]->m_iLevel / 2);
					if (m_pClientList[i]->m_iConstructionPoint > DEF_MAXCONSTRUCTIONPOINT) 
						m_pClientList[i]->m_iConstructionPoint = DEF_MAXCONSTRUCTIONPOINT;
					wsprintf(G_cTxt, "Enemy Player Killed  : by Npc - WarSummon +%d"
						, (m_pClientList[iClientH]->m_iLevel / 2));
					PutLogList(G_cTxt);
					PutLogEventFileList(G_cTxt);
					SendNotifyMsg(NULL, i, DEF_NOTIFY_CONSTRUCTIONPOINT, m_pClientList[i]->m_iConstructionPoint, m_pClientList[i]->m_iWarContribution, NULL, NULL);
					return;
				}				
				ZeroMemory(cData, sizeof(cData));
				cp = (char *)cData;
				*cp = GSM_CONSTRUCTIONPOINT;
				cp++;
				ip = (int*)cp;
				*ip = m_pNpcList[iAttackerH]->m_iGuildGUID;
				cp += 4;
				ip = (int*)cp;
				*ip = (m_pClientList[iClientH]->m_iLevel / 2);
				cp += 4;
				bStockMsgToGateServer(cData, 9);
			}
		}
	}else if (cAttackerType == DEF_OWNERTYPE_PLAYER_INDIRECT) 
	{	_bPKLog(DEF_PKLOG_BYOTHER,iClientH,NULL,NULL) ;
		// m_pClientList[iClientH]->m_iExp -= iDice(1, 50);
		// if (m_pClientList[iClientH]->m_iExp < 0) m_pClientList[iClientH]->m_iExp = 0;
		// SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_EXP, NULL, NULL, NULL, NULL);
	}// else cAttackerType is NULL or an arror !
}

void CGame::ReleaseItemHandler(int iClientH, short sItemIndex, BOOL bNotice)
{char cEquipPos; //, cHeroArmorType;
 short  sTemp;
 int   iTemp;
// char cInfoString[250];
	if (m_pClientList[iClientH] == NULL) return;
	if ((sItemIndex < 0) || (sItemIndex >= DEF_MAXITEMS)) return;
	if (m_pClientList[iClientH]->m_pItemList[sItemIndex] == NULL) return;
	if (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cItemType != DEF_ITEMTYPE_EQUIP) return;
	
	if (m_pClientList[iClientH]->m_bIsItemEquipped[sItemIndex] == FALSE) return;
		
	// unEquiping something removes metamorphosis
	if (m_pClientList[iClientH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_METAMORPHOSIS ] != 0) 
	{	bRemoveFromDelayEventList(iClientH, DEF_OWNERTYPE_PLAYER, DEF_MAGICTYPE_METAMORPHOSIS);
		DWORD 	dwTime = timeGetTime();				
		bRegisterDelayEvent(DEF_DELAYEVENTTYPE_MAGICRELEASE, DEF_MAGICTYPE_METAMORPHOSIS, dwTime, 
							iClientH, DEF_OWNERTYPE_PLAYER, NULL, NULL, NULL, 0, NULL, NULL);
	}	
	//cHeroArmorType = _cCheckHeroItemEquipped(iClientH);
	//if (cHeroArmorType != 0x0FFFFFFFF) m_pClientList[iClientH]->m_cHeroArmourBonus = 0;

	cEquipPos = m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cEquipPos;
	if (cEquipPos == DEF_EQUIPPOS_RHAND) 
	{	if(m_pClientList[iClientH]->m_pItemList[sItemIndex] != NULL)
		{	if ((m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sIDnum == 865) || (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sIDnum == 866)) 
			{	if (m_pClientList[iClientH]->m_cMagicMastery[94] == TRUE) 
				{	m_pClientList[iClientH]->m_cMagicMastery[94] = FALSE;				
					SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_STATECHANGE_SUCCESS, NULL, NULL, NULL, NULL);
	}	}	}	}

	switch (cEquipPos) {
	case DEF_EQUIPPOS_RHAND:
		sTemp = m_pClientList[iClientH]->m_sAppr2;
		sTemp = sTemp & 0xF00F;
		m_pClientList[iClientH]->m_sAppr2 = sTemp;
		iTemp = m_pClientList[iClientH]->m_iApprColor;
		iTemp = iTemp & 0x0FFFFFFF; 
		m_pClientList[iClientH]->m_iApprColor = iTemp;
		iTemp = m_pClientList[iClientH]->m_iStatus;
		iTemp = iTemp & 0xFFFFFFF0;
		m_pClientList[iClientH]->m_iStatus = iTemp;
		m_pClientList[iClientH]->m_iComboAttackCount = 0;
		m_pClientList[iClientH]->m_sUsingWeaponSkill = 5; // Restore OpenHand skill
		break;

	case DEF_EQUIPPOS_LHAND:
		sTemp = m_pClientList[iClientH]->m_sAppr2;
		sTemp = sTemp & 0xFFF0;
		m_pClientList[iClientH]->m_sAppr2 = sTemp;
		iTemp = m_pClientList[iClientH]->m_iApprColor;
		iTemp = iTemp & 0xF0FFFFFF; 
		m_pClientList[iClientH]->m_iApprColor = iTemp;
		break;

	case DEF_EQUIPPOS_TWOHAND:
		sTemp = m_pClientList[iClientH]->m_sAppr2;
		sTemp = sTemp & 0xF00F;	
		m_pClientList[iClientH]->m_sAppr2 = sTemp;
		iTemp = m_pClientList[iClientH]->m_iApprColor;
		iTemp = iTemp & 0x0FFFFFFF; 
		m_pClientList[iClientH]->m_iApprColor = iTemp;
		// Snoopy: Bug 2Hands if removing a weapon, keeps in open Hand the speed of previous weapon
		iTemp = m_pClientList[iClientH]->m_iStatus;
		iTemp = iTemp & 0xFFFFFFF0;
		m_pClientList[iClientH]->m_iStatus = iTemp;
		m_pClientList[iClientH]->m_iComboAttackCount = 0;
		m_pClientList[iClientH]->m_sUsingWeaponSkill = 5; // Restore OpenHand skill
		break;

	case DEF_EQUIPPOS_BODY:
		sTemp = m_pClientList[iClientH]->m_sAppr3;
		sTemp = sTemp & 0x0FFF;	
		m_pClientList[iClientH]->m_sAppr3 = sTemp;
		sTemp = m_pClientList[iClientH]->m_sAppr4;
		sTemp = sTemp & 0xFF7F;						// This bit prevents client to show the armor, but may crash it....
		m_pClientList[iClientH]->m_sAppr4 = sTemp;
		iTemp = m_pClientList[iClientH]->m_iApprColor; 
		iTemp = iTemp & 0xFF0FFFFF; 
		m_pClientList[iClientH]->m_iApprColor = iTemp;
		break;

	case DEF_EQUIPPOS_BACK:
		sTemp = m_pClientList[iClientH]->m_sAppr4;
		sTemp = sTemp & 0xF0FF;
		m_pClientList[iClientH]->m_sAppr4 = sTemp;
		iTemp = m_pClientList[iClientH]->m_iApprColor;
		iTemp = iTemp & 0xFFF0FFFF; 
		m_pClientList[iClientH]->m_iApprColor = iTemp;
		break;

	case DEF_EQUIPPOS_ARMS:
		sTemp = m_pClientList[iClientH]->m_sAppr3;
		sTemp = sTemp & 0xFFF0;	
		m_pClientList[iClientH]->m_sAppr3 = sTemp;
		iTemp = m_pClientList[iClientH]->m_iApprColor; 
		iTemp = iTemp & 0xFFFF0FFF; 
		m_pClientList[iClientH]->m_iApprColor = iTemp;
		break;

	case DEF_EQUIPPOS_PANTS:
		sTemp = m_pClientList[iClientH]->m_sAppr3;
		sTemp = sTemp & 0xF0FF;	
		m_pClientList[iClientH]->m_sAppr3 = sTemp;
		iTemp = m_pClientList[iClientH]->m_iApprColor; 
		iTemp = iTemp & 0xFFFFF0FF; 
		m_pClientList[iClientH]->m_iApprColor = iTemp;
		break;

	case DEF_EQUIPPOS_FOOT:
		sTemp = m_pClientList[iClientH]->m_sAppr4;
		sTemp = sTemp & 0x0FFF;	
		m_pClientList[iClientH]->m_sAppr4 = sTemp;
		iTemp = m_pClientList[iClientH]->m_iApprColor;
		iTemp = iTemp & 0xFFFFFF0F;
		m_pClientList[iClientH]->m_iApprColor = iTemp;
		break;

	case DEF_EQUIPPOS_HEAD:
		sTemp = m_pClientList[iClientH]->m_sAppr3;
		sTemp = sTemp & 0xFF0F;
		m_pClientList[iClientH]->m_sAppr3 = sTemp;
		iTemp = m_pClientList[iClientH]->m_iApprColor;
		iTemp = iTemp & 0xFFFFFFF0; 
		m_pClientList[iClientH]->m_iApprColor = iTemp;
		break;

	case DEF_EQUIPPOS_RELEASEALL:
		sTemp = m_pClientList[iClientH]->m_sAppr3;
		sTemp = sTemp & 0x0FFF;
		m_pClientList[iClientH]->m_sAppr3 = sTemp;
		iTemp = m_pClientList[iClientH]->m_iApprColor;
		iTemp = iTemp & 0xFFF0FFFF; 
		m_pClientList[iClientH]->m_iApprColor = iTemp;
		break;
 	}

	if (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectType == DEF_ITEMEFFECTTYPE_ATTACK_SPECABLTY) 
	{	m_pClientList[iClientH]->m_sAppr4 = m_pClientList[iClientH]->m_sAppr4 & 0xFFF3;	
	}
	if (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectType == DEF_ITEMEFFECTTYPE_DEFENSE_SPECABLTY) 
	{	m_pClientList[iClientH]->m_sAppr4 = m_pClientList[iClientH]->m_sAppr4 & 0xFFFC;
	}
	//SNOOPY: Added this for support of shinning Weapons/armors even if not activable, and other special items
	switch (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sIDnum) {
	case 646: // NecklaceOfBeholder
	 	//SetInvisibilityFlag(iClientH, DEF_OWNERTYPE_PLAYER, FALSE);	
		//m_pClientList[iClientH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_INVISIBILITY ] = NULL;
		if (m_pClientList[iClientH]->m_iAdminUserLevel == 0) 
		{	m_pClientList[iClientH]->m_iBeholderPower = 0;
			SendNewInitMapData(iClientH);
		}
		break;		
	case 445: // Elven cape
		SetInvisibilityFlag(iClientH, DEF_OWNERTYPE_PLAYER, FALSE);
		m_pClientList[iClientH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_INVISIBILITY ] = NULL;
		break;
	case 13:  // SwordSB		0x0008
	case 19:  // Sting-Dart SS	0x000C
	case 616: // DemonSlayer	0x0004
	case 766: // IceGBH 		0x000C
	case 767: // StormBringer	0x0004
		m_pClientList[iClientH]->m_sAppr4 = m_pClientList[iClientH]->m_sAppr4 & 0xFFF3;	
		break;
	case 998:// Pink Shields	0x003
	case 999:
		m_pClientList[iClientH]->m_sAppr4 = m_pClientList[iClientH]->m_sAppr4 & 0xFFFC;
		break;
	}
	m_pClientList[iClientH]->m_bIsItemEquipped[sItemIndex] = FALSE;
	m_pClientList[iClientH]->m_sItemEquipmentStatus[cEquipPos] = -1;	
	if (bNotice == TRUE)
		SendEventToNearClient_TypeA(iClientH, DEF_OWNERTYPE_PLAYER, MSGID_EVENT_MOTION, DEF_OBJECTNULLACTION, NULL, NULL, NULL);
	CalcTotalItemEffect(iClientH, sItemIndex, TRUE);
}

BOOL CGame::_bDecodeNpcConfigFileContents(char * pData, DWORD dwMsgSize)
{char * pContents, * token, cTxt[120];
 char seps[] = "= \t\n";
 char cReadModeA = 0;
 char cReadModeB = 0;
 int  iNpcConfigListIndex = 0;
 class CStrTok * pStrTok;

	pContents = new char[dwMsgSize+1];
	ZeroMemory(pContents, dwMsgSize+1);
	memcpy(pContents, pData, dwMsgSize);

	pStrTok = new class CStrTok(pContents, seps);
	token = pStrTok->pGet();
	//token = strtok(pContents, seps);
	while( token != NULL ) {
		if (cReadModeA != 0) {
			switch (cReadModeA) {
			case 1:
				switch (cReadModeB) {
				case 1:
					// NPC
					if (strlen(token) > 20)	{
						PutLogList("(!!!) CRITICAL ERROR! NPC configuration file error - Too long Npc name.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					ZeroMemory(m_pNpcConfigList[iNpcConfigListIndex]->m_cNpcName, sizeof(m_pNpcConfigList[iNpcConfigListIndex]->m_cNpcName));
					memcpy(m_pNpcConfigList[iNpcConfigListIndex]->m_cNpcName, token, strlen(token));
					cReadModeB = 2;
					break;
				case 2:
					// m_sType
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! NPC configuration file error - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pNpcConfigList[iNpcConfigListIndex]->m_sType = atoi(token);
					cReadModeB = 3;
					break;
				case 3:
					// m_iHitDice
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! NPC configuration file error - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pNpcConfigList[iNpcConfigListIndex]->m_iHitDice = atoi(token);
					cReadModeB = 4;
					break;
				case 4:
					// m_iDefenseRatio
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! NPC configuration file error - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pNpcConfigList[iNpcConfigListIndex]->m_iDefenseRatio = atoi(token);
					cReadModeB = 5;
					break;
				case 5:
					// m_iHitRatio
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! NPC configuration file error - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pNpcConfigList[iNpcConfigListIndex]->m_iHitRatio = atoi(token);
					cReadModeB = 6;
					break;
				case 6:	// m_iMinBravery: 100 is fearless huge value
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! NPC configuration file error - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pNpcConfigList[iNpcConfigListIndex]->m_iMinBravery = atoi(token);
					cReadModeB = 7;
					break;
				case 7: // m_iExpDiceMin
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! NPC configuration file error - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pNpcConfigList[iNpcConfigListIndex]->m_iExpDiceMin = atoi(token);
					cReadModeB = 8;
					break;

				case 8: // m_iExpDiceMax
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! NPC configuration file error - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pNpcConfigList[iNpcConfigListIndex]->m_iExpDiceMax = atoi(token);
					cReadModeB = 9;
					break;

				case 9: // m_iGoldDiceMin
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! NPC configuration file error - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pNpcConfigList[iNpcConfigListIndex]->m_iGoldDiceMin = atoi(token);
					cReadModeB = 10;
					break;

				case 10: // m_iGoldDiceMax
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! NPC configuration file error - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pNpcConfigList[iNpcConfigListIndex]->m_iGoldDiceMax = atoi(token);
					cReadModeB = 11;
					break;
				
				case 11: // m_cAttackDiceThrow
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! NPC configuration file error - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pNpcConfigList[iNpcConfigListIndex]->m_cAttackDiceThrow = atoi(token);
					cReadModeB = 12;
					break;

				case 12: // m_cAttackDiceRange
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! NPC configuration file error - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pNpcConfigList[iNpcConfigListIndex]->m_cAttackDiceRange = atoi(token);
					cReadModeB = 13;
					break;

				case 13: // m_cSize
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! NPC configuration file error - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pNpcConfigList[iNpcConfigListIndex]->m_cSize = atoi(token);
					cReadModeB = 14;
					break;

				case 14:
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! NPC configuration file error - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pNpcConfigList[iNpcConfigListIndex]->m_cSide = atoi(token);
					cReadModeB = 15;
					break;
				
				case 15: // ActionLimit 
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! NPC configuration file error - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pNpcConfigList[iNpcConfigListIndex]->m_cActionLimit = atoi(token);
					cReadModeB = 16;
					break;

				case 16: // Action Time
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! NPC configuration file error - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pNpcConfigList[iNpcConfigListIndex]->m_dwActionTime = atoi(token);
					cReadModeB = 17;
					break;

				case 17: // ResistMagic
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! NPC configuration file error - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pNpcConfigList[iNpcConfigListIndex]->m_cResistMagic = atoi(token);
					cReadModeB = 18;
					break;

				case 18: // cMagicLevel
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! NPC configuration file error - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pNpcConfigList[iNpcConfigListIndex]->m_cMagicLevel = atoi(token);
					cReadModeB = 19;
					break;

				case 19: // cGenDayWeekLimit  
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! NPC configuration file error - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pNpcConfigList[iNpcConfigListIndex]->m_cDayOfWeekLimit = atoi(token);
					cReadModeB = 20;
					break;

				case 20: // cChatMsgPresence
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! NPC configuration file error - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pNpcConfigList[iNpcConfigListIndex]->m_cChatMsgPresence = atoi(token);					
					if (m_pNpcConfigList[iNpcConfigListIndex]->m_cChatMsgPresence == 1) 
					{}
					cReadModeB = 21;
					break;

				case 21: // m_cTargetSearchRange
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! NPC configuration file error - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pNpcConfigList[iNpcConfigListIndex]->m_cTargetSearchRange = atoi(token);										
					cReadModeB = 22;
					break;		

				case 22: // Npc 
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! NPC configuration file error - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pNpcConfigList[iNpcConfigListIndex]->m_dwRegenTime = atoi(token);										
					cReadModeB = 23;
					break;

				case 23:
					// Attribute
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! NPC configuration file error - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pNpcConfigList[iNpcConfigListIndex]->m_cAttribute = atoi(token);										
					cReadModeB = 24;
					break;

				case 24: // Absorb Magic Damage
					if (_bGetIsStringIsNumber(token) == FALSE) 
					{	PutLogList("(!!!) CRITICAL ERROR! NPC configuration file error - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pNpcConfigList[iNpcConfigListIndex]->m_iAbsDamage = atoi(token);					
					cReadModeB = 25;
					break;

				case 25: // Maximum Mana Point
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! NPC configuration file error - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pNpcConfigList[iNpcConfigListIndex]->m_iMaxMana = atoi(token);					
					cReadModeB = 26;
					break;

				case 26:
					// MagicHitRatio
					if (_bGetIsStringIsNumber(token) == FALSE) 
					{	PutLogList("(!!!) CRITICAL ERROR! NPC configuration file error - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pNpcConfigList[iNpcConfigListIndex]->m_iMagicHitRatio = atoi(token);									
					cReadModeB = 27;
					break;

				case 27:
					// AttackRange
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! NPC configuration file error - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pNpcConfigList[iNpcConfigListIndex]->m_iAttackRange = atoi(token);					
					cReadModeB = 28;
					//iNpcConfigListIndex++; // Bug ...
					break;

				case 28:
					// Area Size
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! NPC configuration file error - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pNpcConfigList[iNpcConfigListIndex]->m_cArea = atoi(token);					
					cReadModeB = 29;
					break;

				case 29:
					// Added by snoopy to allow some npcs to be subject to poison
					if (_bGetIsStringIsNumber(token) == FALSE) {
						// Il the value not here, the npc have absolute poison resistance.
						m_pNpcConfigList[iNpcConfigListIndex]->m_cPoisonResistance = 110;
						/*PutLogList("(!!!) CRITICAL ERROR! NPC configuration file error - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;*/
					}else
					{	m_pNpcConfigList[iNpcConfigListIndex]->m_cPoisonResistance = atoi(token);
						// always 10 minimal PR
						if (m_pNpcConfigList[iNpcConfigListIndex]->m_cPoisonResistance < 10 ) 
							m_pNpcConfigList[iNpcConfigListIndex]->m_cPoisonResistance = 10;
					}
					cReadModeA = 0;
					cReadModeB = 0;
					iNpcConfigListIndex++;
					break;
				}
				break;

			case 2:
				m_iPlayerMaxLevel = atoi(token);
				cReadModeA = 0;
				cReadModeB = 0;
				break;

			default: 
				break;
			}
		}else 
		{	if (memcmp(token, "Npc", 3) == 0)
			{	cReadModeA = 1;
				cReadModeB = 1;
				m_pNpcConfigList[iNpcConfigListIndex] = new class CNpc(" ");
			}
			if (memcmp(token, "world-server-max-level", 22) == 0) {
				cReadModeA = 2;
				cReadModeB = 1;
			}
		}
		token = pStrTok->pGet();
	}	
	delete pStrTok;
	delete pContents;
	if ((cReadModeA != 0) || (cReadModeB != 0)) {
		PutLogList("(!!!) CRITICAL ERROR! NPC configuration file contents error!");
		return FALSE;
	}
	wsprintf(cTxt, "(!) NPC (Total:%d) configuration - success!", iNpcConfigListIndex);
	PutLogList(cTxt);

	return TRUE;
}

BOOL CGame::_bInitNpcAttr(class CNpc * pNpc, char * pNpcName, short sClass, char cSA)
{register int i, iTemp;
 char cTmpName[21];
 int sTemp;
 double dV1, dV2, dV3;
	ZeroMemory(cTmpName, sizeof(cTmpName));
	strcpy(cTmpName, pNpcName);
	for (i = 0; i < DEF_MAXNPCTYPES; i++) 
	if (m_pNpcConfigList[i] != NULL) 
	{	if (memcmp(cTmpName, m_pNpcConfigList[i]->m_cNpcName, 20) == 0) 
		{	ZeroMemory(pNpc->m_cNpcName, sizeof(pNpc->m_cNpcName));
			memcpy(pNpc->m_cNpcName, m_pNpcConfigList[i]->m_cNpcName, 20);			
			pNpc->m_sType  = m_pNpcConfigList[i]->m_sType;	
			pNpc->m_sOriginalType  = pNpc->m_sType;
			// HitDice
			if (m_pNpcConfigList[i]->m_iHitDice <= 5)
				 pNpc->m_iHP  = abs(iDice(m_pNpcConfigList[i]->m_iHitDice, 4) + m_pNpcConfigList[i]->m_iHitDice);
			else pNpc->m_iHP  = abs((m_pNpcConfigList[i]->m_iHitDice * 4) + m_pNpcConfigList[i]->m_iHitDice + iDice(1, m_pNpcConfigList[i]->m_iHitDice));

			if (pNpc->m_iHP == 0) pNpc->m_iHP = 1; 
			pNpc->m_iExpDiceMin		 = m_pNpcConfigList[i]->m_iExpDiceMin;
			pNpc->m_iExpDiceMax		 = m_pNpcConfigList[i]->m_iExpDiceMax;
			pNpc->m_iGoldDiceMin	 = m_pNpcConfigList[i]->m_iGoldDiceMin;
			pNpc->m_iGoldDiceMax	 = m_pNpcConfigList[i]->m_iGoldDiceMax;
			pNpc->m_iExp			 = (iDice(1, (m_pNpcConfigList[i]->m_iExpDiceMax - m_pNpcConfigList[i]->m_iExpDiceMin)) + m_pNpcConfigList[i]->m_iExpDiceMin);
			pNpc->m_iHitDice         = m_pNpcConfigList[i]->m_iHitDice;   
			pNpc->m_iDefenseRatio    = m_pNpcConfigList[i]->m_iDefenseRatio;
			pNpc->m_iHitRatio        = m_pNpcConfigList[i]->m_iHitRatio;
			pNpc->m_iMinBravery      = m_pNpcConfigList[i]->m_iMinBravery;		
			pNpc->m_cBravery		 = (char)((rand() % 3) + (char) pNpc->m_iMinBravery);
			pNpc->m_cAttackDiceThrow = m_pNpcConfigList[i]->m_cAttackDiceThrow;
			pNpc->m_cAttackDiceRange = m_pNpcConfigList[i]->m_cAttackDiceRange;
			pNpc->m_cSize            = m_pNpcConfigList[i]->m_cSize;
			pNpc->m_cSide            = m_pNpcConfigList[i]->m_cSide;
			// SNOOPY: Added this for Taming
			pNpc->m_cOriginalSide     = m_pNpcConfigList[i]->m_cSide;
			pNpc->m_dwTamingTime	  = 0;
			pNpc->m_cActionLimit      = m_pNpcConfigList[i]->m_cActionLimit;
			pNpc->m_dwActionTime      = m_pNpcConfigList[i]->m_dwActionTime;
			pNpc->m_dwRegenTime       = m_pNpcConfigList[i]->m_dwRegenTime;
			pNpc->m_cResistMagic      = m_pNpcConfigList[i]->m_cResistMagic;
			pNpc->m_cMagicLevel       = m_pNpcConfigList[i]->m_cMagicLevel;
			pNpc->m_iMaxMana          = m_pNpcConfigList[i]->m_iMaxMana; // v1.4
			pNpc->m_iMana             = m_pNpcConfigList[i]->m_iMaxMana;
			pNpc->m_cChatMsgPresence  = m_pNpcConfigList[i]->m_cChatMsgPresence;
			pNpc->m_cDayOfWeekLimit   = m_pNpcConfigList[i]->m_cDayOfWeekLimit;
			pNpc->m_cTargetSearchRange = m_pNpcConfigList[i]->m_cTargetSearchRange;
			// Added by Snoopy:
			pNpc->m_cPoisonResistance  = m_pNpcConfigList[i]->m_cPoisonResistance;
			pNpc->m_iPoisonLevel       = 0;		
			pNpc->m_iAILevel		   = iDice(1,3);							// Used to know if casting or moving to attack
			pNpc->m_iAbsDamage         = m_pNpcConfigList[i]->m_iAbsDamage;
			pNpc->m_iMagicHitRatio     = m_pNpcConfigList[i]->m_iMagicHitRatio;
			pNpc->m_iAttackRange       = m_pNpcConfigList[i]->m_iAttackRange;
			pNpc->m_cArea			   = m_pNpcConfigList[i]->m_cArea;
			pNpc->m_iNpcBossType	   = 0; 
			if (cSA < 0) 
			{	if (pNpc->m_cActionLimit < 2) pNpc->m_iNpcBossType = 1;				
				if (cSA == -5) cSA  = 10;
				if (cSA == -7) cSA  = 9;
				if (cSA == -8) cSA  = 10;
				if (cSA == -12) cSA = 0;
			}		
			pNpc->m_cSpecialAbility    = abs(cSA);
			switch (pNpc->m_sType) { // was buggy....
			case 10: // Slime
			case 31: // Demon will have "eyes in the back", never suffer 1/2 DefRation when stroken from back
			case 52: // GG
			case 70: // Dragon
			case 80: // Tentocle
			case 95: // Willowisp
			case 96:
			case 97:
			case 98: 
			case 99: //Elementals have eye in the back
				if (pNpc->m_iNpcBossType == 0) pNpc->m_iNpcBossType = -1;
				pNpc->m_iAttackStrategy = iDice(1,12); 	
				break; 
			case 21: // Guards never Boss type from those creatures!
			case 55: // Rabbit
			case 56: // Cat, Hellcat
			case 36: // AGT
			case 37: // CGT
			case 38: // MS
			case 39: // DT
			case 64: // Crops
				pNpc->m_iAttackStrategy = iDice(1,12); 	
				pNpc->m_iNpcBossType    = 0;  //never Boss
				break;
			case 34: // Dummy Never Boss & "Eyes in the back"
				pNpc->m_iNpcBossType    = -1; 
				pNpc->m_iAttackStrategy = iDice(1,12); 	
				break;
			case 43: // LWB
			case 44: // GHK
			case 45: // GHKABS
			case 46: // TK
			case 47: // BG
			//case 50: // TW
			//case 66: // Wyvern
			//case 73: // Fire-Wyvern
			//case 81: // Abaddon
				pNpc->m_iAttackStrategy = DEF_ATTACKAI_NORMAL;
				break; // Never runner
			case 53: // Beholders always Claivoyant
				cSA = 1;
				pNpc->m_cSpecialAbility = 1;
				pNpc->m_iAttackStrategy = iDice(1,12); 
				break;
			default: 
				pNpc->m_iAttackStrategy = iDice(1,12); 
				break;
			}
			pNpc->m_iBuildCount	 = m_pNpcConfigList[i]->m_iMinBravery;
			switch (pNpc->m_cSpecialAbility) {
			case 1: // Clairvoyant
				dV2 = (double)pNpc->m_iExp;
				dV3 = 25.0f/100.0f;
				dV1 = dV2 * dV3;
				pNpc->m_iExp += (int)dV1;
				break;
			case 2: // Destr magic res
				dV2 = (double)pNpc->m_iExp;
				dV3 = 30.0f/100.0f;
				dV1 = dV2 * dV3;
				pNpc->m_iExp += (int)dV1;
				break;			
			case 3: // Absorbing Physical Damage: no PA npc, if they can absorb some Magical damage...
				if (pNpc->m_iAbsDamage > 0) 
				{	pNpc->m_cSpecialAbility = NULL;
					cSA = NULL;
				}else 
				{	iTemp = 20 + iDice(1, 60);
					pNpc->m_iAbsDamage -= iTemp;
					if (pNpc->m_iAbsDamage < -90) pNpc->m_iAbsDamage = -90;
				}
				dV2 = (double)pNpc->m_iExp;
				dV3 = (double)abs(pNpc->m_iAbsDamage)/100.0f;
				dV1 = dV2 * dV3;
				pNpc->m_iExp += (int)dV1;
				break;
			case 4: // Absorbing Magical Damage
				if (pNpc->m_iAbsDamage < 0) 
				{	pNpc->m_cSpecialAbility = NULL;
					cSA = NULL;
				}	else 
				{	iTemp = 20 + iDice(1, 60);
					pNpc->m_iAbsDamage += iTemp;
					if (pNpc->m_iAbsDamage > 90) pNpc->m_iAbsDamage = 90;
				}
				dV2 = (double)pNpc->m_iExp;
				dV3 = (double)(pNpc->m_iAbsDamage)/100.0f;
				dV1 = dV2 * dV3;
				pNpc->m_iExp += (int)dV1;
				break;
			case 5: // Poisonous
				dV2 = (double)pNpc->m_iExp;
				dV3 = 15.0f/100.0f;
				dV1 = dV2 * dV3;
				pNpc->m_iExp += (int)dV1;
				pNpc->m_cPoisonResistance = 110;
				break;
			case 6: // Critical poisonous
				pNpc->m_cPoisonResistance = 110;
			case 7: // Explosive
				dV2 = (double)pNpc->m_iExp;
				dV3 = 20.0f/100.0f;
				dV1 = dV2 * dV3;
				pNpc->m_iExp += (int)dV1;
				break;
			case 8: // Critical Explosive
				dV2 = (double)pNpc->m_iExp;
				dV3 = 25.0f/100.0f;
				dV1 = dV2 * dV3;
				pNpc->m_iExp += (int)dV1;
				break;
			case 9: // Swift 
				if (pNpc->m_iHitRatio<=200)     pNpc->m_iHitRatio     += (pNpc->m_iHitRatio/2);
				else							pNpc->m_iHitRatio     += 100;			
				if (pNpc->m_iDefenseRatio<=200) pNpc->m_iDefenseRatio += (pNpc->m_iDefenseRatio/2);
				else							pNpc->m_iDefenseRatio += 100;
				pNpc->m_dwActionTime     = pNpc->m_dwActionTime/4;
				if (pNpc->m_iNpcBossType == 0)	pNpc->m_iNpcBossType = -1;	 // Eyes in the back...
				if (pNpc->m_dwActionTime < 200) pNpc->m_dwActionTime = 200; 
				pNpc->m_iExp			 += (pNpc->m_iExp / 2);
				break;
			case 10: // Mighty
				pNpc->m_iHitDice		 += (pNpc->m_iHitDice/4);  // No HP increase, but will regen faster & higher 
				pNpc->m_cAttackDiceRange += (pNpc->m_cAttackDiceRange/2);		
				pNpc->m_iAttackRange     += 1;	
				pNpc->m_iExp			 += (pNpc->m_iExp / 2);
				break;
			case 11: // Shaman
				pNpc->m_cResistMagic     *= 2;
				pNpc->m_iMaxMana         *= 2; 
				if (pNpc->m_iMaxMana < 200) pNpc->m_iMaxMana = 200;				
				pNpc->m_iMagicHitRatio     *=2;
				if (pNpc->m_iMagicHitRatio < 200) pNpc->m_iMagicHitRatio = pNpc->m_iHitDice +100;
				pNpc->m_iMana            = pNpc->m_iMaxMana;
				if (pNpc->m_cMagicLevel < 6)	
				{	if ((pNpc->m_iHitDice >= 100) && (iDice(1, pNpc->m_iHitDice) >50))	
													pNpc->m_cMagicLevel = 7;  // 7:  BSW & MFS as Demon as Wyvern
					else							pNpc->m_cMagicLevel = 6;  // 6:  ES & Lightning bolt as Liche
				}else if (pNpc->m_sType == 30)		pNpc->m_cMagicLevel = 13; // 13: Liches will MassBlizz (Tentocle are not Shamans)
				else if (pNpc->m_iHitDice >= 300)	pNpc->m_cMagicLevel = 13; // 13: ESW & MS as Abaddon
				else if (pNpc->m_iHitDice >= 150)	pNpc->m_cMagicLevel = 12; // 12: MassBlizzard as Wyvern
				else pNpc->m_cMagicLevel = 9;								  // 9:  LS as TW
				pNpc->m_iExp			 += (pNpc->m_iExp / 4);
				break;
			case 12: // Crippled
				pNpc->m_iHitDice         = pNpc->m_iHitDice/4;  // No HP diminution, so crippled mob will have hard time regen.... 
				pNpc->m_iDefenseRatio    = pNpc->m_iDefenseRatio/2;
				pNpc->m_iHitRatio        = pNpc->m_iHitRatio/2;
				pNpc->m_iExp			 = pNpc->m_iExp / 4;  
				pNpc->m_dwActionTime     += 600;
				break;
			}	 
			pNpc->m_iNoDieRemainExp  = (pNpc->m_iExp) - (pNpc->m_iExp/3);
			pNpc->m_iStatus	= pNpc->m_iStatus & 0xFFFFF0FF;		
			if (pNpc->m_iNpcBossType == 1) 
			{	pNpc->m_iStatus = (pNpc->m_iStatus | 0x00080000); // to show by client
				if (pNpc->m_iHitDice >50)
				{	pNpc->m_iHitDice     *= 2;   
					pNpc->m_iHP			 *= 2;
				}else 
				{	pNpc->m_iHitDice     += 50; 
					pNpc->m_iHP			 += 300;
				}
				pNpc->m_iDefenseRatio    *= 2;
				if (pNpc->m_iDefenseRatio <100) pNpc->m_iDefenseRatio = 100;
				pNpc->m_iHitRatio        *= 2;
				if (pNpc->m_iHitRatio <150)     pNpc->m_iHitRatio = 150;	
				if (pNpc->m_dwActionTime > 300) pNpc->m_dwActionTime	-= 200; 
				if (pNpc->m_dwActionTime < 100) pNpc->m_dwActionTime = 100; 
				pNpc->m_iExp			 *= 4;
				pNpc->m_iGoldDiceMin	 *= 4; 
				pNpc->m_iGoldDiceMax	 *= 4; 
				pNpc->m_cAttackDiceRange *= 2;		
				pNpc->m_iAttackRange     += 1;	
				pNpc->m_cTargetSearchRange += 1;
				pNpc->m_cResistMagic     *= 2;
				pNpc->m_iAttackStrategy = iDice(1,6) + 6; // Boss are more clever !
				wsprintf(G_cTxt,"(!) Enemi Boss created (%s)", pNpc->m_cNpcName);
				PutLogList(G_cTxt);
			}
			if (   (pNpc->m_iAttackRange <2)
				&& ((pNpc->m_iAttackStrategy == DEF_ATTACKAI_MAGEKILLER) || (pNpc->m_iAttackStrategy == DEF_ATTACKAI_FARATTACK)))
			{	pNpc->m_iAttackStrategy = DEF_ATTACKAI_NORMAL;
			}
			if (   (pNpc->m_iHitDice < 20)
				&& (pNpc->m_iAttackStrategy == DEF_ATTACKAI_CHANGING))
			{	pNpc->m_iAttackStrategy = DEF_ATTACKAI_NORMAL;
			}
			sTemp				= pNpc->m_cSpecialAbility;
			sTemp				= sTemp << 8;
			pNpc->m_iStatus		= pNpc->m_iStatus | sTemp;
			pNpc->m_iStatus	    = pNpc->m_iStatus & 0xFFFFFFF0;
			pNpc->m_iStatus     = pNpc->m_iStatus | (sClass);	// 0..2 seems unused (at least by v2.20 client...)
			return TRUE;
		}
	}
	return FALSE;
}

/*********************************************************************************************************************
**  int CGame::iDice(int iThrow, int iRange)																		**
**  description			:: produces a random number between the throw and range										**
**  last updated		:: November 20, 2004; 10:24 PM; Hypnotoad													**
**	return value		:: int																						**
**********************************************************************************************************************/
int CGame::iDice(int iThrow, int iRange)
{
 register int i, iRet;

	if (iRange <= 0) return 0;
	iRet = 0;
	for (i = 1; i <= iThrow; i++) {
		iRet += (rand() % iRange) + 1;
	}
	return iRet;
}

void CGame::CalculateGuildEffect(int iVictimH, char cVictimType, short sAttackerH)
{ // SNOOPY: This function is unused 
 register int ix, iy, iExp;
 short sOwnerH;
 char cOwnerType;
	// ### ERROR POINT! 
	return;
	if (m_pClientList[sAttackerH] == NULL) return;
	switch (cVictimType) {
	case DEF_OWNERTYPE_NPC:
		if (m_pNpcList[iVictimH] == NULL) return;
		for (ix = m_pNpcList[iVictimH]->m_sX-2; ix <= m_pNpcList[iVictimH]->m_sX+2; ix++)
		for (iy = m_pNpcList[iVictimH]->m_sY-2; iy <= m_pNpcList[iVictimH]->m_sY+2; iy++) {			
			m_pMapList[m_pNpcList[iVictimH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, ix, iy);			
			if ( (cOwnerType == DEF_OWNERTYPE_PLAYER) && (sOwnerH != NULL) && (sOwnerH != sAttackerH) &&
			 	 (memcmp(m_pClientList[sAttackerH]->m_cGuildName, m_pClientList[sOwnerH]->m_cGuildName, 20) == 0) &&
				 (m_pClientList[sAttackerH]->m_iLevel >= m_pClientList[sOwnerH]->m_iLevel) ) { 
				if (iDice(1,3) == 2) {
					iExp = (m_pNpcList[iVictimH]->m_iExp / 3);
					if (m_pClientList[sAttackerH]->m_iLevel >= m_iPlayerMaxLevel) iExp = 0;
					if (iExp > 0) {						
						m_pClientList[sOwnerH]->m_iExp += iExp;
						if (bCheckLimitedUser(sOwnerH) == FALSE) 
						{	SendNotifyMsg(NULL, sOwnerH, DEF_NOTIFY_EXP, NULL, NULL, NULL, NULL);
						}
						bCheckLevelUp(sOwnerH);
		}	}	}	}												     
		break;
	}
}

void CGame::TimeManaPointsUp(int iClientH)
{register int iMaxMP, iTotal;
 double dV1, dV2, dV3;
	if (m_pClientList[iClientH] == NULL) return;
	if (m_pClientList[iClientH]->m_bIsKilled == TRUE) return;
	if (m_pClientList[iClientH]->m_bIsInitComplete == FALSE) return;
	if (m_pClientList[iClientH]->m_iHungerStatus <= 0) return;
	if (m_pClientList[iClientH]->m_bSkillUsingStatus[19] == TRUE) return;
	if (m_pClientList[iClientH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_METAMORPHOSIS ] != 0) return; // No mana regen if metamorphosed

	iMaxMP = iGetMaxMP(iClientH);
	if (m_pClientList[iClientH]->m_iMP < iMaxMP) 
	{	iTotal = iDice(1, (m_pClientList[iClientH]->m_iMag + m_pClientList[iClientH]->m_iAngelicMag));
		if (m_pClientList[iClientH]->m_iAddMP != 0)
		{	dV2 = (double)iTotal;
			dV3 = (double)m_pClientList[iClientH]->m_iAddMP;
			dV1 = (dV3 / 100.0f)*dV2;
			iTotal += (int)dV1;
		}
		m_pClientList[iClientH]->m_iMP += iTotal;		
		if (m_pClientList[iClientH]->m_iMP > iMaxMP) 
			m_pClientList[iClientH]->m_iMP = iMaxMP;

		SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_MP, NULL, NULL, NULL, NULL);
	}
}

// 05/29/2004 - Hypnotoad - fixed infinite sp bug
void CGame::TimeStaminarPointsUp(int iClientH)
{	register int iMaxSP, iTotal=0;
	double dV1, dV2, dV3;
	if (m_pClientList[iClientH] == NULL) return;
	if (m_pClientList[iClientH]->m_bIsKilled == TRUE) return;
	if (m_pClientList[iClientH]->m_bIsInitComplete == FALSE) return;
	if (m_pClientList[iClientH]->m_iHungerStatus <= 0) return;
	if (m_pClientList[iClientH]->m_bSkillUsingStatus[19] == TRUE) return; 

	iMaxSP = iGetMaxSP(iClientH);
	if (m_pClientList[iClientH]->m_iSP < iMaxSP) 
	{	iTotal = iDice(1, (m_pClientList[iClientH]->m_iVit/3)); 
		if (m_pClientList[iClientH]->m_iAddSP != 0) 
		{	dV2 = (double)iTotal;
			dV3 = (double)m_pClientList[iClientH]->m_iAddSP;
			dV1 = (dV3 / 100.0f)*dV2;
			iTotal += (int)dV1;
		}
		if (m_pClientList[iClientH]->m_iLevel <= 20) 
		{	iTotal += 15;
		}else if ( m_pClientList[iClientH]->m_iLevel <= 40) 
		{	iTotal += 10;
		}else if ( m_pClientList[iClientH]->m_iLevel <= 60) 
		{	iTotal += 5;
		}

		m_pClientList[iClientH]->m_iSP += iTotal;
		if (m_pClientList[iClientH]->m_iSP > iMaxSP) 
			m_pClientList[iClientH]->m_iSP = iMaxSP;

		SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_SP, NULL, NULL, NULL, NULL);
	}
}

void CGame::DelayEventProcess()
{}

void CGame::SendGuildMsg(int iClientH, WORD wNotifyMsgType, short sV1, short sV2, char * pString)
{char cData[500];
 DWORD * dwp;
 WORD  * wp;
 char  * cp;
 register int i, iRet = 0;	
	if (m_pClientList[iClientH] == NULL) return;
	if (m_pClientList[iClientH]->m_bIsInitComplete == FALSE) return;
	
	for (i = 0; i < DEF_MAXCLIENTS; i++)
	if ( (m_pClientList[i] != NULL) && 
		 (memcmp(m_pClientList[i]->m_cGuildName, m_pClientList[iClientH]->m_cGuildName, 20) == 0) ) 
	{	ZeroMemory(cData, sizeof(cData));
		dwp  = (DWORD *)(cData + DEF_INDEX4_MSGID);
		*dwp = MSGID_NOTIFY;
		wp   = (WORD *)(cData + DEF_INDEX2_MSGTYPE);
		*wp  = wNotifyMsgType;	
		cp = (char *)(cData	+ DEF_INDEX2_MSGTYPE + 2);

		switch (wNotifyMsgType) {
		case DEF_NOTIFY_GUILDDISBANDED:
			if (i == iClientH) break;
			memcpy(cp, m_pClientList[iClientH]->m_cGuildName, 20);
			cp += 20;
			iRet = m_pClientList[i]->m_pXSock->iSendMsg(cData, 26);
			ZeroMemory(m_pClientList[i]->m_cGuildName, sizeof(m_pClientList[i]->m_cGuildName));
			strcpy(m_pClientList[i]->m_cGuildName, "NONE");
			m_pClientList[i]->m_iGuildRank = -1;
			m_pClientList[i]->m_iGuildGUID = -1;
			break;

		case DEF_NOTIFY_EVENTMSGSTRING:
			strcpy(cp, pString);
			cp += strlen(pString);
			iRet = m_pClientList[i]->m_pXSock->iSendMsg(cData, 6 + strlen(pString) + 1);
			break;

		case DEF_NOTIFY_NEWGUILDSMAN:
			memcpy(cp, m_pClientList[iClientH]->m_cCharName, 10);
			cp += 10;
			iRet = m_pClientList[i]->m_pXSock->iSendMsg(cData, 6 + 10 + 1);
			break;

		case DEF_NOTIFY_DISMISSGUILDSMAN:
			memcpy(cp, m_pClientList[iClientH]->m_cCharName, 10);
			cp += 10;
			iRet = m_pClientList[i]->m_pXSock->iSendMsg(cData, 6 + 10 + 1);
			break;
		}	
		switch (iRet) {
		case DEF_XSOCKEVENT_QUENEFULL:
		case DEF_XSOCKEVENT_SOCKETERROR:
		case DEF_XSOCKEVENT_CRITICALERROR:
		case DEF_XSOCKEVENT_SOCKETCLOSED:
			DeleteClient(i, TRUE, TRUE);
			return;	
	}	}
}

void CGame::GuildNotifyHandler(char * pData, DWORD dwMsgSize)
{char * cp, cCharName[11], cGuildName[21];
	ZeroMemory(cCharName, sizeof(cCharName));
	ZeroMemory(cGuildName, sizeof(cGuildName));
	cp = (char *)(pData + DEF_INDEX2_MSGTYPE + 2);
	memcpy(cCharName, cp, 10);
	cp += 10;
	memcpy(cGuildName, cp, 20);
	cp += 20;
}

void CGame::ToggleCombatModeHandler(int iClientH)
{	short sAppr2;
	if (m_pClientList[iClientH] == NULL) return;
	if (m_pClientList[iClientH]->m_bIsInitComplete == FALSE) return;
	if (m_pClientList[iClientH]->m_bIsKilled == TRUE) return;
	if (m_pClientList[iClientH]->m_bSkillUsingStatus[19] == TRUE) return;
	sAppr2 = (short)((m_pClientList[iClientH]->m_sAppr2 & 0xF000) >> 12);
	m_pClientList[iClientH]->m_bIsAttackModeChange = TRUE; // v2.172
	if (sAppr2 == 0) 
	{	m_pClientList[iClientH]->m_sAppr2 = (0xF000 | m_pClientList[iClientH]->m_sAppr2);
		m_pClientList[iClientH]->m_IsPeaceMode = FALSE;
	}else 
	{	m_pClientList[iClientH]->m_sAppr2 = (0x0FFF & m_pClientList[iClientH]->m_sAppr2);
		m_pClientList[iClientH]->m_IsPeaceMode = TRUE;
	}
	SendEventToNearClient_TypeA(iClientH, DEF_OWNERTYPE_PLAYER, MSGID_EVENT_MOTION, DEF_OBJECTNULLACTION, NULL, NULL, NULL);
}

void CGame::OnGateSocketEvent(UINT message, WPARAM wParam, LPARAM lParam)
{
 int   iRet;	
	if (m_pGateSock == NULL) return;
	iRet = m_pGateSock->iOnSocketEvent(wParam, lParam);

	switch (iRet) {
	case DEF_XSOCKEVENT_UNKNOWN:
		wsprintf(G_cTxt,"(???G) DEF_XSOCKEVENT_UNKNOWN");
		PutLogList(G_cTxt);
		break;

	case DEF_XSOCKEVENT_UNSENTDATASENDCOMPLETE:
		PutLogList("(>>>G) Socket connected to GateServer!");
		SendMsgToGateServer(MSGID_REQUEST_REGISTERGAMESERVER, NULL);
		m_iGateSockConnRetryTimes = 0;
		break;

	case DEF_XSOCKEVENT_CONNECTIONESTABLISH:
		//PutLogList("(>>>G) Gate-socket established!");
		break;
	
	case DEF_XSOCKEVENT_READCOMPLETE:
		OnGateRead();
		break;
	
	case DEF_XSOCKEVENT_BLOCK:
		break;
	
	case DEF_XSOCKEVENT_CONFIRMCODENOTMATCH:
	case DEF_XSOCKEVENT_MSGSIZETOOLARGE:
	case DEF_XSOCKEVENT_SOCKETERROR:
	case DEF_XSOCKEVENT_SOCKETCLOSED:
		delete m_pGateSock;
		m_pGateSock = NULL;
		PutLogList("(---G) Gate-socket connection lost!");
		m_bIsGateSockAvailable = FALSE;

		m_pGateSock = new class XSocket(m_hWnd, DEF_SERVERSOCKETBLOCKLIMIT);
		m_pGateSock->bConnect(m_cGateServerAddr, m_iGateServerPort, WM_ONGATESOCKETEVENT);
		m_pGateSock->bInitBufferSize(DEF_MSGBUFFERSIZE);
		m_iGateSockConnRetryTimes = 1;

		wsprintf(G_cTxt, "(...G) Try to reconnect gate-socket... Addr:%s  Port:%d", m_cGateServerAddr, m_iGateServerPort);
		PutLogList(G_cTxt);
		break;
	}
}

void CGame::OnGateRead()
{
 DWORD dwMsgSize;
 char * pData, cKey;
	pData = m_pGateSock->pGetRcvDataPointer(&dwMsgSize, &cKey);
	if (bPutMsgQuene(DEF_MSGFROM_GATESERVER, pData, dwMsgSize, NULL, cKey, NULL) == FALSE) {
		PutLogList("(@@@G) CRITICAL ERROR in MsgQuene!!! @@@@@@");
	}	
}

void CGame::SendMsgToGateServer(DWORD dwMsg, int iClientH, char * pData)
{ DWORD * dwp;
 WORD  * wp;
 int     iRet = 0, i;
 char    cData[1000], cCharName[11], cAccountName[11], cAccountPassword[11], cAddress[16], cGuildName[21], cTxt[120], * cp;
	if (m_pGateSock == NULL) 
	{	PutLogList("(!) SendMsgToGateServer fail - Socket to Gate-Server not available.");
		return;
	}
	ZeroMemory(cData, sizeof(cData));
	ZeroMemory(cCharName, sizeof(cCharName));
	ZeroMemory(cAccountName, sizeof(cAccountName));
	ZeroMemory(cAccountPassword, sizeof(cAccountPassword));
	ZeroMemory(cAddress,  sizeof(cAddress));
	ZeroMemory(cGuildName, sizeof(cGuildName));

	switch (dwMsg) {
	// New 07/05/2004
	case MSGID_PARTYOPERATION:
		iRet = m_pGateSock->iSendMsg(pData, 50);
		break;

	case MSGID_SERVERSTOCKMSG:
		iRet = m_pGateSock->iSendMsg(pData, m_iIndexGSS+1);
		break;
	
	case MSGID_ITEMLOG:	// Gate can log item exchanges as well
		dwp  = (DWORD *)(cData + DEF_INDEX4_MSGID);
		*dwp = MSGID_ITEMLOG;
		wp   = (WORD *)(cData + DEF_INDEX2_MSGTYPE);
		*wp  = DEF_MSGTYPE_CONFIRM;		
		cp = (char *)(cData + DEF_INDEX2_MSGTYPE + 2);
		memcpy(cp, pData, 47);
		cp += 47;
		iRet = m_pGateSock->iSendMsg(cData, 53);
		break;
	
	case MSGID_REQUEST_REGISTERGAMESERVER: // to GATE
		wsprintf(cTxt, "(...G) Try to register game server(%s) to Gate.", m_cServerName);
		PutLogList(cTxt);		
		dwp  = (DWORD *)(cData + DEF_INDEX4_MSGID);
		*dwp = MSGID_REQUEST_REGISTERGAMESERVER;
		wp   = (WORD *)(cData + DEF_INDEX2_MSGTYPE);
		*wp  = DEF_MSGTYPE_CONFIRM;		
		cp = (char *)(cData + DEF_INDEX2_MSGTYPE + 2);
		memcpy(cAccountName, m_cServerName, 10);
		if (m_iGameServerMode == 1) // Behind a router
		{	memcpy(cAddress, m_cGameServerAddrInternal, strlen(m_cGameServerAddrInternal));
		}else //if (m_iGameServerMode == 2)
		{	memcpy(cAddress, m_cGameServerAddr, strlen(m_cGameServerAddr));
		}
		memcpy(cp, cAccountName, 10);
		cp += 10;
		memcpy(cp, cAddress, 16);
		cp += 16;
		wp  = (WORD *)cp;
		*wp = m_iGameServerPort;
		cp += 2;
		*cp = m_iTotalMaps;
		cp++;
		for (i = 0; i < m_iTotalMaps; i++) 
		{	memcpy(cp, m_pMapList[i]->m_cName, 11);
			cp += 11;
		}		
		dwp = (DWORD *)cp;
		*dwp = (DWORD)GetCurrentProcessId();
		cp += 4;
		dwp = (DWORD *)cp;
		*dwp = m_dwBuildDate;
		iRet = m_pGateSock->iSendMsg(cData, 43 + m_iTotalMaps*11);
		break;

	case MSGID_GAMESERVERALIVE:
		if (m_bIsLogSockAvailable == FALSE) return;		
		dwp  = (DWORD *)(cData + DEF_INDEX4_MSGID);
		*dwp = MSGID_GAMESERVERALIVE;
		wp   = (WORD *)(cData + DEF_INDEX2_MSGTYPE);
		*wp  = DEF_MSGTYPE_CONFIRM;

		cp  = (char *)(cData + DEF_INDEX2_MSGTYPE + 2);
		wp  = (WORD *)cp;
		*wp = m_iTotalClients;
		cp += 2;
		
		iRet = m_pGateSock->iSendMsg(cData, 8);
		break;
	}

	switch (iRet) {
	case DEF_XSOCKEVENT_QUENEFULL:
	case DEF_XSOCKEVENT_SOCKETERROR:
	case DEF_XSOCKEVENT_CRITICALERROR:
	case DEF_XSOCKEVENT_SOCKETCLOSED:
		PutLogList("(---G) Socket to Gate-Server crashed! Critical error!");
		delete m_pGateSock;
		m_pGateSock = NULL;
		m_bIsGateSockAvailable = FALSE;

		// v1.41 Gate Server´
		m_pGateSock = new class XSocket(m_hWnd, DEF_SERVERSOCKETBLOCKLIMIT);
		m_pGateSock->bConnect(m_cGateServerAddr, m_iGateServerPort, WM_ONGATESOCKETEVENT);
		m_pGateSock->bInitBufferSize(DEF_MSGBUFFERSIZE);
		m_iGateSockConnRetryTimes = 1;	

		wsprintf(G_cTxt, "(!) Try to reconnect gate-socket... Addr:%s  Port:%d", m_cGateServerAddr, m_iGateServerPort);
		PutLogList(G_cTxt);
	/*	if (m_bOnExitProcess == FALSE) {
			m_cShutDownCode      = 4;
			m_bOnExitProcess     = TRUE;
			m_dwExitProcessTime  = timeGetTime();
			PutLogList("(!) GAME SERVER SHUTDOWN PROCESS STARTED(by zserver connection Lost)!!!");
		}*/		
		return;
	}
}
/////////////////////////////////////////////////////////////////////////////////////
//  void CGame::CheckDenialServiceAttack(DWORD dwClientTime, char cKey)
//  description			: checks if player send continuouslly same packet
//						: Checks cKey if Parsed, as well (0 means do not parse)
//  DS attack could be done using a packer sniffer to capture a client packet then send it continuouslly.
//	
/////////////////////////////////////////////////////////////////////////////////////
void CGame::CheckDenialServiceAttack(int iClientH, DWORD dwClientTime, DWORD dwMsgTime, char cKey)
{	DWORD dwTime = timeGetTime();
	if (m_pClientList[iClientH] == NULL) return;	
//1st chek: find a Denial of service attack by packet sent time
	if (m_pClientList[iClientH]->m_dwDSLAT == 0)
	{	// Start with 1st msg
		m_pClientList[iClientH]->m_dwDSLAT    = dwClientTime;
		m_pClientList[iClientH]->m_dwDSLATOld = dwClientTime;
		m_pClientList[iClientH]->m_dwDSLATS   = dwTime;
		m_pClientList[iClientH]->m_iDSCount   = 0;
	}else 
	{	if (dwClientTime >= m_pClientList[iClientH]->m_dwDSLAT)
		{	// current message was sent later than previous (normal case)
			m_pClientList[iClientH]->m_dwDSLAT  = dwClientTime;
		}else
		{	// current message was sent before previous
			if (m_pClientList[iClientH]->m_dwDSLATOld == dwClientTime)
			{	// If we receive more late msg with same time
				m_pClientList[iClientH]->m_iDSCount   += 1;
				if (   ((dwTime - m_pClientList[iClientH]->m_dwDSLATS) >10*1000)
					&& (m_pClientList[iClientH]->m_iDSCount > 5))
				{	// Receiving a "late" msg more than 10 sec after !
					// This is an attack!
					wsprintf(G_cTxt, "DS check:   PC(%s) - Denial of service attack! (Disc.) \tIP(%s)"				
						, m_pClientList[iClientH]->m_cCharName
						, m_pClientList[iClientH]->m_cIPaddress);
					PutHackLogFileList(G_cTxt);
					PutLogList(G_cTxt);
					if (m_pClientList[iClientH]->m_bMonitorThisChar) 
					{}else DeleteClient(iClientH, TRUE, TRUE);
					ZeroMemory(m_cBugText, sizeof(m_cBugText));
					wsprintf(m_cBugText, "SERVER UNDER ATTACK:  Denial of service attack by: %s"					
						, m_pClientList[iClientH]->m_cCharName);
					m_iBugWarning = 1;
					return;
				}
			}else
			{	// else this message become late msg
				m_pClientList[iClientH]->m_dwDSLATOld = dwClientTime;
				m_pClientList[iClientH]->m_iDSCount   = 1;
				m_pClientList[iClientH]->m_dwDSLATS = dwTime;
			}
		}
	}
	if (cKey !=0)
	{
// 2nd check:Monitor Keys
		if (cKey == m_pClientList[iClientH]->m_cPreviousKey) 
		{	m_pClientList[iClientH]->m_iNbeSameKey +=1;
		}else 
		{	m_pClientList[iClientH]->m_cPreviousKey = cKey;
			m_pClientList[iClientH]->m_iNbeSameKey = 0;
		}
//Key check: Key is random char, so if client sends same one many times=> Hack
		if (m_pClientList[iClientH]->m_iNbeSameKey > 5)
		{	wsprintf(G_cTxt, "Key check:  PC(%s) - Fixed key (%d), hacked client or Packet editor (Delayed) \tIP(%s)"				
				, m_pClientList[iClientH]->m_cCharName
				, cKey
				, m_pClientList[iClientH]->m_cIPaddress);
			PutHackLogFileList(G_cTxt);
			PutLogList(G_cTxt);
			if (m_pClientList[iClientH]->m_bMonitorThisChar) 
			{	PutMonitorLogFileList(G_cTxt);	
				m_pClientList[iClientH]->dwTimeConnectionCheck = 0;
				m_pClientList[iClientH]->m_iConnectionCheck = 0;
			}else 	DelayedDeleteClient(iClientH, TRUE, TRUE);
			return;
		}		
//Key check: Wrong key. I reduced key scope in my edited client=> Hack
		if ((cKey > -10) && (cKey <0) && (m_iClientConnectionCheckTime != 8000)) // Do not use if not my client
		{	wsprintf(G_cTxt, "Key check:  PC(%s) - Forbiden key (%d), hacked client or Packet editor (Disc.) \tIP(%s)"				
				, m_pClientList[iClientH]->m_cCharName
				, cKey
				, m_pClientList[iClientH]->m_cIPaddress);
			PutHackLogFileList(G_cTxt);
			PutLogList(G_cTxt);
			if (m_pClientList[iClientH]->m_bMonitorThisChar) 
			{	PutMonitorLogFileList(G_cTxt);	
				m_pClientList[iClientH]->dwTimeConnectionCheck = 0;
				m_pClientList[iClientH]->m_iConnectionCheck = 0;
			}else 	DeleteClient(iClientH, TRUE, TRUE);
			return;
		}	
	}
}
/////////////////////////////////////////////////////////////////////////////////////
//  int CGame::iClientMotion_Magic_Handler(int iClientH, short sX, short sY, char cDir, DWORD dwClientTime, DWORD dwMsgTime, short sSpellID)
//  description			:: checks if player is precasting magic
//  Snoopy				:: Magic Speed hack detection, client and server time
//	return value		:: int: 0=problem/hack, 1=OK, 2=coordinates error
/////////////////////////////////////////////////////////////////////////////////////
int CGame::iClientMotion_Magic_Handler(int iClientH, short sX, short sY, char cDir, DWORD dwClientTime, DWORD dwMsgTime, short sSpellID)
{ char  cData[100];
  DWORD * dwp;
  WORD  * wp;
  int     iRet; 		
	if (m_pClientList[iClientH] == NULL) return 0;
	if (m_pClientList[iClientH]->m_bIsKilled == TRUE) return 0;
	if (m_pClientList[iClientH]->m_bIsInitComplete == FALSE) return 0;	
	if ((sX != m_pClientList[iClientH]->m_sX) || (sY != m_pClientList[iClientH]->m_sY)) return 2; // reject casting

	// Remove metamorphosis when Casting
	if (m_pClientList[iClientH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_METAMORPHOSIS ] != 0) 
	{	bRemoveFromDelayEventList(iClientH, DEF_OWNERTYPE_PLAYER, DEF_MAGICTYPE_METAMORPHOSIS);
		SetMetamorphosisFlag(iClientH, DEF_OWNERTYPE_PLAYER, FALSE);
	}	
	 if ( (m_pMagicConfigList[sSpellID]->m_dwDelayTime != 0) 
		&& (m_pClientList[iClientH]->m_iSpecialAbilityTime != 0))// Not possible to cast this spell now.	
	 return 2; // reject casting

	// SNOOPY: Hack detection
	m_pClientList[iClientH]->m_iSpellCount     = 0;	
	m_pClientList[iClientH]->m_dwPreCastLAT    = dwClientTime;
	m_pClientList[iClientH]->m_dwPreCastLATS   = dwMsgTime;	
	m_pClientList[iClientH]->m_sPreCastSpellID = sSpellID;		

	if (m_pClientList[iClientH]->m_bMonitorThisChar)
	{	if ((sSpellID < 0) || (sSpellID >= DEF_MAXMAGICTYPE)) 
		{	wsprintf(G_cTxt, "PreCast:    PC(%s) - PreCast Unknown spell (%d)."				
				, m_pClientList[iClientH]->m_cCharName
				, sSpellID);
		}else
		{	wsprintf(G_cTxt, "PreCast:    PC(%s) - PreCast %s (%d)."				
				, m_pClientList[iClientH]->m_cCharName
				, m_pMagicConfigList[sSpellID]->m_cName
				, sSpellID);
		}
		PutMonitorLogFileList(G_cTxt);
	}

	int iStX, iStY;
	if (m_pMapList[m_pClientList[iClientH]->m_cMapIndex] != NULL) 
	{	iStX = m_pClientList[iClientH]->m_sX / 20;
		iStY = m_pClientList[iClientH]->m_sY / 20;
		m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_stTempSectorInfo[iStX][iStY].iPlayerActivity++;
		switch (m_pClientList[iClientH]->m_cSide) {
		case 1: m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_stTempSectorInfo[iStX][iStY].iAresdenActivity++; break;
		case 2: m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_stTempSectorInfo[iStX][iStY].iElvineActivity++;  break;
		case 4: m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_stTempSectorInfo[iStX][iStY].iExecutorActivity++;  break;
		case 0: 
		default: m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_stTempSectorInfo[iStX][iStY].iNeutralActivity++; break;
		}
	}	
	ClearSkillUsingStatus(iClientH);
	m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->ClearOwner(0, iClientH, DEF_OWNERTYPE_PLAYER, sX, sY);
	m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->SetOwner(iClientH, DEF_OWNERTYPE_PLAYER, sX, sY);
	if ( (m_pClientList[iClientH]->m_iStatus & 0x10) != 0 )	
	{	SetInvisibilityFlag(iClientH, DEF_OWNERTYPE_PLAYER, FALSE);		
		bRemoveFromDelayEventList(iClientH, DEF_OWNERTYPE_PLAYER, DEF_MAGICTYPE_INVISIBILITY);
		m_pClientList[ iClientH ]->m_cMagicEffectStatus[ DEF_MAGICTYPE_INVISIBILITY ] = NULL;
	}

	m_pClientList[iClientH]->m_cDir = cDir;	
	dwp  = (DWORD *)(cData + DEF_INDEX4_MSGID);
	*dwp = MSGID_RESPONSE_MOTION;
	wp   = (WORD *)(cData + DEF_INDEX2_MSGTYPE);
	*wp  = DEF_OBJECTMOTION_CONFIRM;
	iRet = m_pClientList[iClientH]->m_pXSock->iSendMsg(cData, 6);
	switch (iRet) {
	case DEF_XSOCKEVENT_QUENEFULL:
	case DEF_XSOCKEVENT_SOCKETERROR:
	case DEF_XSOCKEVENT_CRITICALERROR:
	case DEF_XSOCKEVENT_SOCKETCLOSED:
		DeleteClient(iClientH, TRUE, TRUE);
		return 0;
	}
	return 1;
}
/////////////////////////////////////////////////////////////////////////////////////
//  int CGame::iClientCommon_Spell_Handler(int iClientH, short sX, short sY, DWORD dwClientTime, DWORD dwMsgTime, short sSpell
//  description			:: checks precasting / casting relationship
//  Snoopy				:: Magic Speed hack detection, client and server time
//	return value		:: int: 0=problem/hack, 1=OK
/////////////////////////////////////////////////////////////////////////////////////
int  CGame::iClientCommon_Spell_Handler(int iClientH, short sX, short sY, DWORD dwClientTime, DWORD dwMsgTime, short sSpellID)
{ 	// Return Value:	// 0 Not cast (heack, deleted...
						// 1 everythink OK	
	if (m_pClientList[iClientH] == NULL) return 0;
	if (m_pClientList[iClientH]->m_bIsKilled == TRUE) return 0;
	if (m_pClientList[iClientH]->m_bIsInitComplete == FALSE) return 0;	
	
	m_pClientList[iClientH]->m_iSpellCount ++;
	m_pClientList[iClientH]->m_bMagicConfirm = TRUE; // client unbound a spell	
	if (m_pClientList[iClientH]->m_iSpellCount > 1)
	{	wsprintf(G_cTxt, "Magic Hack: PC(%s) - Casting magic without precasting.(Delayed). \tIP(%s)"
			, m_pClientList[iClientH]->m_cCharName
			, m_pClientList[iClientH]->m_cIPaddress);
		PutHackLogFileList(G_cTxt);
		DelayedDeleteClient(iClientH, TRUE, TRUE);
		return 0;
	}

	if (m_pClientList[iClientH]->m_sPreCastSpellID != sSpellID)
	{	wsprintf(G_cTxt, "Magic Hack: PC(%s) - Precasting %d but casting %d.(Delayed). \tIP(%s)"
			, m_pClientList[iClientH]->m_cCharName
			, sSpellID
			, m_pClientList[iClientH]->m_sPreCastSpellID
			, m_pClientList[iClientH]->m_cIPaddress);
		PutHackLogFileList(G_cTxt);
		DelayedDeleteClient(iClientH, TRUE, TRUE);
		return 0;
	}	
	//Monitoring: Show all precast/cast gaps...( huge file !)
	if (m_pClientList[iClientH]->m_bMonitorThisChar)
	{	if ((sSpellID < 0) || (sSpellID >= DEF_MAXMAGICTYPE)) 
		{	//printf(G_cTxt, "PreCast:    PC(%s) - PreCast Unknown spell (%d)."				
			wsprintf(G_cTxt, "Casting:    PC(%s) - Cast Unknown spell (%d) - PreCast/Cast gap (C:%dms S:%dms)."				
				, m_pClientList[iClientH]->m_cCharName
				, sSpellID
				, dwClientTime - m_pClientList[iClientH]->m_dwPreCastLAT
				, dwMsgTime - m_pClientList[iClientH]->m_dwPreCastLATS);
		}else
		{	//printf(G_cTxt, "PreCast:    PC(%s) - PreCast Unknown spell (%d)."				
			wsprintf(G_cTxt, "Casting:    PC(%s) - Cast %s (%d) - PreCast/Cast gap (C:%dms S:%dms)."				
				, m_pClientList[iClientH]->m_cCharName
				, m_pMagicConfigList[sSpellID]->m_cName
				, sSpellID
				, dwClientTime - m_pClientList[iClientH]->m_dwPreCastLAT
				, dwMsgTime - m_pClientList[iClientH]->m_dwPreCastLATS);
		}
		PutMonitorLogFileList(G_cTxt);
	}
	// Client gap low....
	if ((dwClientTime - m_pClientList[iClientH]->m_dwPreCastLAT) < 1050) // 1750 tested 1200theoric 900- with a onTimer error
	{	//wsprintf(G_cTxt, "Magic Hack  PC(%s) - PreCast/Cast gap low (%dms).(Disc.). \tIP(%s)"
		wsprintf(G_cTxt, "Magic Hack  PC(%s) - PreCast/Cast client gap low (C:%dms S:%dms). \tIP(%s)"
			, m_pClientList[iClientH]->m_cCharName
			, dwClientTime - m_pClientList[iClientH]->m_dwPreCastLAT
			, dwMsgTime - m_pClientList[iClientH]->m_dwPreCastLATS
			, m_pClientList[iClientH]->m_cIPaddress);		
		PutHackLogFileList(G_cTxt);
		SendEventToNearClient_TypeA(iClientH, DEF_OWNERTYPE_PLAYER, MSGID_EVENT_MOTION, DEF_OBJECTDAMAGE, 0, -1, NULL);
		return 0;
		//DeleteClient(iClientH, TRUE, TRUE);
		//return;
	}
	if ((dwClientTime - m_pClientList[iClientH]->m_dwRecentAttackTime) < 1000) 
	{	wsprintf(G_cTxt, "Magic Hack  PC(%s) - Casting too early after previous action.(%dms) (Disc.). \tIP(%s)"
			, m_pClientList[iClientH]->m_cCharName
			, (dwClientTime - m_pClientList[iClientH]->m_dwRecentAttackTime)
			, m_pClientList[iClientH]->m_cIPaddress);		
		PutHackLogFileList(G_cTxt);
		DeleteClient(iClientH, TRUE, TRUE);
		return 0;
	}	
	m_pClientList[iClientH]->m_dwRecentAttackTime = dwClientTime;	
	/*wsprintf(G_cTxt, "Magic client time  (%dms) ", dwClientTime- m_pClientList[iClientH]->m_dwPreCastLAT);
	PutLogList(G_cTxt);*/
	return 1;
}

/*********************************************************************************************************************
**  void CGame::PlayerMagicHandler(int iClientH, int dX, int dY, short sType, BOOL bItemEffect, int iV1)			**
**  description			:: handles all magic related items/spells													**
**  last updated		:: November 22, 2004; 5:45 PM; Hypnotoad													**
**	return value		:: void																						**
**  commentary			::	-	added 3.51 casting detection														**
**							-	updated it so civilians can only cast certain spells on players and vice versa		**
**							-	fixed bug causing spell to be cast when mana is below required amount				**
**********************************************************************************************************************/
int  _tmp_iMCProb[]        = {0, 300, 250, 200, 150, 100, 80, 70, 60, 50, 40};
int  _tmp_iMLevelPenalty[] = {0,   5,   5,   8,   8,  10, 14, 28, 32, 36, 40};
/*********************************************************************************************************************
**  void CGame::PlayerMagicHandler(int iClientH, int dX, int dY, short sType, BOOL bItemEffect, int iV1)			**
**  SNOOPY: Changed iV1 at -1 value means can be cast with something other than wands in the hands or Shield        ** 
**********************************************************************************************************************/
void CGame::PlayerMagicHandler(int iClientH, int dX, int dY, short sType, BOOL bItemEffect, int iV1, DWORD dwClientTime, DWORD dwMsgTime)
{	short  * sp, sX, sY, sOwnerH, sMagicCircle, rx, ry, sRemainItemSprite, sRemainItemSpriteFrame, sLevelMagic, sTemp;
	char   * cp, cData[120], cDir, cOwnerType, cName[11], cItemName[21], cNpcWaypoint[11], cName_Master[11], cNpcName[21], cRemainItemColor;
	double dV1, dV2, dV3, dV4;
	int    i, iErr, iRet, ix, iy, iResult, iDiceRes, iNamingValue, iFollowersNum, iEraseReq, iWhetherBonus;
	int    tX, tY, iManaCost, iMagicAttr, iIceAtkRatio;
	// SNOOPY: Added BloodWandMS40
	int iLifeCost;
	class  CItem * pItem;
	DWORD * dwp, dwTime;
	WORD  * wp, wWeaponType;
	short sEqStatus;
	char cTemp[256], cParaLevel, cParaLevelID;
	if (m_pClientList[iClientH] == NULL) return;
	if (m_pClientList[iClientH]->m_bIsInitComplete == FALSE) return;	

	m_pClientList[iClientH]->m_dwLastActionTime = m_pClientList[iClientH]->m_dwAFKCheckTime = timeGetTime();;	
	dwTime = timeGetTime();	// SNOOPY: For item creation time stample and LastDamageTime
	if (   (dX < 0) || (dX >= m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_sSizeX) 
		|| (dY < 0) || (dY >= m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_sSizeY)) return;
	if (m_pClientList[iClientH]->m_cMapIndex < 0) return;
	if (m_pMapList[m_pClientList[iClientH]->m_cMapIndex] == NULL) return;
	if ((sType < 0) || (sType >= 100))     return;
	if (m_pMagicConfigList[sType] == NULL) return;
	if ((bItemEffect == FALSE) && (m_pClientList[iClientH]->m_cMagicMastery[sType] != 1)) return;
	if (   (m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_bIsAttackEnabled == FALSE) 
		&& (m_pClientList[iClientH]->m_iAdminUserLevel == 0)) return;

	if ((m_pClientList[iClientH]->m_bInhibition == TRUE) && (bItemEffect != TRUE)) 
	{	SendEventToNearClient_TypeA(iClientH, DEF_OWNERTYPE_PLAYER, MSGID_EVENT_MOTION, DEF_OBJECTDAMAGE, 0, -1, NULL);
		return;
	}
	if ((iV1 >= 0) && (m_pClientList[iClientH]->m_iAdminUserLevel == 0)) // NB: itemEffect spells will not fly if weapon equiped
	{	// Setting this to -1 enable using the spell or spell effect with something in hands..
		if (m_pClientList[iClientH]->m_sItemEquipmentStatus[DEF_EQUIPPOS_RHAND] != -1) 
		{	wWeaponType = ((m_pClientList[iClientH]->m_sAppr2 & 0x0FF0) >> 4);		
			if ((wWeaponType >= 34) && (wWeaponType <= 39)) 
			{}else return;
		}
		if (   (m_pClientList[iClientH]->m_sItemEquipmentStatus[DEF_EQUIPPOS_LHAND]   != -1) 
			|| (m_pClientList[iClientH]->m_sItemEquipmentStatus[DEF_EQUIPPOS_TWOHAND] != -1)) return;
	}else iV1 = abs(iV1);

	//if (   (var_874 == TRUE) && (m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_bIsHeldenianMap == TRUE) 
	//    && (m_pMagicConfigList[sType]->m_sType != 8)) return;	
	/*if (((m_pClientList[iClientH]->m_iUninteruptibleCheck - (iGetMaxHP(iClientH)/10)) > (m_pClientList[iClientH]->m_iHP)) && (m_pClientList[iClientH]->m_bMagicItem == FALSE)) {
		SendEventToNearClient_TypeB(MSGID_EVENT_COMMON, DEF_COMMONTYPE_MAGIC, NULL,
			NULL, NULL, NULL, NULL, NULL, NULL);
		return;
	}*/
	// SNOOPY: Needed here for ResurWand and a bit later for BloodWandMS40
	sEqStatus = m_pClientList[iClientH]->m_sItemEquipmentStatus[DEF_EQUIPPOS_RHAND];
	if (m_pMagicConfigList[sType]->m_sType == DEF_MAGICTYPE_RESURRECTION)  // with ResurWand
	{	if ((sEqStatus != -1) && (m_pClientList[iClientH]->m_pItemList[sEqStatus] != NULL)) 
		{	if (   (m_pClientList[iClientH]->m_pItemList[sEqStatus]->m_sIDnum == 865) 
				|| (m_pClientList[iClientH]->m_pItemList[sEqStatus]->m_sIDnum == 866)) 
			{	bItemEffect = TRUE;
	}	}	}
	sX = m_pClientList[iClientH]->m_sX;
	sY = m_pClientList[iClientH]->m_sY;
	sMagicCircle = (sType / 10) + 1;
	if (m_pClientList[iClientH]->m_cSkillMastery[4] == 0)
		dV1 = 1.0f;
	else dV1 = (double)m_pClientList[iClientH]->m_cSkillMastery[4];
	if (bItemEffect == TRUE) dV1 = (double)100.0f;
	dV2 = (double)(dV1 / 100.0f);
	dV3 = (double)_tmp_iMCProb[sMagicCircle];
	dV1 = dV2 * dV3;
	iResult = (int)dV1;		
	if ((m_pClientList[iClientH]->m_iInt + m_pClientList[iClientH]->m_iAngelicInt) > 50)
		iResult += ((m_pClientList[iClientH]->m_iInt + m_pClientList[iClientH]->m_iAngelicInt) - 50)/2;

	sLevelMagic = (m_pClientList[iClientH]->m_iLevel / 10);
	if (sMagicCircle != sLevelMagic) 
	{	if (sMagicCircle > sLevelMagic) 
		{	dV1 = (double)(m_pClientList[iClientH]->m_iLevel - sLevelMagic*10);
			dV2 = (double)abs(sMagicCircle - sLevelMagic)*_tmp_iMLevelPenalty[sMagicCircle];
			dV3 = (double)abs(sMagicCircle - sLevelMagic)*10;
			dV4 = (dV1 / dV3)*dV2;
			iResult -= abs(abs(sMagicCircle - sLevelMagic)*_tmp_iMLevelPenalty[sMagicCircle] - (int)dV4);
		}else 
		{	iResult += 5*abs(sMagicCircle - sLevelMagic);
		}
	}
	switch (m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cWhetherStatus) {
	case 0: break;
	case 1: iResult = iResult - (iResult / 24); break;
	case 2:	iResult = iResult - (iResult / 12); break;
	case 3: iResult = iResult - (iResult / 5);  break;
	}
	if (m_pClientList[iClientH]->m_iSpecialWeaponEffectType == 10)  // Use a CP Wand
	{	dV1 = (double)iResult;
		dV2 = (double)(m_pClientList[iClientH]->m_iSpecialWeaponEffectValue * 3);
		dV3 = dV1 + dV2;
		iResult = (int)dV3;
	}
	if (iResult <= 0) iResult = 1;
	iWhetherBonus = iGetWhetherMagicBonusEffect(sType, m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cWhetherStatus);
	iManaCost = m_pMagicConfigList[sType]->m_sValue1;
	if (   (m_pClientList[iClientH]->m_bIsSafeAttackMode == TRUE) 
		&& (m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_bIsFightZone == FALSE)) 
//SNOOPY: Spell in safe mode only cost 10% more
		{	iManaCost += /*(iManaCost / 2) -*/ (iManaCost / 10);
		}
// Added BloodWandMS40 life cost
		iLifeCost = iManaCost/5;
		if ((sEqStatus != -1) && (m_pClientList[iClientH]->m_pItemList[sEqStatus] != NULL)) 
		{	if (m_pClientList[iClientH]->m_pItemList[sEqStatus]->m_sIDnum == 982)  // BloodWandMS40
			{	// Damages the caster				
				m_pClientList[iClientH]->m_iHP -= iLifeCost;
				if (m_pClientList[iClientH]->m_iHP <= 0) 
				{	ClientKilledHandler(iClientH, iClientH, DEF_OWNERTYPE_PLAYER, 1);	
				}else
				{	m_pClientList[iClientH]->m_dwLastDamageTime = dwTime;
					SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_HP, NULL, NULL, NULL, NULL);
		}	}	}		
		if (m_pClientList[iClientH]->m_iManaSaveRatio > 0) 
		{	dV1 = (double)m_pClientList[iClientH]->m_iManaSaveRatio;
			dV2 = (double)(dV1 / 100.0f);
			dV3 = (double)iManaCost;
			dV1 = dV2 * dV3;	
			dV2 = dV3 - dV1; 
			iManaCost = (int)dV2;
			if (iManaCost <= 0) iManaCost = 1;
		}
		// Weapontype 34 gives 20 mana point Malus on Mana cost... Based on Wand image
		// SNOOPY: Removed this but Berzerk Wand is now just a MS0....
/*
		wWeaponType = ((m_pClientList[iClientH]->m_sAppr2 & 0x0FF0) >> 4);
		if (wWeaponType == 34) { 
			// SNOOPY: Removed this but Berzerk Wand is now just a MS0......
			iManaCost += 20;
		}*/
		if (bItemEffect == FALSE) // Snoopy: changed this system
		{	if (iResult < 100) 
			{	iDiceRes = iDice(1,100);
				if (iResult < iDiceRes) 
				{	SendEventToNearClient_TypeA(iClientH, DEF_OWNERTYPE_PLAYER, MSGID_EVENT_MOTION, DEF_OBJECTDAMAGE, 0, -1, NULL);
					return;
			}	}
			if (((m_pClientList[iClientH]->m_iHungerStatus <= 10) || (m_pClientList[iClientH]->m_iSP <= 0)) && (iDice(1,1000) <= 100)) 
			{	SendEventToNearClient_TypeA(iClientH, DEF_OWNERTYPE_PLAYER, MSGID_EVENT_MOTION, DEF_OBJECTDAMAGE, 0, -1, NULL);
				return;
			}
		}
		if (m_pClientList[iClientH]->m_iMP < iManaCost) 
		{	return;
		}
		// Now, iResult is used for Magic resistance check
		iResult = m_pClientList[iClientH]->m_cSkillMastery[4];
		if ((m_pClientList[iClientH]->m_iMag + m_pClientList[iClientH]->m_iAngelicMag) > 50) iResult += ((m_pClientList[iClientH]->m_iMag + m_pClientList[iClientH]->m_iAngelicMag) - 50); 	

		sLevelMagic = (m_pClientList[iClientH]->m_iLevel / 10);
		if (sMagicCircle != sLevelMagic) 
		{	if (sMagicCircle > sLevelMagic) 
			{	dV1 = (double)(m_pClientList[iClientH]->m_iLevel - sLevelMagic*10);
				dV2 = (double)abs(sMagicCircle - sLevelMagic)*_tmp_iMLevelPenalty[sMagicCircle];
				dV3 = (double)abs(sMagicCircle - sLevelMagic)*10;
				dV4 = (dV1 / dV3)*dV2;
				iResult -= abs(abs(sMagicCircle - sLevelMagic)*_tmp_iMLevelPenalty[sMagicCircle] - (int)dV4);
			}else 
			{	iResult += 5*abs(sMagicCircle - sLevelMagic); // +5% attack per 10 levels over circle x 10
			}
		}
		iResult += m_pClientList[iClientH]->m_iMagicHitRatio_ItemEffect;
		iResult += m_pClientList[iClientH]->m_iAddAR;
		if (iResult <= 0) iResult = 1;
		iIceAtkRatio = m_pClientList[iClientH]->m_iAddDamageWater * 4;
		if (sType >= 80) iResult += 10000;
		if (m_pMagicConfigList[sType]->m_cCategory == 1) 
		{	if (m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->iGetAttribute(sX, sY, 0x00000005) != 0) return;
			if (m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_bInsideBuildingLimitedCast == TRUE) return;
		}
		iMagicAttr = m_pMagicConfigList[sType]->m_iAttribute;
		// SNOOPY: used iMagicAttr, to send info to damage procedures, 
		if ((m_pClientList[iClientH]->m_iStatus & 0x10) != 0) 
		{	SetInvisibilityFlag(iClientH, DEF_OWNERTYPE_PLAYER, FALSE);
			bRemoveFromDelayEventList(iClientH, DEF_OWNERTYPE_PLAYER, DEF_MAGICTYPE_INVISIBILITY);
			m_pClientList[iClientH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_INVISIBILITY ] = NULL;
		}
		// Prevent civ to cast certain spells on others.
		m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, dX, dY);
		if (   (m_bIsCrusadeMode == FALSE) 
			&& (m_pClientList[iClientH]->m_iAdminUserLevel == 0) // GM not concerned
			&& (cOwnerType == DEF_OWNERTYPE_PLAYER)) 
		{	if (  (m_pClientList[iClientH]->m_bIsPlayerCivil != TRUE) 
				&& (m_pClientList[sOwnerH]->m_bIsPlayerCivil == TRUE)) 
			{	// Not spell from combatant can work on a ennemi civ
				if (m_pClientList[iClientH]->m_cSide != m_pClientList[sOwnerH]->m_cSide) 
					goto MAGIC_NOEFFECT;
			}else 
			{	if (  (m_pClientList[iClientH]->m_bIsPlayerCivil == TRUE)
					&& (m_pClientList[sOwnerH]->m_bIsPlayerCivil != TRUE)) 
				{	// Those spell cant be cast by a civ on combatants
					switch (m_pMagicConfigList[sType]->m_sType) {
					case 1:  // DEF_MAGICTYPE_DAMAGE_SPOT
					case 4:  // DEF_MAGICTYPE_SPDOWN_SPOT 4
					case 8:  // DEF_MAGICTYPE_TELEPORT 8
					case 10: // DEF_MAGICTYPE_CREATE 10
					case 11: // DEF_MAGICTYPE_PROTECT 11
					case 12: // DEF_MAGICTYPE_HOLDOBJECT 12
					case 16: // DEF_MAGICTYPE_CONFUSE
					case 17: // DEF_MAGICTYPE_POISON
					case 20: // DEF_MAGICTYPE_POLYMORPH: //20 Added by Snoopy
					case 24: // DEF_MAGICTYPE_RESURRECTION
						goto MAGIC_NOEFFECT; 
						break;			
		}	}	}	}
		// If target uses Magic reflexion, replace target XY by caster XY...		
		m_pClientList[iClientH]->m_bIsReflexionVictim = FALSE;
		m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, dX, dY);
		if (cOwnerType == DEF_OWNERTYPE_PLAYER) 
		{	if (   (m_pClientList[sOwnerH]->m_cMagicEffectStatus[DEF_MAGICTYPE_REFLEXION] == 3) 
				&& (m_pMagicConfigList[sType]->m_sType != DEF_MAGICTYPE_CANCELLATION))
			{	dX = m_pClientList[iClientH]->m_sX;
				dY = m_pClientList[iClientH]->m_sY;	
				m_pClientList[iClientH]->m_bIsReflexionVictim = TRUE;
		}	}

		if (   (m_pMagicConfigList[sType]->m_dwDelayTime == 0) 
			|| (m_pClientList[iClientH]->m_iSpecialAbilityTime == 0)) // For spells useable only after some delay...
		{	switch (m_pMagicConfigList[sType]->m_sType) {
			//Snoopy: added malus to resist, depending on spells, Dead owner bigger malus 
			case DEF_MAGICTYPE_DAMAGE_SPOT: // 1 (will fly away from caster) (harder to resist by 50)
				m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, dX, dY);
				if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult + 50) == FALSE)
					Effect_Damage_Spot_DamageMove(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, sX, sY, m_pMagicConfigList[sType]->m_sValue4, m_pMagicConfigList[sType]->m_sValue5, m_pMagicConfigList[sType]->m_sValue6 + iWhetherBonus, TRUE, iMagicAttr);
				m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetDeadOwner(&sOwnerH, &cOwnerType, dX, dY);
				if ((cOwnerType == DEF_OWNERTYPE_PLAYER) && (m_pClientList[sOwnerH] != NULL) && (m_pClientList[sOwnerH]->m_iHP > 0)) 
				{	if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult + 100) == FALSE)
						Effect_Damage_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue4, m_pMagicConfigList[sType]->m_sValue5, m_pMagicConfigList[sType]->m_sValue6 + iWhetherBonus, TRUE, iMagicAttr);
				}
				break;	
				
			case DEF_MAGICTYPE_HPUP_SPOT: // 2
				m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, dX, dY);
				Effect_HpUp_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue4, m_pMagicConfigList[sType]->m_sValue5, m_pMagicConfigList[sType]->m_sValue6);
				break;

			case DEF_MAGICTYPE_DAMAGE_AREA: // 3 (will fly from spell center point)
				// Central point strike (harder to resist this attack)
				if (m_pMagicConfigList[sType]->m_sType >= 80) iResult += 100; // Hard to resist MS
				m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, dX, dY);
				if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult+50) == FALSE)
					Effect_Damage_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue4, m_pMagicConfigList[sType]->m_sValue5, m_pMagicConfigList[sType]->m_sValue6 + iWhetherBonus, TRUE, iMagicAttr);
				//Dead Owner central strike
				m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetDeadOwner(&sOwnerH, &cOwnerType, dX, dY);
				if ((cOwnerType == DEF_OWNERTYPE_PLAYER) && (m_pClientList[sOwnerH] != NULL) && (m_pClientList[sOwnerH]->m_iHP > 0)) 
				{	if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult+100) == FALSE)
						Effect_Damage_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue4, m_pMagicConfigList[sType]->m_sValue5, m_pMagicConfigList[sType]->m_sValue6 + iWhetherBonus, TRUE, iMagicAttr);
				}
				// Fly from targeted point with no double strike/fly...
				for (iy = dY - m_pMagicConfigList[sType]->m_sValue3; iy < dY; iy++)// up left
				for (ix = dX - m_pMagicConfigList[sType]->m_sValue2; ix < dX; ix++) 
				{	m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, ix, iy);
					if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE)
						Effect_Damage_Spot_DamageMove(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, dX, dY, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9 + iWhetherBonus, FALSE, iMagicAttr);
				}
				for (iy = dY + m_pMagicConfigList[sType]->m_sValue3; iy >= dY; iy--)// down left
				for (ix = dX - m_pMagicConfigList[sType]->m_sValue2; ix < dX; ix++) 
				{	m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, ix, iy);
					if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE)
						Effect_Damage_Spot_DamageMove(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, dX, dY, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9 + iWhetherBonus, FALSE, iMagicAttr);
				}
				for (iy = dY - m_pMagicConfigList[sType]->m_sValue3; iy < dY; iy++)
				for (ix = dX + m_pMagicConfigList[sType]->m_sValue2 ; ix >= dX; ix--) // up right
				{	m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, ix, iy);
					if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE)
						Effect_Damage_Spot_DamageMove(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, dX, dY, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9 + iWhetherBonus, FALSE, iMagicAttr);
				}
				for (iy = dY + m_pMagicConfigList[sType]->m_sValue3; iy >= dY; iy--) // down right
				for (ix = dX + m_pMagicConfigList[sType]->m_sValue2; ix >= dX; ix--) 
				{	m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, ix, iy);
					if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE)
						Effect_Damage_Spot_DamageMove(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, dX, dY, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9 + iWhetherBonus, FALSE, iMagicAttr);
				}
				// Dead owner will not fly
				for (iy = dY - m_pMagicConfigList[sType]->m_sValue3; iy <= dY + m_pMagicConfigList[sType]->m_sValue3; iy++)
				for (ix = dX - m_pMagicConfigList[sType]->m_sValue2; ix <= dX + m_pMagicConfigList[sType]->m_sValue2; ix++) 
				{	m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetDeadOwner(&sOwnerH, &cOwnerType, dX, dY);				
					if ((cOwnerType == DEF_OWNERTYPE_PLAYER) && (m_pClientList[sOwnerH] != NULL) && (m_pClientList[sOwnerH]->m_iHP > 0)) 
					{	if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult+50) == FALSE)
							Effect_Damage_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9 + iWhetherBonus, FALSE, iMagicAttr);
				}	}				
				break;					

			case DEF_MAGICTYPE_SPDOWN_AREA: //5
				m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, dX, dY);
				if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult+100) == FALSE)
					Effect_SpDown_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue4, m_pMagicConfigList[sType]->m_sValue5, m_pMagicConfigList[sType]->m_sValue6);
				for (iy = dY - m_pMagicConfigList[sType]->m_sValue3; iy <= dY + m_pMagicConfigList[sType]->m_sValue3; iy++)
				for (ix = dX - m_pMagicConfigList[sType]->m_sValue2; ix <= dX + m_pMagicConfigList[sType]->m_sValue2; ix++) {
					m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, ix, iy);
					if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult+10) == FALSE)
						Effect_SpDown_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9);
				}
				break;

			case DEF_MAGICTYPE_SPUP_AREA: // 7
				m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, dX, dY);
				Effect_SpUp_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue4, m_pMagicConfigList[sType]->m_sValue5, m_pMagicConfigList[sType]->m_sValue6);
				for (iy = dY - m_pMagicConfigList[sType]->m_sValue3; iy <= dY + m_pMagicConfigList[sType]->m_sValue3; iy++)
					for (ix = dX - m_pMagicConfigList[sType]->m_sValue2; ix <= dX + m_pMagicConfigList[sType]->m_sValue2; ix++) {
						m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, ix, iy);
						Effect_SpUp_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9);
					}
				break;

			case DEF_MAGICTYPE_TELEPORT: // 8
				//  sValue 
				m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, dX, dY);
//SNOOPY: Added possible TP spells to special places
				switch (m_pMagicConfigList[sType]->m_sValue4) {
					case 1:	// Recall
						if ( (cOwnerType == DEF_OWNERTYPE_PLAYER) && (sOwnerH == iClientH) ) 
						{	RequestTeleportHandler(iClientH, "1   ");
						}
					break;
					case 2: // Bisle
						if ( (cOwnerType == DEF_OWNERTYPE_PLAYER) && (sOwnerH == iClientH) ) {
							RequestTeleportHandler(iClientH, "3   ", "bisle", -1, -1);
						}
					break;	
					case 3: // Temple, depending on religion
						if ( (cOwnerType == DEF_OWNERTYPE_PLAYER) && (sOwnerH == iClientH) ) 
						{	if (m_pClientList[iClientH]->m_cSide == 2) 
							{	RequestTeleportHandler(iClientH, "3   ", "cath_2", -1, -1);
							}
							else if (m_pClientList[iClientH]->m_cSide == 1) 
							{	RequestTeleportHandler(iClientH, "3   ", "cath_1", -1, -1);									
							}	
						}	
					break;
					case 4: // Equilibrium
						if ( (cOwnerType == DEF_OWNERTYPE_PLAYER) && (sOwnerH == iClientH) && (m_bMapModeEquilibrium) ) {
							RequestTeleportHandler(iClientH, "3   ", "lost", -1, -1);
						}
					break;	
					}
				break;

			case DEF_MAGICTYPE_SUMMON: //9
				if (m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_bIsFightZone == TRUE) goto MAGIC_NOEFFECT;
				m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, dX, dY);	// Owner Master. 
				if ((sOwnerH != NULL) && (cOwnerType == DEF_OWNERTYPE_PLAYER)) 
					// SNOOPY: not possible to summon on ennemy
				{	if (m_pClientList[iClientH]->m_cSide != m_pClientList[sOwnerH]->m_cSide) goto MAGIC_NOEFFECT;						
					// Master 
					iFollowersNum = iGetFollowerNumber(sOwnerH, cOwnerType);
					if (   (m_bHeldenianWarInitiated == TRUE)
						&& (m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_bIsHeldenianMap == TRUE)) 
					{	if (iFollowersNum >= 5)	goto MAGIC_NOEFFECT;
					}else							// 1 summon per 20 skill
					{	if (iFollowersNum >= (m_pClientList[iClientH]->m_cSkillMastery[4]/20)) goto MAGIC_NOEFFECT;						
					}
					iNamingValue = m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->iGetEmptyNamingValue();
					if (iNamingValue == -1) 
					{}else 	// NPC
					{	ZeroMemory(cName, sizeof(cName));
						wsprintf(cName, "XX%d", iNamingValue);
						cName[0] = '_';
						cName[1] = m_pClientList[iClientH]->m_cMapIndex+65;
						// Magery
						ZeroMemory(cNpcName, sizeof(cNpcName));
						switch (iV1) {
						case NULL: 
							// Prevent Summon spells but item use is checked at ::UseItemHandler()
							if (m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_bIsHeldenianMap == TRUE) goto MAGIC_NOEFFECT; 
							switch (m_pClientList[iClientH]->m_iPriestDruidID) {
							case 2: // Druid's summons
								iResult = iDice(1, m_pClientList[iClientH]->m_cSkillMastery[4] / 10);
								if (iResult < m_pClientList[iClientH]->m_cSkillMastery[4] / 20) 
									iResult = m_pClientList[iClientH]->m_cSkillMastery[4] / 20;
								if (iResult < m_pClientList[iClientH]->m_iCharisma / 15) 
									iResult = iDice(1,5)+5;
								switch (iResult) {
								case 1: strcpy(cNpcName, "Rabbit"); break;
								case 2: strcpy(cNpcName, "Giant-Ant"); break;
								case 3: strcpy(cNpcName, "Amphis"); break;
								case 4: strcpy(cNpcName, "Cat"); break;
								case 5: strcpy(cNpcName, "Scorpion"); break;
								case 6: strcpy(cNpcName, "Rudolph"); break;
								case 7:	strcpy(cNpcName, "Frog"); break;
								case 8:	strcpy(cNpcName, "DireBoar"); break;
								case 9:	strcpy(cNpcName, "Plant"); break;
								case 10:strcpy(cNpcName, "Giant-Tree"); break;
								}
								break;
							case 1: // Priests's summons
								iResult = iDice(1, m_pClientList[iClientH]->m_cSkillMastery[4] / 10);
								switch (iResult) {
								case 1: strcpy(cNpcName, "Skeleton"); break;
								case 2: strcpy(cNpcName, "Zombie");   break;
								case 3: strcpy(cNpcName, "Skeleton"); break;
								case 4: strcpy(cNpcName, "Zombie");   break;
								case 5: strcpy(cNpcName, "Skeleton"); break;
								case 6:	strcpy(cNpcName, "Zombie");   break;
								case 7: if (iDice(1,500) < m_pClientList[iClientH]->m_iCharisma)
											strcpy(cNpcName, "Liche");
										else strcpy(cNpcName, "Skeleton"); 
										break;
								case 8:	strcpy(cNpcName, "Hellbound"); break;
								case 9:	if (iDice(1,100) < m_pClientList[iClientH]->m_iCharisma)
										strcpy(cNpcName, "Liche"); 
										else
											strcpy(cNpcName, "Zombie");
									break;
								case 10: if (iDice(1,450) < m_pClientList[iClientH]->m_iCharisma)
											strcpy(cNpcName, "Demon"); 
										else
											strcpy(cNpcName, "Skeleton");
									break;
								}
								break;
							default: // Mage or Paladins summons
								if (   (m_pClientList[iClientH]->m_iCharisma > m_pClientList[iClientH]->m_iInt)
									&& (m_pClientList[iClientH]->m_iCharisma > 29) )
								{	iResult = iDice(1, m_pClientList[iClientH]->m_cSkillMastery[4] / 10);
									switch (iResult) {
									case 1: strcpy(cNpcName, "Skeleton"); break;
									case 2: strcpy(cNpcName, "Zombie");   break;
									case 3: strcpy(cNpcName, "Skeleton"); break;
									case 4: strcpy(cNpcName, "Zombie");   break;
									case 5: strcpy(cNpcName, "Skeleton"); break;
									case 6:	strcpy(cNpcName, "Zombie");  break;
									case 7: if (iDice(1,500) < m_pClientList[iClientH]->m_iCharisma)
												strcpy(cNpcName, "Liche"); 
											else strcpy(cNpcName, "Skeleton"); 
											break;
									case 8: strcpy(cNpcName, "Hellbound"); break;
									case 9:
									case 10: if (iDice(1,360) < m_pClientList[iClientH]->m_iCharisma)
												strcpy(cNpcName, "Liche"); 
											else
												strcpy(cNpcName, "Skeleton");
											break;
										}
								}else // Mage summons
								{	iResult = iDice(1, m_pClientList[iClientH]->m_cSkillMastery[4] / 10);
									if (iResult < m_pClientList[iClientH]->m_cSkillMastery[4] / 20) 
										iResult = m_pClientList[iClientH]->m_cSkillMastery[4] / 20;
									switch (iResult) {
									case 1: strcpy(cNpcName, "Slime"); break;
									case 2: strcpy(cNpcName, "Giant-Ant"); break;
									case 3: strcpy(cNpcName, "Amphis"); break;
									case 4: strcpy(cNpcName, "Orc"); break;
									case 5: strcpy(cNpcName, "Skeleton"); break;
									case 6:	strcpy(cNpcName, "Clay-Golem"); break;
									case 7:	strcpy(cNpcName, "Stone-Golem"); break;
									case 8: strcpy(cNpcName, "Orc-Mage"); break;
									case 9:	strcpy(cNpcName, "Hellbound"); break;
									case 10:strcpy(cNpcName, "Cyclops"); break;
								}	}
							} // End of m_iPriestDruidID switch
							break;// End of spell summons // Fin Case NULL
						case 1:	strcpy(cNpcName, "Orc"); break; 
						case 2: strcpy(cNpcName, "Skeleton"); break;
						case 3: strcpy(cNpcName, "Clay-Golem"); break;
						case 4: strcpy(cNpcName, "Stone-Golem"); break;
						case 5: strcpy(cNpcName, "Hellbound"); break;
						case 6: strcpy(cNpcName, "Cyclops"); break;
						case 7: strcpy(cNpcName, "Troll"); break;
						case 8: strcpy(cNpcName, "Ogre"); break;
						case 9: // SummonScroll(SOR)
							switch (m_pClientList[iClientH]->m_cSide) {
								case 1:  strcpy(cNpcName, "Sor-Aresden"); break;
								case 2:  strcpy(cNpcName, "Sor-Elvine"); break;
								default: strcpy(cNpcName, "Evil-Sorceress"); break;
							} 
							break;
						case 10: // SummonScroll(ATK)
							switch (m_pClientList[iClientH]->m_cSide) {
								case 1:  strcpy(cNpcName, "ATK-Aresden"); break;
								case 2:  strcpy(cNpcName, "ATK-Elvine"); break;
								default: strcpy(cNpcName, "Evil-ATK"); break;
							}
							break;
						case 11: // SummonScroll(ELF)
							switch (m_pClientList[iClientH]->m_cSide) {
								case 1:  strcpy(cNpcName, "Elf-Aresden"); break;
								case 2:  strcpy(cNpcName, "Elf-Elvine"); break;
								default: strcpy(cNpcName, "Evil-Elf"); break;
							}
							break;
						case 12: // SummonScroll(DSK)	
							switch (m_pClientList[iClientH]->m_cSide) {
								case 1:  strcpy(cNpcName, "DSK-Aresden"); break;
								case 2:  strcpy(cNpcName, "DSK-Elvine"); break;
								default: strcpy(cNpcName, "Evil-DSK"); break;
							}
							break;
						case 13: // SummonScroll(HBT)
							switch (m_pClientList[iClientH]->m_cSide) {
								case 1:  strcpy(cNpcName, "HBT-Aresden"); break;
								case 2:  strcpy(cNpcName, "HBT-Elvine"); break;
								default: break;
							}
							break;
						case 14: // SummonScroll(BAR)
							switch (m_pClientList[iClientH]->m_cSide) {
								case 1:  strcpy(cNpcName, "Bar-Aresden"); break;
								case 2:  strcpy(cNpcName, "Bar-Elvine"); break;
								default: strcpy(cNpcName, "Evil-Barbarian"); break;
								}
							break;
// SNOOPY: Specials for Equilibrium
						case 15: strcpy(cNpcName, "WereWolf"); break;
						case 16: strcpy(cNpcName, "Demon"); break;
						case 17: strcpy(cNpcName, "Unicorn"); break;
						case 18: strcpy(cNpcName, "BG"); break;				// Battle Golem
						case 19: strcpy(cNpcName, "Evil-Sorceress"); break; // Sorceress
						case 20: strcpy(cNpcName, "Evil-ATK"); break;		// Knight
// In case of addition, think pu put them on log files as well...::_bItemLog
						}
						if (bCreateNewNpc(cNpcName, cName, m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cName, 0, 0, DEF_MOVETYPE_RANDOM, &dX, &dY, cNpcWaypoint, NULL, NULL, m_pClientList[iClientH]->m_cSide, FALSE, TRUE) == FALSE)
						{	m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->SetNamingValueEmpty(iNamingValue);
						}else 
						{	ZeroMemory(cName_Master, sizeof(cName_Master));
							switch (cOwnerType) {
								case DEF_OWNERTYPE_PLAYER:
									memcpy(cName_Master, m_pClientList[sOwnerH]->m_cCharName, 10);
									break;
								case DEF_OWNERTYPE_NPC:
									memcpy(cName_Master, m_pNpcList[sOwnerH]->m_cName, 5);
									break;
							}
							bSetNpcFollowMode(cName, cName_Master, cOwnerType);
						}		
						// SNOOPY: May log the summon if big npc DEF_ITEMLOG_SUMMONMONSTER								
						_bItemLog(DEF_ITEMLOG_SUMMONMONSTER,iClientH,cNpcName,NULL);
				}	}
				break;

			case DEF_MAGICTYPE_CREATE: //10 CreateFood
				if ( m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->bGetIsMoveAllowedTile(dX, dY) == FALSE )
					goto MAGIC_NOEFFECT;
				pItem = new class CItem;
				switch (m_pMagicConfigList[sType]->m_sValue4) {
				case 1:	// Food
					if (iDice(1,2) == 1)
						wsprintf(cItemName, "Meat");
					else wsprintf(cItemName, "Baguette");
					break;
				// Added new possibilities
				case 2: // Fishes
					switch(iDice(1,12)) {
						case 1: wsprintf(cItemName, "YellowFish");break;
						case 2: wsprintf(cItemName, "RedFish");   break;
						case 3: wsprintf(cItemName, "GreenFish"); break;
						default: wsprintf(cItemName, "Fish");     break;
					}						
					break;
				case 3: // Arrow
					wsprintf(cItemName, "Arrow");
					break;
				}
				_bInitItemAttr(pItem, cItemName);
				pItem->m_sTouchEffectType   = DEF_ITET_ID;
				pItem->m_sTouchEffectValue1 = iDice(1,100000);
				pItem->m_sTouchEffectValue2 = iDice(1,100000);
				SYSTEMTIME SysTime;
				GetLocalTime(&SysTime);
				ZeroMemory(cTemp, sizeof(cTemp));
				wsprintf(cTemp, "%d%2d",  (short)SysTime.wMonth, (short)SysTime.wDay);
				pItem->m_sTouchEffectValue3 = atoi(cTemp);
				m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->bSetItem(dX, dY, pItem);
				_bItemLog(DEF_ITEMLOG_DROP, iClientH, (int) -1, pItem);
				SendEventToNearClient_TypeB(MSGID_EVENT_COMMON, DEF_COMMONTYPE_ITEMDROP, m_pClientList[iClientH]->m_cMapIndex,
					dX, dY, pItem->m_sSprite, pItem->m_sSpriteFrame, pItem->m_cItemColor); // v1.4 color
				break;

			case DEF_MAGICTYPE_PROTECT: //11 PFA PFM GDShield....etc
				m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, dX, dY);
				switch (cOwnerType) {
				case DEF_OWNERTYPE_PLAYER:
					if (m_pClientList[sOwnerH] == NULL) goto MAGIC_NOEFFECT;
					if (m_pClientList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_PROTECT ] != 0) goto MAGIC_NOEFFECT;
					if (   (m_pClientList[iClientH]->m_cSide == 0)
						&& (m_pClientList[iClientH]->m_iAdminUserLevel < 1)
						&& (iClientH != sOwnerH)) goto MAGIC_NOEFFECT ;						
					m_pClientList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_PROTECT ] = (char)m_pMagicConfigList[sType]->m_sValue4;
					switch (m_pMagicConfigList[sType]->m_sValue4){								
					case 1:
						SetProtectionFromArrowFlag(sOwnerH, DEF_OWNERTYPE_PLAYER, TRUE);
						break;
					case 2:
					case 5:
						SetMagicProtectionFlag(sOwnerH, DEF_OWNERTYPE_PLAYER, TRUE);
						break;
					case 3: // Defence Shield
						if (m_pMagicConfigList[sType]->m_sValue5 > 0)
							m_pClientList[sOwnerH]->m_cMagicEffectStatus[DEF_MAGICTYPE_DEFENCESHIELD_VALUE] = (char)m_pMagicConfigList[sType]->m_sValue5;	
						else m_pClientList[sOwnerH]->m_cMagicEffectStatus[DEF_MAGICTYPE_DEFENCESHIELD_VALUE] = 40;
						SetDefenseShieldFlag(sOwnerH, DEF_OWNERTYPE_PLAYER, TRUE);
						break;
					case 4: // Great Defence Shield
						if (m_pMagicConfigList[sType]->m_sValue5 > 0)
							m_pClientList[sOwnerH]->m_cMagicEffectStatus[DEF_MAGICTYPE_DEFENCESHIELD_VALUE] = (char)m_pMagicConfigList[sType]->m_sValue5;	
						else m_pClientList[sOwnerH]->m_cMagicEffectStatus[DEF_MAGICTYPE_DEFENCESHIELD_VALUE] = 100;
						SetDefenseShieldFlag(sOwnerH, DEF_OWNERTYPE_PLAYER, TRUE);
						break;
					}
					break;
				case DEF_OWNERTYPE_NPC:
					if (m_pNpcList[sOwnerH] == NULL) goto MAGIC_NOEFFECT;
					if (m_pNpcList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_PROTECT ] != 0) goto MAGIC_NOEFFECT;
					if (m_pNpcList[sOwnerH]->m_cActionLimit > 1 ) goto MAGIC_NOEFFECT;
					m_pNpcList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_PROTECT ] = (char)m_pMagicConfigList[sType]->m_sValue4;
					switch (m_pMagicConfigList[sType]->m_sValue4){
					case 1:
						SetProtectionFromArrowFlag(sOwnerH, DEF_OWNERTYPE_NPC, TRUE);
						break;
					case 2:
					case 5:
						SetMagicProtectionFlag(sOwnerH, DEF_OWNERTYPE_NPC, TRUE);
						break;
					case 3: // Defence Shield
						if (m_pMagicConfigList[sType]->m_sValue5 > 0)
							m_pNpcList[sOwnerH]->m_cMagicEffectStatus[DEF_MAGICTYPE_DEFENCESHIELD_VALUE] = (char)m_pMagicConfigList[sType]->m_sValue5;	
						else m_pNpcList[sOwnerH]->m_cMagicEffectStatus[DEF_MAGICTYPE_DEFENCESHIELD_VALUE] = 40;
						SetDefenseShieldFlag(sOwnerH, DEF_OWNERTYPE_NPC, TRUE);
						break;
					case 4: // Great Defence Shield
						if (m_pMagicConfigList[sType]->m_sValue5 > 0)
							m_pNpcList[sOwnerH]->m_cMagicEffectStatus[DEF_MAGICTYPE_DEFENCESHIELD_VALUE] = (char)m_pMagicConfigList[sType]->m_sValue5;	
						else m_pNpcList[sOwnerH]->m_cMagicEffectStatus[DEF_MAGICTYPE_DEFENCESHIELD_VALUE] = 100;
						SetDefenseShieldFlag(sOwnerH, DEF_OWNERTYPE_NPC, TRUE);
						break;
					}
					break;   
				}
				bRegisterDelayEvent(DEF_DELAYEVENTTYPE_MAGICRELEASE, DEF_MAGICTYPE_PROTECT, dwTime + (m_pMagicConfigList[sType]->m_dwLastTime*1000), 
					sOwnerH, cOwnerType, NULL, NULL, NULL, m_pMagicConfigList[sType]->m_sValue4, NULL, NULL);
				if (cOwnerType == DEF_OWNERTYPE_PLAYER)
					SendNotifyMsg(NULL, sOwnerH, DEF_NOTIFY_MAGICEFFECTON, DEF_MAGICTYPE_PROTECT, m_pMagicConfigList[sType]->m_sValue4, NULL, NULL);
				break;

			case DEF_MAGICTYPE_HOLDOBJECT: // 12 para
				cParaLevel = m_pMagicConfigList[sType]->m_sValue4;
				cParaLevelID = cParaLevel;
				if (   (cParaLevel > 1)
					&& (cParaLevel != 20)
					&& (m_pClientList[iClientH]->m_cSkillMastery[4] == 100))
				{	cParaLevel ++;
					if (iDice(4,100) < (m_pClientList[iClientH]->m_iMag + m_pClientList[iClientH]->m_iAngelicMag)) cParaLevel ++;
				}
				m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, dX, dY);
				if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE) 
				{	switch (cOwnerType) {
					case DEF_OWNERTYPE_PLAYER:
						if (m_pClientList[sOwnerH] == NULL) goto MAGIC_NOEFFECT;
						if (m_pClientList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_HOLDOBJECT ] != 0) goto MAGIC_NOEFFECT;
						if ((cParaLevel > 4) && (cParaLevel < 20) && (m_pClientList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_PROTECT ] == 2)) 
							cParaLevel = 4;
						if (   (m_bIsHeldenianMode == TRUE)		// hold spell don't work on players before war has begun
							&& (m_bHeldenianWarInitiated == FALSE)								
							&& (m_pClientList[iClientH]->m_iAdminUserLevel < 1)
							&& (m_pMapList[m_pClientList[iClientH]->m_cMapIndex] != 0) 
							&& (m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_bIsHeldenianMap == TRUE)) goto MAGIC_NOEFFECT; 
						
						// Give a chance anti-Para if very good PR.. & Medusa neck. 
						if (   ((m_pClientList[sOwnerH]->m_cSkillMastery[23] + m_pClientList[sOwnerH]->m_iAddPR + iDice(1,100)) >= 250) 
							&& (m_pClientList[sOwnerH]->m_iSpecialAbilityType != 3) && (cParaLevel < 20)) goto MAGIC_NOEFFECT;
						// Monks Druids 130+ Para invulnerables
						if ((m_pClientList[sOwnerH]->m_iPriestDruidID == 3 ) && (m_pClientList[sOwnerH]->m_iLevel >129) && (cParaLevel < 20)) goto MAGIC_NOEFFECT;  
						if ((m_pClientList[sOwnerH]->m_iPriestDruidID == 2 ) && (m_pClientList[sOwnerH]->m_iLevel >129) && (cParaLevel < 20)) goto MAGIC_NOEFFECT;  
						if (   (m_pClientList[iClientH]->m_cSide == 0)
							&& (m_pClientList[iClientH]->m_iAdminUserLevel < 1)) goto MAGIC_NOEFFECT ;						
						if (  cOwnerType == DEF_OWNERTYPE_PLAYER ) // (No-Attack-Area) 
						{	if (m_pMapList[m_pClientList[sOwnerH]->m_cMapIndex]->iGetAttribute(sX, sY, 0x00000006) != 0) goto MAGIC_NOEFFECT;
							if (m_pMapList[m_pClientList[sOwnerH]->m_cMapIndex]->iGetAttribute(dX, dY, 0x00000006) != 0) goto MAGIC_NOEFFECT;
						}
						m_pClientList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_HOLDOBJECT ] = cParaLevel;	
						bRegisterDelayEvent(DEF_DELAYEVENTTYPE_MAGICRELEASE, DEF_MAGICTYPE_HOLDOBJECT, dwTime + (m_pMagicConfigList[sType]->m_dwLastTime*1000), 
							sOwnerH, cOwnerType, NULL, NULL, NULL, cParaLevel, NULL, NULL);	
						if (cParaLevel == 20 )						// 20: Medusa Kiss
						{}else if (cParaLevel >8) cParaLevel = 9;	// 9:  Entangle
						else if (cParaLevel >1) cParaLevel = 2;
						SendNotifyMsg(NULL, sOwnerH, DEF_NOTIFY_MAGICEFFECTON, DEF_MAGICTYPE_HOLDOBJECT, cParaLevelID, NULL, NULL);
						break;

					case DEF_OWNERTYPE_NPC:
						if (m_pNpcList[sOwnerH] == NULL) goto MAGIC_NOEFFECT;
						if (m_pNpcList[sOwnerH]->m_iNpcBossType == 1) goto MAGIC_NOEFFECT; // Boss are never paralysed
						if (cParaLevel > 102 ) cParaLevel = 12; // top Paralevel due to Medusa Kiss
						// SNOOPY: Added support of Entangling npc than you can't para.
						if (m_pNpcList[sOwnerH]->m_cMagicLevel >= 6)
						{	if (cParaLevel < 6) 
							{	goto MAGIC_NOEFFECT; 
							}else
							{	switch (m_pNpcList[sOwnerH]->m_sType) {
								case 32: // Uni
								case 45: // GHK
								case 47: // BG
								case 49: // HC
								case 50: // TW
								case 52: // GG
								case 66: // Wyvern
								case 73: // Fire Wyvern
								case 81: // Abaddon
									goto MAGIC_NOEFFECT; 
									break; 
								default: 
									if (m_pNpcList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_HOLDOBJECT ] >= cParaLevel) goto MAGIC_NOEFFECT;
									bRegisterDelayEvent(DEF_DELAYEVENTTYPE_MAGICRELEASE, DEF_MAGICTYPE_HOLDOBJECT, dwTime + (m_pMagicConfigList[sType]->m_dwLastTime*100), 
										sOwnerH, cOwnerType, NULL, NULL, NULL, cParaLevel, NULL, NULL);		
									m_pNpcList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_HOLDOBJECT ] = cParaLevel;						
									break;
							}	}
						}else //m_pNpcList[sOwnerH]->m_cMagicLevel <6
						{	if (m_pNpcList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_HOLDOBJECT ] >= cParaLevel) goto MAGIC_NOEFFECT;
							bRegisterDelayEvent(DEF_DELAYEVENTTYPE_MAGICRELEASE, DEF_MAGICTYPE_HOLDOBJECT, dwTime + (m_pMagicConfigList[sType]->m_dwLastTime*1000), 
								sOwnerH, cOwnerType, NULL, NULL, NULL, cParaLevel, NULL, NULL);				
							m_pNpcList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_HOLDOBJECT ] = cParaLevel;		
						}
						break;
					}// end switch cOwnerType
				}
				break;

			case DEF_MAGICTYPE_INVISIBILITY: //13
				if (   (m_bIsHeldenianMode == TRUE)		// Invi spell don't work on players before war has begun
					&& (m_bHeldenianWarInitiated == FALSE)								
					&& (m_pClientList[iClientH]->m_iAdminUserLevel < 1)
					&& (m_pMapList[m_pClientList[iClientH]->m_cMapIndex] != 0) 
					&& (m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_bIsHeldenianMap == 1)) 
				{	if ((m_iBTFieldMapIndex != -1) && (m_pClientList[iClientH]->m_cMapIndex == m_iBTFieldMapIndex))
					{	switch (m_pClientList[iClientH]->m_cSide) {
						case 2: // Elvine can't invi on SW side 
							if (m_pClientList[iClientH]->m_sX + 20 < m_pClientList[iClientH]->m_sY) goto MAGIC_NOEFFECT; 	
							break;
						case 1: // Ares can't invi on NE side
							if (m_pClientList[iClientH]->m_sY + 20  < m_pClientList[iClientH]->m_sX) goto MAGIC_NOEFFECT; 	
							break;
					}	}		
					if ((m_iRampartMapIndex != -1) && (m_pClientList[iClientH]->m_cMapIndex == m_iRampartMapIndex))
					{	goto MAGIC_NOEFFECT; 
					}
				}

				switch (m_pMagicConfigList[sType]->m_sValue4) {
				case 1: // Invis
					m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, dX, dY);	
					switch (cOwnerType) {
					case DEF_OWNERTYPE_PLAYER:
						if (m_pClientList[sOwnerH] == NULL) goto MAGIC_NOEFFECT;
						if (m_pClientList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_INVISIBILITY ] != 0) goto MAGIC_NOEFFECT;
						if (   (m_pClientList[iClientH]->m_cSide == 0)
							&& (m_pClientList[iClientH]->m_iAdminUserLevel < 1)
							&& (iClientH != sOwnerH)) goto MAGIC_NOEFFECT ;
						m_pClientList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_INVISIBILITY ] = (char)m_pMagicConfigList[sType]->m_sValue4;
						SetInvisibilityFlag(sOwnerH, cOwnerType, TRUE);
						RemoveFromTarget(sOwnerH, DEF_OWNERTYPE_PLAYER, DEF_MAGICTYPE_INVISIBILITY);
						break;

					case DEF_OWNERTYPE_NPC:
						if (m_pNpcList[sOwnerH] == NULL) goto MAGIC_NOEFFECT;
						if (m_pNpcList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_INVISIBILITY ] != 0) goto MAGIC_NOEFFECT;
						if (m_pNpcList[sOwnerH]->m_cActionLimit < 1) 
						{	m_pNpcList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_INVISIBILITY ] = (char)m_pMagicConfigList[sType]->m_sValue4;
							SetInvisibilityFlag(sOwnerH, cOwnerType, TRUE);
							RemoveFromTarget(sOwnerH, DEF_OWNERTYPE_NPC, DEF_MAGICTYPE_INVISIBILITY);	
						}
						break;
					} 
					// Perform the magic
					if (   (m_bIsAvatarMode == TRUE)
						&& (m_iPLmapIndex != -1) 
						&& (cOwnerType == DEF_OWNERTYPE_PLAYER)
						&& (m_iAvatarMessenger == sOwnerH)) // Avatar messenger may Invi only 3 seconds
					{	bRegisterDelayEvent(DEF_DELAYEVENTTYPE_MAGICRELEASE, DEF_MAGICTYPE_INVISIBILITY, dwTime + 3000, 
							sOwnerH, cOwnerType, NULL, NULL, NULL, m_pMagicConfigList[sType]->m_sValue4, NULL, NULL);
					}else
					{	bRegisterDelayEvent(DEF_DELAYEVENTTYPE_MAGICRELEASE, DEF_MAGICTYPE_INVISIBILITY, dwTime + (m_pMagicConfigList[sType]->m_dwLastTime*1000), 
							sOwnerH, cOwnerType, NULL, NULL, NULL, m_pMagicConfigList[sType]->m_sValue4, NULL, NULL);
					}
					if (cOwnerType == DEF_OWNERTYPE_PLAYER)
						SendNotifyMsg(NULL, sOwnerH, DEF_NOTIFY_MAGICEFFECTON, DEF_MAGICTYPE_INVISIBILITY, m_pMagicConfigList[sType]->m_sValue4, NULL, NULL);
					break;

				case 2:	// detect
					// SNOOPY: GM can always detect
					if (   (m_pClientList[iClientH]->m_cSide == 0)
							&& (m_pClientList[iClientH]->m_iAdminUserLevel < 1) ) goto MAGIC_NOEFFECT;
					// dX, dY Invisibility Object
					for (ix = dX - 8; ix <= dX + 8; ix++)
					for (iy = dY - 8; iy <= dY + 8; iy++) 
					{	m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, ix, iy);
						if (sOwnerH != NULL) {
							switch (cOwnerType) {
							case DEF_OWNERTYPE_PLAYER:
								if (m_pClientList[sOwnerH] == NULL) continue;
								if (m_pClientList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_INVISIBILITY ] != NULL) 
								{	m_pClientList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_INVISIBILITY ] = NULL;
									SetInvisibilityFlag(sOwnerH, cOwnerType, FALSE);
									bRemoveFromDelayEventList(sOwnerH, cOwnerType, DEF_MAGICTYPE_INVISIBILITY);
								}
								break;
								case DEF_OWNERTYPE_NPC:
								if (m_pNpcList[sOwnerH] == NULL) continue;
								if (m_pNpcList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_INVISIBILITY ] != NULL) 
								{	m_pNpcList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_INVISIBILITY ] = NULL;
									SetInvisibilityFlag(sOwnerH, cOwnerType, FALSE);
									bRemoveFromDelayEventList(sOwnerH, cOwnerType, DEF_MAGICTYPE_INVISIBILITY);
								}
								break;
					}	}	}
					break;
				case 3: // Beholder
					if (iClientH != sOwnerH) goto MAGIC_NOEFFECT; // Only on self
					if (   (m_pClientList[iClientH]->m_cSide == 0)
							&& (m_pClientList[iClientH]->m_iAdminUserLevel < 1) ) goto MAGIC_NOEFFECT;		
					if (m_pClientList[iClientH]->m_iBeholderPower == 0) // excludes GMs or inactivated necks (Neck are not active if you're invi)
					{	m_pClientList[iClientH]->m_iBeholderPower = m_pMagicConfigList[sType]->m_dwLastTime + 1;  
						SendNewInitMapData(iClientH);
					}
					break;
				}
				break;

			case DEF_MAGICTYPE_CREATE_DYNAMIC: //14 FireWall etc...
				// Dynamic Object .	// v2.1: don't create area spells in cities/Farm
				if (   (m_bIsHeldenianMode == TRUE)		// Poison spell don't work before war has begun
					&& (m_bHeldenianWarInitiated == FALSE)
					&& (m_pClientList[iClientH]->m_iAdminUserLevel < 1)
					&& (m_pMapList[m_pClientList[iClientH]->m_cMapIndex] != 0) 
					&& (m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_bIsHeldenianMap == 1)) goto MAGIC_NOEFFECT; 
				if (m_bIsCrusadeMode == FALSE) 
				{	if (strcmp(m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cName, "arefarm") == 0) goto MAGIC_NOEFFECT;
					if (strcmp(m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cName, "elvfarm") == 0) goto MAGIC_NOEFFECT;						
					if (m_bMapModeEquilibrium) { // Equilibrium	
						if (strcmp(m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cName, "lost") == 0) goto MAGIC_NOEFFECT;
					}else 	// or standard cities										
					{	if (strcmp(m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cName, "aresden") == 0) goto MAGIC_NOEFFECT;
						if (strcmp(m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cName, "elvine") == 0) goto MAGIC_NOEFFECT;
					}
				}
				switch (m_pMagicConfigList[sType]->m_sValue10) {
				case DEF_DYNAMICOBJECT_PCLOUD_BEGIN: // 10: Poison 
				case DEF_DYNAMICOBJECT_FIRE:   // 1: Fire .
				case DEF_DYNAMICOBJECT_SPIKE:  // 9: Spike
#ifdef DEF_TAIWANLOG 
					short sTemp_X, sTemp_Y ;
					// v2.15 
					sTemp_X = m_pClientList[iClientH]->m_sX ;
					sTemp_Y = m_pClientList[iClientH]->m_sY ;
					m_pClientList[iClientH]->m_sX = dX;
					m_pClientList[iClientH]->m_sY = dY;
					_bItemLog(DEF_ITEMLOG_SPELLFIELD,iClientH,m_pMagicConfigList[sType]->m_cName,NULL) ;	
					m_pClientList[iClientH]->m_sX = sTemp_X;
					m_pClientList[iClientH]->m_sY = sTemp_Y;
#endif
					switch (m_pMagicConfigList[sType]->m_sValue11) {
					case 1: // wall - type					
						cDir = m_Misc.cGetNextMoveDir(m_pClientList[iClientH]->m_sX, m_pClientList[iClientH]->m_sY, dX, dY);
						switch (cDir) {
						case 1:	rx = 1; ry = 0;   break;
						case 2: rx = 1; ry = 1;   break;
						case 3: rx = 0; ry = 1;   break;
						case 4: rx = -1; ry = 1;  break;
						case 5: rx = 1; ry = 0;   break;
						case 6: rx = -1; ry = -1; break;
						case 7: rx = 0; ry = -1;  break;
						case 8: rx = 1; ry = -1;  break;
						}
						iAddDynamicObjectList(iClientH, DEF_OWNERTYPE_PLAYER_INDIRECT, m_pMagicConfigList[sType]->m_sValue10, m_pClientList[iClientH]->m_cMapIndex, 
							dX, dY, m_pMagicConfigList[sType]->m_dwLastTime*1000);	
						bAnalyzeCriminalAction(iClientH, dX, dY);
						for (i = 1; i <= m_pMagicConfigList[sType]->m_sValue12; i++)
						{	iAddDynamicObjectList(iClientH, DEF_OWNERTYPE_PLAYER_INDIRECT, m_pMagicConfigList[sType]->m_sValue10, m_pClientList[iClientH]->m_cMapIndex, 
								dX + i*rx, dY + i*ry, m_pMagicConfigList[sType]->m_dwLastTime*1000);	
							bAnalyzeCriminalAction(iClientH, dX + i*rx, dY + i*ry);
							iAddDynamicObjectList(iClientH, DEF_OWNERTYPE_PLAYER_INDIRECT, m_pMagicConfigList[sType]->m_sValue10, m_pClientList[iClientH]->m_cMapIndex, 
								dX - i*rx, dY - i*ry, m_pMagicConfigList[sType]->m_dwLastTime*1000);	
							bAnalyzeCriminalAction(iClientH, dX - i*rx, dY - i*ry);
						}
						break;
					case 2:// Field - Type					
						BOOL bFlag = FALSE;
						int cx, cy;
						for (ix = dX - m_pMagicConfigList[sType]->m_sValue12; ix <= dX + m_pMagicConfigList[sType]->m_sValue12; ix++)
						for (iy = dY - m_pMagicConfigList[sType]->m_sValue12; iy <= dY + m_pMagicConfigList[sType]->m_sValue12; iy++) 
						{	iAddDynamicObjectList(iClientH, DEF_OWNERTYPE_PLAYER_INDIRECT, m_pMagicConfigList[sType]->m_sValue10, m_pClientList[iClientH]->m_cMapIndex, 
								ix, iy, m_pMagicConfigList[sType]->m_dwLastTime*1000, m_pMagicConfigList[sType]->m_sValue5);	
							if (bAnalyzeCriminalAction(iClientH, ix, iy, TRUE) == TRUE) 
							{	bFlag = TRUE;
								cx = ix;
								cy = iy;
							}
						}
						if (bFlag == TRUE) bAnalyzeCriminalAction(iClientH, cx, cy);
						break;
					}
				break;

				case DEF_DYNAMICOBJECT_ICESTORM: // Sub case of above
					// Ice-Storm Dynamic Object 
					// SNOOPY: Increase duration at snowing wheather m_cWhetherStatus
					iAddDynamicObjectList(iClientH, DEF_OWNERTYPE_PLAYER_INDIRECT, m_pMagicConfigList[sType]->m_sValue10, m_pClientList[iClientH]->m_cMapIndex, 
						dX, dY, m_pMagicConfigList[sType]->m_dwLastTime*1000,
					m_pClientList[iClientH]->m_cSkillMastery[4]);	
					break;
				default:
					break;
				}
				break;

			case DEF_MAGICTYPE_POSSESSION: //15						
				if (   (m_pClientList[iClientH]->m_cSide == 0)
						&& (m_pClientList[iClientH]->m_iAdminUserLevel < 1)) goto MAGIC_NOEFFECT ;
				m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, dX, dY);
				if (sOwnerH != NULL) break; 
				if (m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->pCheckBombItem(dX, dY))
				{	goto MAGIC_NOEFFECT ; // Don't try to catch a bomb !
				}
				pItem = m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->pGetItem(dX, dY, &sRemainItemSprite, &sRemainItemSpriteFrame, &cRemainItemColor);
				if (pItem != NULL) 
				{	if (_bAddClientItemList(iClientH, pItem, &iEraseReq) == TRUE) 
					{	_bItemLog(DEF_ITEMLOG_GET, iClientH, (int) -1, pItem);
						dwp  = (DWORD *)(cData + DEF_INDEX4_MSGID);
						*dwp = MSGID_NOTIFY;
						wp   = (WORD *)(cData + DEF_INDEX2_MSGTYPE);
						*wp  = DEF_NOTIFY_ITEMOBTAINED;
						cp = (char *)(cData + DEF_INDEX2_MSGTYPE + 2);
						*cp = 1;
						cp++;
						memcpy(cp, pItem->m_cName, 20);
						cp += 20;
						dwp  = (DWORD *)cp;
						*dwp = pItem->m_dwCount;
						cp += 4;
						*cp = pItem->m_cItemType;
						cp++;
						*cp = pItem->m_cEquipPos;
						cp++;
						*cp = (char)0;
						cp++;
						sp  = (short *)cp;
						*sp = pItem->m_sLevelLimit;
						cp += 2;
						*cp = pItem->m_cGenderLimit;
						cp++;
						wp = (WORD *)cp;
						*wp = pItem->m_wCurLifeSpan;
						cp += 2;
						wp = (WORD *)cp;
						*wp = pItem->m_wWeight;
						cp += 2;
						sp  = (short *)cp;
						*sp = pItem->m_sSprite;
						cp += 2;
						sp  = (short *)cp;
						*sp = pItem->m_sSpriteFrame;
						cp += 2;
						*cp = pItem->m_cItemColor;
						cp++;
						*cp = (char)pItem->m_sItemSpecEffectValue2; // v1.41 
						cp++;
						dwp = (DWORD *)cp;
						*dwp = pItem->m_dwAttribute;
						cp += 4;
						/*
						*cp = (char)(pItem->m_dwAttribute & 0x00000001); 
						// Custom-Item
						cp++;
						*/
						if (iEraseReq == 1) delete pItem;
						SendEventToNearClient_TypeB(MSGID_EVENT_COMMON, DEF_COMMONTYPE_SETITEM, m_pClientList[iClientH]->m_cMapIndex,
							dX, dY,	sRemainItemSprite, sRemainItemSpriteFrame, cRemainItemColor); // v1.4
						iRet = m_pClientList[iClientH]->m_pXSock->iSendMsg(cData, 53);
						switch (iRet) {
							case DEF_XSOCKEVENT_QUENEFULL:
							case DEF_XSOCKEVENT_SOCKETERROR:
							case DEF_XSOCKEVENT_CRITICALERROR:
							case DEF_XSOCKEVENT_SOCKETCLOSED:
								DeleteClient(iClientH, TRUE, TRUE);
								return;
						}
					}else 
					{	m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->bSetItem(dX, dY, pItem);
						dwp  = (DWORD *)(cData + DEF_INDEX4_MSGID);
						*dwp = MSGID_NOTIFY;
						wp   = (WORD *)(cData + DEF_INDEX2_MSGTYPE);
						*wp  = DEF_NOTIFY_CANNOTCARRYMOREITEM;
						iRet = m_pClientList[iClientH]->m_pXSock->iSendMsg(cData, 6);
						switch (iRet) {
							case DEF_XSOCKEVENT_QUENEFULL:
							case DEF_XSOCKEVENT_SOCKETERROR:
							case DEF_XSOCKEVENT_CRITICALERROR:
							case DEF_XSOCKEVENT_SOCKETCLOSED:
								DeleteClient(iClientH, TRUE, TRUE);
								return;
						}
					}
				}
				break;

			case DEF_MAGICTYPE_CONFUSE: // 16
				// if the caster side is the same as the targets side, no effect occurs
				if (   (m_bIsHeldenianMode == TRUE)		// Confusion type spell don't work before war has begun
					&& (m_bHeldenianWarInitiated == FALSE)
					&& (m_pClientList[iClientH]->m_iAdminUserLevel < 1)
					&& (m_pMapList[m_pClientList[iClientH]->m_cMapIndex] != 0) 
					&& (m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_bIsHeldenianMap == 1)) goto MAGIC_NOEFFECT; 
				switch (m_pMagicConfigList[sType]->m_sValue4) {
				case 1: // confuse Language 
				case 2: // Confusion, Mass Confusion 	
					for (iy = dY - m_pMagicConfigList[sType]->m_sValue3; iy <= dY + m_pMagicConfigList[sType]->m_sValue3; iy++)
					for (ix = dX - m_pMagicConfigList[sType]->m_sValue2; ix <= dX + m_pMagicConfigList[sType]->m_sValue2; ix++) {
						m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, ix, iy);
						if (cOwnerType == DEF_OWNERTYPE_PLAYER) {
								// snoopy debugged: must continue and not exit !
							if (m_pClientList[sOwnerH] == NULL) continue;
							// donnot confuse self
							if (sOwnerH == iClientH) continue;
							if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE) 
							{	if (m_pClientList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_CONFUSE ] != 0) continue; 
								// Confuse
								m_pClientList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_CONFUSE ] = (char)m_pMagicConfigList[sType]->m_sValue4;
								bRegisterDelayEvent(DEF_DELAYEVENTTYPE_MAGICRELEASE, DEF_MAGICTYPE_CONFUSE, dwTime + (m_pMagicConfigList[sType]->m_dwLastTime*1000), 
									sOwnerH, cOwnerType, NULL, NULL, NULL, m_pMagicConfigList[sType]->m_sValue4, NULL, NULL);
								SendNotifyMsg(NULL, sOwnerH, DEF_NOTIFY_MAGICEFFECTON, DEF_MAGICTYPE_CONFUSE, m_pMagicConfigList[sType]->m_sValue4, iClientH, NULL);
								// SNOOPY: Send info about players arroud
								SetConfusionFlag(sOwnerH, DEF_OWNERTYPE_PLAYER, TRUE);
							}
						}else // Target is npc
						{	if (m_pNpcList[sOwnerH] == NULL) continue;										
							switch (m_pMagicConfigList[sType]->m_sValue4) {
							case 2:
								if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == TRUE) continue; 
								NpcBehavior_Flee(sOwnerH);
								break;
							}																
						}
					}	
					break;
				
				case 3: // Ilusion, Mass-Ilusion
					for (iy = dY - m_pMagicConfigList[sType]->m_sValue3; iy <= dY + m_pMagicConfigList[sType]->m_sValue3; iy++)
					for (ix = dX - m_pMagicConfigList[sType]->m_sValue2; ix <= dX + m_pMagicConfigList[sType]->m_sValue2; ix++) {
						
						m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, ix, iy);
						if (cOwnerType == DEF_OWNERTYPE_PLAYER) {
							// snoopy debugged: must continue and not exit !
							if (m_pClientList[sOwnerH] == NULL) continue;
							// donnot confuse self
							if (sOwnerH == iClientH) continue;
							
							if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE) {
								if (m_pClientList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_CONFUSE ] != 0) continue; 
								//Confuse
								m_pClientList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_CONFUSE ] = (char)m_pMagicConfigList[sType]->m_sValue4;
									switch (m_pMagicConfigList[sType]->m_sValue4) {
									case 3:
										SetIllusionFlag(sOwnerH, DEF_OWNERTYPE_PLAYER, TRUE);
										break;
								}
								bRegisterDelayEvent(DEF_DELAYEVENTTYPE_MAGICRELEASE, DEF_MAGICTYPE_CONFUSE, dwTime + (m_pMagicConfigList[sType]->m_dwLastTime*1000), 
									sOwnerH, cOwnerType, NULL, NULL, NULL, m_pMagicConfigList[sType]->m_sValue4, NULL, NULL);
								SendNotifyMsg(NULL, sOwnerH, DEF_NOTIFY_MAGICEFFECTON, DEF_MAGICTYPE_CONFUSE, m_pMagicConfigList[sType]->m_sValue4, iClientH, NULL);
							}
						}else // Target is npc
						{	if (m_pNpcList[sOwnerH] == NULL) continue;										
							switch (m_pMagicConfigList[sType]->m_sValue4) {
							case 3:
								if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == TRUE) continue; 
							NpcBehavior_Stop(sOwnerH);
								break;
							}
						}
					}	
					break;

				case 4: // Ilusion Movement
					//if (m_pClientList[iClientH]->m_cMagicEffectStatus[DEF_MAGICTYPE_INVISIBILITY] != 0) break;
					for (iy = dY - m_pMagicConfigList[sType]->m_sValue3; iy <= dY + m_pMagicConfigList[sType]->m_sValue3; iy++)
					for (ix = dX - m_pMagicConfigList[sType]->m_sValue2; ix <= dX + m_pMagicConfigList[sType]->m_sValue2; ix++) 
					{	
						m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, ix, iy);
						if (cOwnerType == DEF_OWNERTYPE_PLAYER) 
						{	// snoopy debugged: must continue and not exit !
							if (m_pClientList[sOwnerH] == NULL) continue;
							// donnot confuse self
							if (sOwnerH == iClientH) continue;
							if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE) {
								if (m_pClientList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_CONFUSE ] != 0) continue;
								m_pClientList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_CONFUSE ] = (char)m_pMagicConfigList[sType]->m_sValue4;
								switch (m_pMagicConfigList[sType]->m_sValue4) {
								case 4:
									SetIllusionMovementFlag(sOwnerH, DEF_OWNERTYPE_PLAYER, TRUE);
									break;
								}
								bRegisterDelayEvent(DEF_DELAYEVENTTYPE_MAGICRELEASE, DEF_MAGICTYPE_CONFUSE, dwTime + (m_pMagicConfigList[sType]->m_dwLastTime*1000), 
									sOwnerH, cOwnerType, NULL, NULL, NULL, m_pMagicConfigList[sType]->m_sValue4, NULL, NULL);
								SendNotifyMsg(NULL, sOwnerH, DEF_NOTIFY_MAGICEFFECTON, DEF_MAGICTYPE_CONFUSE, m_pMagicConfigList[sType]->m_sValue4, iClientH, NULL);
							}
						}							
					}
					break;	
				} // End off illusion types switch
				break;

			case DEF_MAGICTYPE_POISON: // 17 Poison & Cure
				m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, dX, dY);
				if (m_pMagicConfigList[sType]->m_sValue4 == 1) 
				{	if (   (m_bIsHeldenianMode == TRUE)		// Poison spell don't work before war has begun
						&& (m_bHeldenianWarInitiated == FALSE)							
						&& (m_pClientList[iClientH]->m_iAdminUserLevel < 1)
						&& (m_pMapList[m_pClientList[iClientH]->m_cMapIndex] != 0) 
						&& (m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_bIsHeldenianMap == 1)) goto MAGIC_NOEFFECT; 
					switch (cOwnerType) {
					case DEF_OWNERTYPE_PLAYER:
						if (m_pClientList[sOwnerH] == NULL) goto MAGIC_NOEFFECT;
						if (   (m_pClientList[iClientH]->m_cSide == 0)
							&& (m_pClientList[iClientH]->m_iAdminUserLevel < 1)) goto MAGIC_NOEFFECT;
						// Allow or not Poison depending on he map 
						bAnalyzeCriminalAction(iClientH, dX, dY);
						// Can not Magic resist a Poison spell.
						//if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, -1) == FALSE) 
						{	if (bCheckResistingPoisonSuccess(sOwnerH, cOwnerType) == FALSE) 
							{	m_pClientList[sOwnerH]->m_bIsPoisoned  = TRUE;
								m_pClientList[sOwnerH]->m_iPoisonLevel = m_pMagicConfigList[sType]->m_sValue5;
								m_pClientList[sOwnerH]->m_dwPoisonTime = dwTime;
								// 05/06/2004 - Hypnotoad - poison aura appears when cast Poison
								SetPoisonFlag(sOwnerH, cOwnerType, TRUE);
								SendNotifyMsg(NULL, sOwnerH, DEF_NOTIFY_MAGICEFFECTON, DEF_MAGICTYPE_POISON, m_pMagicConfigList[sType]->m_sValue5, NULL, NULL);
#ifdef DEF_TAIWANLOG
								_bItemLog(DEF_ITEMLOG_POISONED,sOwnerH,(char *) NULL,NULL) ;
#endif
							}
						}
						break;
					case DEF_OWNERTYPE_NPC:
						if (m_pNpcList[sOwnerH] == NULL) goto MAGIC_NOEFFECT;
						if (m_pNpcList[sOwnerH]->m_iHP <= 0) goto MAGIC_NOEFFECT;
						if (bCheckResistingPoisonSuccess(sOwnerH, cOwnerType) == FALSE) 
						{	// SNOOPY: Add support for ncp been poisonned
							if (m_pNpcList[sOwnerH]->m_iPoisonLevel < m_pMagicConfigList[sType]->m_sValue5) 
								m_pNpcList[sOwnerH]->m_iPoisonLevel = m_pMagicConfigList[sType]->m_sValue5; 
							SetPoisonFlag(sOwnerH, DEF_OWNERTYPE_NPC, TRUE);
						}							
						break;
					}
				}else if (m_pMagicConfigList[sType]->m_sValue4 == 0) { // Cure
					switch (cOwnerType) {
						case DEF_OWNERTYPE_PLAYER:
							if (m_pClientList[sOwnerH] == NULL) goto MAGIC_NOEFFECT;
							if (m_pClientList[sOwnerH]->m_bIsPoisoned == TRUE) {
								m_pClientList[sOwnerH]->m_bIsPoisoned = FALSE;
								// 05/06/2004 - Hypnotoad - poison aura removed when cure cast
								SetPoisonFlag(sOwnerH, cOwnerType, FALSE);
								SendNotifyMsg(NULL, sOwnerH, DEF_NOTIFY_MAGICEFFECTOFF, DEF_MAGICTYPE_POISON, NULL, NULL, NULL);
							}
							break;

						case DEF_OWNERTYPE_NPC:
							if (m_pNpcList[sOwnerH] == NULL) goto MAGIC_NOEFFECT;
							if (m_pNpcList[sOwnerH]->m_iPoisonLevel > 0) 
							{	m_pNpcList[sOwnerH]->m_iPoisonLevel = 0; 
								SetPoisonFlag(sOwnerH, DEF_OWNERTYPE_NPC, FALSE);
							}
							break;
					}
				}
				break;

				case DEF_MAGICTYPE_BERSERK: //18, Snoopy added new kinds of spells
				switch (m_pMagicConfigList[sType]->m_sValue4) {
				case -1: // Peace spell...
					m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, dX, dY);
					switch (cOwnerType) {
					case DEF_OWNERTYPE_PLAYER: // remove zerk, and any weapon...
						if (m_pClientList[sOwnerH] == NULL) goto MAGIC_NOEFFECT;
						if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE) 
						{	SetBerserkFlag(sOwnerH, cOwnerType, FALSE);
							// Unequip weapons 
							if(m_pClientList[sOwnerH]->m_sItemEquipmentStatus[DEF_EQUIPPOS_TWOHAND] != -1)
							{	SendNotifyMsg(NULL, sOwnerH, DEF_NOTIFY_ITEMRELEASED, DEF_EQUIPPOS_TWOHAND, m_pClientList[sOwnerH]->m_sItemEquipmentStatus[DEF_EQUIPPOS_TWOHAND], NULL, NULL);
								ReleaseItemHandler(sOwnerH, m_pClientList[sOwnerH]->m_sItemEquipmentStatus[DEF_EQUIPPOS_TWOHAND], TRUE);
							}
							if(m_pClientList[sOwnerH]->m_sItemEquipmentStatus[DEF_EQUIPPOS_RHAND] != -1)
							{	SendNotifyMsg(NULL, sOwnerH, DEF_NOTIFY_ITEMRELEASED, DEF_EQUIPPOS_RHAND, m_pClientList[sOwnerH]->m_sItemEquipmentStatus[DEF_EQUIPPOS_RHAND], NULL, NULL);
								ReleaseItemHandler(sOwnerH, m_pClientList[sOwnerH]->m_sItemEquipmentStatus[DEF_EQUIPPOS_RHAND], TRUE);
							}									
							// if an item was removed compute Total item effect
							CalcTotalItemEffect(sOwnerH, -1, false);
						}
						break;
					case DEF_OWNERTYPE_NPC: // npc flee !
						if (m_pNpcList[sOwnerH] == NULL) goto MAGIC_NOEFFECT;
						if (m_pNpcList[sOwnerH]->m_cActionLimit > 1) goto MAGIC_NOEFFECT;
						m_pNpcList[sOwnerH]->m_sBehaviorTurnCount = 0;
						m_pNpcList[sOwnerH]->m_cBehavior = DEF_BEHAVIOR_FLEE;
						m_pNpcList[sOwnerH]->m_bIsPermAttackMode = FALSE;
						m_pNpcList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_BERSERK ] = 3; // Still <=> to a mighty mob
						SetBerserkFlag(sOwnerH, cOwnerType, FALSE);
						break;
					}					
					break;

					case 0: // Prayer NG spell, only works on self
					m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, dX, dY);
					switch (cOwnerType) {
					case DEF_OWNERTYPE_PLAYER:
						if (m_pClientList[sOwnerH] == NULL) goto MAGIC_NOEFFECT;
						if ( iClientH != sOwnerH ) goto MAGIC_NOEFFECT;
						// HP up by Values 789
						Effect_HpUp_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, DEF_OWNERTYPE_PLAYER, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9);
						// Small Beserk effect (by value5)
						if (m_pClientList[iClientH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_BERSERK ] <= (char)m_pMagicConfigList[sType]->m_sValue5) 
						{	m_pClientList[iClientH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_BERSERK ] = (char)m_pMagicConfigList[sType]->m_sValue5;
								SetBerserkFlag(iClientH, DEF_OWNERTYPE_PLAYER, TRUE);
							bRegisterDelayEvent(DEF_DELAYEVENTTYPE_MAGICRELEASE, DEF_MAGICTYPE_BERSERK, dwTime + (m_pMagicConfigList[sType]->m_dwLastTime*1000), 
								sOwnerH, DEF_OWNERTYPE_PLAYER, NULL, NULL, NULL, 1, NULL, NULL);
							SendNotifyMsg(NULL, sOwnerH, DEF_NOTIFY_MAGICEFFECTON, DEF_MAGICTYPE_BERSERK, 1, NULL, NULL);
						}
						// And a pretty good Defence shield (by value6)
						if (   (m_pClientList[sOwnerH]->m_cMagicEffectStatus[DEF_MAGICTYPE_DEFENCESHIELD_VALUE] < m_pMagicConfigList[sType]->m_sValue6) 
							&& (m_pClientList[sOwnerH]->m_cMagicEffectStatus[DEF_MAGICTYPE_PROTECT] == 0))
						{	m_pClientList[sOwnerH]->m_cMagicEffectStatus[DEF_MAGICTYPE_DEFENCESHIELD_VALUE] = m_pMagicConfigList[sType]->m_sValue6;
							m_pClientList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_PROTECT ] = 4; // GreatDefShield
							SetDefenseShieldFlag(sOwnerH, DEF_OWNERTYPE_PLAYER, TRUE);						
							bRegisterDelayEvent(DEF_DELAYEVENTTYPE_MAGICRELEASE, DEF_MAGICTYPE_PROTECT, dwTime + (m_pMagicConfigList[sType]->m_dwLastTime*1000), 
								sOwnerH, DEF_OWNERTYPE_PLAYER, NULL, NULL, NULL, 4, NULL, NULL);
							SendNotifyMsg(NULL, sOwnerH, DEF_NOTIFY_MAGICEFFECTON, DEF_MAGICTYPE_PROTECT, 4, NULL, NULL);
						}
						// Anti-icing effect..
						m_pClientList[sOwnerH]->m_dwWarmEffectTime = dwTime;
						break;
					case DEF_OWNERTYPE_NPC:
						goto MAGIC_NOEFFECT;
						break;
					}
					break;

				default:	// Berserk 
					m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, dX, dY);
					switch (cOwnerType) {
					case DEF_OWNERTYPE_PLAYER:
						if (m_pClientList[sOwnerH] == NULL) goto MAGIC_NOEFFECT;
						if (m_pClientList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_BERSERK ] >= (char)m_pMagicConfigList[sType]->m_sValue4) goto MAGIC_NOEFFECT;
						m_pClientList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_BERSERK ] = (char)m_pMagicConfigList[sType]->m_sValue4;
						SetBerserkFlag(sOwnerH, cOwnerType, TRUE);
						break;

					case DEF_OWNERTYPE_NPC:
						if (m_pNpcList[sOwnerH] == NULL) goto MAGIC_NOEFFECT;
						if (m_pNpcList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_BERSERK ] >= (char)m_pMagicConfigList[sType]->m_sValue4) goto MAGIC_NOEFFECT;
						if (m_pNpcList[sOwnerH]->m_cActionLimit > 1) goto MAGIC_NOEFFECT;
						if ( m_pClientList[iClientH]->m_cSide != m_pNpcList[sOwnerH]->m_cSide ) goto MAGIC_NOEFFECT;
						m_pNpcList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_BERSERK ] = (char)3;
						SetBerserkFlag(sOwnerH, cOwnerType, TRUE);
						break;
					}
					// Variable delay for priests/Paladins
					switch (m_pClientList[iClientH]->m_iPriestDruidID) {
					case 1: // Priests
						bRegisterDelayEvent(DEF_DELAYEVENTTYPE_MAGICRELEASE, DEF_MAGICTYPE_BERSERK, dwTime + (m_pClientList[iClientH]->m_iCharisma*1000), 
							sOwnerH, cOwnerType, NULL, NULL, NULL, m_pMagicConfigList[sType]->m_sValue4, NULL, NULL);
						break;
					case 4: // Paladins
						bRegisterDelayEvent(DEF_DELAYEVENTTYPE_MAGICRELEASE, DEF_MAGICTYPE_BERSERK, dwTime + (m_pClientList[iClientH]->m_iCharisma*1000), 
							sOwnerH, cOwnerType, NULL, NULL, NULL, m_pMagicConfigList[sType]->m_sValue4, NULL, NULL);
						break;						
					default: // All others (Mage, BMages)
						bRegisterDelayEvent(DEF_DELAYEVENTTYPE_MAGICRELEASE, DEF_MAGICTYPE_BERSERK, dwTime + (m_pMagicConfigList[sType]->m_dwLastTime*1000), 
							sOwnerH, cOwnerType, NULL, NULL, NULL, m_pMagicConfigList[sType]->m_sValue4, NULL, NULL);
						break;
					}
					if (cOwnerType == DEF_OWNERTYPE_PLAYER)
						SendNotifyMsg(NULL, sOwnerH, DEF_NOTIFY_MAGICEFFECTON, DEF_MAGICTYPE_BERSERK, 1/*m_pMagicConfigList[sType]->m_sValue4*/, NULL, NULL);
					break;
				}
				break;

			case DEF_MAGICTYPE_DAMAGE_LINEAR: //19 BSW & LightBolt for players
				// m_sValue456 = Spot damage
				// m_sValue789 = Linear damage
				// m_sValue789 = Area damage		
				for (i = 2; i < 10; i++) { // Max range is 10
					iErr = 0; // Bigger would change to a less linear line (more concave)
					// Linear damage: (1 on Target and Caster)
					//   1 1 1 1 1 1  
					// M 2 3 3 3 3 2 T
					//   1 1 1 1 1 1 
					m_Misc.GetPoint2(sX, sY, dX, dY, &tX, &tY, &iErr, i);
					// tx, ty
					m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, tX, tY);
					if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult+50) == FALSE)
						Effect_Damage_Spot_DamageMove(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, sX, sY, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9 + iWhetherBonus, FALSE, iMagicAttr);
					m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetDeadOwner(&sOwnerH, &cOwnerType, tX, tY);
					if ( (cOwnerType == DEF_OWNERTYPE_PLAYER) && (m_pClientList[sOwnerH] != NULL) && (m_pClientList[sOwnerH]->m_iHP > 0) ) 
					{	if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult+100) == FALSE)
							Effect_Damage_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9 + iWhetherBonus, FALSE, iMagicAttr);
					}
					// tx-1, ty
					m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, tX-1, tY);
					if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult+50) == FALSE)
						Effect_Damage_Spot_DamageMove(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, sX, sY, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9 + iWhetherBonus, FALSE, iMagicAttr);
					m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetDeadOwner(&sOwnerH, &cOwnerType, tX-1, tY);
					if ( (cOwnerType == DEF_OWNERTYPE_PLAYER) && (m_pClientList[sOwnerH] != NULL) && (m_pClientList[sOwnerH]->m_iHP > 0) ) 
					{	if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult+100) == FALSE)
							Effect_Damage_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9 + iWhetherBonus, FALSE, iMagicAttr);
					}
					// tx+1, ty
					m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, tX+1, tY);
					if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult+50) == FALSE)
						Effect_Damage_Spot_DamageMove(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, sX, sY, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9 + iWhetherBonus, FALSE, iMagicAttr);
					m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetDeadOwner(&sOwnerH, &cOwnerType, tX+1, tY);
					if ( (cOwnerType == DEF_OWNERTYPE_PLAYER) && (m_pClientList[sOwnerH] != NULL) && (m_pClientList[sOwnerH]->m_iHP > 0) ) 
					{	if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult+100) == FALSE)
							Effect_Damage_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9 + iWhetherBonus, FALSE, iMagicAttr);
					}
					// tx, ty-1
					m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, tX, tY-1);
					if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult+50) == FALSE)
						Effect_Damage_Spot_DamageMove(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, sX, sY, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9 + iWhetherBonus, FALSE, iMagicAttr);
						m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetDeadOwner(&sOwnerH, &cOwnerType, tX, tY-1);
					if ( (cOwnerType == DEF_OWNERTYPE_PLAYER) && (m_pClientList[sOwnerH] != NULL) && (m_pClientList[sOwnerH]->m_iHP > 0) )
					{	if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult+100) == FALSE)
							Effect_Damage_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9 + iWhetherBonus, FALSE, iMagicAttr);
					}
					// tx, ty+1
					m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, tX, tY+1);
					if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult+50) == FALSE)
						Effect_Damage_Spot_DamageMove(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, sX, sY, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9 + iWhetherBonus, FALSE, iMagicAttr);
					m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetDeadOwner(&sOwnerH, &cOwnerType, tX, tY+1);
					if ( (cOwnerType == DEF_OWNERTYPE_PLAYER) && (m_pClientList[sOwnerH] != NULL) && (m_pClientList[sOwnerH]->m_iHP > 0) ) 
					{	if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult+100) == FALSE)
							Effect_Damage_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9 + iWhetherBonus, FALSE, iMagicAttr);
					}
				    //  Break if we reach the target point
					if ( (abs(tX - dX) <= 1) && (abs(tY - dY) <= 1)) break;
				}
				// Area damage around target: m_sValue789, Deadowner
				for (iy = dY - m_pMagicConfigList[sType]->m_sValue3; iy <= dY + m_pMagicConfigList[sType]->m_sValue3; iy++)
				for (ix = dX - m_pMagicConfigList[sType]->m_sValue2; ix <= dX + m_pMagicConfigList[sType]->m_sValue2; ix++) 
				{	m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetDeadOwner(&sOwnerH, &cOwnerType, ix, iy);
					if ( (cOwnerType == DEF_OWNERTYPE_PLAYER) && (m_pClientList[sOwnerH] != NULL) && (m_pClientList[sOwnerH]->m_iHP > 0) ) 
					{	if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult+100) == FALSE)
							Effect_Damage_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9 + iWhetherBonus, FALSE, iMagicAttr);
					}
				}	
				// Area damage around target: m_sValue789: Alive owner									
				if ((dX >= sX) && (dY >= sY))
				{	for (ix = dX - m_pMagicConfigList[sType]->m_sValue2; ix <= dX + m_pMagicConfigList[sType]->m_sValue2; ix++) 
					for (iy = dY - m_pMagicConfigList[sType]->m_sValue3; iy <= dY + m_pMagicConfigList[sType]->m_sValue3; iy++)
					{	m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, ix, iy);
						if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult+50) == FALSE)
							Effect_Damage_Spot_DamageMove(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, sX, sY, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9 + iWhetherBonus, TRUE, iMagicAttr);
					}					
				}else if ((dX >= sX) && (dY < sY)) 
				{	for (ix = dX - m_pMagicConfigList[sType]->m_sValue2; ix <= dX + m_pMagicConfigList[sType]->m_sValue2; ix++) 
					for (iy = dY + m_pMagicConfigList[sType]->m_sValue3; iy >= dY - m_pMagicConfigList[sType]->m_sValue3; iy--)
					{	m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, ix, iy);
						if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult+50) == FALSE)
							Effect_Damage_Spot_DamageMove(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, sX, sY, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9 + iWhetherBonus, TRUE, iMagicAttr);
					}	
				}else if((dX < sX) && (dY >= sY))  
				{	for (ix = dX + m_pMagicConfigList[sType]->m_sValue2; ix >= dX - m_pMagicConfigList[sType]->m_sValue2; ix--) 
					for (iy = dY - m_pMagicConfigList[sType]->m_sValue3; iy <= dY + m_pMagicConfigList[sType]->m_sValue3; iy++)
					{	m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, ix, iy);
						if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult+50) == FALSE)
							Effect_Damage_Spot_DamageMove(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, sX, sY, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9 + iWhetherBonus, TRUE, iMagicAttr);
					}	
				}else //if((dX < sX) && (dY < sY)) 
				{	for (ix = dX + m_pMagicConfigList[sType]->m_sValue2; ix >= dX - m_pMagicConfigList[sType]->m_sValue2; ix--) 
					for (iy = dY + m_pMagicConfigList[sType]->m_sValue3; iy >= dY - m_pMagicConfigList[sType]->m_sValue3; iy--)
					{	m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, ix, iy);
						if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult+50) == FALSE)
							Effect_Damage_Spot_DamageMove(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, sX, sY, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9 + iWhetherBonus, TRUE, iMagicAttr);
					}
				}
				// Spot damage over Target m_sValue456
				m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, dX, dY);
				if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult+50) == FALSE)
					Effect_Damage_Spot_DamageMove(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, sX, sY, m_pMagicConfigList[sType]->m_sValue4, m_pMagicConfigList[sType]->m_sValue5, m_pMagicConfigList[sType]->m_sValue6 + iWhetherBonus, TRUE, iMagicAttr); // v1.41 FALSE
				m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetDeadOwner(&sOwnerH, &cOwnerType, dX, dY);
				if ( (cOwnerType == DEF_OWNERTYPE_PLAYER) && (m_pClientList[sOwnerH] != NULL) && (m_pClientList[sOwnerH]->m_iHP > 0) ) 
				{	if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult+100) == FALSE)
							Effect_Damage_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue4, m_pMagicConfigList[sType]->m_sValue5, m_pMagicConfigList[sType]->m_sValue6 + iWhetherBonus, TRUE, iMagicAttr); // v1.41 FALSE
				}
				break;
				
			case DEF_MAGICTYPE_POLYMORPH: //20
				// This magis was bugged on HBint due to any character running or casting spell while polymorphed was dc 
				m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, dX, dY);
				if (TRUE)  // bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE) {
				{	switch (cOwnerType) {
					case DEF_OWNERTYPE_PLAYER:
						// SNOOPY81: Players are polymorphed to the other sex if Magic Resist failure
						if (m_pClientList[sOwnerH] == NULL) goto MAGIC_NOEFFECT;
						if ((sOwnerH != iClientH) && (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == TRUE)) goto MAGIC_NOEFFECT;
						// Allow same spell to reverse effect on player	
						if (m_pClientList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_POLYMORPH ] == 0) 
						{	if (m_pClientList[sOwnerH]->m_cMagicEffectStatus[DEF_MAGICTYPE_PROTECT] == 2) goto MAGIC_NOEFFECT;
							if (m_pClientList[sOwnerH]->m_cMagicEffectStatus[DEF_MAGICTYPE_PROTECT] == 5) goto MAGIC_NOEFFECT;
							m_pClientList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_POLYMORPH ] = (char)m_pMagicConfigList[sType]->m_sValue4;
							//m_pClientList[sOwnerH]->m_sOriginalType = m_pClientList[sOwnerH]->m_sType;
							if (m_pClientList[sOwnerH]->m_sOriginalType >3 ) 
							{	m_pClientList[sOwnerH]->m_sType -= 3;
							}else 
							{	m_pClientList[sOwnerH]->m_sType += 3;
							}								
						}else  // Reverse the effect
						{	m_pClientList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_POLYMORPH ] = 0;
							m_pClientList[sOwnerH]->m_sType = m_pClientList[sOwnerH]->m_sOriginalType;
						}
						// Unequip armors if sex no longer allows it
						for ( i = 0; i < DEF_MAXITEMS; i++) {
							if (   (m_pClientList[sOwnerH]->m_pItemList[i] != NULL)										
								&& (m_pClientList[sOwnerH]->m_bIsItemEquipped[i]) )	
							{	if (bEquipItemHandler(sOwnerH, i, TRUE) == FALSE)  
								{	// if an item was removed compute Total item effect
									CalcTotalItemEffect(sOwnerH, i, false);
						}	}	}
						SendEventToNearClient_TypeA(sOwnerH, DEF_OWNERTYPE_PLAYER, MSGID_EVENT_MOTION, DEF_OBJECTNULLACTION, NULL, NULL, NULL);
						break;
					case DEF_OWNERTYPE_NPC:
						// Monsters are polymorphed to Zombie or the monster defined by m_sValue5
						if (m_pNpcList[sOwnerH] == NULL) goto MAGIC_NOEFFECT;
						if (m_pNpcList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_POLYMORPH ] != 0) goto MAGIC_NOEFFECT;
						if (m_pNpcList[sOwnerH]->m_cMagicEffectStatus[DEF_MAGICTYPE_PROTECT] == 2) goto MAGIC_NOEFFECT;
						if (m_pNpcList[sOwnerH]->m_cMagicEffectStatus[DEF_MAGICTYPE_PROTECT] == 5) goto MAGIC_NOEFFECT;
						switch (m_pNpcList[sOwnerH]->m_sType) {
						case 36: // AGT Arrow tower
						case 37: // CGT Cannon Tower
						case 38: // MS  ManaSShield
						case 39: // DT	Detector
						case 40: // ESG Shield
						case 41: // GMG Grand Magic Generator
						case 42: // ManaStone
						case 15: // ShopKeeper
						case 19: // Gandlf
						case 20: // Howard
						case 24: // ShopKeeper
						case 25: // Tom
						case 26: // William
						case 67: // Kennedy
						case 68: // Perry
						case 69: // Devlin	
						case 64: // Crops
						case 81: // Abaddon
						case 87: // Heldenian Crossbow Turret
						case 89: // Heldenian Ancient Grand Cannon
						case 91: // Gate
							goto MAGIC_NOEFFECT;
						default: break;
						}								
						m_pNpcList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_POLYMORPH ] = (char)m_pMagicConfigList[sType]->m_sValue4;
						m_pNpcList[sOwnerH]->m_sOriginalType = m_pNpcList[sOwnerH]->m_sType;
						// SNOOPY: Uses m_sValue5 to define something other than Zombie.
						if (m_pMagicConfigList[sType]->m_sValue5>1) 
						{	m_pNpcList[sOwnerH]->m_sType = (char)m_pMagicConfigList[sType]->m_sValue5;
						}else 
						{	m_pNpcList[sOwnerH]->m_sType = 18;
						}
						SendEventToNearClient_TypeA(sOwnerH, DEF_OWNERTYPE_NPC, MSGID_EVENT_MOTION, DEF_OBJECTNULLACTION, NULL, NULL, NULL);
						break;
				}
				// SNOOPY: Polymorph uses caster level as duration
				// bRegisterDelayEvent(DEF_DELAYEVENTTYPE_MAGICRELEASE, DEF_MAGICTYPE_POLYMORPH, dwTime + (m_pMagicConfigList[sType]->m_dwLastTime*1000),
				//                   sOwnerH, cOwnerType, NULL, NULL, NULL, m_pMagicConfigList[sType]->m_sValue4, NULL, NULL);
				bRegisterDelayEvent(DEF_DELAYEVENTTYPE_MAGICRELEASE, DEF_MAGICTYPE_POLYMORPH, dwTime + 	(m_pClientList[iClientH]->m_iLevel*1000),
					sOwnerH, cOwnerType, NULL, NULL, NULL, m_pMagicConfigList[sType]->m_sValue4, NULL, NULL);
				// Motify to client
				if (cOwnerType == DEF_OWNERTYPE_PLAYER)
				SendNotifyMsg(NULL, sOwnerH, DEF_NOTIFY_MAGICEFFECTON, DEF_MAGICTYPE_POLYMORPH, m_pMagicConfigList[sType]->m_sValue4, NULL, NULL);
			}
			break;

			case DEF_MAGICTYPE_DAMAGE_AREA_NOSPOT: //21 (fly from caster, and possibly multiple fly/strike !)
				if ((dX >= sX) && (dY >= sY))
				{	for (ix = dX - m_pMagicConfigList[sType]->m_sValue2; ix <= dX + m_pMagicConfigList[sType]->m_sValue2; ix++) 
					for (iy = dY - m_pMagicConfigList[sType]->m_sValue3; iy <= dY + m_pMagicConfigList[sType]->m_sValue3; iy++)
					{	m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, ix, iy);
						if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE)
							Effect_Damage_Spot_DamageMove(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, sX, sY, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9 + iWhetherBonus, TRUE, iMagicAttr);
					}					
				}else if ((dX >= sX) && (dY < sY)) 
				{	for (ix = dX - m_pMagicConfigList[sType]->m_sValue2; ix <= dX + m_pMagicConfigList[sType]->m_sValue2; ix++) 
					for (iy = dY + m_pMagicConfigList[sType]->m_sValue3; iy >= dY - m_pMagicConfigList[sType]->m_sValue3; iy--)
					{	m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, ix, iy);
						if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE)
							Effect_Damage_Spot_DamageMove(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, sX, sY, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9 + iWhetherBonus, TRUE, iMagicAttr);
					}	
				}else if((dX < sX) && (dY >= sY))  
				{	for (ix = dX + m_pMagicConfigList[sType]->m_sValue2; ix >= dX - m_pMagicConfigList[sType]->m_sValue2; ix--) 
					for (iy = dY - m_pMagicConfigList[sType]->m_sValue3; iy <= dY + m_pMagicConfigList[sType]->m_sValue3; iy++)
					{	m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, ix, iy);
						if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE)
							Effect_Damage_Spot_DamageMove(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, sX, sY, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9 + iWhetherBonus, TRUE, iMagicAttr);
					}	
				}else //if((dX < sX) && (dY < sY)) 
				{	for (ix = dX + m_pMagicConfigList[sType]->m_sValue2; ix >= dX - m_pMagicConfigList[sType]->m_sValue2; ix--) 
					for (iy = dY + m_pMagicConfigList[sType]->m_sValue3; iy >= dY - m_pMagicConfigList[sType]->m_sValue3; iy--)
					{	m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, ix, iy);
						if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE)
							Effect_Damage_Spot_DamageMove(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, sX, sY, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9 + iWhetherBonus, TRUE, iMagicAttr);
					}
				}
				for (iy = dY - m_pMagicConfigList[sType]->m_sValue3; iy <= dY + m_pMagicConfigList[sType]->m_sValue3; iy++)
				for (ix = dX - m_pMagicConfigList[sType]->m_sValue2; ix <= dX + m_pMagicConfigList[sType]->m_sValue2; ix++) 
				{	/*m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, ix, iy);
					if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE)
						Effect_Damage_Spot_DamageMove(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, sX, sY, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9 + iWhetherBonus, TRUE, iMagicAttr);
					*/m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetDeadOwner(&sOwnerH, &cOwnerType, ix, iy);
					if (   (cOwnerType == DEF_OWNERTYPE_PLAYER) && (m_pClientList[sOwnerH] != NULL) 
						&& (m_pClientList[sOwnerH]->m_iHP > 0) ) 
					{	if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE)
							Effect_Damage_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9 + iWhetherBonus, TRUE, iMagicAttr);
					}
				}
				break;		
					
			case DEF_MAGICTYPE_TREMOR: // 22 TREMOR is same than DamageArea but will not Fly you 
				// Standing character have no chance to resist Tremor	
				m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, dX, dY);
				if (bCheckResistingTremorSuccess(sOwnerH, cOwnerType) == FALSE) 
					Effect_Damage_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue4, m_pMagicConfigList[sType]->m_sValue5, m_pMagicConfigList[sType]->m_sValue6 + iWhetherBonus, TRUE, iMagicAttr);
				m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetDeadOwner(&sOwnerH, &cOwnerType, dX, dY);
				if (   (cOwnerType == DEF_OWNERTYPE_PLAYER) && (m_pClientList[sOwnerH] != NULL) 
					&& (m_pClientList[sOwnerH]->m_iHP > 0) ) 
				{	if (bCheckResistingTremorSuccess(sOwnerH, cOwnerType) == FALSE)
						Effect_Damage_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue4, m_pMagicConfigList[sType]->m_sValue5, m_pMagicConfigList[sType]->m_sValue6 + iWhetherBonus, TRUE, iMagicAttr);
				}
				for (iy = dY - m_pMagicConfigList[sType]->m_sValue3; iy <= dY + m_pMagicConfigList[sType]->m_sValue3; iy++)
				for (ix = dX - m_pMagicConfigList[sType]->m_sValue2; ix <= dX + m_pMagicConfigList[sType]->m_sValue2; ix++) 
				{	m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, ix, iy);
					if (bCheckResistingTremorSuccess(sOwnerH, cOwnerType) == FALSE) 
						Effect_Damage_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9 + iWhetherBonus, FALSE, iMagicAttr);
					m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetDeadOwner(&sOwnerH, &cOwnerType, ix, iy);
					if (   (cOwnerType == DEF_OWNERTYPE_PLAYER) && (m_pClientList[sOwnerH] != NULL)
						&& (m_pClientList[sOwnerH]->m_iHP > 0) ) 
					{	if (bCheckResistingTremorSuccess(sOwnerH, cOwnerType) == FALSE)
							Effect_Damage_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9 + iWhetherBonus, FALSE, iMagicAttr);
					}
				}
				break;

			case DEF_MAGICTYPE_ICE:  //23 (don't fly target)
				for (iy = dY - m_pMagicConfigList[sType]->m_sValue3; iy <= dY + m_pMagicConfigList[sType]->m_sValue3; iy++)
				for (ix = dX - m_pMagicConfigList[sType]->m_sValue2; ix <= dX + m_pMagicConfigList[sType]->m_sValue2; ix++) 
				{	m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, ix, iy);
					if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE) 
						Effect_Damage_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue4, m_pMagicConfigList[sType]->m_sValue5, m_pMagicConfigList[sType]->m_sValue6 + iWhetherBonus, TRUE, iMagicAttr);
					switch (cOwnerType) {
					case DEF_OWNERTYPE_PLAYER:
						if (m_pClientList[sOwnerH] == NULL) continue; // Snoopy: replaced goto MAGIC_NOEFFECT by continue...
						// SNOOPY: No more self icing!
						if (sOwnerH != iClientH) 
						{	if ((m_pClientList[sOwnerH]->m_iHP > 0) && (bCheckResistingIceSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iIceAtkRatio) == FALSE))
							{	if (m_pClientList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_ICE ] == 0) 
								{	m_pClientList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_ICE ] = 1;
									SetIceFlag(sOwnerH, cOwnerType, TRUE);
									bRegisterDelayEvent(DEF_DELAYEVENTTYPE_MAGICRELEASE, DEF_MAGICTYPE_ICE, dwTime + (m_pMagicConfigList[sType]->m_sValue10*1000), 
										sOwnerH, cOwnerType, NULL, NULL, NULL, 1, NULL, NULL);
									SendNotifyMsg(NULL, sOwnerH, DEF_NOTIFY_MAGICEFFECTON, DEF_MAGICTYPE_ICE, 1, NULL, NULL);
						}	}	}
						break;
					case DEF_OWNERTYPE_NPC:
						if (m_pNpcList[sOwnerH] == NULL) continue; // Snoopy: replaced goto MAGIC_NOEFFECT by continue...
						if ((m_pNpcList[sOwnerH]->m_iHP > 0) && (bCheckResistingIceSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iIceAtkRatio) == FALSE)) 
						{	if (m_pNpcList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_ICE ] == 0) 
							{	m_pNpcList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_ICE ] = 1;
								SetIceFlag(sOwnerH, cOwnerType, TRUE);
								bRegisterDelayEvent(DEF_DELAYEVENTTYPE_MAGICRELEASE, DEF_MAGICTYPE_ICE, dwTime + (m_pMagicConfigList[sType]->m_sValue10*1000), 
									sOwnerH, cOwnerType, NULL, NULL, NULL, 1, NULL, NULL);
						}	}
						break;
					}
					// Ice is bad to discover pretencorpse
					m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetDeadOwner(&sOwnerH, &cOwnerType, ix, iy);
					if (   (cOwnerType == DEF_OWNERTYPE_PLAYER) && (m_pClientList[sOwnerH] != NULL)
						&& (m_pClientList[sOwnerH]->m_iHP > 0) ) 
					{	if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult-100) == FALSE) 
						{	Effect_Damage_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue4, m_pMagicConfigList[sType]->m_sValue5, m_pMagicConfigList[sType]->m_sValue6 + iWhetherBonus, TRUE, iMagicAttr);
							if ((m_pClientList[sOwnerH]->m_iHP > 0) && (bCheckResistingIceSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iIceAtkRatio) == FALSE)) {
								if (m_pClientList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_ICE ] == 0) 
								{	m_pClientList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_ICE ] = 1;
									SetIceFlag(sOwnerH, cOwnerType, TRUE);
									bRegisterDelayEvent(DEF_DELAYEVENTTYPE_MAGICRELEASE, DEF_MAGICTYPE_ICE, dwTime + (m_pMagicConfigList[sType]->m_sValue10*1000), 
										sOwnerH, cOwnerType, NULL, NULL, NULL, 1, NULL, NULL);
									SendNotifyMsg(NULL, sOwnerH, DEF_NOTIFY_MAGICEFFECTON, DEF_MAGICTYPE_ICE, 1, NULL, NULL);
				}	}	}	}	}
				break;
			// SNOOPY: Implemented special Type for Lightning spell
			// (There too many Lightning spells striking single case target in this Damned HB !)
			// Note we'll have to change Npcs spell lists as well...
			
			case DEF_MAGICTYPE_DAMAGE_SPOT_RANDOM: // 24
				rx = iDice(2,2)-3;
				ry = iDice(2,2)-3; // Hard to resist
				m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, dX+rx, dY+ry);
				if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, -1) == FALSE)
					Effect_Damage_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue4, m_pMagicConfigList[sType]->m_sValue5, m_pMagicConfigList[sType]->m_sValue6 + iWhetherBonus, TRUE, iMagicAttr);
				m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetDeadOwner(&sOwnerH, &cOwnerType, dX+rx, dY+ry);
				if ((cOwnerType == DEF_OWNERTYPE_PLAYER) && (m_pClientList[sOwnerH] != NULL) && (m_pClientList[sOwnerH]->m_iHP > 0)) 
				{	if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, -1) == FALSE)
						Effect_Damage_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue4, m_pMagicConfigList[sType]->m_sValue5, m_pMagicConfigList[sType]->m_sValue6 + iWhetherBonus, TRUE, iMagicAttr);
				}
				break;

			case DEF_MAGICTYPE_DAMAGE_AREA_NOSPOT_SPDOWN: //25 // EWS (will fly in random position)
				// 1st remove SP and raise PretentCorpse characters
				for (iy = dY - m_pMagicConfigList[sType]->m_sValue3; iy <= dY + m_pMagicConfigList[sType]->m_sValue3; iy++)
				for (ix = dX - m_pMagicConfigList[sType]->m_sValue2; ix <= dX + m_pMagicConfigList[sType]->m_sValue2; ix++) 
				{	// SNOOPY: Damage is on 456, Special SPdown on 789
					m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, ix, iy);
					if (bCheckResistingMagicSuccess(-1, sOwnerH, cOwnerType, iMagicAttr + 10200) == FALSE) 
					{	// SP down effect will pass PFM and attack as +200
						Effect_SpDown_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9);
					}
					m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetDeadOwner(&sOwnerH, &cOwnerType, ix, iy);
					if (    (cOwnerType == DEF_OWNERTYPE_PLAYER) && (m_pClientList[sOwnerH] != NULL) 
							 && (m_pClientList[sOwnerH]->m_iHP > 0) ) 
					{	if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iMagicAttr+ 10200) == FALSE) 
						{	Effect_Damage_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue4, m_pMagicConfigList[sType]->m_sValue5, 10 + m_pMagicConfigList[sType]->m_sValue6 + iWhetherBonus, FALSE, iMagicAttr);
							Effect_SpDown_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, 10 + m_pMagicConfigList[sType]->m_sValue9);
				}	}	}
				// Then damage (may Fly pcs/mobs) // No chance to MR this spell
				m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, dX, dY);
				// Fly from targeted point with not double strike/fly...
				for (iy = dY - m_pMagicConfigList[sType]->m_sValue3; iy < dY; iy++)// up left
				for (ix = dX - m_pMagicConfigList[sType]->m_sValue2; ix < dX; ix++) 
				{	m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, ix, iy);
					if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, -1) == FALSE)
						Effect_Damage_Spot_DamageMove(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, dX, dY, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9 + iWhetherBonus, FALSE, iMagicAttr);
				}
				for (iy = dY + m_pMagicConfigList[sType]->m_sValue3; iy >= dY; iy--)// down left
				for (ix = dX - m_pMagicConfigList[sType]->m_sValue2; ix < dX; ix++) 
				{	m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, ix, iy);
					if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, -1) == FALSE)
						Effect_Damage_Spot_DamageMove(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, dX, dY, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9 + iWhetherBonus, FALSE, iMagicAttr);
				}
				for (iy = dY - m_pMagicConfigList[sType]->m_sValue3; iy < dY; iy++)
				for (ix = dX + m_pMagicConfigList[sType]->m_sValue2 ; ix >= dX; ix--) // up right
				{	m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, ix, iy);
					if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, -1) == FALSE)
						Effect_Damage_Spot_DamageMove(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, dX, dY, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9 + iWhetherBonus, FALSE, iMagicAttr);
				}
				for (iy = dY + m_pMagicConfigList[sType]->m_sValue3; iy >= dY; iy--) // down right
				for (ix = dX + m_pMagicConfigList[sType]->m_sValue2; ix >= dX; ix--) 
				{	m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, ix, iy);
					if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, -1) == FALSE)
						Effect_Damage_Spot_DamageMove(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, dX, dY, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9 + iWhetherBonus, FALSE, iMagicAttr);
				}					
				break;

			// Blizzard
			case DEF_MAGICTYPE_ICE_LINEAR: //26
				for (i = 2; i < 10; i++) 
				{	iErr = 0;
					m_Misc.GetPoint2(sX, sY, dX, dY, &tX, &tY, &iErr, i);
					// tx, ty
					m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, tX, tY);
					if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE) 
					{	Effect_Damage_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9 + iWhetherBonus, FALSE, iMagicAttr, 1);
						switch (cOwnerType) {
						case DEF_OWNERTYPE_PLAYER:
							if (m_pClientList[sOwnerH] == NULL) break;
							if ((m_pClientList[sOwnerH]->m_iHP > 0) && (bCheckResistingIceSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iIceAtkRatio) == FALSE))
							{	if (m_pClientList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_ICE ] == 0) 
								{	m_pClientList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_ICE ] = 1;
									SetIceFlag(sOwnerH, cOwnerType, TRUE);
									bRegisterDelayEvent(DEF_DELAYEVENTTYPE_MAGICRELEASE, DEF_MAGICTYPE_ICE, dwTime + (m_pMagicConfigList[sType]->m_sValue10*1000), 
										sOwnerH, cOwnerType, NULL, NULL, NULL, 1, NULL, NULL);
									SendNotifyMsg(NULL, sOwnerH, DEF_NOTIFY_MAGICEFFECTON, DEF_MAGICTYPE_ICE, 1, NULL, NULL);
							}	}
							break;
						case DEF_OWNERTYPE_NPC:
							if (m_pNpcList[sOwnerH] == NULL) break;
							if ((m_pNpcList[sOwnerH]->m_iHP > 0) && (bCheckResistingIceSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iIceAtkRatio) == FALSE)) {
								if (m_pNpcList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_ICE ] == 0) 
								{	m_pNpcList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_ICE ] = 1;
									SetIceFlag(sOwnerH, cOwnerType, TRUE);
									bRegisterDelayEvent(DEF_DELAYEVENTTYPE_MAGICRELEASE, DEF_MAGICTYPE_ICE, dwTime + (m_pMagicConfigList[sType]->m_sValue10*1000), 
										sOwnerH, cOwnerType, NULL, NULL, NULL, 1, NULL, NULL);
							}	}
							break;
					}	} 
					m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetDeadOwner(&sOwnerH, &cOwnerType, tX, tY);
					if ( (cOwnerType == DEF_OWNERTYPE_PLAYER) && (m_pClientList[sOwnerH] != NULL) && (m_pClientList[sOwnerH]->m_iHP > 0) ) 
					{	if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE) 
						{	Effect_Damage_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9 + iWhetherBonus, FALSE, iMagicAttr, 1);
							if ((m_pClientList[sOwnerH]->m_iHP > 0) && (bCheckResistingIceSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iIceAtkRatio) == FALSE))
							{	if (m_pClientList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_ICE ] == 0)
								{	m_pClientList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_ICE ] = 1;
									SetIceFlag(sOwnerH, cOwnerType, TRUE);
									bRegisterDelayEvent(DEF_DELAYEVENTTYPE_MAGICRELEASE, DEF_MAGICTYPE_ICE, dwTime + (m_pMagicConfigList[sType]->m_sValue10*1000), 
										sOwnerH, cOwnerType, NULL, NULL, NULL, 1, NULL, NULL);
									SendNotifyMsg(NULL, sOwnerH, DEF_NOTIFY_MAGICEFFECTON, DEF_MAGICTYPE_ICE, 1, NULL, NULL);
					}	}	}	}
					// tx-1, ty
					m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, tX-1, tY);
					if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE) 
					{	Effect_Damage_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9 + iWhetherBonus, FALSE, iMagicAttr, 1);
						switch (cOwnerType) {
						case DEF_OWNERTYPE_PLAYER:
							if (m_pClientList[sOwnerH] == NULL) break;
							if ((m_pClientList[sOwnerH]->m_iHP > 0) && (bCheckResistingIceSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iIceAtkRatio) == FALSE))
							{	if (m_pClientList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_ICE ] == 0) 
								{	m_pClientList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_ICE ] = 1;
									SetIceFlag(sOwnerH, cOwnerType, TRUE);
									bRegisterDelayEvent(DEF_DELAYEVENTTYPE_MAGICRELEASE, DEF_MAGICTYPE_ICE, dwTime + (m_pMagicConfigList[sType]->m_sValue10*1000), 
										sOwnerH, cOwnerType, NULL, NULL, NULL, 1, NULL, NULL);
									SendNotifyMsg(NULL, sOwnerH, DEF_NOTIFY_MAGICEFFECTON, DEF_MAGICTYPE_ICE, 1, NULL, NULL);
							}	}
							break;
						case DEF_OWNERTYPE_NPC:
							if (m_pNpcList[sOwnerH] == NULL) break;
							if ((m_pNpcList[sOwnerH]->m_iHP > 0) && (bCheckResistingIceSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iIceAtkRatio) == FALSE)) {
								if (m_pNpcList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_ICE ] == 0) 
								{	m_pNpcList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_ICE ] = 1;
									SetIceFlag(sOwnerH, cOwnerType, TRUE);
									bRegisterDelayEvent(DEF_DELAYEVENTTYPE_MAGICRELEASE, DEF_MAGICTYPE_ICE, dwTime + (m_pMagicConfigList[sType]->m_sValue10*1000), 
										sOwnerH, cOwnerType, NULL, NULL, NULL, 1, NULL, NULL);
							}	}
							break;
					}	} 
					m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetDeadOwner(&sOwnerH, &cOwnerType, tX-1, tY);
					if ( (cOwnerType == DEF_OWNERTYPE_PLAYER) && (m_pClientList[sOwnerH] != NULL) && (m_pClientList[sOwnerH]->m_iHP > 0) ) 
					{	if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE) 
						{	Effect_Damage_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9 + iWhetherBonus, FALSE, iMagicAttr, 1);
							if ((m_pClientList[sOwnerH]->m_iHP > 0) && (bCheckResistingIceSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iIceAtkRatio) == FALSE))
							{	if (m_pClientList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_ICE ] == 0)
								{	m_pClientList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_ICE ] = 1;
									SetIceFlag(sOwnerH, cOwnerType, TRUE);
									bRegisterDelayEvent(DEF_DELAYEVENTTYPE_MAGICRELEASE, DEF_MAGICTYPE_ICE, dwTime + (m_pMagicConfigList[sType]->m_sValue10*1000), 
										sOwnerH, cOwnerType, NULL, NULL, NULL, 1, NULL, NULL);
									SendNotifyMsg(NULL, sOwnerH, DEF_NOTIFY_MAGICEFFECTON, DEF_MAGICTYPE_ICE, 1, NULL, NULL);
					}	}	}	}
					// tx+1, ty
					m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, tX+1, tY);
					if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE) 
					{	Effect_Damage_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9 + iWhetherBonus, FALSE, iMagicAttr, 1);
						switch (cOwnerType) {
						case DEF_OWNERTYPE_PLAYER:
							if (m_pClientList[sOwnerH] == NULL) break;
							if ((m_pClientList[sOwnerH]->m_iHP > 0) && (bCheckResistingIceSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iIceAtkRatio) == FALSE))
							{	if (m_pClientList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_ICE ] == 0) 
								{	m_pClientList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_ICE ] = 1;
									SetIceFlag(sOwnerH, cOwnerType, TRUE);
									bRegisterDelayEvent(DEF_DELAYEVENTTYPE_MAGICRELEASE, DEF_MAGICTYPE_ICE, dwTime + (m_pMagicConfigList[sType]->m_sValue10*1000), 
										sOwnerH, cOwnerType, NULL, NULL, NULL, 1, NULL, NULL);
									SendNotifyMsg(NULL, sOwnerH, DEF_NOTIFY_MAGICEFFECTON, DEF_MAGICTYPE_ICE, 1, NULL, NULL);
							}	}
							break;
						case DEF_OWNERTYPE_NPC:
							if (m_pNpcList[sOwnerH] == NULL) break;
							if ((m_pNpcList[sOwnerH]->m_iHP > 0) && (bCheckResistingIceSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iIceAtkRatio) == FALSE)) {
								if (m_pNpcList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_ICE ] == 0) 
								{	m_pNpcList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_ICE ] = 1;
									SetIceFlag(sOwnerH, cOwnerType, TRUE);
									bRegisterDelayEvent(DEF_DELAYEVENTTYPE_MAGICRELEASE, DEF_MAGICTYPE_ICE, dwTime + (m_pMagicConfigList[sType]->m_sValue10*1000), 
										sOwnerH, cOwnerType, NULL, NULL, NULL, 1, NULL, NULL);
							}	}
							break;
					}	} 
					m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetDeadOwner(&sOwnerH, &cOwnerType, tX+1, tY);
					if ( (cOwnerType == DEF_OWNERTYPE_PLAYER) && (m_pClientList[sOwnerH] != NULL) && (m_pClientList[sOwnerH]->m_iHP > 0) ) 
					{	if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE) 
						{	Effect_Damage_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9 + iWhetherBonus, FALSE, iMagicAttr, 1);
							if ((m_pClientList[sOwnerH]->m_iHP > 0) && (bCheckResistingIceSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iIceAtkRatio) == FALSE))
							{	if (m_pClientList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_ICE ] == 0)
								{	m_pClientList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_ICE ] = 1;
									SetIceFlag(sOwnerH, cOwnerType, TRUE);
									bRegisterDelayEvent(DEF_DELAYEVENTTYPE_MAGICRELEASE, DEF_MAGICTYPE_ICE, dwTime + (m_pMagicConfigList[sType]->m_sValue10*1000), 
										sOwnerH, cOwnerType, NULL, NULL, NULL, 1, NULL, NULL);
									SendNotifyMsg(NULL, sOwnerH, DEF_NOTIFY_MAGICEFFECTON, DEF_MAGICTYPE_ICE, 1, NULL, NULL);
					}	}	}	}
					// tx, ty-1
					m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, tX, tY-1);
					if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE) 
					{	Effect_Damage_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9 + iWhetherBonus, FALSE, iMagicAttr, 1);
						switch (cOwnerType) {
						case DEF_OWNERTYPE_PLAYER:
							if (m_pClientList[sOwnerH] == NULL) break;
							if ((m_pClientList[sOwnerH]->m_iHP > 0) && (bCheckResistingIceSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iIceAtkRatio) == FALSE))
							{	if (m_pClientList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_ICE ] == 0) 
								{	m_pClientList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_ICE ] = 1;
									SetIceFlag(sOwnerH, cOwnerType, TRUE);
									bRegisterDelayEvent(DEF_DELAYEVENTTYPE_MAGICRELEASE, DEF_MAGICTYPE_ICE, dwTime + (m_pMagicConfigList[sType]->m_sValue10*1000), 
										sOwnerH, cOwnerType, NULL, NULL, NULL, 1, NULL, NULL);
									SendNotifyMsg(NULL, sOwnerH, DEF_NOTIFY_MAGICEFFECTON, DEF_MAGICTYPE_ICE, 1, NULL, NULL);
							}	}
							break;
						case DEF_OWNERTYPE_NPC:
							if (m_pNpcList[sOwnerH] == NULL) break;
							if ((m_pNpcList[sOwnerH]->m_iHP > 0) && (bCheckResistingIceSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iIceAtkRatio) == FALSE)) {
								if (m_pNpcList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_ICE ] == 0) 
								{	m_pNpcList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_ICE ] = 1;
									SetIceFlag(sOwnerH, cOwnerType, TRUE);
									bRegisterDelayEvent(DEF_DELAYEVENTTYPE_MAGICRELEASE, DEF_MAGICTYPE_ICE, dwTime + (m_pMagicConfigList[sType]->m_sValue10*1000), 
										sOwnerH, cOwnerType, NULL, NULL, NULL, 1, NULL, NULL);
							}	}
							break;
					}	} 
					m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetDeadOwner(&sOwnerH, &cOwnerType, tX, tY-1);
					if ( (cOwnerType == DEF_OWNERTYPE_PLAYER) && (m_pClientList[sOwnerH] != NULL) && (m_pClientList[sOwnerH]->m_iHP > 0) ) 
					{	if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE) 
						{	Effect_Damage_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9 + iWhetherBonus, FALSE, iMagicAttr, 1);
							if ((m_pClientList[sOwnerH]->m_iHP > 0) && (bCheckResistingIceSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iIceAtkRatio) == FALSE))
							{	if (m_pClientList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_ICE ] == 0)
								{	m_pClientList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_ICE ] = 1;
									SetIceFlag(sOwnerH, cOwnerType, TRUE);
									bRegisterDelayEvent(DEF_DELAYEVENTTYPE_MAGICRELEASE, DEF_MAGICTYPE_ICE, dwTime + (m_pMagicConfigList[sType]->m_sValue10*1000), 
										sOwnerH, cOwnerType, NULL, NULL, NULL, 1, NULL, NULL);
									SendNotifyMsg(NULL, sOwnerH, DEF_NOTIFY_MAGICEFFECTON, DEF_MAGICTYPE_ICE, 1, NULL, NULL);
					}	}	}	}
					// tx, ty+1
					m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, tX, tY+1);
					if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE) 
					{	Effect_Damage_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9 + iWhetherBonus, FALSE, iMagicAttr, 1);
						switch (cOwnerType) {
						case DEF_OWNERTYPE_PLAYER:
							if (m_pClientList[sOwnerH] == NULL) break;
							if ((m_pClientList[sOwnerH]->m_iHP > 0) && (bCheckResistingIceSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iIceAtkRatio) == FALSE))
							{	if (m_pClientList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_ICE ] == 0) 
								{	m_pClientList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_ICE ] = 1;
									SetIceFlag(sOwnerH, cOwnerType, TRUE);
									bRegisterDelayEvent(DEF_DELAYEVENTTYPE_MAGICRELEASE, DEF_MAGICTYPE_ICE, dwTime + (m_pMagicConfigList[sType]->m_sValue10*1000), 
										sOwnerH, cOwnerType, NULL, NULL, NULL, 1, NULL, NULL);
									SendNotifyMsg(NULL, sOwnerH, DEF_NOTIFY_MAGICEFFECTON, DEF_MAGICTYPE_ICE, 1, NULL, NULL);
							}	}
							break;
						case DEF_OWNERTYPE_NPC:
							if (m_pNpcList[sOwnerH] == NULL) break;
							if ((m_pNpcList[sOwnerH]->m_iHP > 0) && (bCheckResistingIceSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iIceAtkRatio) == FALSE)) {
								if (m_pNpcList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_ICE ] == 0) 
								{	m_pNpcList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_ICE ] = 1;
									SetIceFlag(sOwnerH, cOwnerType, TRUE);
									bRegisterDelayEvent(DEF_DELAYEVENTTYPE_MAGICRELEASE, DEF_MAGICTYPE_ICE, dwTime + (m_pMagicConfigList[sType]->m_sValue10*1000), 
										sOwnerH, cOwnerType, NULL, NULL, NULL, 1, NULL, NULL);
							}	}
							break;
					}	} 
					m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetDeadOwner(&sOwnerH, &cOwnerType, tX, tY+1);
					if ( (cOwnerType == DEF_OWNERTYPE_PLAYER) && (m_pClientList[sOwnerH] != NULL) && (m_pClientList[sOwnerH]->m_iHP > 0) ) 
					{	if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE) 
						{	Effect_Damage_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9 + iWhetherBonus, FALSE, iMagicAttr, 1);
							if ((m_pClientList[sOwnerH]->m_iHP > 0) && (bCheckResistingIceSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iIceAtkRatio) == FALSE))
							{	if (m_pClientList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_ICE ] == 0)
								{	m_pClientList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_ICE ] = 1;
									SetIceFlag(sOwnerH, cOwnerType, TRUE);
									bRegisterDelayEvent(DEF_DELAYEVENTTYPE_MAGICRELEASE, DEF_MAGICTYPE_ICE, dwTime + (m_pMagicConfigList[sType]->m_sValue10*1000), 
										sOwnerH, cOwnerType, NULL, NULL, NULL, 1, NULL, NULL);
									SendNotifyMsg(NULL, sOwnerH, DEF_NOTIFY_MAGICEFFECTON, DEF_MAGICTYPE_ICE, 1, NULL, NULL);
					}	}	}	}				
					// Exit if reaching the Target
					if ( (abs(tX - dX) <= 1) && (abs(tY - dY) <= 1)) break;
				}
				// Area damage: depends on X/Y settings in the spell and m_sValue789, same as linear damge
				for (iy = dY - m_pMagicConfigList[sType]->m_sValue3; iy <= dY + m_pMagicConfigList[sType]->m_sValue3; iy++)
				for (ix = dX - m_pMagicConfigList[sType]->m_sValue2; ix <= dX + m_pMagicConfigList[sType]->m_sValue2; ix++) 
				{	m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, ix, iy);
					if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE) 
					{	Effect_Damage_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9 + iWhetherBonus, FALSE, iMagicAttr, 1);
						switch (cOwnerType) {
						case DEF_OWNERTYPE_PLAYER:
							if (m_pClientList[sOwnerH] == NULL) break;
							if ((m_pClientList[sOwnerH]->m_iHP > 0) && (bCheckResistingIceSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iIceAtkRatio) == FALSE)) {
								if (m_pClientList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_ICE ] == 0) 
								{	m_pClientList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_ICE ] = 1;
									SetIceFlag(sOwnerH, cOwnerType, TRUE);
									bRegisterDelayEvent(DEF_DELAYEVENTTYPE_MAGICRELEASE, DEF_MAGICTYPE_ICE, dwTime + (m_pMagicConfigList[sType]->m_sValue10*1000), 
										sOwnerH, cOwnerType, NULL, NULL, NULL, 1, NULL, NULL);
									SendNotifyMsg(NULL, sOwnerH, DEF_NOTIFY_MAGICEFFECTON, DEF_MAGICTYPE_ICE, 1, NULL, NULL);
							}	}
							break;
						case DEF_OWNERTYPE_NPC:
							if (m_pNpcList[sOwnerH] == NULL) break;
							if ((m_pNpcList[sOwnerH]->m_iHP > 0) && (bCheckResistingIceSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iIceAtkRatio) == FALSE)) {
							if (m_pNpcList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_ICE ] == 0) 
							{	m_pNpcList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_ICE ] = 1;
								SetIceFlag(sOwnerH, cOwnerType, TRUE);
								bRegisterDelayEvent(DEF_DELAYEVENTTYPE_MAGICRELEASE, DEF_MAGICTYPE_ICE, dwTime + (m_pMagicConfigList[sType]->m_sValue10*1000), 
									sOwnerH, cOwnerType, NULL, NULL, NULL, 1, NULL, NULL);
							}	}
							break;	
					}	}
					m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetDeadOwner(&sOwnerH, &cOwnerType, ix, iy);
					if ( (cOwnerType == DEF_OWNERTYPE_PLAYER) && (m_pClientList[sOwnerH] != NULL) && (m_pClientList[sOwnerH]->m_iHP > 0) ) 
					{	if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE) 
						{	Effect_Damage_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9 + iWhetherBonus, FALSE, iMagicAttr, 1);
							if ((m_pClientList[sOwnerH]->m_iHP > 0) && (bCheckResistingIceSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iIceAtkRatio) == FALSE)) 
							{	if (m_pClientList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_ICE ] == 0) 
								{	m_pClientList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_ICE ] = 1;
									SetIceFlag(sOwnerH, cOwnerType, TRUE);
									bRegisterDelayEvent(DEF_DELAYEVENTTYPE_MAGICRELEASE, DEF_MAGICTYPE_ICE, dwTime + (m_pMagicConfigList[sType]->m_sValue10*1000), 
										sOwnerH, cOwnerType, NULL, NULL, NULL, 1, NULL, NULL);
									SendNotifyMsg(NULL, sOwnerH, DEF_NOTIFY_MAGICEFFECTON, DEF_MAGICTYPE_ICE, 1, NULL, NULL);
					}	}	}	}
				}
				// Target Damage: depends on m_sValue456
				m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, dX, dY);
				if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE) 
				{	Effect_Damage_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue4, m_pMagicConfigList[sType]->m_sValue5, m_pMagicConfigList[sType]->m_sValue6 + iWhetherBonus, TRUE, iMagicAttr, 1); // v1.41 FALSE
					switch (cOwnerType) {
					case DEF_OWNERTYPE_PLAYER:
						if (m_pClientList[sOwnerH] == NULL) break;
						if ((m_pClientList[sOwnerH]->m_iHP > 0) && (bCheckResistingIceSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iIceAtkRatio) == FALSE)) 
						{	if (m_pClientList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_ICE ] == 0) 
							{	m_pClientList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_ICE ] = 1;
								SetIceFlag(sOwnerH, cOwnerType, TRUE);
								bRegisterDelayEvent(DEF_DELAYEVENTTYPE_MAGICRELEASE, DEF_MAGICTYPE_ICE, dwTime + (m_pMagicConfigList[sType]->m_sValue10*1000), 
									sOwnerH, cOwnerType, NULL, NULL, NULL, 1, NULL, NULL);
								SendNotifyMsg(NULL, sOwnerH, DEF_NOTIFY_MAGICEFFECTON, DEF_MAGICTYPE_ICE, 1, NULL, NULL);
						}	}
						break;
					case DEF_OWNERTYPE_NPC:
						if (m_pNpcList[sOwnerH] == NULL) break;
						if ((m_pNpcList[sOwnerH]->m_iHP > 0) && (bCheckResistingIceSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iIceAtkRatio) == FALSE)) 
						{	if (m_pNpcList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_ICE ] == 0) 
							{	m_pNpcList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_ICE ] = 1;
								SetIceFlag(sOwnerH, cOwnerType, TRUE);
								bRegisterDelayEvent(DEF_DELAYEVENTTYPE_MAGICRELEASE, DEF_MAGICTYPE_ICE, dwTime + (m_pMagicConfigList[sType]->m_sValue10*1000), 
									sOwnerH, cOwnerType, NULL, NULL, NULL, 1, NULL, NULL);
						}	}
						break;				
				}	}
				m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetDeadOwner(&sOwnerH, &cOwnerType, dX, dY);
				if ( (cOwnerType == DEF_OWNERTYPE_PLAYER) && (m_pClientList[sOwnerH] != NULL) && (m_pClientList[sOwnerH]->m_iHP > 0) ) 
				{	if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE) 
					{	Effect_Damage_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue4, m_pMagicConfigList[sType]->m_sValue5, m_pMagicConfigList[sType]->m_sValue6 + iWhetherBonus, TRUE, iMagicAttr, 1); // v1.41 FALSE
						if ((m_pClientList[sOwnerH]->m_iHP > 0) && (bCheckResistingIceSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iIceAtkRatio) == FALSE)) 
						{	if (m_pClientList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_ICE ] == 0) 
							{	m_pClientList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_ICE ] = 1;
								SetIceFlag(sOwnerH, cOwnerType, TRUE);
								bRegisterDelayEvent(DEF_DELAYEVENTTYPE_MAGICRELEASE, DEF_MAGICTYPE_ICE, dwTime + (m_pMagicConfigList[sType]->m_sValue10*1000), 
									sOwnerH, cOwnerType, NULL, NULL, NULL, 1, NULL, NULL);
								SendNotifyMsg(NULL, sOwnerH, DEF_NOTIFY_MAGICEFFECTON, DEF_MAGICTYPE_ICE, 1, NULL, NULL);
				}	}	}	}
				break;

			case DEF_MAGICTYPE_HPUP_AREA: // 27, Added by Snoopy
				m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, dX, dY);
				Effect_HpUp_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue4, m_pMagicConfigList[sType]->m_sValue5, m_pMagicConfigList[sType]->m_sValue6);
				
				for (iy = dY - m_pMagicConfigList[sType]->m_sValue3; iy <= dY + m_pMagicConfigList[sType]->m_sValue3; iy++)
				for (ix = dX - m_pMagicConfigList[sType]->m_sValue2; ix <= dX + m_pMagicConfigList[sType]->m_sValue2; ix++) 
				{	m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, ix, iy);
					if (   (cOwnerType == DEF_OWNERTYPE_PLAYER) 
						&& (m_pClientList[sOwnerH] != NULL) 
						&& (m_pClientList[sOwnerH]->m_iHP > 0)) 
					{	if (m_pClientList[sOwnerH]->m_cSide == m_pClientList[iClientH]->m_cSide)
						{	Effect_HpUp_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9);
						}else
						{	if ((m_pClientList[sOwnerH]->m_iPartyID == m_pClientList[iClientH]->m_iPartyID) 
								&& (m_pClientList[sOwnerH]->m_iPartyID != NULL))
							{	Effect_HpUp_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9);
				}	}	}	}					
				break;

			case DEF_MAGICTYPE_DAMAGE_AREA_ARMOR_BREAK: //28 m_sValue10 is used for armor decrement					
				if (m_pMagicConfigList[sType]->m_sType == 28) 
				{	iResult += 10000; // ArmorBreak effect overcomes PFM.
				}		
				for (iy = dY - m_pMagicConfigList[sType]->m_sValue3; iy <= dY + m_pMagicConfigList[sType]->m_sValue3; iy++)
				for (ix = dX - m_pMagicConfigList[sType]->m_sValue2; ix <= dX + m_pMagicConfigList[sType]->m_sValue2; ix++) 
				{	m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, ix, iy);
					if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE) 
					{	Effect_Damage_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9 + iWhetherBonus, FALSE, iMagicAttr);
						ArmorLifeDecrement(iClientH,sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue10);
					}
					m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetDeadOwner(&sOwnerH, &cOwnerType, ix, iy);
					if (   (cOwnerType == DEF_OWNERTYPE_PLAYER) && (m_pClientList[sOwnerH] != NULL) 
						&& (m_pClientList[sOwnerH]->m_iHP > 0) ) 
					{	if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE) 
						{	Effect_Damage_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9 + iWhetherBonus, FALSE, iMagicAttr);
							ArmorLifeDecrement(iClientH,sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue10);
						}
					}
				}
				break;

			case DEF_MAGICTYPE_CANCELLATION: //29
				// Simple to destroy effects are area, PFM are only point
				for (iy = dY - m_pMagicConfigList[sType]->m_sValue3; iy <= dY + m_pMagicConfigList[sType]->m_sValue3; iy++)
				for (ix = dX - m_pMagicConfigList[sType]->m_sValue2; ix <= dX + m_pMagicConfigList[sType]->m_sValue2; ix++) 
				{	m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, ix, iy);
					switch (cOwnerType){
					case DEF_OWNERTYPE_PLAYER:
						if ((m_pClientList[sOwnerH] != NULL) && (m_pClientList[sOwnerH]->m_iHP > 0) && (m_pClientList[sOwnerH]->m_iAdminUserLevel == 0)) 
						{	// Removes Invisibility :		Time 0 remove now
							if (m_pClientList[sOwnerH]->m_cMagicEffectStatus[DEF_MAGICTYPE_INVISIBILITY] != NULL)
							{	m_pClientList[sOwnerH]->m_cMagicEffectStatus[DEF_MAGICTYPE_INVISIBILITY] = 0;
								bRemoveFromDelayEventList(sOwnerH, DEF_OWNERTYPE_PLAYER, DEF_MAGICTYPE_INVISIBILITY);						
								SetInvisibilityFlag(sOwnerH, DEF_OWNERTYPE_PLAYER, FALSE);
							}	
							// removes PARA
							if (m_pClientList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_HOLDOBJECT ] != 0) 
							{	SendNotifyMsg(NULL, sOwnerH, DEF_NOTIFY_MAGICEFFECTOFF, DEF_MAGICTYPE_HOLDOBJECT, m_pClientList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_HOLDOBJECT ], NULL, NULL);							
								m_pClientList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_HOLDOBJECT ] = NULL;
								bRemoveFromDelayEventList(sOwnerH, DEF_OWNERTYPE_PLAYER, DEF_MAGICTYPE_HOLDOBJECT);
							}
							// Remove metamorphosis:	    Time 0 remove now
							if (m_pClientList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_METAMORPHOSIS ] != 0) 
							{	bRemoveFromDelayEventList(sOwnerH, DEF_OWNERTYPE_PLAYER, DEF_MAGICTYPE_METAMORPHOSIS);
								SetMetamorphosisFlag(sOwnerH, DEF_OWNERTYPE_PLAYER, FALSE);
							}
							// Remove Polymorph	
							if (m_pClientList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_POLYMORPH ] != 0)
							{	m_pClientList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_POLYMORPH ] = 0;
								m_pClientList[sOwnerH]->m_sType = m_pClientList[sOwnerH]->m_sOriginalType;
								// Unequip armors if sex no longer allows it
								for ( i = 0; i < DEF_MAXITEMS; i++) 
								{	if (   (m_pClientList[sOwnerH]->m_pItemList[i] != NULL)										
									&& (m_pClientList[sOwnerH]->m_bIsItemEquipped[i]) )	
									{	if (bEquipItemHandler(sOwnerH, i, TRUE) == FALSE)  
										{	CalcTotalItemEffect(sOwnerH, i, false);// if an item was removed compute Total item effect
								}	}	}
							}						
							// Remove WarmEffect :			Time 0 remove now
							m_pClientList[sOwnerH]->m_dwWarmEffectTime = 0;
							// Remove Ice Effect :			Time 0 remove now
							if (m_pClientList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_ICE ] == 1) 
							{	bRemoveFromDelayEventList(sOwnerH, DEF_OWNERTYPE_PLAYER, DEF_MAGICTYPE_ICE);							
								SetIceFlag(sOwnerH, DEF_OWNERTYPE_PLAYER, FALSE);
							}
							// Remove Illusion type spells : Time x 0.25
							if (m_pClientList[sOwnerH]->m_cMagicEffectStatus[DEF_MAGICTYPE_CONFUSE] != NULL)
							{	bRemoveFromDelayEventList(sOwnerH, DEF_OWNERTYPE_PLAYER, DEF_MAGICTYPE_CONFUSE);
								bRegisterDelayEvent(DEF_DELAYEVENTTYPE_MAGICRELEASE, DEF_MAGICTYPE_CONFUSE, dwTime + (250 * m_pMagicConfigList[sType]->m_dwLastTime), 
									sOwnerH, DEF_OWNERTYPE_PLAYER, NULL, NULL, NULL, m_pClientList[sOwnerH]->m_cMagicEffectStatus[DEF_MAGICTYPE_CONFUSE], NULL, NULL);
							}	
							// Remove Reflexion spells :	Time x 0.25
							if (m_pClientList[sOwnerH]->m_cMagicEffectStatus[DEF_MAGICTYPE_REFLEXION] != NULL)
							{	bRemoveFromDelayEventList(sOwnerH, DEF_OWNERTYPE_PLAYER, DEF_MAGICTYPE_REFLEXION);
								bRegisterDelayEvent(DEF_DELAYEVENTTYPE_MAGICRELEASE, DEF_MAGICTYPE_REFLEXION, dwTime + (250 * m_pMagicConfigList[sType]->m_dwLastTime), 
									sOwnerH, DEF_OWNERTYPE_PLAYER, NULL, NULL, NULL, 1, NULL, NULL);
							}
							// Removes Inhibition :			Time x 0.5
							if (m_pClientList[iClientH]->m_bInhibition == TRUE)
							{	bRemoveFromDelayEventList(sOwnerH, DEF_OWNERTYPE_PLAYER, DEF_MAGICTYPE_INHIBITION);
								bRegisterDelayEvent(DEF_DELAYEVENTTYPE_MAGICRELEASE, DEF_MAGICTYPE_INHIBITION, dwTime + (500 * m_pMagicConfigList[sType]->m_dwLastTime), 
									sOwnerH, DEF_OWNERTYPE_PLAYER, NULL, NULL, NULL, 1, NULL, NULL);
							}
							// Update Client
							SendEventToNearClient_TypeA(sOwnerH, DEF_OWNERTYPE_PLAYER, MSGID_EVENT_MOTION, DEF_OBJECTNULLACTION, NULL, NULL, NULL);
						}
						break;
					case DEF_OWNERTYPE_NPC:
						if ((m_pNpcList[sOwnerH] != NULL) && (m_pNpcList[sOwnerH]->m_iHP > 0)) 
						{	// Removes Invisibility :		Time 0 remove now
							if (m_pNpcList[sOwnerH]->m_cMagicEffectStatus[DEF_MAGICTYPE_INVISIBILITY] != NULL)
							{	m_pNpcList[sOwnerH]->m_cMagicEffectStatus[DEF_MAGICTYPE_INVISIBILITY] = 0;
								bRemoveFromDelayEventList(sOwnerH, DEF_OWNERTYPE_NPC, DEF_MAGICTYPE_INVISIBILITY);						
								SetInvisibilityFlag(sOwnerH, DEF_OWNERTYPE_NPC, FALSE);
							}	
							// Removes PARA
							if (m_pNpcList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_HOLDOBJECT ] != 0) 
							{	m_pNpcList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_HOLDOBJECT ] = NULL;
								bRemoveFromDelayEventList(sOwnerH, DEF_OWNERTYPE_NPC, DEF_MAGICTYPE_HOLDOBJECT);
							}
							// Remove Polymorph	
							if (m_pNpcList[sOwnerH]->m_cMagicEffectStatus[DEF_MAGICTYPE_POLYMORPH] != 0)
							{	m_pNpcList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_POLYMORPH ] = 0;
								m_pNpcList[sOwnerH]->m_sType = m_pNpcList[sOwnerH]->m_sOriginalType;		
							}
							// Remove Ice Effect :			Time 0 remove now
							if (m_pNpcList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_ICE ] == 1) 
							{	bRemoveFromDelayEventList(sOwnerH, DEF_OWNERTYPE_NPC, DEF_MAGICTYPE_ICE);							
								SetIceFlag(sOwnerH, DEF_OWNERTYPE_NPC, FALSE);
							}
							// Update Client
							SendEventToNearClient_TypeA(sOwnerH, DEF_OWNERTYPE_NPC, MSGID_EVENT_MOTION, DEF_OBJECTNULLACTION, NULL, NULL, NULL);
						}
						break;
					}
				} //end of forXY
				// Targetted point
				m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, dX, dY);
				switch (cOwnerType){
				case DEF_OWNERTYPE_PLAYER:
					if ((m_pClientList[sOwnerH] != NULL) && (m_pClientList[sOwnerH]->m_iHP > 0) && (m_pClientList[sOwnerH]->m_iAdminUserLevel == 0)) 
					{	// Remove Berzerk type spells : Time x 0.5
						if (m_pClientList[sOwnerH]->m_cMagicEffectStatus[DEF_MAGICTYPE_BERSERK] != NULL)
						{	bRemoveFromDelayEventList(sOwnerH, DEF_OWNERTYPE_PLAYER, DEF_MAGICTYPE_BERSERK);
							bRegisterDelayEvent(DEF_DELAYEVENTTYPE_MAGICRELEASE, DEF_MAGICTYPE_BERSERK, dwTime + (500 * m_pMagicConfigList[sType]->m_dwLastTime), 
								sOwnerH, DEF_OWNERTYPE_PLAYER, NULL, NULL, NULL, 1, NULL, NULL);
						}
						// Remove Protections:			Time x 1.0
						if (m_pClientList[sOwnerH]->m_cMagicEffectStatus[DEF_MAGICTYPE_PROTECT] != NULL)
						{	bRemoveFromDelayEventList(sOwnerH, DEF_OWNERTYPE_PLAYER, DEF_MAGICTYPE_PROTECT);
							bRegisterDelayEvent(DEF_DELAYEVENTTYPE_MAGICRELEASE, DEF_MAGICTYPE_PROTECT, dwTime + (1000 * m_pMagicConfigList[sType]->m_dwLastTime), 
								sOwnerH, DEF_OWNERTYPE_PLAYER, NULL, NULL, NULL, m_pClientList[sOwnerH]->m_cMagicEffectStatus[DEF_MAGICTYPE_PROTECT], NULL, NULL);
						}	
						ZeroMemory(cTemp, sizeof(cTemp));
						if (   (m_pClientList[iClientH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_CONFUSE ] == 0)
							&& (   (m_bIsCrusadeMode == FALSE)
								|| (m_pClientList[sOwnerH]->m_cSide == m_pClientList[iClientH]->m_cSide)))
						{	wsprintf(cTemp, "You detroyed magic from %s",m_pClientList[sOwnerH]->m_cCharName);
						}else
						{	wsprintf(cTemp, "You detroyed magic from someone.");
						}
						ShowClientMsg(iClientH,  "Cancellat.", cTemp);
						// Update Client
						SendEventToNearClient_TypeA(sOwnerH, DEF_OWNERTYPE_PLAYER, MSGID_EVENT_MOTION, DEF_OBJECTNULLACTION, NULL, NULL, NULL);
					}
					break;
				case DEF_OWNERTYPE_NPC:
					if ((m_pNpcList[sOwnerH] != NULL) && (m_pNpcList[sOwnerH]->m_iHP > 0)) 
					{	// Remove Berzerk type spells : Time x 0.6
						if (m_pNpcList[sOwnerH]->m_cMagicEffectStatus[DEF_MAGICTYPE_BERSERK] != NULL)
						{	bRemoveFromDelayEventList(sOwnerH, DEF_OWNERTYPE_NPC, DEF_MAGICTYPE_BERSERK);
							bRegisterDelayEvent(DEF_DELAYEVENTTYPE_MAGICRELEASE, DEF_MAGICTYPE_BERSERK, dwTime + (600 * m_pMagicConfigList[sType]->m_dwLastTime), 
								sOwnerH, DEF_OWNERTYPE_NPC, NULL, NULL, NULL, 1, NULL, NULL);
						}
						// Remove Protections:			Time x 1.0
						if (m_pNpcList[sOwnerH]->m_cMagicEffectStatus[DEF_MAGICTYPE_PROTECT] != NULL)
						{	bRemoveFromDelayEventList(sOwnerH, DEF_OWNERTYPE_NPC, DEF_MAGICTYPE_PROTECT);
							bRegisterDelayEvent(DEF_DELAYEVENTTYPE_MAGICRELEASE, DEF_MAGICTYPE_PROTECT, dwTime + (1000 * m_pMagicConfigList[sType]->m_dwLastTime), 
								sOwnerH, DEF_OWNERTYPE_NPC, NULL, NULL, NULL, m_pNpcList[sOwnerH]->m_cMagicEffectStatus[DEF_MAGICTYPE_PROTECT], NULL, NULL);
						}
						ZeroMemory(cTemp, sizeof(cTemp));
						wsprintf(cTemp, "You detroyed magic from a %s.",m_pNpcList[sOwnerH]->m_cNpcName);
						ShowClientMsg(iClientH,  "Cancellat.", cTemp);
						// Update Client
						SendEventToNearClient_TypeA(sOwnerH, DEF_OWNERTYPE_NPC, MSGID_EVENT_MOTION, DEF_OBJECTNULLACTION, NULL, NULL, NULL);
					}
					break;
				}
				break;

			case DEF_MAGICTYPE_DAMAGE_LINEAR_SPDOWN: //30 ESW
				//  m_sValue4 5 6 used for damage target
				//  m_sValue7 8 9 used for damage Linear, Area 
				//  m_sValue10 11 12 used for SP down
				for (i = 2; i < 10; i++) 
				{	iErr = 0;
					m_Misc.GetPoint2(sX, sY, dX, dY, &tX, &tY, &iErr, i);
					// tx, ty
					m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, tX, tY);
					if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult+50) == FALSE) 
					{	switch (cOwnerType) {
						case DEF_OWNERTYPE_PLAYER:
							if (m_pClientList[sOwnerH] == NULL) break;
							Effect_Damage_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9 + iWhetherBonus, TRUE, iMagicAttr, 1);
							Effect_SpDown_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue10, m_pMagicConfigList[sType]->m_sValue11, m_pMagicConfigList[sType]->m_sValue12);
							break;
						case DEF_OWNERTYPE_NPC:
							if (m_pNpcList[sOwnerH] == NULL) break;
							Effect_Damage_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9 + iWhetherBonus, TRUE, iMagicAttr, 1);
							break;						
					}	}
					m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetDeadOwner(&sOwnerH, &cOwnerType, tX, tY);
					if ( (cOwnerType == DEF_OWNERTYPE_PLAYER) && (m_pClientList[sOwnerH] != NULL) && (m_pClientList[sOwnerH]->m_iHP > 0) ) 
					{	if (m_pClientList[sOwnerH] == NULL) continue;
						if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult+100) == FALSE) 
						{	Effect_Damage_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9 + iWhetherBonus, TRUE, iMagicAttr, 1);
							Effect_SpDown_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue10, m_pMagicConfigList[sType]->m_sValue11, m_pMagicConfigList[sType]->m_sValue12);
					}	}

					// tx-1, ty
					m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, tX-1, tY);
					if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult+50) == FALSE) 
					{	switch (cOwnerType) {
						case DEF_OWNERTYPE_PLAYER:
							if (m_pClientList[sOwnerH] == NULL) break;
							Effect_Damage_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9 + iWhetherBonus, TRUE, iMagicAttr, 1);
							Effect_SpDown_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue10, m_pMagicConfigList[sType]->m_sValue11, m_pMagicConfigList[sType]->m_sValue12);
							break;
						case DEF_OWNERTYPE_NPC:
							if (m_pNpcList[sOwnerH] == NULL) break;
							Effect_Damage_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9 + iWhetherBonus, TRUE, iMagicAttr, 1);
							break;							
					}	}
					m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetDeadOwner(&sOwnerH, &cOwnerType, tX-1, tY);
					if ( (cOwnerType == DEF_OWNERTYPE_PLAYER) && (m_pClientList[sOwnerH] != NULL) && (m_pClientList[sOwnerH]->m_iHP > 0) )
					{	if (m_pClientList[sOwnerH] == NULL) continue;
						if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult+100) == FALSE)
						{	Effect_Damage_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9 + iWhetherBonus, TRUE, iMagicAttr, 1);
							Effect_SpDown_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue10, m_pMagicConfigList[sType]->m_sValue11, m_pMagicConfigList[sType]->m_sValue12);
					}	}

					// tx+1, ty
					m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, tX+1, tY);
					if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult+50) == FALSE) 
					{	switch (cOwnerType) {
						case DEF_OWNERTYPE_PLAYER:
							if (m_pClientList[sOwnerH] == NULL) break;
							Effect_Damage_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9 + iWhetherBonus, TRUE, iMagicAttr, 1);
							Effect_SpDown_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue10, m_pMagicConfigList[sType]->m_sValue11, m_pMagicConfigList[sType]->m_sValue12);
							break;
						case DEF_OWNERTYPE_NPC:
							if (m_pNpcList[sOwnerH] == NULL) break;
							Effect_Damage_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9 + iWhetherBonus, TRUE, iMagicAttr, 1);
							break;							
					}	}
					m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetDeadOwner(&sOwnerH, &cOwnerType, tX+1, tY);
					if ( (cOwnerType == DEF_OWNERTYPE_PLAYER) && (m_pClientList[sOwnerH] != NULL) && (m_pClientList[sOwnerH]->m_iHP > 0) ) 
					{	if (m_pClientList[sOwnerH] == NULL) continue;
						if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType+100, iResult) == FALSE) 
						{	Effect_Damage_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9 + iWhetherBonus, TRUE, iMagicAttr, 1);
							Effect_SpDown_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue10, m_pMagicConfigList[sType]->m_sValue11, m_pMagicConfigList[sType]->m_sValue12);
					}	}

					// tx, ty-1
					m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, tX, tY-1);
					if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult+50) == FALSE) 
					{	switch (cOwnerType) {
						case DEF_OWNERTYPE_PLAYER:
							if (m_pClientList[sOwnerH] == NULL) break;
							Effect_Damage_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9 + iWhetherBonus, TRUE, iMagicAttr, 1);
							Effect_SpDown_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue10, m_pMagicConfigList[sType]->m_sValue11, m_pMagicConfigList[sType]->m_sValue12);
								break;
						case DEF_OWNERTYPE_NPC:
							if (m_pNpcList[sOwnerH] == NULL) break;
							Effect_Damage_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9 + iWhetherBonus, TRUE, iMagicAttr, 1);
							break;						
					}	}
					m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetDeadOwner(&sOwnerH, &cOwnerType, tX, tY-1);
					if ( (cOwnerType == DEF_OWNERTYPE_PLAYER) && (m_pClientList[sOwnerH] != NULL) && (m_pClientList[sOwnerH]->m_iHP > 0) ) 
					{	if (m_pClientList[sOwnerH] == NULL) continue;
						if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult+100) == FALSE) 
						{	Effect_Damage_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9 + iWhetherBonus, TRUE, iMagicAttr, 1);
							Effect_SpDown_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue10, m_pMagicConfigList[sType]->m_sValue11, m_pMagicConfigList[sType]->m_sValue12);
					}	}

					// tx, ty+1
					m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, tX, tY+1);
					if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult+50) == FALSE) 
					{	switch (cOwnerType) {
						case DEF_OWNERTYPE_PLAYER:
							if (m_pClientList[sOwnerH] == NULL) break;
							Effect_Damage_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9 + iWhetherBonus, TRUE, iMagicAttr, 1);
							Effect_SpDown_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue10, m_pMagicConfigList[sType]->m_sValue11, m_pMagicConfigList[sType]->m_sValue12);
							break;
						case DEF_OWNERTYPE_NPC:
							if (m_pNpcList[sOwnerH] == NULL) break;
							Effect_Damage_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9 + iWhetherBonus, TRUE, iMagicAttr, 1);
							break;
					}	}
					m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetDeadOwner(&sOwnerH, &cOwnerType, tX, tY+1);
					if ( (cOwnerType == DEF_OWNERTYPE_PLAYER) && (m_pClientList[sOwnerH] != NULL) && (m_pClientList[sOwnerH]->m_iHP > 0) ) 
					{	if (m_pClientList[sOwnerH] == NULL) continue;
						if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult+100) == FALSE) 
						{	Effect_Damage_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9 + iWhetherBonus, TRUE, iMagicAttr, 1);
							Effect_SpDown_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue10, m_pMagicConfigList[sType]->m_sValue11, m_pMagicConfigList[sType]->m_sValue12);
					}	}
					// Do not strike again if target is close to caster
					if ( (abs(tX - dX) <= 1) && (abs(tY - dY) <= 1)) break;
				}
				// Area Damage
				for (iy = dY - m_pMagicConfigList[sType]->m_sValue3; iy <= dY + m_pMagicConfigList[sType]->m_sValue3; iy++)
				{	for (ix = dX - m_pMagicConfigList[sType]->m_sValue2; ix <= dX + m_pMagicConfigList[sType]->m_sValue2; ix++) 
					{	m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, ix, iy);
						if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult+50) == FALSE) 
						{	switch (cOwnerType) {
							case DEF_OWNERTYPE_PLAYER:
								if (m_pClientList[sOwnerH] == NULL) break;
								Effect_Damage_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9 + iWhetherBonus, TRUE, iMagicAttr, 1);
								Effect_SpDown_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue10, m_pMagicConfigList[sType]->m_sValue11, m_pMagicConfigList[sType]->m_sValue12);
								break;
							case DEF_OWNERTYPE_NPC:
								if (m_pNpcList[sOwnerH] == NULL) break;
								Effect_Damage_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9 + iWhetherBonus, TRUE, iMagicAttr, 1);
								break;							
						}	}
						m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetDeadOwner(&sOwnerH, &cOwnerType, ix, iy);
						if ( (cOwnerType == DEF_OWNERTYPE_PLAYER) && (m_pClientList[sOwnerH] != NULL) && (m_pClientList[sOwnerH]->m_iHP > 0) ) 
						{	if (m_pClientList[sOwnerH] == NULL) break;
							if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult+100) == FALSE) 
							{	Effect_Damage_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9 + iWhetherBonus, TRUE, iMagicAttr, 1);
				}	}	}	}

				// Damage on Target m_sValue456
				m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, dX, dY);
				if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult+50) == FALSE) 
				{	switch (cOwnerType) {
					case DEF_OWNERTYPE_PLAYER:
						Effect_Damage_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue4, m_pMagicConfigList[sType]->m_sValue5, m_pMagicConfigList[sType]->m_sValue6 + iWhetherBonus, TRUE, iMagicAttr, 1);
						Effect_SpDown_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue10, m_pMagicConfigList[sType]->m_sValue11, m_pMagicConfigList[sType]->m_sValue12);
						break;
					case DEF_OWNERTYPE_NPC:
						if (m_pNpcList[sOwnerH] == NULL) break;
						Effect_Damage_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue4, m_pMagicConfigList[sType]->m_sValue5, m_pMagicConfigList[sType]->m_sValue6 + iWhetherBonus, TRUE, iMagicAttr, 1);
						break;
				}	}
				m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetDeadOwner(&sOwnerH, &cOwnerType, dX, dY);
				if ( (cOwnerType == DEF_OWNERTYPE_PLAYER) && (m_pClientList[sOwnerH] != NULL) && (m_pClientList[sOwnerH]->m_iHP > 0) ) 
				{	if (m_pClientList[sOwnerH] == NULL) break;
					if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult+100) == FALSE) 
					{	Effect_Damage_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue4, m_pMagicConfigList[sType]->m_sValue5, m_pMagicConfigList[sType]->m_sValue6 + iWhetherBonus, TRUE, iMagicAttr, 1);
						Effect_SpDown_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue10, m_pMagicConfigList[sType]->m_sValue11, m_pMagicConfigList[sType]->m_sValue12);
				}	}					
				break;

			case DEF_MAGICTYPE_INHIBITION: //31
				m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, dX, dY);
				switch (cOwnerType) {
				case DEF_OWNERTYPE_PLAYER:
					if (m_pClientList[sOwnerH] == NULL) goto MAGIC_NOEFFECT;
					if (m_pClientList[sOwnerH]->m_bInhibition == TRUE) goto MAGIC_NOEFFECT;
					if (   (m_pClientList[iClientH]->m_cSide == 0)
						&& (m_pClientList[iClientH]->m_iAdminUserLevel < 1)) goto MAGIC_NOEFFECT ;
					if (m_pClientList[sOwnerH]->m_iAdminUserLevel != 0) goto MAGIC_NOEFFECT;
					if (m_pClientList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_PROTECT ] == 5) goto MAGIC_NOEFFECT; 
					m_pClientList[sOwnerH]->m_bInhibition = TRUE;
					if (m_pClientList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_PROTECT ] == 2) // Half time if PFM
					bRegisterDelayEvent(DEF_DELAYEVENTTYPE_MAGICRELEASE, DEF_MAGICTYPE_INHIBITION, dwTime + (m_pMagicConfigList[sType]->m_dwLastTime*500), 
						sOwnerH, cOwnerType, NULL, NULL, NULL, 1, NULL, NULL);
					else
					bRegisterDelayEvent(DEF_DELAYEVENTTYPE_MAGICRELEASE, DEF_MAGICTYPE_INHIBITION, dwTime + (m_pMagicConfigList[sType]->m_dwLastTime*1000), 
						sOwnerH, cOwnerType, NULL, NULL, NULL, 1, NULL, NULL);
					break;
				}
				break;

			case DEF_MAGICTYPE_SCAN: //33 SCAN
				ZeroMemory(cTemp, sizeof(cTemp));
				m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, dX, dY);
				if ((bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE)
					// SNOOPY: Added no chance to resist a scan by a GM
					|| (m_pClientList[iClientH]->m_iAdminUserLevel > 0 )){
					switch (cOwnerType) {
					case DEF_OWNERTYPE_PLAYER:
						if (m_pClientList[sOwnerH] == NULL) goto MAGIC_NOEFFECT;
						wsprintf(cTemp, " Player: %s HP:%d MP:%d.", m_pClientList[sOwnerH]->m_cCharName, m_pClientList[sOwnerH]->m_iHP, m_pClientList[sOwnerH]->m_iMP);
							ShowClientMsg(iClientH,  "Scan", cTemp);
							break;
					case DEF_OWNERTYPE_NPC:
						if (m_pNpcList[sOwnerH] == NULL) goto MAGIC_NOEFFECT;
						wsprintf(cTemp, " NPC: %s HP:%d MP:%d", m_pNpcList[sOwnerH]->m_cNpcName, m_pNpcList[sOwnerH]->m_iHP, m_pNpcList[sOwnerH]->m_iMana);
						ShowClientMsg(iClientH, "Scan", cTemp);
						break;
					}
				SendEventToNearClient_TypeB(MSGID_EVENT_COMMON, DEF_COMMONTYPE_MAGIC, m_pClientList[iClientH]->m_cMapIndex,
						m_pClientList[iClientH]->m_sX, m_pClientList[iClientH]->m_sY, dX, dY, 10, 10);
				}
				break;

			case DEF_MAGICTYPE_MANA_DOWN_SPOT: // 50, added by Spoopy
				m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, dX, dY);
				if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, -1) == FALSE)
					Effect_ManaDown_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue4, m_pMagicConfigList[sType]->m_sValue5, m_pMagicConfigList[sType]->m_sValue6 + iWhetherBonus, TRUE, iMagicAttr);
				m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetDeadOwner(&sOwnerH, &cOwnerType, dX, dY);
				if ((cOwnerType == DEF_OWNERTYPE_PLAYER) && (m_pClientList[sOwnerH] != NULL) && (m_pClientList[sOwnerH]->m_iHP > 0)) {
					if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, -1) == FALSE)
						Effect_ManaDown_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue4, m_pMagicConfigList[sType]->m_sValue5, m_pMagicConfigList[sType]->m_sValue6 + iWhetherBonus, TRUE, iMagicAttr);
				}
				break;

			case DEF_MAGICTYPE_REFLEXION: // 51, added by Spoopy
				if (m_pClientList[iClientH] == NULL) goto MAGIC_NOEFFECT;
				if (   (m_pClientList[iClientH]->m_cSide == 0)
					&& (m_pClientList[iClientH]->m_iAdminUserLevel < 1)) goto MAGIC_NOEFFECT ;
				if (m_pClientList[iClientH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_REFLEXION] == 0) 
				{	m_pClientList[iClientH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_REFLEXION] = m_pMagicConfigList[sType]->m_sValue4;
					m_pClientList[iClientH]->m_cMagicEffectStatus[DEF_MAGICTYPE_REFLEXION_COUNT] = 0;
					bRegisterDelayEvent(DEF_DELAYEVENTTYPE_MAGICRELEASE, DEF_MAGICTYPE_REFLEXION, dwTime + (m_pMagicConfigList[sType]->m_dwLastTime*1000), 
						iClientH, DEF_OWNERTYPE_PLAYER, NULL, NULL, NULL, 0, NULL, NULL);
					SetReflexionFlag(sOwnerH, DEF_OWNERTYPE_PLAYER, TRUE);
				}else 
				{	goto MAGIC_NOEFFECT;
				}
				break;
	
			case DEF_MAGICTYPE_EXPLOSION: // 52, Sends back pc or mobs away from caster with some damage.					
				// Damage is 456, fly pc/mobs is automatic
				// Fly from targeted point with double/mulptiple strike/fly...
				for (iy = dY; iy >= dY - m_pMagicConfigList[sType]->m_sValue3; iy--)// up left
				for (ix = dX; ix >= dX - m_pMagicConfigList[sType]->m_sValue2; ix--) 
				{	m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, ix, iy);
					//if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE)
					Effect_Damage_Explosion(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, dX, dY, m_pMagicConfigList[sType]->m_sValue4, m_pMagicConfigList[sType]->m_sValue5, m_pMagicConfigList[sType]->m_sValue6 + iWhetherBonus, FALSE, iMagicAttr);
				}
				for (iy = dY+1; iy <= dY + m_pMagicConfigList[sType]->m_sValue3; iy++)// down left
				for (ix = dX;   ix >= dX - m_pMagicConfigList[sType]->m_sValue2; ix--) 
				{	m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, ix, iy);
					//if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE)
					Effect_Damage_Explosion(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, dX, dY, m_pMagicConfigList[sType]->m_sValue4, m_pMagicConfigList[sType]->m_sValue5, m_pMagicConfigList[sType]->m_sValue6 + iWhetherBonus, FALSE, iMagicAttr);
				}
				for (iy = dY;   iy >= dY - m_pMagicConfigList[sType]->m_sValue3; iy--)
				for (ix = dX+1; ix <= dX + m_pMagicConfigList[sType]->m_sValue2; ix++) // up right
				{	m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, ix, iy);
					//if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE)
					Effect_Damage_Explosion(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, dX, dY, m_pMagicConfigList[sType]->m_sValue4, m_pMagicConfigList[sType]->m_sValue5, m_pMagicConfigList[sType]->m_sValue6 + iWhetherBonus, FALSE, iMagicAttr);
				}
				for (iy = dY+1; iy <= dY + m_pMagicConfigList[sType]->m_sValue3; iy++) // down right
				for (ix = dX+1; ix <= dX + m_pMagicConfigList[sType]->m_sValue2; ix++) 
				{	m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, ix, iy);
					//if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE)
					Effect_Damage_Explosion(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, dX, dY, m_pMagicConfigList[sType]->m_sValue4, m_pMagicConfigList[sType]->m_sValue5, m_pMagicConfigList[sType]->m_sValue6 + iWhetherBonus, FALSE, iMagicAttr);
				}				
				// Show effect
				SendEventToNearClient_TypeB(MSGID_EVENT_COMMON, DEF_COMMONTYPE_MAGIC, m_pClientList[iClientH]->m_cMapIndex,
					m_pClientList[iClientH]->m_sX, m_pClientList[iClientH]->m_sY, dX, dY, (161), m_pClientList[iClientH]->m_sType);
				
				// Dead owner will fly without MR possibility
				for (iy = dY - m_pMagicConfigList[sType]->m_sValue3; iy <= dY + m_pMagicConfigList[sType]->m_sValue3; iy++)
				for (ix = dX - m_pMagicConfigList[sType]->m_sValue2; ix <= dX + m_pMagicConfigList[sType]->m_sValue2; ix++) 
				{	m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetDeadOwner(&sOwnerH, &cOwnerType, ix, iy);
					if ((cOwnerType == DEF_OWNERTYPE_PLAYER) && (m_pClientList[sOwnerH] != NULL) && (m_pClientList[sOwnerH]->m_iHP > 0)) 
					{	if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE)
							Effect_Damage_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue4, m_pMagicConfigList[sType]->m_sValue5, m_pMagicConfigList[sType]->m_sValue6 + iWhetherBonus, FALSE, iMagicAttr);
					}
					if (iDice(1,7)==4) // Add fires
					iAddDynamicObjectList(iClientH, DEF_OWNERTYPE_PLAYER_INDIRECT, DEF_DYNAMICOBJECT_FIRE3, m_pClientList[iClientH]->m_cMapIndex, ix, iy, (iDice(1,7)+3)*1000, 8);
				} 
				break;

			case DEF_MAGICTYPE_METAMORPHOSIS: // 60, added by Spoopy
				m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, dX, dY);
				// The spell costs all Player's mana
				if (m_pClientList[iClientH]->m_iAdminUserLevel <1) 
				{	iManaCost = m_pClientList[iClientH]->m_iMP;
					if(	m_pClientList[iClientH]->m_iMP <500) goto MAGIC_NOEFFECT; 
				}
				if (cOwnerType != DEF_OWNERTYPE_PLAYER) goto MAGIC_NOEFFECT; 
				if (m_pClientList[sOwnerH] == NULL) goto MAGIC_NOEFFECT;						
				if (   (m_pClientList[iClientH]->m_cSide == 0)
					&& (m_pClientList[iClientH]->m_iAdminUserLevel < 1)
					&& (iClientH != sOwnerH)) goto MAGIC_NOEFFECT;
				if (m_pClientList[sOwnerH]->m_cMagicEffectStatus[DEF_MAGICTYPE_METAMORPHOSIS] == 0) 
				{	//Type of sword
					m_pClientList[sOwnerH]->m_cMagicEffectStatus[DEF_MAGICTYPE_METAMORPHOSIS_WEAPONTYPE] = 1;
					if  ((m_pClientList[iClientH]->m_iInt + m_pClientList[iClientH]->m_iAngelicInt) > 181)							
						m_pClientList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_METAMORPHOSIS_WEAPONTYPE] = 2;
					if  ((m_pClientList[iClientH]->m_iInt + m_pClientList[iClientH]->m_iAngelicInt) > 220)							
						m_pClientList[sOwnerH]->m_cMagicEffectStatus[DEF_MAGICTYPE_METAMORPHOSIS_WEAPONTYPE] = 3;
					if  ((m_pClientList[iClientH]->m_iInt + m_pClientList[iClientH]->m_iAngelicInt) > 246)							
						m_pClientList[sOwnerH]->m_cMagicEffectStatus[DEF_MAGICTYPE_METAMORPHOSIS_WEAPONTYPE] = 4;
					if ((m_pClientList[iClientH]->m_iInt + m_pClientList[iClientH]->m_iAngelicInt) <250) // Uses caster Int as target Strength						
						m_pClientList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_METAMORPHOSIS ] = (char) ((m_pClientList[iClientH]->m_iInt + m_pClientList[iClientH]->m_iAngelicInt)/10);
					else
						m_pClientList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_METAMORPHOSIS ] = (char) 25; // Max possible
											
					if ((m_pClientList[iClientH]->m_iMag + m_pClientList[iClientH]->m_iAngelicMag) <250) // Uses caster Mag as target Dext						
						m_pClientList[sOwnerH]->m_cMagicEffectStatus[DEF_MAGICTYPE_METAMORPHOSIS_TEMP_DEXT] = (char) ((m_pClientList[iClientH]->m_iMag + m_pClientList[iClientH]->m_iAngelicMag)/10);
					else
						m_pClientList[sOwnerH]->m_cMagicEffectStatus[DEF_MAGICTYPE_METAMORPHOSIS_TEMP_DEXT] = (char) 25;
					bRegisterDelayEvent(DEF_DELAYEVENTTYPE_MAGICRELEASE, DEF_MAGICTYPE_METAMORPHOSIS, dwTime + (m_pMagicConfigList[sType]->m_dwLastTime*1000), 
						sOwnerH, cOwnerType, NULL, NULL, NULL, 0, NULL, NULL);
					SetMetamorphosisFlag(sOwnerH, DEF_OWNERTYPE_PLAYER, TRUE);
				}else // Same spell can reverse effect
				{	bRemoveFromDelayEventList(iClientH, DEF_OWNERTYPE_PLAYER, DEF_MAGICTYPE_METAMORPHOSIS);			
					bRegisterDelayEvent(DEF_DELAYEVENTTYPE_MAGICRELEASE, DEF_MAGICTYPE_METAMORPHOSIS, dwTime, 
						iClientH, DEF_OWNERTYPE_PLAYER, NULL, NULL, NULL, 0, NULL, NULL);
				}
				break;

			case DEF_MAGICTYPE_RESURRECTION: // For this spell m_dwDelayTime is not zero !
				// Check if player has resurrection wand
				if (   (m_pClientList[iClientH] != NULL)
					&& (m_pClientList[iClientH]->m_iSpecialAbilityTime == 0)
					&& (m_pClientList[iClientH]->m_bIsSpecialAbilityEnabled == FALSE) )
				{	m_pMapList[ m_pClientList[iClientH]->m_cMapIndex ]->GetDeadOwner(&sOwnerH, &cOwnerType, dX, dY);
					if ((m_pClientList[sOwnerH] != NULL) && (cOwnerType == DEF_OWNERTYPE_PLAYER))
					{	sEqStatus = m_pClientList[iClientH]->m_sItemEquipmentStatus[DEF_EQUIPPOS_RHAND];							
						if ((sEqStatus != -1) && (m_pClientList[iClientH]->m_pItemList[sEqStatus] != NULL)) 
						{	if (   (m_pClientList[iClientH]->m_pItemList[sEqStatus]->m_sIDnum != 865) 
								&& (m_pClientList[iClientH]->m_pItemList[sEqStatus]->m_sIDnum != 866)
								&& (m_pClientList[iClientH]->m_iPriestDruidID != 1)
								&& (m_pClientList[iClientH]->m_iAdminUserLevel < 2)) 
							{	wsprintf(G_cTxt, "Resurection Hack:  PC(%s) - Cast resurrect with wrong wand (is not Priest)!.(Delayed). \tIP(%s)"
									, m_pClientList[iClientH]->m_cCharName
									, m_pClientList[iClientH]->m_cIPaddress);
								PutHackLogFileList(G_cTxt);
								DelayedDeleteClient(iClientH, TRUE, TRUE, TRUE, TRUE);
								return;
							}
						}else // No wand ewuiped
						{	if (   (m_pClientList[iClientH]->m_iPriestDruidID != 1)
								&& (m_pClientList[iClientH]->m_iAdminUserLevel < 2))
							{	wsprintf(G_cTxt, "Resurection Hack:  PC(%s) - Cast resurrect without a wand  (is not Priest)!.(Delayed). \tIP(%s)"
									, m_pClientList[iClientH]->m_cCharName
									, m_pClientList[iClientH]->m_cIPaddress);
								PutHackLogFileList(G_cTxt);
								DelayedDeleteClient(iClientH, TRUE, TRUE, TRUE, TRUE);
								return;						
						}	}
						// SNOOPY Prevent ressurect between cities if not in Party
						if (   (m_pClientList[sOwnerH]->m_iPartyID == NULL)
							|| (m_pClientList[sOwnerH]->m_iPartyID != m_pClientList[iClientH]->m_iPartyID)) 
						{	if (   (m_pClientList[iClientH]->m_iAdminUserLevel < 2)
								&& (m_pClientList[sOwnerH]->m_cSide != m_pClientList[iClientH]->m_cSide)) 
							{	wsprintf(G_cTxt, "(!) Player(%s) tried to cast resurrect an ennemi (%s)."
									, m_pClientList[iClientH]->m_cCharName
									, m_pClientList[sOwnerH]->m_cCharName);
								PutLogList(G_cTxt);
								goto MAGIC_NOEFFECT;
						} }
						if ((m_pClientList[sOwnerH]->m_iHP <= 0)||(m_pClientList[sOwnerH]->m_bIsKilled == TRUE))
						{	m_pClientList[sOwnerH]->m_bIsBeingResurrected = TRUE;
							SendNotifyMsg(NULL, sOwnerH, DEF_NOTIFY_RESURRECTPLAYER, NULL, NULL, NULL, NULL);
							// Resetting of SpecialAbilityTime moved down...
						}else
						{	wsprintf(G_cTxt, "(!) Player(%s) tried to cast resurrect on player with more than 0 HP (%s)."
								, m_pClientList[iClientH]->m_cCharName
								, m_pClientList[sOwnerH]->m_cCharName);
							PutLogList(G_cTxt);
							goto MAGIC_NOEFFECT;
				}	}	}
				break;

			default:
				break;
			}// End Spells switch
			// Cast a "DelayTime" type spell, reset Specialability timer.	
			if (m_pMagicConfigList[sType]->m_dwDelayTime != 0)
			{	if (m_pClientList[iClientH]->m_iAdminUserLevel < 2) 
				{	m_pClientList[iClientH]->m_bIsSpecialAbilityEnabled	 = FALSE;
					m_pClientList[iClientH]->m_dwSpecialAbilityStartTime = dwTime;
					m_pClientList[iClientH]->m_iSpecialAbilityLastSec    = 0;
					m_pClientList[iClientH]->m_iSpecialAbilityTime       = m_pMagicConfigList[sType]->m_dwDelayTime;
					sTemp = m_pClientList[iClientH]->m_sAppr4;
					sTemp = 0xFF0F & sTemp;
					sTemp = sTemp | 0x40;
					m_pClientList[iClientH]->m_sAppr4 = sTemp;
					SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_SPECIALABILITYSTATUS, 1, 55, m_pClientList[iClientH]->m_iSpecialAbilityTime, NULL);
					SendEventToNearClient_TypeA(iClientH, DEF_OWNERTYPE_PLAYER, MSGID_EVENT_MOTION, DEF_OBJECTNULLACTION, NULL, NULL, NULL);
			}	}
		}else if ( (m_pMagicConfigList[sType]->m_dwDelayTime != 0) 
				&& (m_pClientList[iClientH]->m_iSpecialAbilityTime != 0))// Not possible to cast this spell now.	
		{	ZeroMemory(cTemp, sizeof(cTemp));
			wsprintf(cTemp, "You cannot use this spell now, wait for %d minutes.",  m_pClientList[iClientH]->m_iSpecialAbilityTime/60);
			ShowClientMsg(iClientH, "Casting", cTemp);
			iManaCost = 0;
		}
MAGIC_NOEFFECT:;
		if (m_pClientList[iClientH] == NULL) return;
		// restore PartyID
		m_pClientList[iClientH]->m_bIsReflexionVictim = FALSE;
		//Mana Slate
		if (m_pClientList[iClientH]->m_bManaSlate) 
		{	iManaCost = 0;
		}
		// Mana
		m_pClientList[iClientH]->m_iMP -= iManaCost; // sValue1 Mana Cost
		if (m_pClientList[iClientH]->m_iMP < 0) 
			m_pClientList[iClientH]->m_iMP = 0;

		CalculateSSN_SkillIndex(iClientH, 4, 1 );
		SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_MP, NULL, NULL, NULL, NULL);
		switch (m_pMagicConfigList[sType]->m_sType) {
		case DEF_MAGICTYPE_EXPLOSION: // 52, Sends back pc or mobs away from caster with some damage.
			// Effect is shown first
			//SendEventToNearClient_TypeB(MSGID_EVENT_COMMON, DEF_COMMONTYPE_MAGIC, m_pClientList[iClientH]->m_cMapIndex,
			//	m_pClientList[iClientH]->m_sX, m_pClientList[iClientH]->m_sY, dX, dY, (161), m_pClientList[iClientH]->m_sType);
			break;
		default:
			SendEventToNearClient_TypeB(MSGID_EVENT_COMMON, DEF_COMMONTYPE_MAGIC, m_pClientList[iClientH]->m_cMapIndex,
				m_pClientList[iClientH]->m_sX, m_pClientList[iClientH]->m_sY, dX, dY, (sType+100), m_pClientList[iClientH]->m_sType);
			break;
		}
}

void CGame::NpcMagicHandler(int iNpcH, short dX, short dY, short sType)
{
 short  sOwnerH;
 char   cOwnerType;
 register int i, iErr, ix, iy, sX, sY, tX, tY;
 int iResult, iIceAtkRatio, iWhetherBonus, iMagicAttr;
 DWORD  dwTime = timeGetTime();

	if (m_pNpcList[iNpcH] == NULL) return;
	if ((dX < 0) || (dX >= m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->m_sSizeX) ||
        (dY < 0) || (dY >= m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->m_sSizeY)) return;
									   
	if ((sType < 0) || (sType >= 100))     return;
	if (m_pMagicConfigList[sType] == NULL) return;
	
	if (m_pMapList[ m_pNpcList[iNpcH]->m_cMapIndex ]->m_bIsAttackEnabled == FALSE) return;
	
	iResult = m_pNpcList[iNpcH]->m_iMagicHitRatio;
	iIceAtkRatio = iResult/8;
	iWhetherBonus = iGetWhetherMagicBonusEffect(sType, m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->m_cWhetherStatus);
	iMagicAttr = m_pMagicConfigList[sType]->m_iAttribute;

	// If target uses Magic reflexion, replace target XY by caster XY...
	m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, dX, dY);
	if (cOwnerType == DEF_OWNERTYPE_PLAYER) 
		if (m_pClientList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_REFLEXION] == 3) 
		{	dX = m_pNpcList[iNpcH]->m_sX;
			dY = m_pNpcList[iNpcH]->m_sY;	
		}
	// sX, sY is Caster position
	sX = m_pNpcList[iNpcH]->m_sX;
	sY = m_pNpcList[iNpcH]->m_sY;
	if (m_pMagicConfigList[sType]->m_dwDelayTime == 0) 
	{	switch (m_pMagicConfigList[sType]->m_sType) {
		
		case DEF_MAGICTYPE_DAMAGE_SPOT: // 1
			m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, dX, dY);
			if (bCheckResistingMagicSuccess(-1, sOwnerH, cOwnerType, iResult+50) == FALSE)
				Effect_Damage_Spot_DamageMove(iNpcH, DEF_OWNERTYPE_NPC, sOwnerH, cOwnerType, sX, sY, m_pMagicConfigList[sType]->m_sValue4, m_pMagicConfigList[sType]->m_sValue5, m_pMagicConfigList[sType]->m_sValue6 + iWhetherBonus, FALSE, iMagicAttr);
			m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->GetDeadOwner(&sOwnerH, &cOwnerType, dX, dY);
			if (    (cOwnerType == DEF_OWNERTYPE_PLAYER) && (m_pClientList[sOwnerH] != NULL) 
			 	 && (m_pClientList[sOwnerH]->m_iHP > 0) ) 
			{	if (bCheckResistingMagicSuccess(-1, sOwnerH, cOwnerType, iResult) == FALSE)
				Effect_Damage_Spot(iNpcH, DEF_OWNERTYPE_NPC, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue4, m_pMagicConfigList[sType]->m_sValue5, m_pMagicConfigList[sType]->m_sValue6 + iWhetherBonus, FALSE, iMagicAttr);
			}
			break;

		case DEF_MAGICTYPE_HPUP_SPOT: // 2
			m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, dX, dY);
			Effect_HpUp_Spot(iNpcH, DEF_OWNERTYPE_NPC, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue4, m_pMagicConfigList[sType]->m_sValue5, m_pMagicConfigList[sType]->m_sValue6);
			break;

		case DEF_MAGICTYPE_DAMAGE_AREA: // 3 (will fly from spell center point)
			m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, dX, dY);
			if (bCheckResistingMagicSuccess(-1, sOwnerH, cOwnerType, iResult) == FALSE)
				Effect_Damage_Spot(iNpcH, DEF_OWNERTYPE_NPC, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue4, m_pMagicConfigList[sType]->m_sValue5, m_pMagicConfigList[sType]->m_sValue6 + iWhetherBonus, FALSE, iMagicAttr);
			
			m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->GetDeadOwner(&sOwnerH, &cOwnerType, dX, dY);
			if (    (cOwnerType == DEF_OWNERTYPE_PLAYER) && (m_pClientList[sOwnerH] != NULL) 
			 	 && (m_pClientList[sOwnerH]->m_iHP > 0) ) 
			{	if (bCheckResistingMagicSuccess(-1, sOwnerH, cOwnerType, iResult) == FALSE)
				Effect_Damage_Spot(iNpcH, DEF_OWNERTYPE_NPC, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue4, m_pMagicConfigList[sType]->m_sValue5, m_pMagicConfigList[sType]->m_sValue6 + iWhetherBonus, FALSE, iMagicAttr);
			}			
			for (iy = dY - m_pMagicConfigList[sType]->m_sValue3; iy <= dY + m_pMagicConfigList[sType]->m_sValue3; iy++)
			for (ix = dX - m_pMagicConfigList[sType]->m_sValue2; ix <= dX + m_pMagicConfigList[sType]->m_sValue2; ix++) 
			{	m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, ix, iy);
				if (bCheckResistingMagicSuccess(-1, sOwnerH, cOwnerType, iResult) == FALSE)
					Effect_Damage_Spot_DamageMove(iNpcH, DEF_OWNERTYPE_NPC, sOwnerH, cOwnerType, dX, dY, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9 + iWhetherBonus, FALSE, iMagicAttr);

				m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->GetDeadOwner(&sOwnerH, &cOwnerType, ix, iy);
				if (    (cOwnerType == DEF_OWNERTYPE_PLAYER) && (m_pClientList[sOwnerH] != NULL) 
			 	     && (m_pClientList[sOwnerH]->m_iHP > 0) ) 
				{	if (bCheckResistingMagicSuccess(-1, sOwnerH, cOwnerType, iResult) == FALSE)
						Effect_Damage_Spot_DamageMove(iNpcH, DEF_OWNERTYPE_NPC, sOwnerH, cOwnerType, dX, dY, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9 + iWhetherBonus, FALSE, iMagicAttr);
			   	}
			}
			break;

		case DEF_MAGICTYPE_SPDOWN_AREA: // 5
			m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, dX, dY);
			if (bCheckResistingMagicSuccess(-1, sOwnerH, cOwnerType, iResult) == FALSE)
				Effect_SpDown_Spot(iNpcH, DEF_OWNERTYPE_NPC, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue4, m_pMagicConfigList[sType]->m_sValue5, m_pMagicConfigList[sType]->m_sValue6);
			for (iy = dY - m_pMagicConfigList[sType]->m_sValue3; iy <= dY + m_pMagicConfigList[sType]->m_sValue3; iy++)
			for (ix = dX - m_pMagicConfigList[sType]->m_sValue2; ix <= dX + m_pMagicConfigList[sType]->m_sValue2; ix++) {
				m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, ix, iy);
				if (bCheckResistingMagicSuccess(-1, sOwnerH, cOwnerType, iResult) == FALSE)
					Effect_SpDown_Spot(iNpcH, DEF_OWNERTYPE_NPC, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9);
			}
			break;

		case DEF_MAGICTYPE_SPUP_AREA: // 7
			m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, dX, dY);
			Effect_SpUp_Spot(iNpcH, DEF_OWNERTYPE_NPC, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue4, m_pMagicConfigList[sType]->m_sValue5, m_pMagicConfigList[sType]->m_sValue6);
			for (iy = dY - m_pMagicConfigList[sType]->m_sValue3; iy <= dY + m_pMagicConfigList[sType]->m_sValue3; iy++)
			for (ix = dX - m_pMagicConfigList[sType]->m_sValue2; ix <= dX + m_pMagicConfigList[sType]->m_sValue2; ix++) {
				m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, ix, iy);
				Effect_SpUp_Spot(iNpcH, DEF_OWNERTYPE_NPC, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9);
			}
			break;

		case DEF_MAGICTYPE_HOLDOBJECT: // 12
			m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, dX, dY);
			if (bCheckResistingMagicSuccess(-1, sOwnerH, cOwnerType, iResult) == FALSE) 				
			{	switch (cOwnerType) {
				case DEF_OWNERTYPE_PLAYER:
					if (m_pClientList[sOwnerH] == NULL) goto NMH_NOEFFECT;
					if (m_pClientList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_HOLDOBJECT ] != 0) goto NMH_NOEFFECT;
					// Give a chance anti-Para if very good PR... 
					if (   ((m_pClientList[sOwnerH]->m_cSkillMastery[23] + m_pClientList[sOwnerH]->m_iAddPR + iDice(1,100)) >= 250) 
							&& (m_pClientList[sOwnerH]->m_iSpecialAbilityType != 3)) goto NMH_NOEFFECT;		
					// Monks Druids 130+ Para invulnerables
					if ((m_pClientList[sOwnerH]->m_iPriestDruidID == 3 ) && (m_pClientList[sOwnerH]->m_iLevel >129)) goto NMH_NOEFFECT;  
					if ((m_pClientList[sOwnerH]->m_iPriestDruidID == 2 ) && (m_pClientList[sOwnerH]->m_iLevel >129)) goto NMH_NOEFFECT; 
					m_pClientList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_HOLDOBJECT ] = (char)m_pMagicConfigList[sType]->m_sValue4;
					break;
					
				case DEF_OWNERTYPE_NPC:
					if (m_pNpcList[sOwnerH] == NULL) goto NMH_NOEFFECT;
					if (m_pNpcList[sOwnerH]->m_cMagicLevel >= 6) goto NMH_NOEFFECT; 
					if (m_pNpcList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_HOLDOBJECT ] != 0) goto NMH_NOEFFECT;
					m_pNpcList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_HOLDOBJECT ] = (char)m_pMagicConfigList[sType]->m_sValue4;
					break;
				}
				bRegisterDelayEvent(DEF_DELAYEVENTTYPE_MAGICRELEASE, DEF_MAGICTYPE_HOLDOBJECT, dwTime + (m_pMagicConfigList[sType]->m_dwLastTime*1000), 
					sOwnerH, cOwnerType, NULL, NULL, NULL, m_pMagicConfigList[sType]->m_sValue4, NULL, NULL);
				if (cOwnerType == DEF_OWNERTYPE_PLAYER)
				{	char cParaLevel = m_pMagicConfigList[sType]->m_sValue4; 					
					if (cParaLevel == 20 )						// 20: Medusa Kiss
					{} else if (cParaLevel >8) cParaLevel = 9;	// 9:  Entangle
					else if (cParaLevel >1) cParaLevel = 2;
					SendNotifyMsg(NULL, sOwnerH, DEF_NOTIFY_MAGICEFFECTON, DEF_MAGICTYPE_HOLDOBJECT, cParaLevel, NULL, NULL);
			}	}
			break;

		case DEF_MAGICTYPE_INVISIBILITY: //13
			switch (m_pMagicConfigList[sType]->m_sValue4) {
			case 1:	// Invisibility
				m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, dX, dY);
				switch (cOwnerType) {
				case DEF_OWNERTYPE_PLAYER:
					if (m_pClientList[sOwnerH] == NULL) goto NMH_NOEFFECT;
					if (m_pClientList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_INVISIBILITY ] != 0) goto NMH_NOEFFECT;
					m_pClientList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_INVISIBILITY ] = (char)m_pMagicConfigList[sType]->m_sValue4;
					SetInvisibilityFlag(sOwnerH, cOwnerType, TRUE);
					RemoveFromTarget(sOwnerH, DEF_OWNERTYPE_PLAYER, DEF_MAGICTYPE_INVISIBILITY);
					break;
				case DEF_OWNERTYPE_NPC:
					if (m_pNpcList[sOwnerH] == NULL) goto NMH_NOEFFECT;
					if (m_pNpcList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_INVISIBILITY ] != 0) goto NMH_NOEFFECT;
					m_pNpcList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_INVISIBILITY ] = (char)m_pMagicConfigList[sType]->m_sValue4;
					SetInvisibilityFlag(sOwnerH, cOwnerType, TRUE);
					RemoveFromTarget(sOwnerH, DEF_OWNERTYPE_NPC, DEF_MAGICTYPE_INVISIBILITY);
					break;
				}			
				bRegisterDelayEvent(DEF_DELAYEVENTTYPE_MAGICRELEASE, DEF_MAGICTYPE_INVISIBILITY, dwTime + (m_pMagicConfigList[sType]->m_dwLastTime*1000), 
					                sOwnerH, cOwnerType, NULL, NULL, NULL, m_pMagicConfigList[sType]->m_sValue4, NULL, NULL);
				if (cOwnerType == DEF_OWNERTYPE_PLAYER)
					SendNotifyMsg(NULL, sOwnerH, DEF_NOTIFY_MAGICEFFECTON, DEF_MAGICTYPE_INVISIBILITY, m_pMagicConfigList[sType]->m_sValue4, NULL, NULL);
				break;
			case 2:	// Detect Invisibility
				for (ix = dX - 8; ix <= dX + 8; ix++)
				for (iy = dY - 8; iy <= dY + 8; iy++) {
					m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, ix, iy);
					if (sOwnerH != NULL) {
						switch (cOwnerType) {
						case DEF_OWNERTYPE_PLAYER:
							if (m_pClientList[sOwnerH] == NULL) continue;
							if (m_pClientList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_INVISIBILITY ] != NULL) 
							{	if (m_pClientList[sOwnerH]->m_sType != 66) 
								{	m_pClientList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_INVISIBILITY ] = NULL;
									SetInvisibilityFlag(sOwnerH, cOwnerType, FALSE);
									bRemoveFromDelayEventList(sOwnerH, cOwnerType, DEF_MAGICTYPE_INVISIBILITY);
								}
							}
							break;
						case DEF_OWNERTYPE_NPC:
							if (m_pNpcList[sOwnerH] == NULL) continue;
							if (m_pNpcList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_INVISIBILITY ] != NULL) 
							{	if (m_pClientList[sOwnerH]->m_sType != 66) 
								{	m_pNpcList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_INVISIBILITY ] = NULL;
									SetInvisibilityFlag(sOwnerH, cOwnerType, FALSE);
									bRemoveFromDelayEventList(sOwnerH, cOwnerType, DEF_MAGICTYPE_INVISIBILITY);							
							}	}
							break;
				}	}	}
				break;
			}
			break;

		case DEF_MAGICTYPE_DAMAGE_LINEAR: // 19 BloodyShockWave, LightningBolt
			for (i = 2; i < 10; i++) 
			{	iErr = 0;
				m_Misc.GetPoint2(sX, sY, dX, dY, &tX, &tY, &iErr, i);			
				// tx, ty
				m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, tX, tY);
				if (bCheckResistingMagicSuccess(-1, sOwnerH, cOwnerType, iResult) == FALSE)
					Effect_Damage_Spot_DamageMove(iNpcH, DEF_OWNERTYPE_NPC, sOwnerH, cOwnerType, sX, sY, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9 + iWhetherBonus, FALSE, iMagicAttr);
				m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->GetDeadOwner(&sOwnerH, &cOwnerType, tX, tY);
				if ( (cOwnerType == DEF_OWNERTYPE_PLAYER) && (m_pClientList[sOwnerH] != NULL) && (m_pClientList[sOwnerH]->m_iHP > 0) ) 
				{	if (bCheckResistingMagicSuccess(-1, sOwnerH, cOwnerType, iResult) == FALSE)
						Effect_Damage_Spot(iNpcH, DEF_OWNERTYPE_NPC, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9 + iWhetherBonus, FALSE, iMagicAttr);
				}
				// tx-1, ty
				m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, tX-1, tY);
				if (bCheckResistingMagicSuccess(-1, sOwnerH, cOwnerType, iResult) == FALSE)
					Effect_Damage_Spot_DamageMove(iNpcH, DEF_OWNERTYPE_NPC, sOwnerH, cOwnerType, sX, sY, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9 + iWhetherBonus, FALSE, iMagicAttr);
				m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->GetDeadOwner(&sOwnerH, &cOwnerType, tX-1, tY);
				if ( (cOwnerType == DEF_OWNERTYPE_PLAYER) && (m_pClientList[sOwnerH] != NULL) && (m_pClientList[sOwnerH]->m_iHP > 0) ) 
				{	if (bCheckResistingMagicSuccess(-1, sOwnerH, cOwnerType, iResult) == FALSE)
						Effect_Damage_Spot(iNpcH, DEF_OWNERTYPE_NPC, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9 + iWhetherBonus, FALSE, iMagicAttr);
				}
				// tx+1, ty
				m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, tX+1, tY);
				if (bCheckResistingMagicSuccess(-1, sOwnerH, cOwnerType, iResult) == FALSE)
					Effect_Damage_Spot_DamageMove(iNpcH, DEF_OWNERTYPE_NPC, sOwnerH, cOwnerType, sX, sY, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9 + iWhetherBonus, FALSE, iMagicAttr);
				m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->GetDeadOwner(&sOwnerH, &cOwnerType, tX+1, tY);
				if ( (cOwnerType == DEF_OWNERTYPE_PLAYER) && (m_pClientList[sOwnerH] != NULL) && (m_pClientList[sOwnerH]->m_iHP > 0) ) 
				{	if (bCheckResistingMagicSuccess(-1, sOwnerH, cOwnerType, iResult) == FALSE)
						Effect_Damage_Spot(iNpcH, DEF_OWNERTYPE_NPC, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9 + iWhetherBonus, FALSE, iMagicAttr);
				}
				// tx, ty-1
				m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, tX, tY-1);
				if (bCheckResistingMagicSuccess(-1, sOwnerH, cOwnerType, iResult) == FALSE)
					Effect_Damage_Spot_DamageMove(iNpcH, DEF_OWNERTYPE_NPC, sOwnerH, cOwnerType, sX, sY, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9 + iWhetherBonus, FALSE, iMagicAttr);
				m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->GetDeadOwner(&sOwnerH, &cOwnerType, tX, tY-1);
				if ( (cOwnerType == DEF_OWNERTYPE_PLAYER) && (m_pClientList[sOwnerH] != NULL) && (m_pClientList[sOwnerH]->m_iHP > 0) ) 
				{	if (bCheckResistingMagicSuccess(-1, sOwnerH, cOwnerType, iResult) == FALSE)
						Effect_Damage_Spot(iNpcH, DEF_OWNERTYPE_NPC, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9 + iWhetherBonus, FALSE, iMagicAttr);
				}
				// tx, ty+1
				m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, tX, tY+1);
				if (bCheckResistingMagicSuccess(-1, sOwnerH, cOwnerType, iResult) == FALSE)
					Effect_Damage_Spot_DamageMove(iNpcH, DEF_OWNERTYPE_NPC, sOwnerH, cOwnerType, sX, sY, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9 + iWhetherBonus, FALSE, iMagicAttr);
				m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->GetDeadOwner(&sOwnerH, &cOwnerType, tX, tY+1);
				if ( (cOwnerType == DEF_OWNERTYPE_PLAYER) && (m_pClientList[sOwnerH] != NULL) && (m_pClientList[sOwnerH]->m_iHP > 0) ) 
				{	if (bCheckResistingMagicSuccess(-1, sOwnerH, cOwnerType, iResult) == FALSE)
						Effect_Damage_Spot(iNpcH, DEF_OWNERTYPE_NPC, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9 + iWhetherBonus, FALSE, iMagicAttr);
				}
				if ( (abs(tX - dX) <= 1) && (abs(tY - dY) <= 1)) break;
			}
			// Damage Area
			for (iy = dY - m_pMagicConfigList[sType]->m_sValue3; iy <= dY + m_pMagicConfigList[sType]->m_sValue3; iy++)
			for (ix = dX - m_pMagicConfigList[sType]->m_sValue2; ix <= dX + m_pMagicConfigList[sType]->m_sValue2; ix++) 
			{	m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, ix, iy);
				if (bCheckResistingMagicSuccess(-1, sOwnerH, cOwnerType, iResult) == FALSE)
					Effect_Damage_Spot_DamageMove(iNpcH, DEF_OWNERTYPE_NPC, sOwnerH, cOwnerType, sX, sY, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9 + iWhetherBonus, FALSE, iMagicAttr);
				m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->GetDeadOwner(&sOwnerH, &cOwnerType, ix, iy);
				if ( (cOwnerType == DEF_OWNERTYPE_PLAYER) && (m_pClientList[sOwnerH] != NULL) && (m_pClientList[sOwnerH]->m_iHP > 0) ) 
				{	if (bCheckResistingMagicSuccess(-1, sOwnerH, cOwnerType, iResult) == FALSE)
						Effect_Damage_Spot(iNpcH, DEF_OWNERTYPE_NPC, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9 + iWhetherBonus, FALSE, iMagicAttr);
				}
			}
			// Target damage dX, dY
			m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, dX, dY);
			if (bCheckResistingMagicSuccess(-1, sOwnerH, cOwnerType, iResult) == FALSE)
				Effect_Damage_Spot_DamageMove(iNpcH, DEF_OWNERTYPE_NPC, sOwnerH, cOwnerType, sX, sY, m_pMagicConfigList[sType]->m_sValue4, m_pMagicConfigList[sType]->m_sValue5, m_pMagicConfigList[sType]->m_sValue6 + iWhetherBonus, FALSE, iMagicAttr);
			m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->GetDeadOwner(&sOwnerH, &cOwnerType, dX, dY);
			if ( (cOwnerType == DEF_OWNERTYPE_PLAYER) && (m_pClientList[sOwnerH] != NULL) && (m_pClientList[sOwnerH]->m_iHP > 0) ) 
			{	if (bCheckResistingMagicSuccess(-1, sOwnerH, cOwnerType, iResult) == FALSE)
					Effect_Damage_Spot(iNpcH, DEF_OWNERTYPE_NPC, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue4, m_pMagicConfigList[sType]->m_sValue5, m_pMagicConfigList[sType]->m_sValue6 + iWhetherBonus, FALSE, iMagicAttr);
			}
			break;

		case DEF_MAGICTYPE_DAMAGE_AREA_NOSPOT:  //21 (fly from caster)
			for (iy = dY - m_pMagicConfigList[sType]->m_sValue3; iy <= dY + m_pMagicConfigList[sType]->m_sValue3; iy++)
			for (ix = dX - m_pMagicConfigList[sType]->m_sValue2; ix <= dX + m_pMagicConfigList[sType]->m_sValue2; ix++) {
				m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, ix, iy);
				if (bCheckResistingMagicSuccess(-1, sOwnerH, cOwnerType, iResult) == FALSE)
					Effect_Damage_Spot_DamageMove(iNpcH, DEF_OWNERTYPE_NPC, sOwnerH, cOwnerType, sX, sY, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9 + iWhetherBonus, FALSE, iMagicAttr);
				m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->GetDeadOwner(&sOwnerH, &cOwnerType, ix, iy);
				if (    (cOwnerType == DEF_OWNERTYPE_PLAYER) && (m_pClientList[sOwnerH] != NULL) 
			 	     && (m_pClientList[sOwnerH]->m_iHP > 0) ) 
				{	if (bCheckResistingMagicSuccess(-1, sOwnerH, cOwnerType, iResult) == FALSE)
						Effect_Damage_Spot(iNpcH, DEF_OWNERTYPE_NPC, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9 + iWhetherBonus, FALSE, iMagicAttr);
			   	}
			}
			break;

		case DEF_MAGICTYPE_ICE:  //23 (don't fly target) Added by Snoopy
			for (iy = dY - m_pMagicConfigList[sType]->m_sValue3; iy <= dY + m_pMagicConfigList[sType]->m_sValue3; iy++)
			for (ix = dX - m_pMagicConfigList[sType]->m_sValue2; ix <= dX + m_pMagicConfigList[sType]->m_sValue2; ix++) 
			{	m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, ix, iy);
				if (bCheckResistingMagicSuccess(-1, sOwnerH, cOwnerType, iResult) == FALSE)
					Effect_Damage_Spot_DamageMove(iNpcH, DEF_OWNERTYPE_NPC, sOwnerH, cOwnerType, sX, sY, m_pMagicConfigList[sType]->m_sValue4, m_pMagicConfigList[sType]->m_sValue5, m_pMagicConfigList[sType]->m_sValue6 + iWhetherBonus, FALSE, iMagicAttr);
				switch (cOwnerType) {
				case DEF_OWNERTYPE_PLAYER:
					if (m_pClientList[sOwnerH] == NULL) continue; // Snoopy: replaced goto MAGIC_NOEFFECT by continue...
					if ((m_pClientList[sOwnerH]->m_iHP > 0) && (bCheckResistingIceSuccess(-1, sOwnerH, cOwnerType, iIceAtkRatio) == FALSE)) 
					{	if (m_pClientList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_ICE ] == 0) 
						{	m_pClientList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_ICE ] = 1;
							SetIceFlag(sOwnerH, cOwnerType, TRUE);
							bRegisterDelayEvent(DEF_DELAYEVENTTYPE_MAGICRELEASE, DEF_MAGICTYPE_ICE, dwTime + (m_pMagicConfigList[sType]->m_sValue10*1000), 
								sOwnerH, cOwnerType, NULL, NULL, NULL, 1, NULL, NULL);
							SendNotifyMsg(NULL, sOwnerH, DEF_NOTIFY_MAGICEFFECTON, DEF_MAGICTYPE_ICE, 1, NULL, NULL);
						}
					}
					break;
				case DEF_OWNERTYPE_NPC:
					if (m_pNpcList[sOwnerH] == NULL) continue; // Snoopy: replaced goto MAGIC_NOEFFECT by continue...
					if ((m_pNpcList[sOwnerH]->m_iHP > 0) && (bCheckResistingIceSuccess(-1, sOwnerH, cOwnerType, iIceAtkRatio) == FALSE)) 
					{	if (m_pNpcList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_ICE ] == 0) 
						{	m_pNpcList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_ICE ] = 1;
							SetIceFlag(sOwnerH, cOwnerType, TRUE);
							bRegisterDelayEvent(DEF_DELAYEVENTTYPE_MAGICRELEASE, DEF_MAGICTYPE_ICE, dwTime + (m_pMagicConfigList[sType]->m_sValue10*1000), 
								sOwnerH, cOwnerType, NULL, NULL, NULL, 1, NULL, NULL);
						}
					}
					break;
				}
				// Will not ice is not discovered pretencorpse		
				m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->GetDeadOwner(&sOwnerH, &cOwnerType, ix, iy);
				if (    (cOwnerType == DEF_OWNERTYPE_PLAYER) && (m_pClientList[sOwnerH] != NULL) 
			 	     && (m_pClientList[sOwnerH]->m_iHP > 0) ) 
				{	if (bCheckResistingMagicSuccess(-1, sOwnerH, cOwnerType, iResult) == FALSE)
						Effect_Damage_Spot(iNpcH, DEF_OWNERTYPE_NPC, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue4, m_pMagicConfigList[sType]->m_sValue5, m_pMagicConfigList[sType]->m_sValue6 + iWhetherBonus, FALSE, iMagicAttr);
			   		if ((m_pClientList[sOwnerH]->m_iHP > 0) && (bCheckResistingIceSuccess(-1, sOwnerH, cOwnerType, iIceAtkRatio) == FALSE)) 
					{	if (m_pClientList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_ICE ] == 0) 
						{	m_pClientList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_ICE ] = 1;
							SetIceFlag(sOwnerH, cOwnerType, TRUE);
							bRegisterDelayEvent(DEF_DELAYEVENTTYPE_MAGICRELEASE, DEF_MAGICTYPE_ICE, dwTime + (m_pMagicConfigList[sType]->m_sValue10*1000), 
								sOwnerH, cOwnerType, NULL, NULL, NULL, 1, NULL, NULL);
							SendNotifyMsg(NULL, sOwnerH, DEF_NOTIFY_MAGICEFFECTON, DEF_MAGICTYPE_ICE, 1, NULL, NULL);
						}
					}								
				}
			}
			break;
				
		// SNOOPY: Implemented special Type for Lightning spell
		// For npc they nerver miss but strike 1/2 strength
		case DEF_MAGICTYPE_DAMAGE_SPOT_RANDOM: // 24
			m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, dX, dY);
			if (bCheckResistingMagicSuccess(-1, sOwnerH, cOwnerType, iResult) == FALSE)
				Effect_Damage_Spot(iNpcH, DEF_OWNERTYPE_NPC, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue4/2, m_pMagicConfigList[sType]->m_sValue5, m_pMagicConfigList[sType]->m_sValue6/2 + iWhetherBonus, TRUE, iMagicAttr);
			
			m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->GetDeadOwner(&sOwnerH, &cOwnerType, dX, dY);
			if ( (cOwnerType == DEF_OWNERTYPE_PLAYER) && (m_pClientList[sOwnerH] != NULL) &&
			 	 (m_pClientList[sOwnerH]->m_iHP > 0) ) 
			{	if (bCheckResistingMagicSuccess(-1, sOwnerH, cOwnerType, iResult) == FALSE)
				Effect_Damage_Spot(iNpcH, DEF_OWNERTYPE_NPC, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue4/2, m_pMagicConfigList[sType]->m_sValue5, m_pMagicConfigList[sType]->m_sValue6/2 + iWhetherBonus, TRUE, iMagicAttr);
			}
			break;

		case DEF_MAGICTYPE_DAMAGE_AREA_NOSPOT_SPDOWN: //25 // EWS (will fly in random position)
			for (iy = dY - m_pMagicConfigList[sType]->m_sValue3; iy <= dY + m_pMagicConfigList[sType]->m_sValue3; iy++)
			for (ix = dX - m_pMagicConfigList[sType]->m_sValue2; ix <= dX + m_pMagicConfigList[sType]->m_sValue2; ix++) 
			{	// SNOOPY: Damage is on 456, Special SPdown on 789
				m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, ix, iy);
				if (bCheckResistingMagicSuccess(-1, sOwnerH, cOwnerType, iResult) == FALSE) 
				{	if ((iy == dY) && (ix == dX))
					{	// Will fly random direction // 10 more damage if targetted.
						Effect_Damage_Spot_DamageMove(iNpcH, DEF_OWNERTYPE_NPC, sOwnerH, cOwnerType, ix, iy, m_pMagicConfigList[sType]->m_sValue4, m_pMagicConfigList[sType]->m_sValue5, 10 + m_pMagicConfigList[sType]->m_sValue6 + iWhetherBonus, FALSE, iMagicAttr);
						Effect_SpDown_Spot(iNpcH, DEF_OWNERTYPE_NPC, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, 10 + m_pMagicConfigList[sType]->m_sValue9);
					}else
					{	// Will fly random direction
						Effect_Damage_Spot_DamageMove(iNpcH, DEF_OWNERTYPE_NPC, sOwnerH, cOwnerType, ix, iy, m_pMagicConfigList[sType]->m_sValue4, m_pMagicConfigList[sType]->m_sValue5, m_pMagicConfigList[sType]->m_sValue6 + iWhetherBonus, FALSE, iMagicAttr);
						Effect_SpDown_Spot(iNpcH, DEF_OWNERTYPE_NPC, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9);
					}
				}
				m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->GetDeadOwner(&sOwnerH, &cOwnerType, ix, iy);
				if (    (cOwnerType == DEF_OWNERTYPE_PLAYER) && (m_pClientList[sOwnerH] != NULL) 
						 && (m_pClientList[sOwnerH]->m_iHP > 0) ) 
				{	if (bCheckResistingMagicSuccess(-1, sOwnerH, cOwnerType, iResult) == FALSE) 
					{	Effect_Damage_Spot_DamageMove(iNpcH, DEF_OWNERTYPE_NPC, sOwnerH, cOwnerType, ix, iy, m_pMagicConfigList[sType]->m_sValue4, m_pMagicConfigList[sType]->m_sValue5, 10 + m_pMagicConfigList[sType]->m_sValue6 + iWhetherBonus, FALSE, iMagicAttr);
						Effect_SpDown_Spot(iNpcH, DEF_OWNERTYPE_NPC, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, 10 + m_pMagicConfigList[sType]->m_sValue9);
					}
				}
			}
			break;	

		case DEF_MAGICTYPE_ICE_LINEAR: //26 Added by Snoopy
			// SNOOPY: used iMagicAttr, to send info to damage procedures, not to add bonus for Berzerk Liche Wands
			iMagicAttr +=100;
			for (i = 2; i < 10; i++) 
			{	iErr = 0;
				m_Misc.GetPoint2(sX, sY, dX, dY, &tX, &tY, &iErr, i);
				// tx, ty
				m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, tX, tY);
				if (bCheckResistingMagicSuccess(-1, sOwnerH, cOwnerType, iResult) == FALSE) 
				{	Effect_Damage_Spot(iNpcH, DEF_OWNERTYPE_NPC, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9 + iWhetherBonus, FALSE, iMagicAttr);
					switch (cOwnerType) {
					case DEF_OWNERTYPE_PLAYER:
						if (m_pClientList[sOwnerH] == NULL) break;
						if ((m_pClientList[sOwnerH]->m_iHP > 0) && (bCheckResistingIceSuccess(-1, sOwnerH, cOwnerType, iIceAtkRatio) == FALSE))
						{	if (m_pClientList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_ICE ] == 0) 
							{	m_pClientList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_ICE ] = 1;
								SetIceFlag(sOwnerH, cOwnerType, TRUE);
								bRegisterDelayEvent(DEF_DELAYEVENTTYPE_MAGICRELEASE, DEF_MAGICTYPE_ICE, dwTime + (m_pMagicConfigList[sType]->m_sValue10*1000), 
									sOwnerH, cOwnerType, NULL, NULL, NULL, 1, NULL, NULL);
								SendNotifyMsg(NULL, sOwnerH, DEF_NOTIFY_MAGICEFFECTON, DEF_MAGICTYPE_ICE, 1, NULL, NULL);
						}	}
						break;
					case DEF_OWNERTYPE_NPC:
						if (m_pNpcList[sOwnerH] == NULL) break;
						if ((m_pNpcList[sOwnerH]->m_iHP > 0) && (bCheckResistingIceSuccess(-1, sOwnerH, cOwnerType, iIceAtkRatio) == FALSE)) {
							if (m_pNpcList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_ICE ] == 0) 
							{	m_pNpcList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_ICE ] = 1;
								SetIceFlag(sOwnerH, cOwnerType, TRUE);
								bRegisterDelayEvent(DEF_DELAYEVENTTYPE_MAGICRELEASE, DEF_MAGICTYPE_ICE, dwTime + (m_pMagicConfigList[sType]->m_sValue10*1000), 
									sOwnerH, cOwnerType, NULL, NULL, NULL, 1, NULL, NULL);
						}	}
						break;
				}	} 
				m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->GetDeadOwner(&sOwnerH, &cOwnerType, tX, tY);
				if ( (cOwnerType == DEF_OWNERTYPE_PLAYER) && (m_pClientList[sOwnerH] != NULL) && (m_pClientList[sOwnerH]->m_iHP > 0) ) 
				{	if (bCheckResistingMagicSuccess(-1, sOwnerH, cOwnerType, iResult) == FALSE) 
					{	Effect_Damage_Spot(iNpcH, DEF_OWNERTYPE_NPC, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9 + iWhetherBonus, FALSE, iMagicAttr);
						if ((m_pClientList[sOwnerH]->m_iHP > 0) && (bCheckResistingIceSuccess(-1, sOwnerH, cOwnerType, iIceAtkRatio) == FALSE))
						{	if (m_pClientList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_ICE ] == 0)
							{	m_pClientList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_ICE ] = 1;
								SetIceFlag(sOwnerH, cOwnerType, TRUE);
								bRegisterDelayEvent(DEF_DELAYEVENTTYPE_MAGICRELEASE, DEF_MAGICTYPE_ICE, dwTime + (m_pMagicConfigList[sType]->m_sValue10*1000), 
									sOwnerH, cOwnerType, NULL, NULL, NULL, 1, NULL, NULL);
								SendNotifyMsg(NULL, sOwnerH, DEF_NOTIFY_MAGICEFFECTON, DEF_MAGICTYPE_ICE, 1, NULL, NULL);
				}	}	}	}

				// tx-1, ty
				m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, tX-1, tY);
				if (bCheckResistingMagicSuccess(-1, sOwnerH, cOwnerType, iResult) == FALSE) 
				{	Effect_Damage_Spot(iNpcH, DEF_OWNERTYPE_NPC, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9 + iWhetherBonus, FALSE, iMagicAttr);
					switch (cOwnerType) {
					case DEF_OWNERTYPE_PLAYER:
						if (m_pClientList[sOwnerH] == NULL) break;
						if ((m_pClientList[sOwnerH]->m_iHP > 0) && (bCheckResistingIceSuccess(-1, sOwnerH, cOwnerType, iIceAtkRatio) == FALSE))
						{	if (m_pClientList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_ICE ] == 0) 
							{	m_pClientList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_ICE ] = 1;
							SetIceFlag(sOwnerH, cOwnerType, TRUE);
								bRegisterDelayEvent(DEF_DELAYEVENTTYPE_MAGICRELEASE, DEF_MAGICTYPE_ICE, dwTime + (m_pMagicConfigList[sType]->m_sValue10*1000), 
									sOwnerH, cOwnerType, NULL, NULL, NULL, 1, NULL, NULL);
								SendNotifyMsg(NULL, sOwnerH, DEF_NOTIFY_MAGICEFFECTON, DEF_MAGICTYPE_ICE, 1, NULL, NULL);
						}	}
						break;
					case DEF_OWNERTYPE_NPC:
						if (m_pNpcList[sOwnerH] == NULL) break;
						if ((m_pNpcList[sOwnerH]->m_iHP > 0) && (bCheckResistingIceSuccess(-1, sOwnerH, cOwnerType, iIceAtkRatio) == FALSE)) {
							if (m_pNpcList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_ICE ] == 0) 
							{	m_pNpcList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_ICE ] = 1;
								SetIceFlag(sOwnerH, cOwnerType, TRUE);
								bRegisterDelayEvent(DEF_DELAYEVENTTYPE_MAGICRELEASE, DEF_MAGICTYPE_ICE, dwTime + (m_pMagicConfigList[sType]->m_sValue10*1000), 
									sOwnerH, cOwnerType, NULL, NULL, NULL, 1, NULL, NULL);
						}	}
						break;
				}	} 
				m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->GetDeadOwner(&sOwnerH, &cOwnerType, tX-1, tY);
				if ( (cOwnerType == DEF_OWNERTYPE_PLAYER) && (m_pClientList[sOwnerH] != NULL) && (m_pClientList[sOwnerH]->m_iHP > 0) ) 
				{	if (bCheckResistingMagicSuccess(-1, sOwnerH, cOwnerType, iResult) == FALSE) 
					{	Effect_Damage_Spot(iNpcH, DEF_OWNERTYPE_NPC, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9 + iWhetherBonus, FALSE, iMagicAttr);
						if ((m_pClientList[sOwnerH]->m_iHP > 0) && (bCheckResistingIceSuccess(-1, sOwnerH, cOwnerType, iIceAtkRatio) == FALSE))
						{	if (m_pClientList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_ICE ] == 0)
							{	m_pClientList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_ICE ] = 1;
								SetIceFlag(sOwnerH, cOwnerType, TRUE);
								bRegisterDelayEvent(DEF_DELAYEVENTTYPE_MAGICRELEASE, DEF_MAGICTYPE_ICE, dwTime + (m_pMagicConfigList[sType]->m_sValue10*1000), 
									sOwnerH, cOwnerType, NULL, NULL, NULL, 1, NULL, NULL);
								SendNotifyMsg(NULL, sOwnerH, DEF_NOTIFY_MAGICEFFECTON, DEF_MAGICTYPE_ICE, 1, NULL, NULL);
				}	}	}	}
				
				// tx+1, ty
				m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, tX+1, tY);
				if (bCheckResistingMagicSuccess(-1, sOwnerH, cOwnerType, iResult) == FALSE) 
				{	Effect_Damage_Spot(iNpcH, DEF_OWNERTYPE_NPC, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9 + iWhetherBonus, FALSE, iMagicAttr);
					switch (cOwnerType) {
					case DEF_OWNERTYPE_PLAYER:
						if (m_pClientList[sOwnerH] == NULL) break;
						if ((m_pClientList[sOwnerH]->m_iHP > 0) && (bCheckResistingIceSuccess(-1, sOwnerH, cOwnerType, iIceAtkRatio) == FALSE))
						{	if (m_pClientList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_ICE ] == 0) 
							{	m_pClientList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_ICE ] = 1;
							SetIceFlag(sOwnerH, cOwnerType, TRUE);
								bRegisterDelayEvent(DEF_DELAYEVENTTYPE_MAGICRELEASE, DEF_MAGICTYPE_ICE, dwTime + (m_pMagicConfigList[sType]->m_sValue10*1000), 
									sOwnerH, cOwnerType, NULL, NULL, NULL, 1, NULL, NULL);
								SendNotifyMsg(NULL, sOwnerH, DEF_NOTIFY_MAGICEFFECTON, DEF_MAGICTYPE_ICE, 1, NULL, NULL);
						}	}
						break;
					case DEF_OWNERTYPE_NPC:
						if (m_pNpcList[sOwnerH] == NULL) break;
						if ((m_pNpcList[sOwnerH]->m_iHP > 0) && (bCheckResistingIceSuccess(-1, sOwnerH, cOwnerType, iIceAtkRatio) == FALSE)) {
							if (m_pNpcList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_ICE ] == 0) 
							{	m_pNpcList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_ICE ] = 1;
								SetIceFlag(sOwnerH, cOwnerType, TRUE);
								bRegisterDelayEvent(DEF_DELAYEVENTTYPE_MAGICRELEASE, DEF_MAGICTYPE_ICE, dwTime + (m_pMagicConfigList[sType]->m_sValue10*1000), 
									sOwnerH, cOwnerType, NULL, NULL, NULL, 1, NULL, NULL);
						}	}
						break;
				}	} 
				m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->GetDeadOwner(&sOwnerH, &cOwnerType, tX+1, tY);
				if ( (cOwnerType == DEF_OWNERTYPE_PLAYER) && (m_pClientList[sOwnerH] != NULL) && (m_pClientList[sOwnerH]->m_iHP > 0) ) 
				{	if (bCheckResistingMagicSuccess(-1, sOwnerH, cOwnerType, iResult) == FALSE) 
					{	Effect_Damage_Spot(iNpcH, DEF_OWNERTYPE_NPC, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9 + iWhetherBonus, FALSE, iMagicAttr);
						if ((m_pClientList[sOwnerH]->m_iHP > 0) && (bCheckResistingIceSuccess(-1, sOwnerH, cOwnerType, iIceAtkRatio) == FALSE))
						{	if (m_pClientList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_ICE ] == 0)
							{	m_pClientList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_ICE ] = 1;
								SetIceFlag(sOwnerH, cOwnerType, TRUE);
								bRegisterDelayEvent(DEF_DELAYEVENTTYPE_MAGICRELEASE, DEF_MAGICTYPE_ICE, dwTime + (m_pMagicConfigList[sType]->m_sValue10*1000), 
									sOwnerH, cOwnerType, NULL, NULL, NULL, 1, NULL, NULL);
								SendNotifyMsg(NULL, sOwnerH, DEF_NOTIFY_MAGICEFFECTON, DEF_MAGICTYPE_ICE, 1, NULL, NULL);
				}	}	}	}
				
				// tx, ty-1
				m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, tX, tY-1);
				if (bCheckResistingMagicSuccess(-1, sOwnerH, cOwnerType, iResult) == FALSE) 
				{	Effect_Damage_Spot(iNpcH, DEF_OWNERTYPE_NPC, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9 + iWhetherBonus, FALSE, iMagicAttr);
					switch (cOwnerType) {
					case DEF_OWNERTYPE_PLAYER:
						if (m_pClientList[sOwnerH] == NULL) break;
						if ((m_pClientList[sOwnerH]->m_iHP > 0) && (bCheckResistingIceSuccess(-1, sOwnerH, cOwnerType, iIceAtkRatio) == FALSE))
						{	if (m_pClientList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_ICE ] == 0) 
							{	m_pClientList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_ICE ] = 1;
							SetIceFlag(sOwnerH, cOwnerType, TRUE);
								bRegisterDelayEvent(DEF_DELAYEVENTTYPE_MAGICRELEASE, DEF_MAGICTYPE_ICE, dwTime + (m_pMagicConfigList[sType]->m_sValue10*1000), 
									sOwnerH, cOwnerType, NULL, NULL, NULL, 1, NULL, NULL);
								SendNotifyMsg(NULL, sOwnerH, DEF_NOTIFY_MAGICEFFECTON, DEF_MAGICTYPE_ICE, 1, NULL, NULL);
						}	}
						break;
					case DEF_OWNERTYPE_NPC:
						if (m_pNpcList[sOwnerH] == NULL) break;
						if ((m_pNpcList[sOwnerH]->m_iHP > 0) && (bCheckResistingIceSuccess(-1, sOwnerH, cOwnerType, iIceAtkRatio) == FALSE)) {
							if (m_pNpcList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_ICE ] == 0) 
							{	m_pNpcList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_ICE ] = 1;
								SetIceFlag(sOwnerH, cOwnerType, TRUE);
								bRegisterDelayEvent(DEF_DELAYEVENTTYPE_MAGICRELEASE, DEF_MAGICTYPE_ICE, dwTime + (m_pMagicConfigList[sType]->m_sValue10*1000), 
									sOwnerH, cOwnerType, NULL, NULL, NULL, 1, NULL, NULL);
						}	}
						break;
				}	} 
				m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->GetDeadOwner(&sOwnerH, &cOwnerType, tX, tY-1);
				if ( (cOwnerType == DEF_OWNERTYPE_PLAYER) && (m_pClientList[sOwnerH] != NULL) && (m_pClientList[sOwnerH]->m_iHP > 0) ) 
				{	if (bCheckResistingMagicSuccess(-1, sOwnerH, cOwnerType, iResult) == FALSE) 
					{	Effect_Damage_Spot(iNpcH, DEF_OWNERTYPE_NPC, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9 + iWhetherBonus, FALSE, iMagicAttr);
						if ((m_pClientList[sOwnerH]->m_iHP > 0) && (bCheckResistingIceSuccess(-1, sOwnerH, cOwnerType, iIceAtkRatio) == FALSE))
						{	if (m_pClientList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_ICE ] == 0)
							{	m_pClientList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_ICE ] = 1;
								SetIceFlag(sOwnerH, cOwnerType, TRUE);
								bRegisterDelayEvent(DEF_DELAYEVENTTYPE_MAGICRELEASE, DEF_MAGICTYPE_ICE, dwTime + (m_pMagicConfigList[sType]->m_sValue10*1000), 
									sOwnerH, cOwnerType, NULL, NULL, NULL, 1, NULL, NULL);
								SendNotifyMsg(NULL, sOwnerH, DEF_NOTIFY_MAGICEFFECTON, DEF_MAGICTYPE_ICE, 1, NULL, NULL);
				}	}	}	}

				// tx, ty+1
				m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, tX, tY+1);
				if (bCheckResistingMagicSuccess(-1, sOwnerH, cOwnerType, iResult) == FALSE) 
				{	Effect_Damage_Spot(iNpcH, DEF_OWNERTYPE_NPC, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9 + iWhetherBonus, FALSE, iMagicAttr);
					switch (cOwnerType) {
					case DEF_OWNERTYPE_PLAYER:
						if (m_pClientList[sOwnerH] == NULL) break;
						if ((m_pClientList[sOwnerH]->m_iHP > 0) && (bCheckResistingIceSuccess(-1, sOwnerH, cOwnerType, iIceAtkRatio) == FALSE))
						{	if (m_pClientList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_ICE ] == 0) 
							{	m_pClientList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_ICE ] = 1;
							SetIceFlag(sOwnerH, cOwnerType, TRUE);
								bRegisterDelayEvent(DEF_DELAYEVENTTYPE_MAGICRELEASE, DEF_MAGICTYPE_ICE, dwTime + (m_pMagicConfigList[sType]->m_sValue10*1000), 
									sOwnerH, cOwnerType, NULL, NULL, NULL, 1, NULL, NULL);
								SendNotifyMsg(NULL, sOwnerH, DEF_NOTIFY_MAGICEFFECTON, DEF_MAGICTYPE_ICE, 1, NULL, NULL);
						}	}
						break;
					case DEF_OWNERTYPE_NPC:
						if (m_pNpcList[sOwnerH] == NULL) break;
						if ((m_pNpcList[sOwnerH]->m_iHP > 0) && (bCheckResistingIceSuccess(-1, sOwnerH, cOwnerType, iIceAtkRatio) == FALSE)) {
							if (m_pNpcList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_ICE ] == 0) 
							{	m_pNpcList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_ICE ] = 1;
								SetIceFlag(sOwnerH, cOwnerType, TRUE);
								bRegisterDelayEvent(DEF_DELAYEVENTTYPE_MAGICRELEASE, DEF_MAGICTYPE_ICE, dwTime + (m_pMagicConfigList[sType]->m_sValue10*1000), 
									sOwnerH, cOwnerType, NULL, NULL, NULL, 1, NULL, NULL);
						}	}
						break;
				}	} 
				m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->GetDeadOwner(&sOwnerH, &cOwnerType, tX, tY+1);
				if ( (cOwnerType == DEF_OWNERTYPE_PLAYER) && (m_pClientList[sOwnerH] != NULL) && (m_pClientList[sOwnerH]->m_iHP > 0) ) 
				{	if (bCheckResistingMagicSuccess(-1, sOwnerH, cOwnerType, iResult) == FALSE) 
					{	Effect_Damage_Spot(iNpcH, DEF_OWNERTYPE_NPC, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9 + iWhetherBonus, FALSE, iMagicAttr);
						if ((m_pClientList[sOwnerH]->m_iHP > 0) && (bCheckResistingIceSuccess(-1, sOwnerH, cOwnerType, iIceAtkRatio) == FALSE))
						{	if (m_pClientList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_ICE ] == 0)
							{	m_pClientList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_ICE ] = 1;
								SetIceFlag(sOwnerH, cOwnerType, TRUE);
								bRegisterDelayEvent(DEF_DELAYEVENTTYPE_MAGICRELEASE, DEF_MAGICTYPE_ICE, dwTime + (m_pMagicConfigList[sType]->m_sValue10*1000), 
									sOwnerH, cOwnerType, NULL, NULL, NULL, 1, NULL, NULL);
								SendNotifyMsg(NULL, sOwnerH, DEF_NOTIFY_MAGICEFFECTON, DEF_MAGICTYPE_ICE, 1, NULL, NULL);
				}	}	}	}
				// Exit if reaching the Target
				if ( (abs(tX - dX) <= 1) && (abs(tY - dY) <= 1)) break;
			}

			// Area damage: depends on X/Y settings in the spell and m_sValue789, same as linear damge
			for (iy = dY - m_pMagicConfigList[sType]->m_sValue3; iy <= dY + m_pMagicConfigList[sType]->m_sValue3; iy++)
			for (ix = dX - m_pMagicConfigList[sType]->m_sValue2; ix <= dX + m_pMagicConfigList[sType]->m_sValue2; ix++) 
			{	m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, ix, iy);
				if (bCheckResistingMagicSuccess(-1, sOwnerH, cOwnerType, iResult) == FALSE) 
				{	Effect_Damage_Spot(iNpcH, DEF_OWNERTYPE_NPC, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9 + iWhetherBonus, FALSE, iMagicAttr);
					switch (cOwnerType) {
					case DEF_OWNERTYPE_PLAYER:
						if (m_pClientList[sOwnerH] == NULL) break;
						if ((m_pClientList[sOwnerH]->m_iHP > 0) && (bCheckResistingIceSuccess(-1, sOwnerH, cOwnerType, iIceAtkRatio) == FALSE)) {
							if (m_pClientList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_ICE ] == 0) 
							{	m_pClientList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_ICE ] = 1;
								SetIceFlag(sOwnerH, cOwnerType, TRUE);
								bRegisterDelayEvent(DEF_DELAYEVENTTYPE_MAGICRELEASE, DEF_MAGICTYPE_ICE, dwTime + (m_pMagicConfigList[sType]->m_sValue10*1000), 
									sOwnerH, cOwnerType, NULL, NULL, NULL, 1, NULL, NULL);
								SendNotifyMsg(NULL, sOwnerH, DEF_NOTIFY_MAGICEFFECTON, DEF_MAGICTYPE_ICE, 1, NULL, NULL);
						}	}
						break;
					case DEF_OWNERTYPE_NPC:
						if (m_pNpcList[sOwnerH] == NULL) break;
						if ((m_pNpcList[sOwnerH]->m_iHP > 0) && (bCheckResistingIceSuccess(-1, sOwnerH, cOwnerType, iIceAtkRatio) == FALSE)) {
						if (m_pNpcList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_ICE ] == 0) 
						{	m_pNpcList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_ICE ] = 1;
							SetIceFlag(sOwnerH, cOwnerType, TRUE);
							bRegisterDelayEvent(DEF_DELAYEVENTTYPE_MAGICRELEASE, DEF_MAGICTYPE_ICE, dwTime + (m_pMagicConfigList[sType]->m_sValue10*1000), 
								sOwnerH, cOwnerType, NULL, NULL, NULL, 1, NULL, NULL);
						}	}
						break;	
				}	}
				m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->GetDeadOwner(&sOwnerH, &cOwnerType, ix, iy);
				if ( (cOwnerType == DEF_OWNERTYPE_PLAYER) && (m_pClientList[sOwnerH] != NULL) && (m_pClientList[sOwnerH]->m_iHP > 0) ) 
				{	if (bCheckResistingMagicSuccess(-1, sOwnerH, cOwnerType, iResult) == FALSE) 
					{	Effect_Damage_Spot(iNpcH, DEF_OWNERTYPE_NPC, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9 + iWhetherBonus, FALSE, iMagicAttr);
						if ((m_pClientList[sOwnerH]->m_iHP > 0) && (bCheckResistingIceSuccess(-1, sOwnerH, cOwnerType, iIceAtkRatio) == FALSE)) 
						{	if (m_pClientList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_ICE ] == 0) 
							{	m_pClientList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_ICE ] = 1;
								SetIceFlag(sOwnerH, cOwnerType, TRUE);
								bRegisterDelayEvent(DEF_DELAYEVENTTYPE_MAGICRELEASE, DEF_MAGICTYPE_ICE, dwTime + (m_pMagicConfigList[sType]->m_sValue10*1000), 
									sOwnerH, cOwnerType, NULL, NULL, NULL, 1, NULL, NULL);
								SendNotifyMsg(NULL, sOwnerH, DEF_NOTIFY_MAGICEFFECTON, DEF_MAGICTYPE_ICE, 1, NULL, NULL);
				}	}	}	}
			}

			// Target Damage: depends on m_sValue456
			m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, dX, dY);
			if (bCheckResistingMagicSuccess(-1, sOwnerH, cOwnerType, iResult) == FALSE) 
			{	Effect_Damage_Spot(iNpcH, DEF_OWNERTYPE_NPC, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue4, m_pMagicConfigList[sType]->m_sValue5, m_pMagicConfigList[sType]->m_sValue6 + iWhetherBonus, TRUE, iMagicAttr); // v1.41 FALSE
				switch (cOwnerType) {
				case DEF_OWNERTYPE_PLAYER:
					if (m_pClientList[sOwnerH] == NULL) break;
					if ((m_pClientList[sOwnerH]->m_iHP > 0) && (bCheckResistingIceSuccess(-1, sOwnerH, cOwnerType, iIceAtkRatio) == FALSE)) 
					{	if (m_pClientList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_ICE ] == 0) 
						{	m_pClientList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_ICE ] = 1;
							SetIceFlag(sOwnerH, cOwnerType, TRUE);
							bRegisterDelayEvent(DEF_DELAYEVENTTYPE_MAGICRELEASE, DEF_MAGICTYPE_ICE, dwTime + (m_pMagicConfigList[sType]->m_sValue10*1000), 
								sOwnerH, cOwnerType, NULL, NULL, NULL, 1, NULL, NULL);
							SendNotifyMsg(NULL, sOwnerH, DEF_NOTIFY_MAGICEFFECTON, DEF_MAGICTYPE_ICE, 1, NULL, NULL);
					}	}
					break;
				case DEF_OWNERTYPE_NPC:
					if (m_pNpcList[sOwnerH] == NULL) break;
					if ((m_pNpcList[sOwnerH]->m_iHP > 0) && (bCheckResistingIceSuccess(-1, sOwnerH, cOwnerType, iIceAtkRatio) == FALSE)) 
					{	if (m_pNpcList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_ICE ] == 0) 
						{	m_pNpcList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_ICE ] = 1;
							SetIceFlag(sOwnerH, cOwnerType, TRUE);
							bRegisterDelayEvent(DEF_DELAYEVENTTYPE_MAGICRELEASE, DEF_MAGICTYPE_ICE, dwTime + (m_pMagicConfigList[sType]->m_sValue10*1000), 
								sOwnerH, cOwnerType, NULL, NULL, NULL, 1, NULL, NULL);
					}	}
					break;				
			}	}
			m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->GetDeadOwner(&sOwnerH, &cOwnerType, dX, dY);
			if ( (cOwnerType == DEF_OWNERTYPE_PLAYER) && (m_pClientList[sOwnerH] != NULL) && (m_pClientList[sOwnerH]->m_iHP > 0) ) 
			{	if (bCheckResistingMagicSuccess(-1, sOwnerH, cOwnerType, iResult) == FALSE) 
				{	Effect_Damage_Spot(iNpcH, DEF_OWNERTYPE_NPC, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue4, m_pMagicConfigList[sType]->m_sValue5, m_pMagicConfigList[sType]->m_sValue6 + iWhetherBonus, TRUE, iMagicAttr); // v1.41 FALSE
					if ((m_pClientList[sOwnerH]->m_iHP > 0) && (bCheckResistingIceSuccess(-1, sOwnerH, cOwnerType, iIceAtkRatio) == FALSE)) 
					{	if (m_pClientList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_ICE ] == 0) 
						{	m_pClientList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_ICE ] = 1;
							SetIceFlag(sOwnerH, cOwnerType, TRUE);
							bRegisterDelayEvent(DEF_DELAYEVENTTYPE_MAGICRELEASE, DEF_MAGICTYPE_ICE, dwTime + (m_pMagicConfigList[sType]->m_sValue10*1000), 
								sOwnerH, cOwnerType, NULL, NULL, NULL, 1, NULL, NULL);
							SendNotifyMsg(NULL, sOwnerH, DEF_NOTIFY_MAGICEFFECTON, DEF_MAGICTYPE_ICE, 1, NULL, NULL);
			}	}	}	}
			break;

		case DEF_MAGICTYPE_DAMAGE_LINEAR_SPDOWN: //30 ESW
			//  m_sValue4 5 6 used for damage target
			//  m_sValue7 8 9 used for damage Linear, Area 
			//  m_sValue10 11 12 used for SP down
			// SNOOPY: used iMagicAttr, to send info to damage procedures, not to add bonus for Berzerk Liche Wands
			iMagicAttr +=100;			
			for (i = 2; i < 10; i++) 
			{	iErr = 0;
				m_Misc.GetPoint2(sX, sY, dX, dY, &tX, &tY, &iErr, i);
				// tx, ty
				m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, tX, tY);
				if (bCheckResistingMagicSuccess(-1, sOwnerH, cOwnerType, iResult) == FALSE) 
				{	switch (cOwnerType) {
					case DEF_OWNERTYPE_PLAYER:
						if (m_pClientList[sOwnerH] == NULL) continue;
						Effect_Damage_Spot(iNpcH, DEF_OWNERTYPE_NPC, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9 + iWhetherBonus, TRUE, iMagicAttr);
						Effect_SpDown_Spot(iNpcH, DEF_OWNERTYPE_NPC, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue10, m_pMagicConfigList[sType]->m_sValue11, m_pMagicConfigList[sType]->m_sValue12);
						break;
					case DEF_OWNERTYPE_NPC:
						if (m_pNpcList[sOwnerH] == NULL) continue;
						Effect_Damage_Spot(iNpcH, DEF_OWNERTYPE_NPC, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue4, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9 + iWhetherBonus, TRUE, iMagicAttr);
						break;						
				}	}
				m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->GetDeadOwner(&sOwnerH, &cOwnerType, tX, tY);
				if ( (cOwnerType == DEF_OWNERTYPE_PLAYER) && (m_pClientList[sOwnerH] != NULL) && (m_pClientList[sOwnerH]->m_iHP > 0) ) 
				{	if (m_pClientList[sOwnerH] == NULL) continue;
					if (bCheckResistingMagicSuccess(-1, sOwnerH, cOwnerType, iResult) == FALSE) 
					{	Effect_Damage_Spot(iNpcH, DEF_OWNERTYPE_NPC, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9 + iWhetherBonus, TRUE, iMagicAttr);
						Effect_SpDown_Spot(iNpcH, DEF_OWNERTYPE_NPC, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue10, m_pMagicConfigList[sType]->m_sValue11, m_pMagicConfigList[sType]->m_sValue12);
				}	}

				// tx-1, ty
				m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, tX-1, tY);
				if (bCheckResistingMagicSuccess(-1, sOwnerH, cOwnerType, iResult) == FALSE) 
				{	switch (cOwnerType) {
					case DEF_OWNERTYPE_PLAYER:
						if (m_pClientList[sOwnerH] == NULL) continue;
						Effect_Damage_Spot(iNpcH, DEF_OWNERTYPE_NPC, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9 + iWhetherBonus, TRUE, iMagicAttr);
						Effect_SpDown_Spot(iNpcH, DEF_OWNERTYPE_NPC, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue10, m_pMagicConfigList[sType]->m_sValue11, m_pMagicConfigList[sType]->m_sValue12);
						break;
					case DEF_OWNERTYPE_NPC:
						if (m_pNpcList[sOwnerH] == NULL) continue;
						Effect_Damage_Spot(iNpcH, DEF_OWNERTYPE_NPC, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue4, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9 + iWhetherBonus, TRUE, iMagicAttr);
						break;						
				}	}
				m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->GetDeadOwner(&sOwnerH, &cOwnerType, tX-1, tY);
				if ( (cOwnerType == DEF_OWNERTYPE_PLAYER) && (m_pClientList[sOwnerH] != NULL) && (m_pClientList[sOwnerH]->m_iHP > 0) ) 
				{	if (m_pClientList[sOwnerH] == NULL) continue;
					if (bCheckResistingMagicSuccess(-1, sOwnerH, cOwnerType, iResult) == FALSE) 
					{	Effect_Damage_Spot(iNpcH, DEF_OWNERTYPE_NPC, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9 + iWhetherBonus, TRUE, iMagicAttr);
						Effect_SpDown_Spot(iNpcH, DEF_OWNERTYPE_NPC, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue10, m_pMagicConfigList[sType]->m_sValue11, m_pMagicConfigList[sType]->m_sValue12);
				}	}
					
				// tx+1, ty
				m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, tX+1, tY);
				if (bCheckResistingMagicSuccess(-1, sOwnerH, cOwnerType, iResult) == FALSE) 
				{	switch (cOwnerType) {
					case DEF_OWNERTYPE_PLAYER:
						if (m_pClientList[sOwnerH] == NULL) continue;
						Effect_Damage_Spot(iNpcH, DEF_OWNERTYPE_NPC, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9 + iWhetherBonus, TRUE, iMagicAttr);
						Effect_SpDown_Spot(iNpcH, DEF_OWNERTYPE_NPC, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue10, m_pMagicConfigList[sType]->m_sValue11, m_pMagicConfigList[sType]->m_sValue12);
						break;
					case DEF_OWNERTYPE_NPC:
						if (m_pNpcList[sOwnerH] == NULL) continue;
						Effect_Damage_Spot(iNpcH, DEF_OWNERTYPE_NPC, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue4, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9 + iWhetherBonus, TRUE, iMagicAttr);
						break;						
				}	}
				m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->GetDeadOwner(&sOwnerH, &cOwnerType, tX+1, tY);
				if ( (cOwnerType == DEF_OWNERTYPE_PLAYER) && (m_pClientList[sOwnerH] != NULL) && (m_pClientList[sOwnerH]->m_iHP > 0) ) 
				{	if (m_pClientList[sOwnerH] == NULL) continue;
					if (bCheckResistingMagicSuccess(-1, sOwnerH, cOwnerType, iResult) == FALSE) 
					{	Effect_Damage_Spot(iNpcH, DEF_OWNERTYPE_NPC, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9 + iWhetherBonus, TRUE, iMagicAttr);
						Effect_SpDown_Spot(iNpcH, DEF_OWNERTYPE_NPC, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue10, m_pMagicConfigList[sType]->m_sValue11, m_pMagicConfigList[sType]->m_sValue12);
				}	}

				// tx, ty-1
				m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, tX, tY-1);
				if (bCheckResistingMagicSuccess(-1, sOwnerH, cOwnerType, iResult) == FALSE) 
				{	switch (cOwnerType) {
					case DEF_OWNERTYPE_PLAYER:
						if (m_pClientList[sOwnerH] == NULL) continue;
						Effect_Damage_Spot(iNpcH, DEF_OWNERTYPE_NPC, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9 + iWhetherBonus, TRUE, iMagicAttr);
						Effect_SpDown_Spot(iNpcH, DEF_OWNERTYPE_NPC, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue10, m_pMagicConfigList[sType]->m_sValue11, m_pMagicConfigList[sType]->m_sValue12);
						break;
					case DEF_OWNERTYPE_NPC:
						if (m_pNpcList[sOwnerH] == NULL) continue;
						Effect_Damage_Spot(iNpcH, DEF_OWNERTYPE_NPC, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue4, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9 + iWhetherBonus, TRUE, iMagicAttr);
						break;						
				}	}
				m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->GetDeadOwner(&sOwnerH, &cOwnerType, tX, tY-1);
				if ( (cOwnerType == DEF_OWNERTYPE_PLAYER) && (m_pClientList[sOwnerH] != NULL) && (m_pClientList[sOwnerH]->m_iHP > 0) ) 
				{	if (m_pClientList[sOwnerH] == NULL) continue;
					if (bCheckResistingMagicSuccess(-1, sOwnerH, cOwnerType, iResult) == FALSE) 
					{	Effect_Damage_Spot(iNpcH, DEF_OWNERTYPE_NPC, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9 + iWhetherBonus, TRUE, iMagicAttr);
						Effect_SpDown_Spot(iNpcH, DEF_OWNERTYPE_NPC, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue10, m_pMagicConfigList[sType]->m_sValue11, m_pMagicConfigList[sType]->m_sValue12);
				}	}
					
				// tx, ty+1
				m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, tX, tY+1);
				if (bCheckResistingMagicSuccess(-1, sOwnerH, cOwnerType, iResult) == FALSE) 
				{	switch (cOwnerType) {
					case DEF_OWNERTYPE_PLAYER:
						if (m_pClientList[sOwnerH] == NULL) continue;
						Effect_Damage_Spot(iNpcH, DEF_OWNERTYPE_NPC, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9 + iWhetherBonus, TRUE, iMagicAttr);
						Effect_SpDown_Spot(iNpcH, DEF_OWNERTYPE_NPC, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue10, m_pMagicConfigList[sType]->m_sValue11, m_pMagicConfigList[sType]->m_sValue12);
						break;
					case DEF_OWNERTYPE_NPC:
						if (m_pNpcList[sOwnerH] == NULL) continue;
						Effect_Damage_Spot(iNpcH, DEF_OWNERTYPE_NPC, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue4, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9 + iWhetherBonus, TRUE, iMagicAttr);
						break;						
				}	}
				m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->GetDeadOwner(&sOwnerH, &cOwnerType, tX, tY+1);
				if ( (cOwnerType == DEF_OWNERTYPE_PLAYER) && (m_pClientList[sOwnerH] != NULL) && (m_pClientList[sOwnerH]->m_iHP > 0) ) 
				{	if (m_pClientList[sOwnerH] == NULL) continue;
					if (bCheckResistingMagicSuccess(-1, sOwnerH, cOwnerType, iResult) == FALSE) 
					{	Effect_Damage_Spot(iNpcH, DEF_OWNERTYPE_NPC, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9 + iWhetherBonus, TRUE, iMagicAttr);
						Effect_SpDown_Spot(iNpcH, DEF_OWNERTYPE_NPC, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue10, m_pMagicConfigList[sType]->m_sValue11, m_pMagicConfigList[sType]->m_sValue12);
				}	}				
				// Do not strike again if target is close to caster
				if ( (abs(tX - dX) <= 1) && (abs(tY - dY) <= 1)) break;
			}
			// Area Damage
			for (iy = dY - m_pMagicConfigList[sType]->m_sValue3; iy <= dY + m_pMagicConfigList[sType]->m_sValue3; iy++)
			{	for (ix = dX - m_pMagicConfigList[sType]->m_sValue2; ix <= dX + m_pMagicConfigList[sType]->m_sValue2; ix++) 
				{	m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, ix, iy);
					if (bCheckResistingMagicSuccess(-1, sOwnerH, cOwnerType, iResult) == FALSE) 
					{	switch (cOwnerType) {
						case DEF_OWNERTYPE_PLAYER:
							if (m_pClientList[sOwnerH] == NULL) continue;
							Effect_Damage_Spot(iNpcH, DEF_OWNERTYPE_NPC, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9 + iWhetherBonus, TRUE, iMagicAttr);
							Effect_SpDown_Spot(iNpcH, DEF_OWNERTYPE_NPC, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue10, m_pMagicConfigList[sType]->m_sValue11, m_pMagicConfigList[sType]->m_sValue12);
							break;
						case DEF_OWNERTYPE_NPC:
							if (m_pNpcList[sOwnerH] == NULL) continue;
							Effect_Damage_Spot(iNpcH, DEF_OWNERTYPE_NPC, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9 + iWhetherBonus, TRUE, iMagicAttr);
							break;							
					}	}
					m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->GetDeadOwner(&sOwnerH, &cOwnerType, ix, iy);
					if ( (cOwnerType == DEF_OWNERTYPE_PLAYER) && (m_pClientList[sOwnerH] != NULL) && (m_pClientList[sOwnerH]->m_iHP > 0) ) 
					{	if (m_pClientList[sOwnerH] == NULL) break;
						if (bCheckResistingMagicSuccess(-1, sOwnerH, cOwnerType, iResult) == FALSE) 
						{	Effect_Damage_Spot(iNpcH, DEF_OWNERTYPE_NPC, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9 + iWhetherBonus, TRUE, iMagicAttr);
							Effect_SpDown_Spot(iNpcH, DEF_OWNERTYPE_NPC, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue10, m_pMagicConfigList[sType]->m_sValue11, m_pMagicConfigList[sType]->m_sValue12);
					}	}
				}
			}
			// Damage on Target m_sValue456
			m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, dX, dY);
			if (bCheckResistingMagicSuccess(-1, sOwnerH, cOwnerType, iResult) == FALSE) 
			{	switch (cOwnerType) {
				case DEF_OWNERTYPE_PLAYER:
					Effect_Damage_Spot(iNpcH, DEF_OWNERTYPE_NPC, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue4, m_pMagicConfigList[sType]->m_sValue5, m_pMagicConfigList[sType]->m_sValue6 + iWhetherBonus, TRUE, iMagicAttr);
					Effect_SpDown_Spot(iNpcH, DEF_OWNERTYPE_NPC, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue10, m_pMagicConfigList[sType]->m_sValue11, m_pMagicConfigList[sType]->m_sValue12);
					break;
				case DEF_OWNERTYPE_NPC:
					if (m_pNpcList[sOwnerH] == NULL) break;
					Effect_Damage_Spot(iNpcH, DEF_OWNERTYPE_NPC, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue4, m_pMagicConfigList[sType]->m_sValue5, m_pMagicConfigList[sType]->m_sValue6 + iWhetherBonus, TRUE, iMagicAttr);
					break;
			}	}
			m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->GetDeadOwner(&sOwnerH, &cOwnerType, dX, dY);
			if ( (cOwnerType == DEF_OWNERTYPE_PLAYER) && (m_pClientList[sOwnerH] != NULL) && (m_pClientList[sOwnerH]->m_iHP > 0) ) 
			{	if (m_pClientList[sOwnerH] == NULL) break;
				if (bCheckResistingMagicSuccess(-1, sOwnerH, cOwnerType, iResult) == FALSE) 
				{	Effect_Damage_Spot(iNpcH, DEF_OWNERTYPE_NPC, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue4, m_pMagicConfigList[sType]->m_sValue5, m_pMagicConfigList[sType]->m_sValue6 + iWhetherBonus, TRUE, iMagicAttr);
					Effect_SpDown_Spot(iNpcH, DEF_OWNERTYPE_NPC, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue10, m_pMagicConfigList[sType]->m_sValue11, m_pMagicConfigList[sType]->m_sValue12);
			}	}					
			break;

		}
	}
NMH_NOEFFECT:;
	// Mana
	m_pNpcList[iNpcH]->m_iMana -= m_pMagicConfigList[sType]->m_sValue1; // sValue1ÀÌ Mana Cost
	if (m_pNpcList[iNpcH]->m_iMana < 0) 
		m_pNpcList[iNpcH]->m_iMana = 0;
	SendEventToNearClient_TypeB(MSGID_EVENT_COMMON, DEF_COMMONTYPE_MAGIC, m_pNpcList[iNpcH]->m_cMapIndex,
					            m_pNpcList[iNpcH]->m_sX, m_pNpcList[iNpcH]->m_sY, dX, dY, (sType+100), m_pNpcList[iNpcH]->m_sType);
}

void CGame::RequestTeleportHandler(int iClientH, char * pData, char * cMapName, int dX, int dY)
{	char  * pBuffer, cTempMapName[21];
	DWORD * dwp;
	WORD  * wp;
	char  * cp, cDestMapName[11], cDir, cMapIndex, cQuestRemain;
	short * sp, sX, sY, sSummonPoints;
	int   * ip, i, iRet, iSize, iDestX, iDestY, iExH;
	BOOL    bRet, bIsLockedMapNotify;
	SYSTEMTIME SysTime;

	if (m_pClientList[iClientH] == NULL) return;
	if (m_pClientList[iClientH]->m_bIsInitComplete == FALSE)	return; // Dont TP if logon not finished
	if (m_pClientList[iClientH]->m_bIsKilled == TRUE)			return; // Don't TP deadman
	if (m_pClientList[iClientH]->m_bIsOnWaitingProcess == TRUE) return; // Don't TP if already TPing
	if (m_pClientList[iClientH]->m_cDelayedDeco != 0)			return; // Don't TP if DelayedDeleteClient	

	m_pClientList[iClientH]->m_dwLastActionTime = m_pClientList[iClientH]->m_dwAFKCheckTime = timeGetTime();

	// Avatar Anti-TP
	if (   (m_bIsAvatarMode == TRUE) && (m_iPLmapIndex != -1) && (m_iAvatarMessenger == iClientH)) 
		CheckIfRelicDrop(iClientH);				

	// Prevent recalls spells/scrolls, and any recall type magic if forbidden on the map
	if ((m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_bIsRecallImpossible == TRUE) 
		&& (m_pClientList[iClientH]->m_iAdminUserLevel == 0) 
		&& (m_pClientList[iClientH]->m_bIsKilled == FALSE) 
		/*&& (m_bIsApocalypseMode == TRUE)*/  
		&& (m_pClientList[iClientH]->m_iHP > 0)) 
	{	if (   (m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_bIsApocalypseMap == TRUE)
				&& (m_bIsApocalypseMode == FALSE))
		{	// Can recall
		}else // either Apocalypse running on Apoc map or not an apoc map
		{	if ((pData[0] == '3') ||(pData[0] == '1')) 
			// '0' is forced recall
			// '1' is recall spells
			// '2' is fixed, stated destination such as tickets or GM TPing characters
			// '3' is fixed, stated destination but forbidden on NoRecall map
			// '' Means client is on TP tile and asks the server to perform the TP.
			{	SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_NORECALL, NULL, NULL, NULL, NULL);
				return;
	}	}	}
	// no TP from ennemi city
	if (   (m_pClientList[iClientH]->m_cSide == 1) // Ares
		&& (memcmp(m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cLocationName, "elvine", 6) == 0)
		&& ((pData[0] == '1') ||(pData[0] == '3')) 
		&& ((m_bMapModeEquilibrium == FALSE) || (m_bIsCrusadeMode == TRUE)) // Recall possible at EQUILIBRIUM map-mode
		&& (m_pClientList[iClientH]->m_iAdminUserLevel == 0)) return ;

	// no TP from ennemi city
	if ((m_pClientList[iClientH]->m_cSide == 2) // Evine
		&& (memcmp(m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cLocationName, "aresden", 7) == 0)
		&& ((pData[0] == '1') ||(pData[0] == '3')) 
		&& ((m_bMapModeEquilibrium == FALSE) || (m_bIsCrusadeMode == TRUE)) // Recall possible at EQUILIBRIUM map-mode
		&& (m_pClientList[iClientH]->m_iAdminUserLevel == 0)) return;

	bIsLockedMapNotify = FALSE;

	// no TP during item exchange
	if (m_pClientList[iClientH]->m_bIsExchangeMode == TRUE) 
	{	iExH = m_pClientList[iClientH]->m_iExchangeH;
		_ClearExchangeStatus(iExH);
		_ClearExchangeStatus(iClientH);
	}	// ???? No recall for travellers ????
	// SNOOPY removed this...
	//if ((memcmp(m_pClientList[iClientH]->m_cLocation, "NONE", 4) == 0) && (pData[0] == '1'))
	//	return;	 . 
	RemoveFromTarget(iClientH, DEF_OWNERTYPE_PLAYER, DEF_MAGICTYPE_TELEPORT);
	m_pClientList[iClientH]->m_dwLastDamageMoveTime = timeGetTime();	
	m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->ClearOwner(13, iClientH, DEF_OWNERTYPE_PLAYER, 
		m_pClientList[iClientH]->m_sX, 
		m_pClientList[iClientH]->m_sY); 
	SendEventToNearClient_TypeA(iClientH, DEF_OWNERTYPE_PLAYER, MSGID_EVENT_LOG, DEF_MSGTYPE_REJECT, NULL, NULL, NULL);

	sX = m_pClientList[iClientH]->m_sX;
	sY = m_pClientList[iClientH]->m_sY;

	ZeroMemory(cDestMapName, sizeof(cDestMapName));
	bRet = m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->bSearchTeleportDest(sX, sY, cDestMapName, &iDestX, &iDestY, &cDir);

	// All TP from Equilibrium must go to proper city, if crusade started at Equi map settings
	if ((m_bMapModeEquilibriumChanged == TRUE) && (bRet == TRUE) && (cMapName == NULL))
	{	if (memcmp(m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cLocationName, "lost", 4) == 0)
		{	if (m_pClientList[iClientH]->m_iAdminUserLevel == 0)
			{	//wsprintf(G_cTxt,"Avant test: (%s)", cDestMapName );
				//PutLogList(G_cTxt);
				if (   (memcmp(cDestMapName, "elvine", 6)		== 0)
					|| (memcmp(cDestMapName, "aresden", 7)		== 0)
					|| (memcmp(cDestMapName, "middleland", 10)	== 0)
					|| (memcmp(cDestMapName, "arefarm", 7)		== 0)
					|| (memcmp(cDestMapName, "elvfarm", 7)		== 0))
				{	ZeroMemory(cDestMapName, sizeof(cDestMapName));				
					switch (m_pClientList[iClientH]->m_cSide) {
					case 1: // Aresden
						if (m_pClientList[iClientH]->m_iLevel > 80)
						{	strcpy(cDestMapName, "aresden");
						}else 
						{	strcpy(cDestMapName, "arefarm");
						}			
						break;
					case 2: // Elvine
						if (m_pClientList[iClientH]->m_iLevel > 80)
						{	strcpy(cDestMapName, "elvine");
						}else 
						{	strcpy(cDestMapName, "elvfarm");
						}				
						break;
					case 4: // evil
						strcpy(cDestMapName, "middleland");
						break;
					default:
					case 0: // Travellers go Beginner zone
						strcpy(cDestMapName, "default");
						break;
					}	
					iDestX = -1;
					iDestY = -1;
					cDir = 5;
	}	}	}	}
	// Heldenian: TP to GodH go to appropriate place...
	if ((m_bIsHeldenianMode == TRUE) && (bRet == TRUE) && (cMapName == NULL))
	{	if (memcmp(m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cLocationName, "HRampart", 8) == 0)
		{	if (m_pClientList[iClientH]->m_iAdminUserLevel == 0)
			{	if (memcmp(cDestMapName, "GodH", 4) == 0)
				{	if (m_pClientList[iClientH]->m_cSide == m_sLastHeldenianWinner)
					{	iDestX = 54;
						iDestY = 67;
						cDir = 4;
					}else
					{	iDestX = 192 + iDice(1,20);
						iDestY = 166 + iDice(1,10);
						cDir = 7;
	}	}	}	}	}

	// Logging in enemy shops => Set recall time if Crusade or Standard Map settings
	if (   ((!m_bMapModeEquilibrium) || (m_bIsCrusadeMode == TRUE))
		&& (m_pClientList[iClientH]->m_cSide == iGetMapLocationForbiddenSide(cDestMapName)) 
		&& (m_pClientList[iClientH]->m_iAdminUserLevel == 0))  // Not in own town
	{	m_pClientList[iClientH]->m_bIsWarLocation = TRUE;
		m_pClientList[iClientH]->m_iTimeLeft_ForceRecall = 0;
	}

	// Locked maps, such as bisle, jails, cities in Crusade
	if ((strcmp(m_pClientList[iClientH]->m_cLockedMapName, "NONE") != 0) && (m_pClientList[iClientH]->m_iLockedMapTime > 0)) 
	{	int iSideMapCdt = iGetMapLocationForbiddenSide(cDestMapName) + m_pClientList[iClientH]->m_cSide;
		if ((iSideMapCdt == 3) || (strcmp(m_pClientList[iClientH]->m_cLockedMapName, cDestMapName) == 0))
		{}else // 3 allows city buildings when blocked in city
		{	iDestX = -1;
			iDestY = -1;
			bIsLockedMapNotify = TRUE;
			ZeroMemory(cDestMapName, sizeof(cDestMapName));
			strcpy(cDestMapName, m_pClientList[iClientH]->m_cLockedMapName);
	}	}

	if ((bRet == TRUE) && (cMapName == NULL))  // Parse TP command from client.
	{	// bRet=> found a location on current map, cMapName==NULL => no map parsed to this function
		for (i = 0; i < DEF_MAXMAPS; i++)
		{	if (m_pMapList[i] != NULL) 
			{	if (memcmp(m_pMapList[i]->m_cName, cDestMapName, 10) == 0) 
				{	m_pClientList[iClientH]->m_sX   = iDestX;	  
					m_pClientList[iClientH]->m_sY   = iDestY;
					m_pClientList[iClientH]->m_cDir = cDir;
					m_pClientList[iClientH]->m_cMapIndex = i; 
					ZeroMemory(m_pClientList[iClientH]->m_cMapName, sizeof(m_pClientList[iClientH]->m_cMapName));
					memcpy(m_pClientList[iClientH]->m_cMapName, m_pMapList[i]->m_cName, 10);  // 
					goto RTH_NEXTSTEP;			
		}	}	}
		// teleport on another server 
		m_pClientList[iClientH]->m_sX   = iDestX;
		m_pClientList[iClientH]->m_sY   = iDestY;
		m_pClientList[iClientH]->m_cDir = cDir;
		ZeroMemory(m_pClientList[iClientH]->m_cMapName, sizeof(m_pClientList[iClientH]->m_cMapName));
		memcpy(m_pClientList[iClientH]->m_cMapName, cDestMapName, 10);  
		// New 18/05/2004
		SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_MAGICEFFECTOFF, DEF_MAGICTYPE_CONFUSE,
			m_pClientList[iClientH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_CONFUSE ], NULL, NULL);
		SetSlateFlag(iClientH, DEF_NOTIFY_SLATECLEAR, FALSE);
		m_pClientList[iClientH]->m_cdwDecoTime = timeGetTime(); // Set deco time (needed to go temporary map)
		bSendMsgToLS(MSGID_REQUEST_SAVEPLAYERDATA_REPLY, iClientH, FALSE); 
		m_pClientList[iClientH]->m_bIsOnWaitingProcess = TRUE;
		return;
	}else 
	{	switch (pData[0]) {
		case '0': // Forced Recall. 
			ZeroMemory(cTempMapName, sizeof(cTempMapName));				
			switch (m_pClientList[iClientH]->m_cSide) {
			case 1: // Aresden
				if (m_pClientList[iClientH]->m_bIsPlayerCivil == FALSE)
				{	if (m_bMapModeEquilibrium) 
					{	strcpy(cTempMapName, "lost");
					}else
					{	strcpy(cTempMapName, "aresden");
					}
				}else 
				{	if (m_bMapModeEquilibrium) 
					{	strcpy(cTempMapName, "lost");
					}else
					{	strcpy(cTempMapName, "arefarm");
					}
				}			
				break;
			case 2: // Elvine
				if (m_pClientList[iClientH]->m_bIsPlayerCivil == FALSE)
				{	if (m_bMapModeEquilibrium) 
					{	strcpy(cTempMapName, "lost");
					}else
					{	strcpy(cTempMapName, "elvine");
					}
				}else 
				{	if (m_bMapModeEquilibrium) 
					{	strcpy(cTempMapName, "lost");
					}else
					{	strcpy(cTempMapName, "elvfarm");
					}
				}				
				break;
			case 4: // executors
				if (m_pClientList[iClientH]->m_iLevel < 101) 
				{	strcpy(cTempMapName, "2ndmiddle");
				}else
				{	strcpy(cTempMapName, "middleland");
				}	
				if (   (m_bIsCrusadeMode == TRUE) 
					&& (m_pClientList[iClientH]->m_iAdminUserLevel == 0))
				{	ZeroMemory(cTempMapName, sizeof(cTempMapName));	
					strcpy(cTempMapName, "bisle");				
				}	
				break;
			default:
			case 0: // Travellers go Beginner zone
				if (   (m_pClientList[iClientH]->m_iAdminUserLevel == 0) 
					|| (m_bMapModeEquilibrium == FALSE)) 
				{	strcpy(cTempMapName, "default");
				}else // GM go to Equi if possible
				{	strcpy(cTempMapName, "lost");
				}
				break;
			}

			// if map is locked, Force recall go locked map
			if ((strcmp(m_pClientList[iClientH]->m_cLockedMapName, "NONE") != 0) && (m_pClientList[iClientH]->m_iLockedMapTime > 0)) 
			{	bIsLockedMapNotify = TRUE;
				ZeroMemory(cTempMapName, sizeof(cTempMapName));
				strcpy(cTempMapName, m_pClientList[iClientH]->m_cLockedMapName);
			}

			for (i = 0; i < DEF_MAXMAPS; i++)
				if (m_pMapList[i] != NULL) 
				{	if (memcmp(m_pMapList[i]->m_cName, cTempMapName, 10) == 0) 
						// Find initial point for forced recall
					{	GetMapInitialPoint(i, &m_pClientList[iClientH]->m_sX, &m_pClientList[iClientH]->m_sY);
						m_pClientList[iClientH]->m_cMapIndex = i;
						ZeroMemory(m_pClientList[iClientH]->m_cMapName, sizeof(m_pClientList[iClientH]->m_cMapName));
						memcpy(m_pClientList[iClientH]->m_cMapName, cTempMapName, 10); 					
						goto RTH_NEXTSTEP;
					}
				}
				//  teleport on another server ???
				m_pClientList[iClientH]->m_sX   = -1;	  // 
				m_pClientList[iClientH]->m_sY   = -1;	  //  InitialPoint
				ZeroMemory(m_pClientList[iClientH]->m_cMapName, sizeof(m_pClientList[iClientH]->m_cMapName));
				memcpy(m_pClientList[iClientH]->m_cMapName, cTempMapName, 10);  
				// New 18/05/2004
				SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_MAGICEFFECTOFF, DEF_MAGICTYPE_CONFUSE,
					m_pClientList[iClientH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_CONFUSE ], NULL, NULL);
				SetSlateFlag(iClientH, DEF_NOTIFY_SLATECLEAR, FALSE);
				m_pClientList[iClientH]->m_cdwDecoTime = timeGetTime(); // Set deco time (needed to go temporary map)
				bSendMsgToLS(MSGID_REQUEST_SAVEPLAYERDATA_REPLY, iClientH, FALSE); 
				m_pClientList[iClientH]->m_bIsOnWaitingProcess = TRUE;
				return;

		case '1':
			// Recall. 
			// if (memcmp(m_pMapList[ m_pClientList[iClientH]->m_cMapIndex ]->m_cName, "resurr", 6) == 0) return;				
			ZeroMemory(cTempMapName, sizeof(cTempMapName));				
			switch (m_pClientList[iClientH]->m_cSide) {
			case 1: // Aresden
				if (m_pClientList[iClientH]->m_iLevel > 80)
				{	if (m_bMapModeEquilibrium) 
					{	strcpy(cTempMapName, "lost");
					}else
					{	strcpy(cTempMapName, "aresden");
					}
				}else 
				{	strcpy(cTempMapName, "arefarm");
				}			
				break;
			case 2: // Elvine
				if (m_pClientList[iClientH]->m_iLevel > 80)
				{	if (m_bMapModeEquilibrium) 
					{	strcpy(cTempMapName, "lost");
					}else
					{	strcpy(cTempMapName, "elvine");
					}
				}else 
				{	strcpy(cTempMapName, "elvfarm");
				}				
				break;
			case 4: // evil
				if (m_bMapModeEquilibrium) 
				{	switch (iDice(1,2)) {
					case 1:
						strcpy(cTempMapName, "aresden");
						break;
					case 2:
						strcpy(cTempMapName, "elvine");
						break;
					}
				}else 
				{	if (m_pClientList[iClientH]->m_iLevel < 101) 
					{	strcpy(cTempMapName, "2ndmiddle");
					}else
					{	strcpy(cTempMapName, "middleland");
				}	}					
				if (   (m_bIsCrusadeMode == TRUE)
					&& (m_pClientList[iClientH]->m_iAdminUserLevel == 0))
				{	ZeroMemory(cTempMapName, sizeof(cTempMapName));	
					strcpy(cTempMapName, "bisle");				
				}	
				break;
			default:
			case 0: // Travellers go Beginner zone
				if (   (m_pClientList[iClientH]->m_iAdminUserLevel == 0) 
					|| (m_bMapModeEquilibrium == FALSE)) 
				{	strcpy(cTempMapName, "default");
				}else
				{	strcpy(cTempMapName, "lost");
				}
				break;
			}		
			// if map is locked, Recall go locked map
			if ((strcmp(m_pClientList[iClientH]->m_cLockedMapName, "NONE") != 0) && (m_pClientList[iClientH]->m_iLockedMapTime > 0)) 
			{	bIsLockedMapNotify = TRUE;
				ZeroMemory(cTempMapName, sizeof(cTempMapName));
				strcpy(cTempMapName, m_pClientList[iClientH]->m_cLockedMapName);
			}
			for (i = 0; i < DEF_MAXMAPS; i++)
			{	if (m_pMapList[i] != NULL) 
				{	if (memcmp(m_pMapList[i]->m_cName, cTempMapName, 10) == 0) 
					{	GetMapInitialPoint(i, &m_pClientList[iClientH]->m_sX, &m_pClientList[iClientH]->m_sY);
						m_pClientList[iClientH]->m_cMapIndex = i;
						ZeroMemory(m_pClientList[iClientH]->m_cMapName, sizeof(m_pClientList[iClientH]->m_cMapName));
						memcpy(m_pClientList[iClientH]->m_cMapName, m_pMapList[i]->m_cName, 10);  						
						goto RTH_NEXTSTEP;	// TP on same server	
			}	}	}
			//  teleport on another server 
			m_pClientList[iClientH]->m_sX   = -1;
			m_pClientList[iClientH]->m_sY   = -1;			
			ZeroMemory(m_pClientList[iClientH]->m_cMapName, sizeof(m_pClientList[iClientH]->m_cMapName));
			memcpy(m_pClientList[iClientH]->m_cMapName, cTempMapName, 10); 
			// New 18/05/2004
			SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_MAGICEFFECTOFF, DEF_MAGICTYPE_CONFUSE,
				m_pClientList[iClientH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_CONFUSE ], NULL, NULL);				
			SetSlateFlag(iClientH, DEF_NOTIFY_SLATECLEAR, FALSE);
			m_pClientList[iClientH]->m_cdwDecoTime = timeGetTime(); // Set deco time (needed to go temporary map)
			bSendMsgToLS(MSGID_REQUEST_SAVEPLAYERDATA_REPLY, iClientH, FALSE);
			m_pClientList[iClientH]->m_bIsOnWaitingProcess   = TRUE;
			return;

		case '2':// fixed destination
		case '3':// fixed destination, but not allowed from "recall-impossible" maps...
			// Crusade
			if ((strcmp(m_pClientList[iClientH]->m_cLockedMapName, "NONE") != 0) && (m_pClientList[iClientH]->m_iLockedMapTime > 0)) 
			{	dX = -1;
				dY = -1;
				bIsLockedMapNotify = TRUE;
				ZeroMemory(cTempMapName, sizeof(cTempMapName));
				strcpy(cTempMapName, m_pClientList[iClientH]->m_cLockedMapName);
			}else 
			{	ZeroMemory(cTempMapName, sizeof(cTempMapName));
				strcpy(cTempMapName, cMapName);
			}
			cMapIndex = iGetMapIndex(cTempMapName);
			if (cMapIndex == -1) 		//  teleport on another server 				
			{	m_pClientList[iClientH]->m_sX   = dX; //-1;	  .
				m_pClientList[iClientH]->m_sY   = dY; //-1;	  InitialPoint.
				ZeroMemory(m_pClientList[iClientH]->m_cMapName, sizeof(m_pClientList[iClientH]->m_cMapName));
				memcpy(m_pClientList[iClientH]->m_cMapName, cTempMapName, 10);
				// New 18/05/2004
				SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_MAGICEFFECTOFF, DEF_MAGICTYPE_CONFUSE,
					m_pClientList[iClientH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_CONFUSE ], NULL, NULL);
				SetSlateFlag(iClientH, DEF_NOTIFY_SLATECLEAR, FALSE);
				m_pClientList[iClientH]->m_cdwDecoTime = timeGetTime(); // Set deco time (needed to go temporary map)
				bSendMsgToLS(MSGID_REQUEST_SAVEPLAYERDATA_REPLY, iClientH, FALSE); 
				m_pClientList[iClientH]->m_bIsOnWaitingProcess   = TRUE;
				return;
			}
			m_pClientList[iClientH]->m_sX   = dX;
			m_pClientList[iClientH]->m_sY   = dY;
			m_pClientList[iClientH]->m_cMapIndex = cMapIndex;
			ZeroMemory(m_pClientList[iClientH]->m_cMapName, sizeof(m_pClientList[iClientH]->m_cMapName));
			memcpy(m_pClientList[iClientH]->m_cMapName, m_pMapList[cMapIndex]->m_cName, 10);  
			break;	
	}	}

RTH_NEXTSTEP: // Teleport on some map from same server
	SetPlayingStatus(iClientH);
	int iTemp, iTemp2;
	iTemp = m_pClientList[iClientH]->m_iStatus;
	iTemp = 0x0FFBFFFF & iTemp;
	iTemp2 = iGetPlayerABSStatus(iClientH);
	iTemp = iTemp | (iTemp2 << 28);
	m_pClientList[iClientH]->m_iStatus = iTemp;

	// Crusade
	if (bIsLockedMapNotify == TRUE) SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_LOCKEDMAP, m_pClientList[iClientH]->m_iLockedMapTime, NULL, NULL, m_pClientList[iClientH]->m_cLockedMapName);

	pBuffer = new char [DEF_MSGBUFFERSIZE+1];
	ZeroMemory(pBuffer, DEF_MSGBUFFERSIZE+1);

	dwp  = (DWORD *)(pBuffer + DEF_INDEX4_MSGID);
	*dwp = MSGID_RESPONSE_INITDATA;
	wp   = (WORD *)(pBuffer + DEF_INDEX2_MSGTYPE);
	*wp  = DEF_MSGTYPE_CONFIRM;
	cp = (char *)(pBuffer + DEF_INDEX2_MSGTYPE + 2);
	if (m_pClientList[iClientH]->m_bIsObserverMode == FALSE)
		bGetEmptyPosition(&m_pClientList[iClientH]->m_sX, &m_pClientList[iClientH]->m_sY, m_pClientList[iClientH]->m_cMapIndex);
	else GetMapInitialPoint(m_pClientList[iClientH]->m_cMapIndex, &m_pClientList[iClientH]->m_sX, &m_pClientList[iClientH]->m_sY);
	// (x, y)(x+14, y+12)
	sp  = (short *)cp;
	*sp = iClientH;		// Player ObjectID
	cp += 2;
	sp  = (short *)cp;
	*sp = m_pClientList[iClientH]->m_sX - 14 - 5;
	cp += 2;
	sp  = (short *)cp;
	*sp = m_pClientList[iClientH]->m_sY - 12 - 5;
	cp += 2;
	sp  = (short *)cp;
	*sp = m_pClientList[iClientH]->m_sType;
	cp += 2;
	sp  = (short *)cp;
	*sp = m_pClientList[iClientH]->m_sAppr1;
	cp += 2;
	sp  = (short *)cp;
	*sp = m_pClientList[iClientH]->m_sAppr2;
	cp += 2;
	sp  = (short *)cp;
	*sp = m_pClientList[iClientH]->m_sAppr3;
	cp += 2;
	sp  = (short *)cp;
	*sp = m_pClientList[iClientH]->m_sAppr4;
	cp += 2;
	// v1.4 ApprColor
	ip = (int *)cp;
	*ip = m_pClientList[iClientH]->m_iApprColor;
	cp += 4;
	ip  = (int *)cp;
	*ip = m_pClientList[iClientH]->m_iStatus;
	cp += 4;//Original 2
	memcpy(cp, m_pClientList[iClientH]->m_cMapName, 10);
	cp += 10;
	memcpy(cp, m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cLocationName, 10);
	cp += 10;
	if (m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_bIsFixedDayMode == TRUE) 
	{	*cp = 1;
		cp++;
		*cp = NULL;
	}else 
	{	*cp = m_cDayOrNight;
		cp++;
		*cp = m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cWhetherStatus;
	}
	cp++;
	ip = (int *)cp;
	*ip = m_pClientList[iClientH]->m_iContribution;
	cp += 4;
	// Snoopy moved this before test
	*cp = (char)m_pClientList[iClientH]->m_bIsObserverMode;
	cp++;
	if (m_pClientList[iClientH]->m_bIsObserverMode == FALSE) 
	{	m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->SetOwner(iClientH, 
			DEF_OWNERTYPE_PLAYER, 
			m_pClientList[iClientH]->m_sX, 
			m_pClientList[iClientH]->m_sY);
	}
	ip = (int *)cp;
	*ip = m_pClientList[iClientH]->m_iRating;
	cp += 4;
	ip = (int *)cp;
	*ip = m_pClientList[iClientH]->m_iHP;
	cp += 4;	
	*cp = m_pClientList[iClientH]->m_cDiscount;	//m_cDiscount = (char )*cp; // 100=> Price +100%
	cp++;
	iSize = iComposeInitMapData(m_pClientList[iClientH]->m_sX - 10, m_pClientList[iClientH]->m_sY - 7, iClientH, cp );
	iRet = m_pClientList[iClientH]->m_pXSock->iSendMsg(pBuffer, 46 + iSize +4 +4 +1 +4 +4 + 3); //Zabuza fix
	switch (iRet) {
	case DEF_XSOCKEVENT_QUENEFULL:
	case DEF_XSOCKEVENT_SOCKETERROR:
	case DEF_XSOCKEVENT_CRITICALERROR:
	case DEF_XSOCKEVENT_SOCKETCLOSED:
		DeleteClient(iClientH, TRUE, TRUE);
		if(pBuffer != NULL) delete pBuffer;
		return;
	}

	if(pBuffer != NULL) delete pBuffer; 
	SendEventToNearClient_TypeA(iClientH, DEF_OWNERTYPE_PLAYER, MSGID_EVENT_LOG, DEF_MSGTYPE_CONFIRM, NULL, NULL, NULL);
	if (   (memcmp(m_pClientList[iClientH]->m_cLocation, "are", 3) == 0) 
		&& (memcmp(m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cLocationName, "elvine", 6) == 0) 
		&& (m_pClientList[iClientH]->m_iAdminUserLevel == 0)
		// Snoopy added mapmode here to prevent recall time message to client 
		&& (!m_bMapModeEquilibrium) ) 
	{	m_pClientList[iClientH]->m_bIsWarLocation = TRUE;
		CheckForceRecallTime(iClientH);
	}else if ( (memcmp(m_pClientList[iClientH]->m_cLocation, "elv", 3) == 0)
		&& (memcmp(m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cLocationName, "aresden", 7) == 0)
		&& 	(m_pClientList[iClientH]->m_iAdminUserLevel == 0) 
		// Snoopy added mapmode here to prevent recall time message to client 
		&& (!m_bMapModeEquilibrium) ) 
	{	m_pClientList[iClientH]->m_bIsWarLocation = TRUE;
		// New 17/05/2004
		CheckForceRecallTime(iClientH);
	}else if ( m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_bIsFightZone == TRUE ) 
	{	m_pClientList[iClientH]->m_bIsWarLocation = TRUE;
		SetForceRecallTime(iClientH);
		GetLocalTime(&SysTime);
		m_pClientList[iClientH]->m_iTimeLeft_ForceRecall = 2*20*60 - ((SysTime.wHour%2)*20*60 + SysTime.wMinute*20) - 2*20;  
	} else 
	{	m_pClientList[iClientH]->m_bIsWarLocation = FALSE;	
		m_pClientList[iClientH]->m_iTimeLeft_ForceRecall = 0;
		SetForceRecallTime(iClientH) ;
	}
	// TP in enemy shops => Set a very short recall time if Crusade or Standard Map settings
	if (   ((!m_bMapModeEquilibrium) || (m_bIsCrusadeMode == TRUE))
		&& (m_pClientList[iClientH]->m_cSide == iGetMapLocationForbiddenSide(m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cName)) 
		&& (m_pClientList[iClientH]->m_iAdminUserLevel == 0))  // Not in own town
	{	m_pClientList[iClientH]->m_bIsWarLocation = TRUE;
		m_pClientList[iClientH]->m_iTimeLeft_ForceRecall = 0;
	}
	// TP in arenas
	if (   (m_pMapList[ m_pClientList[iClientH]->m_cMapIndex ]->m_bIsFightZone == TRUE )
		&& (m_iFightzoneNoForceRecall == FALSE) 
		&& (m_pClientList[iClientH]->m_iAdminUserLevel == 0)) 
	{	m_pClientList[iClientH]->m_bIsWarLocation = TRUE;
		GetLocalTime(&SysTime);
		m_pClientList[iClientH]->m_iTimeLeft_ForceRecall = 2*60*20 - ((SysTime.wHour%2)*20*60 + SysTime.wMinute*20) - 2*20;
	// TP in jails
	}else if ( (memcmp(m_pMapList[ m_pClientList[iClientH]->m_cMapIndex ]->m_cLocationName, "arejail", 7) == 0) 
		   	|| (memcmp(m_pMapList[ m_pClientList[iClientH]->m_cMapIndex ]->m_cLocationName, "elvjail", 7) == 0)) 
	{	if (m_pClientList[iClientH]->m_iAdminUserLevel == 0) 
		{	m_pClientList[iClientH]->m_bIsWarLocation = TRUE;
			if (m_pClientList[iClientH]->m_iTimeLeft_ForceRecall == 0)
				m_pClientList[iClientH]->m_iTimeLeft_ForceRecall = 100; // 5 minutes
			else if(m_pClientList[iClientH]->m_iTimeLeft_ForceRecall > 100)
				m_pClientList[iClientH]->m_iTimeLeft_ForceRecall = 100; // 5 minutes
		}
	}
	SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_SAFEATTACKMODE, NULL, NULL, NULL, NULL);
	SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_DOWNSKILLINDEXSET, m_pClientList[iClientH]->m_iDownSkillIndex, NULL, NULL, NULL);
	SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_ITEMPOSLIST, NULL, NULL, NULL, NULL);
	_SendQuestContents(iClientH);
	_CheckQuestEnvironment(iClientH);

	// v1.432
	if (m_pClientList[iClientH]->m_iSpecialAbilityTime == 0)
		SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_SPECIALABILITYENABLED, NULL, NULL, NULL, NULL);

// Crusade mode on¨
	if (m_bIsCrusadeMode == TRUE) 
	{	if (m_pClientList[iClientH]->m_dwCrusadeGUID == 0) 
		{	m_pClientList[iClientH]->m_iCrusadeDuty = 0;
			m_pClientList[iClientH]->m_iConstructionPoint = 0;
			m_pClientList[iClientH]->m_dwCrusadeGUID = m_dwCrusadeGUID;
		}else if (m_pClientList[iClientH]->m_dwCrusadeGUID != m_dwCrusadeGUID) 
		{	m_pClientList[iClientH]->m_iCrusadeDuty       = 0;
	 		m_pClientList[iClientH]->m_iConstructionPoint = 0;
			m_pClientList[iClientH]->m_iWarContribution   = 0;
			m_pClientList[iClientH]->m_dwCrusadeGUID = m_dwCrusadeGUID;
			SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_CRUSADE, (DWORD)m_bIsCrusadeMode, 0, 0, NULL, -1);	//iV4=-1: cnl previous crusade	
		}
		SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_CONSTRUCTIONPOINT, m_pClientList[iClientH]->m_iConstructionPoint, m_pClientList[iClientH]->m_iWarContribution, 1, NULL);
		m_pClientList[iClientH]->m_cVar = 1;
		SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_CRUSADE, (DWORD)m_bIsCrusadeMode, m_pClientList[iClientH]->m_iCrusadeDuty, 0, NULL);
// Heldenian mode on
	}else if (m_bIsHeldenianMode == TRUE) 
	{	sSummonPoints = 10000 + m_pClientList[iClientH]->m_iCharisma*100;
		if (sSummonPoints > DEF_MAXHELDENIANSUMMONPOINT) sSummonPoints = DEF_MAXHELDENIANSUMMONPOINT;
		if (m_pClientList[iClientH]->m_dwHeldenianGUID == NULL) 
		{	m_pClientList[iClientH]->m_dwHeldenianGUID    = m_dwHeldenianGUID;
			m_pClientList[iClientH]->m_iConstructionPoint = sSummonPoints;
			m_pClientList[iClientH]->m_iWarContribution   = 0;
		}else if (m_pClientList[iClientH]->m_dwHeldenianGUID != m_dwHeldenianGUID) 
		{	m_pClientList[iClientH]->m_dwHeldenianGUID    = m_dwHeldenianGUID;
			m_pClientList[iClientH]->m_iConstructionPoint = sSummonPoints;
			m_pClientList[iClientH]->m_iWarContribution   = 0;
		}
		//UpdateHeldenianStatus(iClientH);
		if (m_cHeldenianWinner == -1) 
		{	if (m_bHeldenianWarInitiated == TRUE) 
			{	SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_HELDENIANSTART, NULL, NULL, NULL, NULL);
			}else
			{	SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_HELDENIANTELEPORT, NULL, NULL, NULL, NULL);
			}
		}
		m_pClientList[iClientH]->m_cVar = 2;// character have been informed of heldenian starting...
		SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_CONSTRUCTIONPOINT, m_pClientList[iClientH]->m_iConstructionPoint, m_pClientList[iClientH]->m_iWarContribution, 1, NULL);
		UpdateHeldenianStatus(iClientH);
	// Just finished a crusade
	// The use of m_cVar, here, is to prevent the Experience screen before changing map at least once. 
	}else if ((m_pClientList[iClientH]->m_cVar == 1) // Just finished a crusade
		&& (m_pClientList[iClientH]->m_dwCrusadeGUID == m_dwCrusadeGUID)
		&& (m_pClientList[iClientH]->m_dwCrusadeGUID != NULL)) 
	{	m_pClientList[iClientH]->m_iCrusadeDuty = 0;
		m_pClientList[iClientH]->m_iConstructionPoint = 0;
		SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_CRUSADE, (DWORD)m_bIsCrusadeMode, 0, 0, NULL, -1);
		m_pClientList[iClientH]->m_cVar = 0; // Tell the client, he'll get XP later
	// The Heldenian he has participated is over...
	}else if ( (m_pClientList[iClientH]->m_cVar == 2) // Just finished Heldenian
			&& (m_pClientList[iClientH]->m_dwHeldenianGUID == m_dwHeldenianGUID)
			&& (m_pClientList[iClientH]->m_dwHeldenianGUID != NULL)) 
	{	m_pClientList[iClientH]->m_iConstructionPoint = 0;
		SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_HELDENIANEND, NULL, NULL, NULL, NULL);
		m_pClientList[iClientH]->m_cVar = 0; // Character is informed of Hedenian end... so he'll get XP later
	}

	// The Avatar is running... (in case the char was TPing during the start message ???) and informing at each TP
	if ( m_bIsAvatarMode == TRUE) 
	{	if (m_pClientList[iClientH]->m_dwAvatarGUID != m_dwAvatarGUID)
		{	m_pClientList[iClientH]->m_dwAvatarGUID = m_dwAvatarGUID;
			m_pClientList[iClientH]->m_iConstructionPoint = 0; // not the messenger!
			m_pClientList[iClientH]->m_iWarContribution   = 0; // reset xp
		}else
		{	m_pClientList[iClientH]->m_iConstructionPoint = 0; // not the messenger!
		}		
		SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_AVATAR, (DWORD)1, 0, 0, NULL, 0);
	}

	if (memcmp(m_pClientList[iClientH]->m_cMapName, "fight", 5) == 0) 
	{	wsprintf(G_cTxt, "Char(%s)-Enter(%s) Observer(%d)", m_pClientList[iClientH]->m_cCharName, m_pClientList[iClientH]->m_cMapName, m_pClientList[iClientH]->m_bIsObserverMode);
		PutLogEventFileList(G_cTxt);
	}
	SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_GIZONITEMUPGRADELEFT, m_pClientList[iClientH]->m_iGizonItemUpgradeLeft, NULL, NULL, NULL);
	if (m_pClientList[iClientH]->m_iQuest != NULL) 
	{ 	cQuestRemain = (m_pQuestConfigList[m_pClientList[iClientH]->m_iQuest]->m_iMaxCount - m_pClientList[iClientH]->m_iCurQuestCount);
		SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_QUESTCOUNTER, cQuestRemain, NULL, NULL, NULL);
		_bCheckIsQuestCompleted(iClientH);
	}
	// SNOOPY: Send gate positions if applicable.
	Notify_ApocalypseGateState(iClientH);	
}
BOOL CGame::_bDecodeMagicConfigFileContents(char * pData, DWORD dwMsgSize)
{
 char * pContents, * token, cTxt[120];
 char seps[] = "= \t\n";
 char cReadModeA = 0;
 char cReadModeB = 0;
 int  iMagicConfigListIndex = 0;
 class CStrTok * pStrTok;

	pContents = new char[dwMsgSize+1];
	ZeroMemory(pContents, dwMsgSize+1);
	memcpy(pContents, pData, dwMsgSize);

	pStrTok = new class CStrTok(pContents, seps);
	token = pStrTok->pGet();
	//token = strtok(pContents, seps);
	while( token != NULL ) {
		if (cReadModeA != 0) {
			switch (cReadModeA) {
			case 1:
				switch (cReadModeB) {
				case 1:
					// Â¸Â¶Â¹Ã½ Â¹Ã¸ÃˆÂ£ 
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! MAGIC configuration file error - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					
					if (m_pMagicConfigList[atoi(token)] != NULL) {
						// Ã€ÃŒÂ¹ÃŒ Ã‡Ã’Â´Ã§ÂµÃˆ Â¹Ã¸ÃˆÂ£Â°Â¡ Ã€Ã–Â´Ã™. Â¿Â¡Â·Â¯Ã€ÃŒÂ´Ã™.
						PutLogList("(!!!) CRITICAL ERROR! MAGIC configuration file error - Duplicate magic number.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pMagicConfigList[atoi(token)] = new class CMagic;
					iMagicConfigListIndex = atoi(token);

					cReadModeB = 2;
					break;

				case 2:
					ZeroMemory(m_pMagicConfigList[iMagicConfigListIndex]->m_cName, sizeof(m_pMagicConfigList[iMagicConfigListIndex]->m_cName));
					memcpy(m_pMagicConfigList[iMagicConfigListIndex]->m_cName, token, strlen(token));
					cReadModeB = 3;
					break;

				case 3:	//  m_sType
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! MAGIC configuration file error - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pMagicConfigList[iMagicConfigListIndex]->m_sType = atoi(token);
					cReadModeB = 4;
					break;

				case 4:	// m_dwDelayTime
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! MAGIC configuration file error - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pMagicConfigList[iMagicConfigListIndex]->m_dwDelayTime = atoi(token);
					if ((m_pMagicConfigList[iMagicConfigListIndex]->m_dwDelayTime % 3) !=0)
						m_pMagicConfigList[iMagicConfigListIndex]->m_dwDelayTime -= m_pMagicConfigList[iMagicConfigListIndex]->m_dwDelayTime % 3;
					cReadModeB = 5;
					break;

				case 5:	//  m_dwLastTime
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! MAGIC configuration file error - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pMagicConfigList[iMagicConfigListIndex]->m_dwLastTime = atoi(token);
					cReadModeB = 6;
					break;

				case 6:	// m_sValue1
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! MAGIC configuration file error - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pMagicConfigList[iMagicConfigListIndex]->m_sValue1 = atoi(token);
					cReadModeB = 7;
					break;
				
				case 7:	// m_sValue2
					if (_bGetIsStringIsNumber(token) == FALSE) 
					{	PutLogList("(!!!) CRITICAL ERROR! MAGIC configuration file error - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pMagicConfigList[iMagicConfigListIndex]->m_sValue2 = atoi(token);
					cReadModeB = 8;
					break;

				case 8:
					// m_sValue3
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! MAGIC configuration file error - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pMagicConfigList[iMagicConfigListIndex]->m_sValue3 = atoi(token);
					cReadModeB = 9;
					break;

				case 9:
					// m_sValue4
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! MAGIC configuration file error - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pMagicConfigList[iMagicConfigListIndex]->m_sValue4 = atoi(token);
					cReadModeB = 10;
					break;

				case 10:
					// m_sValue5
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! MAGIC configuration file error - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pMagicConfigList[iMagicConfigListIndex]->m_sValue5 = atoi(token);
					cReadModeB = 11;
					break;

				case 11:
					// m_sValue6
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! MAGIC configuration file error - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pMagicConfigList[iMagicConfigListIndex]->m_sValue6 = atoi(token);
					cReadModeB = 12;
					break;

				case 12:
					// m_sValue7
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! MAGIC configuration file error - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pMagicConfigList[iMagicConfigListIndex]->m_sValue7 = atoi(token);
					cReadModeB = 13;
					break;
				
				case 13:
					// m_sValue8
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! MAGIC configuration file error - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pMagicConfigList[iMagicConfigListIndex]->m_sValue8 = atoi(token);
					cReadModeB = 14;
					break;

				case 14:
					// m_sValue9
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! MAGIC configuration file error - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pMagicConfigList[iMagicConfigListIndex]->m_sValue9 = atoi(token);
					cReadModeB = 15;
					break;

				case 15:
					// m_sValue10
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! MAGIC configuration file error - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pMagicConfigList[iMagicConfigListIndex]->m_sValue10 = atoi(token);
					cReadModeB = 16;
					break;

				case 16:
					// m_sValue11
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! MAGIC configuration file error - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pMagicConfigList[iMagicConfigListIndex]->m_sValue11 = atoi(token);
					cReadModeB = 17;
					break;

				case 17:
					// m_sValue12
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! MAGIC configuration file error - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pMagicConfigList[iMagicConfigListIndex]->m_sValue12 = atoi(token);
					cReadModeB = 18;
					break;

				case 18:
					// m_sIntLimit
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! MAGIC configuration file error - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pMagicConfigList[iMagicConfigListIndex]->m_sIntLimit = atoi(token);
					cReadModeB = 19;
					break;

				case 19:
					// m_iGoldCost
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! MAGIC configuration file error - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pMagicConfigList[iMagicConfigListIndex]->m_iGoldCost = atoi(token);
					
					cReadModeB = 20;
					break;

				case 20:
					// m_cCategory
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! MAGIC configuration file error - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pMagicConfigList[iMagicConfigListIndex]->m_cCategory = atoi(token);
					cReadModeB = 21;
					break;

				case 21:
					// m_iAttribute
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! MAGIC configuration file error - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pMagicConfigList[iMagicConfigListIndex]->m_iAttribute = atoi(token);
					cReadModeA = 0;
					cReadModeB = 0;
					break;
				}
				break;

			default: 
				break;
			}
		}
		else {
			if (memcmp(token, "magic", 5) == 0) {
				cReadModeA = 1;
				cReadModeB = 1;
			}
			
		}
		token = pStrTok->pGet();
		//token = strtok(NULL, seps);
	}	

	delete pStrTok;
	delete pContents;

	if ((cReadModeA != 0) || (cReadModeB != 0)) {
		PutLogList("(!!!) CRITICAL ERROR! MAGIC configuration file contents error!");
		return FALSE;
	}

	wsprintf(cTxt, "(!) MAGIC (Total:%d) configuration - success!", iMagicConfigListIndex);
	PutLogList(cTxt);

	return TRUE;

}



BOOL CGame::_bDecodeSkillConfigFileContents(char * pData, DWORD dwMsgSize)
{
 char * pContents, * token, cTxt[120];
 char seps[] = "= \t\n";
 char cReadModeA = 0;
 char cReadModeB = 0;
 int  iSkillConfigListIndex = 0;
 class CStrTok * pStrTok;

	pContents = new char[dwMsgSize+1];
	ZeroMemory(pContents, dwMsgSize+1);
	memcpy(pContents, pData, dwMsgSize);

	pStrTok = new class CStrTok(pContents, seps);
	token = pStrTok->pGet();
	//token = strtok(pContents, seps);
	while( token != NULL ) {
		if (cReadModeA != 0) {
			switch (cReadModeA) {
			case 1:
				switch (cReadModeB) {
				case 1:
					// Â½ÂºÃ…Â³ Â¹Ã¸ÃˆÂ£ 
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! SKILL configuration file error - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					
					if (m_pSkillConfigList[atoi(token)] != NULL) {
						// Ã€ÃŒÂ¹ÃŒ Ã‡Ã’Â´Ã§ÂµÃˆ Â¹Ã¸ÃˆÂ£Â°Â¡ Ã€Ã–Â´Ã™. Â¿Â¡Â·Â¯Ã€ÃŒÂ´Ã™.
						PutLogList("(!!!) CRITICAL ERROR! SKILL configuration file error - Duplicate magic number.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pSkillConfigList[atoi(token)] = new class CSkill;
					iSkillConfigListIndex = atoi(token);

					cReadModeB = 2;
					break;

				case 2:
					// Â½ÂºÃ…Â³ Ã€ÃŒÂ¸Â§ 
					ZeroMemory(m_pSkillConfigList[iSkillConfigListIndex]->m_cName, sizeof(m_pSkillConfigList[iSkillConfigListIndex]->m_cName));
					memcpy(m_pSkillConfigList[iSkillConfigListIndex]->m_cName, token, strlen(token));
					cReadModeB = 3;
					break;

				case 3:
					// Â½ÂºÃ…Â³ ÃÂ¾Â·Ã¹ m_sType
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! SKILL configuration file error - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pSkillConfigList[iSkillConfigListIndex]->m_sType = atoi(token);
					cReadModeB = 4;
					break;

				case 4:
					// m_sValue1
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! SKILL configuration file error - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pSkillConfigList[iSkillConfigListIndex]->m_sValue1 = atoi(token);
					cReadModeB = 5;
					break;
				
				case 5:
					// m_sValue2
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! SKILL configuration file error - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pSkillConfigList[iSkillConfigListIndex]->m_sValue2 = atoi(token);
					cReadModeB = 6;
					break;

				case 6:
					// m_sValue3
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! SKILL configuration file error - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pSkillConfigList[iSkillConfigListIndex]->m_sValue3 = atoi(token);
					cReadModeB = 7;
					break;

				case 7:
					// m_sValue4
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! SKILL configuration file error - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pSkillConfigList[iSkillConfigListIndex]->m_sValue4 = atoi(token);
					cReadModeB = 8;
					break;

				case 8:
					// m_sValue5
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! SKILL configuration file error - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pSkillConfigList[iSkillConfigListIndex]->m_sValue5 = atoi(token);
					cReadModeB = 9;
					break;

				case 9:
					// m_sValue6
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! SKILL configuration file error - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pSkillConfigList[iSkillConfigListIndex]->m_sValue6 = atoi(token);
					cReadModeA = 0;
					cReadModeB = 0;
					break;
				}
				break;

			default: 
				break;
			}
		}
		else {
			if (memcmp(token, "skill", 5) == 0) {
				cReadModeA = 1;
				cReadModeB = 1;
			}
			
		}
		token = pStrTok->pGet();
		//token = strtok(NULL, seps);
	}	

	delete pStrTok;
	delete pContents;

	if ((cReadModeA != 0) || (cReadModeB != 0)) {
		PutLogList("(!!!) CRITICAL ERROR! SKILL configuration file contents error!");
		return FALSE;
	}

	wsprintf(cTxt, "(!) SKILL (Total:%d) configuration - success!", iSkillConfigListIndex);
	PutLogList(cTxt);

	return TRUE;
}

void CGame::RequestStudyMagicHandler(int iClientH, char * pName, BOOL & bSucces, BOOL bIsPurchase)
{char  * cp, cMagicName[31], cData[100];
 DWORD * dwp, dwGoldCount = 0;
 WORD  * wp;
 int   * ip, iReqInt, iCost, iRet, iTempInt;
 BOOL bMagic = TRUE ;
	// SNOOPY, added this to prevent esrasing a manual if not enough int.
	bSucces = FALSE;
	iTempInt = m_pClientList[iClientH]->m_iInt;
	// SNOOPY: Angelic allow to buy Spell but not to read manual.

	if (m_pClientList[iClientH] == NULL) return;
	if (m_pClientList[iClientH]->m_bIsInitComplete == FALSE) return;
	ZeroMemory(cData, sizeof(cData));	
	ZeroMemory(cMagicName, sizeof(cMagicName));
	memcpy(cMagicName, pName, 30);	
	iRet = _iGetMagicNumber(cMagicName, &iReqInt, &iCost);
	if (iRet == -1) 
	{}else 
	{	if (bIsPurchase == TRUE) 
		{	if (m_pMagicConfigList[iRet]->m_iGoldCost < 0) bMagic = FALSE ; 
			dwGoldCount = dwGetItemCount(iClientH, "Gold");
			if ((DWORD)iCost > dwGoldCount)  bMagic = FALSE ; 	
			iTempInt += m_pClientList[iClientH]->m_iAngelicInt;
			// SNOOPY: Was Buggy couldn't leran a Spell Book outside Magic Tower !
			if (m_pClientList[iClientH]->m_bIsInsideWizardTower == FALSE) return;
		}		
		if (m_pClientList[iClientH]->m_cMagicMastery[iRet] != 0) return;

		if ((iReqInt <= iTempInt) && (bMagic == TRUE) ) 
		{	if (bIsPurchase == TRUE) SetItemCount(iClientH, "Gold", dwGoldCount - iCost);
			iCalcTotalWeight(iClientH);
			m_pClientList[iClientH]->m_cMagicMastery[iRet] = 1;
			// Snoopy: notify sender function off the succes.
			bSucces = TRUE;
			dwp  = (DWORD *)(cData + DEF_INDEX4_MSGID);
			*dwp = MSGID_NOTIFY;
			wp   = (WORD *)(cData + DEF_INDEX2_MSGTYPE);
			*wp  = DEF_NOTIFY_MAGICSTUDYSUCCESS;
			cp = (char *)(cData + DEF_INDEX2_MSGTYPE + 2);
			*cp = iRet;
			cp++;
			memcpy(cp, cMagicName, 30);
			cp += 30;
			iRet = m_pClientList[iClientH]->m_pXSock->iSendMsg(cData, 37);
			switch (iRet) {
			case DEF_XSOCKEVENT_QUENEFULL:
			case DEF_XSOCKEVENT_SOCKETERROR:
			case DEF_XSOCKEVENT_CRITICALERROR:
			case DEF_XSOCKEVENT_SOCKETCLOSED:
				DeleteClient(iClientH, TRUE, TRUE);
				return;
			}
		}else 
		{	dwp  = (DWORD *)(cData + DEF_INDEX4_MSGID);
			*dwp = MSGID_NOTIFY;
			wp   = (WORD *)(cData + DEF_INDEX2_MSGTYPE);
			*wp  = DEF_NOTIFY_MAGICSTUDYFAIL;
			cp = (char *)(cData + DEF_INDEX2_MSGTYPE + 2);
			*cp = 1;
			cp++;
			*cp = iRet;
			cp++;
			memcpy(cp, cMagicName, 30);
			cp += 30;
			ip = (int *)cp;
			*ip = iCost;
			cp += 4;
			ip = (int *)cp;
			*ip = iReqInt;
			cp += 4;
			iRet = m_pClientList[iClientH]->m_pXSock->iSendMsg(cData, 46);
			switch (iRet) {
			case DEF_XSOCKEVENT_QUENEFULL:
			case DEF_XSOCKEVENT_SOCKETERROR:
			case DEF_XSOCKEVENT_CRITICALERROR:
			case DEF_XSOCKEVENT_SOCKETCLOSED:
				DeleteClient(iClientH, TRUE, TRUE);
				return;
	}	}	}
}

int CGame::_iGetMagicNumber(char * pMagicName, int * pReqInt, int * pCost)
{
 register int i;
 char cTmpName[31];

	ZeroMemory(cTmpName, sizeof(cTmpName));
	strcpy(cTmpName, pMagicName);

	for (i = 0; i < DEF_MAXMAGICTYPE; i++) 
	if (m_pMagicConfigList[i] != NULL) {
		if (memcmp(cTmpName, m_pMagicConfigList[i]->m_cName, 30) == 0) {
			// Â°Â°Ã€Âº Ã€ÃŒÂ¸Â§Ã€Â» Â°Â¡ÃÃ¸ Â¸Â¶Â¹Ã½ Â¼Â³ÃÂ¤Ã€Â» ÃƒÂ£Â¾Ã’Â´Ã™. Â¸Â¶Â¹Ã½ Â¹Ã¸ÃˆÂ£Â¸Â¦ Â¹ÃÃˆÂ¯Ã‡Ã‘Â´Ã™.
			*pReqInt = (int)m_pMagicConfigList[i]->m_sIntLimit;
			*pCost   = (int)m_pMagicConfigList[i]->m_iGoldCost;
			
			return i;
		}
	}
	
	return -1;
}

void CGame::TrainSkillResponse(BOOL bSuccess, int iClientH, int iSkillNum, int iSkillLevel)
{	char  * cp, cData[100];
	DWORD * dwp;
	WORD  * wp;
	int   iRet;
	if (m_pClientList[iClientH] == NULL) return;
	if (m_pClientList[iClientH]->m_bIsInitComplete == FALSE) return;
	if ((iSkillNum < 0)	|| (iSkillNum > 100)) return;
	if ((iSkillLevel < 0) || (iSkillLevel > 100)) return;

	if (bSuccess == TRUE) // Upgrade skill to specified value
	{	if (m_pClientList[iClientH]->m_cSkillMastery[iSkillNum] != 0) return;		
		m_pClientList[iClientH]->m_cSkillMastery[iSkillNum] = iSkillLevel;
		// Not logged here, because this is called when using item to learn skill
		bCheckTotalSkillMasteryPoints(iClientH, iSkillNum);
		dwp  = (DWORD *)(cData + DEF_INDEX4_MSGID);
		*dwp = MSGID_NOTIFY;
		wp   = (WORD *)(cData + DEF_INDEX2_MSGTYPE);
		*wp  = DEF_NOTIFY_SKILLTRAINSUCCESS;		
		cp = (char *)(cData + DEF_INDEX2_MSGTYPE + 2);
		*cp = iSkillNum;
		cp++;
		*cp = iSkillLevel;
		cp++;
		if (m_pSkillConfigList[iSkillNum]->m_cName != NULL) 
			_bItemLog(DEF_ITEMLOG_SKILLLEARN,iClientH,m_pSkillConfigList[iSkillNum]->m_cName,NULL);
		iRet = m_pClientList[iClientH]->m_pXSock->iSendMsg(cData, 8);
		switch (iRet) {
		case DEF_XSOCKEVENT_QUENEFULL:
		case DEF_XSOCKEVENT_SOCKETERROR:
		case DEF_XSOCKEVENT_CRITICALERROR:
		case DEF_XSOCKEVENT_SOCKETCLOSED:
			DeleteClient(iClientH, TRUE, TRUE);
			return;
		}
	}else // Upgrade skill by X points
	{	if (m_pClientList[iClientH]->m_cSkillMastery[iSkillNum] == 0) return;		
		m_pClientList[iClientH]->m_cSkillMastery[iSkillNum] += iSkillLevel;
		if (m_pClientList[iClientH]->m_cSkillMastery[iSkillNum] >100)
			m_pClientList[iClientH]->m_cSkillMastery[iSkillNum] = 100;
		// Not logged here, because this is called when using item to learn skill
		bCheckTotalSkillMasteryPoints(iClientH, iSkillNum);

		dwp  = (DWORD *)(cData + DEF_INDEX4_MSGID);
		*dwp = MSGID_NOTIFY;
		wp   = (WORD *)(cData + DEF_INDEX2_MSGTYPE);
		*wp  = DEF_NOTIFY_SKILLTRAINSUCCESS;		
		cp = (char *)(cData + DEF_INDEX2_MSGTYPE + 2);
		*cp = iSkillNum;
		cp++;		
		*cp = iSkillLevel;
		cp++;
		if (m_pSkillConfigList[iSkillNum]->m_cName != NULL) 
			_bItemLog(DEF_ITEMLOG_SKILLLEARN,iClientH,m_pSkillConfigList[iSkillNum]->m_cName,NULL);
		iRet = m_pClientList[iClientH]->m_pXSock->iSendMsg(cData, 8);
		switch (iRet) {
		case DEF_XSOCKEVENT_QUENEFULL:
		case DEF_XSOCKEVENT_SOCKETERROR:
		case DEF_XSOCKEVENT_CRITICALERROR:
		case DEF_XSOCKEVENT_SOCKETCLOSED:
			DeleteClient(iClientH, TRUE, TRUE);
			return;	
		}
	}
}

int CGame::_iGetSkillNumber(char * pSkillName)
{
 register int i;
 char cTmpName[21];

	ZeroMemory(cTmpName, sizeof(cTmpName));
	strcpy(cTmpName, pSkillName);

	for (i = 1; i < DEF_MAXSKILLTYPE; i++) 
	if (m_pSkillConfigList[i] != NULL) {
		if (memcmp(cTmpName, m_pSkillConfigList[i]->m_cName, 20) == 0) {
			return i;
		}
	}
	
	return 0;
}
// SNOOPY: This function seems unused
BOOL CGame::bPlayerItemToBank(int iClientH, short sItemIndex)
{
 register int i, iIndex;

	if (m_pClientList[iClientH] == NULL) return FALSE;

	for (i = 0; i < DEF_MAXBANKITEMS; i++)
	if (m_pClientList[iClientH]->m_pItemInBankList[i] == NULL) {
		iIndex = i;
		goto NEXT_STEP_PLTB;
	}
	return FALSE;

NEXT_STEP_PLTB:;

	ReleaseItemHandler(iClientH, sItemIndex, TRUE);

	m_pClientList[iClientH]->m_pItemInBankList[iIndex] = m_pClientList[iClientH]->m_pItemList[sItemIndex];
	m_pClientList[iClientH]->m_pItemList[sItemIndex] = NULL;
	m_pClientList[iClientH]->m_bIsItemEquipped[sItemIndex] = FALSE;

	for (i = 1; i < DEF_MAXITEMS; i++)
	if ((m_pClientList[iClientH]->m_pItemList[i-1] == NULL) && (m_pClientList[iClientH]->m_pItemList[i] != NULL)) {
		m_pClientList[iClientH]->m_pItemList[i-1]       = m_pClientList[iClientH]->m_pItemList[i];	
		m_pClientList[iClientH]->m_bIsItemEquipped[i-1] = m_pClientList[iClientH]->m_bIsItemEquipped[i];	
		m_pClientList[iClientH]->m_pItemList[i]   = NULL;
		m_pClientList[iClientH]->m_bIsItemEquipped[i] = FALSE;
	}

	return TRUE;
}
// SNOOPY: This function seems unused
BOOL CGame::bBankItemToPlayer(int iClientH, short sItemIndex)
{
 register int i, iIndex;

	if (m_pClientList[iClientH] == NULL) return FALSE;
	
	if (m_pClientList[iClientH]->m_pItemInBankList[sItemIndex] == NULL) return FALSE;

	for (i = 0; i < DEF_MAXITEMS; i++)
	if (m_pClientList[iClientH]->m_pItemList[i] == NULL) {
		iIndex = i;
		goto NEXT_STEP_PLTB;
	}
	return FALSE;

NEXT_STEP_PLTB:;
	m_pClientList[iClientH]->m_pItemList[iIndex] = m_pClientList[iClientH]->m_pItemInBankList[sItemIndex]; 	
	m_pClientList[iClientH]->m_pItemInBankList[sItemIndex] = NULL;

	return TRUE;
}

////////////////////////////////////////////////////////////////////////////
//	Snoopy: __bReadMapCrusade Info is used to reload some settings for Crusade 
//                            if playing in EQUILIBRIUM map mode             
//                            BtField also changed for Heldenian
////////////////////////////////////////////////////////////////////////////
BOOL CGame::__bReadMapCrusadeInfo(int iMapIndex, BOOL bCrusadeBegin)
{	if (m_pMapList[iMapIndex] == NULL) return FALSE;
	int i, j, iNbeMobItemEvent, iAdjustMobNum;
 char * pContents, * token, cTxt[250], cFn[255]; 
 char seps[] = "= \t\n";
 char cReadModeA = 0;
 char cReadModeB = 0;
 int  iMGARCfgIndex = 0; // Npc avoid rect
 int  iSMGRCfgIndex = 0; // Spot Mog Generator
 int  iIndex = 0;
 class CStrTok * pStrTok;
 HANDLE hFile;
 DWORD  dwFileSize, dwReadSize;
 FILE * pFile;

	ZeroMemory(cFn, sizeof(cFn));
	if (bCrusadeBegin)
	{	strcat(cFn, "mapcrus\\");
	}else
	{	strcat(cFn, "mapdata\\");
	}
	strcat(cFn, m_pMapList[iMapIndex]->m_cName);
	strcat(cFn, ".txt");
	
	hFile = CreateFile(cFn, GENERIC_READ, NULL, NULL, OPEN_EXISTING, NULL, NULL);
	if (hFile == INVALID_HANDLE_VALUE) return FALSE;
	dwFileSize = GetFileSize(hFile, NULL);
	CloseHandle(hFile);
	pContents = new char[dwFileSize+1];
	ZeroMemory(pContents, dwFileSize+1);
	pFile = fopen(cFn, "rt");
	if (pFile == NULL) 
	{	wsprintf(cTxt, "(!) Cannot open Crusade Map info file : %s", cFn);
		PutLogList(cTxt);
		return FALSE;
	}else 
	{	wsprintf(cTxt, "(!) Reading Crusade Map info file : %s", cFn);
		PutLogList(cTxt);
		dwReadSize = fread(pContents, dwFileSize, 1, pFile);
		fclose(pFile);
	}

// Here, the Crusade map has been openned
// so, reset current data
	// Remove old pit's mobs...
	for (j = 0; j <DEF_MAXNPCS ; j++)  
	{	if (   (m_pNpcList[j] != NULL) 
			&& (m_pNpcList[j]->m_cMapIndex == iMapIndex)
			&& (m_pNpcList[j]->m_iSpotMobIndex != NULL))
		{	//m_pNpcList[j]->m_iSpotMobIndex = NULL;
			m_pNpcList[j]->m_bIsUnsummoned = TRUE; 	
			NpcKilledHandler(j, DEF_OWNERTYPE_NPC, j, 0);	
			DeleteNpc(j);
	}	}
	m_pMapList[iMapIndex]->m_cRandomMobGeneratorLevel = 0;	// 4 RandomMogGenerator
	m_pMapList[iMapIndex]->m_iRandomMobGeneratorSA	  = 0;	
	m_pMapList[iMapIndex]->m_iNoSMRGKilledMobs        = 0;
	m_pMapList[iMapIndex]->m_iMaximumObject = 100;			// 5 Maximum Object
	for (i = 0; i < DEF_MAXMGAR; i++) 						// 6 MobGen avoid rect
	{	m_pMapList[iMapIndex]->m_rcMobGenAvoidRect[i].top  = -1;
		m_pMapList[iMapIndex]->m_rcMobGenAvoidRect[i].left = -1;
	}
	for (i = 0; i < DEF_MAXSPOTMOBGENERATOR; i++) 			// 7 SpotMogGenerator
	{	m_pMapList[iMapIndex]->m_stSpotMobGenerator[i].bDefined = FALSE;
		m_pMapList[iMapIndex]->m_stSpotMobGenerator[i].iTotalActiveMob = 0;
		m_pMapList[iMapIndex]->m_stSpotMobGenerator[i].iCurMobs = 0;
		m_pMapList[iMapIndex]->m_stSpotMobGenerator[i].iMaxMobs = 0;
		m_pMapList[iMapIndex]->m_stSpotMobGenerator[i].cType = 0;		
		m_pMapList[iMapIndex]->m_stSpotMobGenerator[i].iMobType = -1;		
		m_pMapList[iMapIndex]->m_stSpotMobGenerator[i].iKilledMobs = 0;
	}
	m_pMapList[iMapIndex]->m_iTotalItemEvents = 0;			// 24 Item Events
	for (i = 0; i < DEF_MAXITEMEVENTS; i++) 	
	{	ZeroMemory(m_pMapList[iMapIndex]->m_stItemEventList[i].cItemName, sizeof(m_pMapList[iMapIndex]->m_stItemEventList[i].cItemName));
		m_pMapList[iMapIndex]->	m_stItemEventList[i].iAmount	= 0;
		m_pMapList[iMapIndex]->	m_stItemEventList[i].iTotalNum	= 0;
		m_pMapList[iMapIndex]->	m_stItemEventList[i].iDropped	= 0;
		m_pMapList[iMapIndex]->	m_stItemEventList[i].iMonth		= 0;
		m_pMapList[iMapIndex]->	m_stItemEventList[i].iDay		= 0;
		m_pMapList[iMapIndex]->	m_stItemEventList[i].iType		= 0;
		if (m_pMapList[iMapIndex]->m_stItemEventList[i].cMob[0] != NULL) delete m_pMapList[iMapIndex]->m_stItemEventList[i].cMob[0];
		if (m_pMapList[iMapIndex]->m_stItemEventList[i].cMob[1] != NULL) delete m_pMapList[iMapIndex]->m_stItemEventList[i].cMob[1];
		if (m_pMapList[iMapIndex]->m_stItemEventList[i].cMob[2] != NULL) delete m_pMapList[iMapIndex]->m_stItemEventList[i].cMob[2];
		if (m_pMapList[iMapIndex]->m_stItemEventList[i].cMob[3] != NULL) delete m_pMapList[iMapIndex]->m_stItemEventList[i].cMob[3];
		if (m_pMapList[iMapIndex]->m_stItemEventList[i].cMob[4] != NULL) delete m_pMapList[iMapIndex]->m_stItemEventList[i].cMob[4];
		m_pMapList[iMapIndex]->	m_stItemEventList[i].iNbeMob	= 0;
	}
	m_pMapList[iMapIndex]->sMobEventAmount = 15;			// 25 MobEvent amount
	m_pMapList[iMapIndex]->m_iPKmode = 0;					// 38 PKmode
	m_pMapList[iMapIndex]->m_nIsNotPermanentMap = FALSE;	// 39 IsNotParmanentMap;	
	m_pMapList[iMapIndex]->m_iXPRate = 100;					// 42 m_iXPRate = 100 (default)
	m_pMapList[iMapIndex]->m_iExtraDrop = 0;				// 43 m_iExtraDrop = 0 (default)
	m_pMapList[iMapIndex]->m_iBossAdjust = 100;				// 44 m_iBossAdjust = 100 (default)

 char cNpcName[21];
	pStrTok = new class CStrTok(pContents, seps);
	token = pStrTok->pGet();
	//token = strtok(pContents, seps);
	while( token != NULL ) {
		if (cReadModeA != 0) {
			switch (cReadModeA) {
			case 4:	// Random-Mob-Generator 	
				switch (cReadModeB) {
				case 1:				
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 12 - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					// Snoopy: Changed m_iRandomMobGeneratorSA to int
					m_pMapList[iMapIndex]->m_iRandomMobGeneratorSA = atoi(token);
					// 0 means no mobs (still used for zerking spot mobs)
					// Above 1 value will be used to remove npc every 5 minutes 
					// (5 minutes is Special event time)
					// Value beween 2% and 80% off all mobs
					// NB: Bigger than Ogre npc will not be removed
					if (m_pMapList[iMapIndex]->m_iRandomMobGeneratorSA < 0) m_pMapList[iMapIndex]->m_iRandomMobGeneratorSA = 0;
					if (m_pMapList[iMapIndex]->m_iRandomMobGeneratorSA >80) m_pMapList[iMapIndex]->m_iRandomMobGeneratorSA = 80;

					cReadModeB = 2;
					break;

				case 2:	// Mob- Level
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 13 - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pMapList[iMapIndex]->m_cRandomMobGeneratorLevel = atoi(token);
					m_pMapList[iMapIndex]->m_iMapLevel = 0;	
					switch (m_pMapList[iMapIndex]->m_cRandomMobGeneratorLevel) {
					case 1: // arefarm, elvfarm, aresden, elvine
						m_pMapList[iMapIndex]->m_iMapLevel = 0;		break;
					case 3:     // MiddleLand
						m_pMapList[iMapIndex]->m_iMapLevel = 3;		break;
					case 4: // Dungeon 1 
						m_pMapList[iMapIndex]->m_iMapLevel = 1;		break;
					case 5: // Dungeon 2 
						m_pMapList[iMapIndex]->m_iMapLevel = 2;		break;
					case 6: // huntzone3, huntzone4 (SW/DV) from HBChina351
						m_pMapList[iMapIndex]->m_iMapLevel = 4;		break;
					case 7: // areuni, elvuni
						m_pMapList[iMapIndex]->m_iMapLevel = 4;		break;
					case 8: // PL (HBChina351 uses RMG16)
						m_pMapList[iMapIndex]->m_iMapLevel = 1;		break;
					case 9: // D3 same HBChina351
						m_pMapList[iMapIndex]->m_iMapLevel = 6;		break;		// 30% zerk en pit
					case 10: // D4 Not same as China351 (Zombie replaced by Stone + Clops)
						m_pMapList[iMapIndex]->m_iMapLevel = 7;		break;		// 35% zerk en pit (DDs)
					case 11: // was tweaked for EF/RH on Revival/Equilibrium
						m_pMapList[iMapIndex]->m_iMapLevel = 2;		break;
					case 12: // Noob Dungeon from HBChina351
						m_pMapList[iMapIndex]->m_iMapLevel = 1;		break;
					case 13: // TOH1 from HBChina351
						m_pMapList[iMapIndex]->m_iMapLevel = 8;		break;		// 40% zerk en pit
					case 14: // TOH2: HBChina351 replaces DD by Ogres....
						m_pMapList[iMapIndex]->m_iMapLevel = 10;	break;		// 50% Zerk en pit
					case 15: //TOH3 from HBChina351
						m_pMapList[iMapIndex]->m_iMapLevel = 10;	break;		// 50% Zerk en pit
					case 16: // 2ndmiddle, huntzone1, huntzone2 from HBChina351 
						m_pMapList[iMapIndex]->m_iMapLevel = 1;		break;
					case 17: // SNOOPY: improved for Icebound 
						m_pMapList[iMapIndex]->m_iMapLevel = 5;		break;		// 25% Zerk en pit
					case 18: // druncncity Map from HBChina351
						m_pMapList[iMapIndex]->m_iMapLevel = 20;	break;		// 100% zerk en pit	
					case 19: // Maze Map from HBChina351
						m_pMapList[iMapIndex]->m_iMapLevel = 50;	break;		// All pit zerk, big chanbces for special spawn
					case 20: // Heldenian Map from HBChina351
						m_pMapList[iMapIndex]->m_iMapLevel = 30;	break;
					case 21: // ????????
						m_pMapList[iMapIndex]->m_iMapLevel = 4;		break;
					case 22: // SNOOPY: Catacombs
						m_pMapList[iMapIndex]->m_iMapLevel = 15;	break;		// 100% zerk en pit				
					case 23: // SNOOPY: Occupied cities
						m_pMapList[iMapIndex]->m_iMapLevel = 6; 	break;		// 30% zerk en pit				
					case 24: // Special design for QusMarch
						m_pMapList[iMapIndex]->m_iMapLevel = 8;		break;		// 40% zerk en pit
					}
					cReadModeA = 0;
					cReadModeB = 0;
					break;
				}
				break;

			case 5:	// Maximum object
				if (_bGetIsStringIsNumber(token) == FALSE) {
					PutLogList("(!!!) CRITICAL ERROR! Map Info file error 14 - Wrong Data format.");
					delete pContents;
					delete pStrTok;
					return FALSE;
				}
				m_pMapList[iMapIndex]->m_iMaximumObject = atoi(token);
				// Set a maximum to 980 to avoid objects over 999 (Crash risk?)
				if (m_pMapList[iMapIndex]->m_iMaximumObject >980) m_pMapList[iMapIndex]->m_iMaximumObject = 980;
				m_pMapList[iMapIndex]->m_iMaximumObjectDefault = m_pMapList[iMapIndex]->m_iMaximumObject;
				cReadModeA = 0;
				cReadModeB = 0;
				break;

			case 6: // npc-avoidrect
				switch (cReadModeB) {
				case 1:	// Rect 
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 15 - Wrong Data format(MGAR num).");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					iMGARCfgIndex = atoi(token);
					if (m_pMapList[iMapIndex]->m_rcMobGenAvoidRect[iMGARCfgIndex].left != -1) {
						//  Waypoint 
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 16 - Duplicated Mob Gen Rect Number!");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					cReadModeB = 2;
					break;

				case 2:	// left
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 17 - Wrong Data format(MGAR num).");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pMapList[iMapIndex]->m_rcMobGenAvoidRect[iMGARCfgIndex].left = atoi(token);
					cReadModeB = 3;
					break;

				case 3:	// top
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 18 - Wrong Data format(MGAR num).");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pMapList[iMapIndex]->m_rcMobGenAvoidRect[iMGARCfgIndex].top = atoi(token);
					cReadModeB = 4;
					break;

				case 4:	// right
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 19 - Wrong Data format(MGAR num).");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pMapList[iMapIndex]->m_rcMobGenAvoidRect[iMGARCfgIndex].right = atoi(token);
					cReadModeB = 5;
					break;

				case 5:	// bottom
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 20 - Wrong Data format(MGAR num).");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pMapList[iMapIndex]->m_rcMobGenAvoidRect[iMGARCfgIndex].bottom = atoi(token);
					cReadModeA = 0;
					cReadModeB = 0;
					break;
				}
				break;
			
			case 7:// SpotMobGenerator
				switch (cReadModeB) {
				case 1:	// Rect  m_stSpotMobGenerator[]
					if (_bGetIsStringIsNumber(token) == FALSE) 
					{	PutLogList("(!!!) CRITICAL ERROR! Map Info file error 21 - Wrong Data format(MGAR num).");
						delete pContents; delete pStrTok; return FALSE;
					}
					iSMGRCfgIndex = atoi(token);
					if (m_pMapList[iMapIndex]->m_stSpotMobGenerator[iSMGRCfgIndex].bDefined == TRUE) 
					{	PutLogList("(!!!) CRITICAL ERROR! Map Info file error - Duplicate SpotMobGenerator");
						delete pContents; delete pStrTok; return FALSE;
					}
					cReadModeB = 2;
					m_pMapList[iMapIndex]->m_stSpotMobGenerator[iSMGRCfgIndex].bDefined = TRUE;
					break;

				case 2: // SpotMobGen Type
					if (_bGetIsStringIsNumber(token) == FALSE) 
					{	PutLogList("(!!!) CRITICAL ERROR! Map Info file error 22 - Wrong Data format(SMGAR num).");
						delete pContents; delete pStrTok; return FALSE;
					}
					m_pMapList[iMapIndex]->m_stSpotMobGenerator[iSMGRCfgIndex].cType = atoi(token);	
					if (m_pMapList[iMapIndex]->m_stSpotMobGenerator[iSMGRCfgIndex].cType < 0) 
						m_pMapList[iMapIndex]->m_stSpotMobGenerator[iSMGRCfgIndex].cType = -1 * iDice(1,19);				
					if (   (m_pMapList[iMapIndex]->m_stSpotMobGenerator[iSMGRCfgIndex].cType >1 )
						&& (m_pMapList[iMapIndex]->m_stSpotMobGenerator[iSMGRCfgIndex].cType <4))
						cReadModeB = 9;  // Waypoint 
					else cReadModeB = 3;  // rect 
					break;

				case 3:	// left
					if (_bGetIsStringIsNumber(token) == FALSE) 
					{	PutLogList("(!!!) CRITICAL ERROR! Map Info file error 23 - Wrong Data format.");
						delete pContents; delete pStrTok; return FALSE;
					}
					m_pMapList[iMapIndex]->m_stSpotMobGenerator[iSMGRCfgIndex].rcRect.left = atoi(token);
					cReadModeB = 4;
					break;

				case 4:	// top
					if (_bGetIsStringIsNumber(token) == FALSE) 
					{	PutLogList("(!!!) CRITICAL ERROR! Map Info file error 24 - Wrong Data format.");
						delete pContents; delete pStrTok; return FALSE;
					}
					m_pMapList[iMapIndex]->m_stSpotMobGenerator[iSMGRCfgIndex].rcRect.top = atoi(token);
					cReadModeB = 5;
					break;

				case 5: // right
					if (_bGetIsStringIsNumber(token) == FALSE) 
					{	PutLogList("(!!!) CRITICAL ERROR! Map Info file error 25 - Wrong Data format.");
						delete pContents; delete pStrTok; return FALSE;
					}
					m_pMapList[iMapIndex]->m_stSpotMobGenerator[iSMGRCfgIndex].rcRect.right = atoi(token);
					cReadModeB = 6;
					break;

				case 6:	// bottom
					if (_bGetIsStringIsNumber(token) == FALSE) 
					{	PutLogList("(!!!) CRITICAL ERROR! Map Info file error 26 - Wrong Data format.");
						delete pContents; delete pStrTok; return FALSE;
					}
					m_pMapList[iMapIndex]->m_stSpotMobGenerator[iSMGRCfgIndex].rcRect.bottom = atoi(token);
					cReadModeB = 7;
					break;

				case 7:	// creature type
					if (_bGetIsStringIsNumber(token) == FALSE) 
					{	PutLogList("(!!!) CRITICAL ERROR! Map Info file error 27 - Wrong Data format.");
						delete pContents; delete pStrTok; return FALSE;
					}
					m_pMapList[iMapIndex]->m_stSpotMobGenerator[iSMGRCfgIndex].iMobType = atoi(token);
					iAdjustMobNum = 0;
					if (m_pMapList[iMapIndex]->m_stSpotMobGenerator[iSMGRCfgIndex].iMobType == -1)
					{	ZeroMemory(cNpcName, sizeof(cNpcName));
						switch (iDice(1,16)) {
						case 1: // 58MG 48SK 59Ettin 61Rudolf 80Tentocle 78Minaus
							switch (iDice(1,9)) {
							case 1: // Ettin
								m_pMapList[iMapIndex]->m_stSpotMobGenerator[iSMGRCfgIndex].iMobType = 59; 
								iAdjustMobNum = -2;  
								strcpy(cNpcName,"Ettin"); 
								break;
							case 2: // Tentocle
								m_pMapList[iMapIndex]->m_stSpotMobGenerator[iSMGRCfgIndex].iMobType = 80; 
								iAdjustMobNum = 3;   
								strcpy(cNpcName,"Tentocle"); 
								break;
							case 3: // Minaus
								m_pMapList[iMapIndex]->m_stSpotMobGenerator[iSMGRCfgIndex].iMobType = 78; 
								iAdjustMobNum = -3;   
								strcpy(cNpcName,"Minautor"); 
								break;
							case 4:
							case 5: // SK
								m_pMapList[iMapIndex]->m_stSpotMobGenerator[iSMGRCfgIndex].iMobType = 48;
								iAdjustMobNum = -1;  
								strcpy(cNpcName,"Stalker"); 
								break;
							default: // MG
								m_pMapList[iMapIndex]->m_stSpotMobGenerator[iSMGRCfgIndex].iMobType = 58; 
								iAdjustMobNum = 0; 
								strcpy(cNpcName,"MG"); 
								break;
							}
							break;
						case 2: 
						case 6:
						case 8: 
						case 9:
						case 12:
						case 13:  // Ogres 
							m_pMapList[iMapIndex]->m_stSpotMobGenerator[iSMGRCfgIndex].iMobType = 29;  
							iAdjustMobNum = 0;
								strcpy(cNpcName,"Ogre"); 
							break; 
						case 3:
						case 5:
						case 10: 
						case 11: 
						case 15: // Cyclops 
							m_pMapList[iMapIndex]->m_stSpotMobGenerator[iSMGRCfgIndex].iMobType = 13;  
							iAdjustMobNum = 2;
								strcpy(cNpcName,"Cyclop"); 
							break;
						case 4:  
						case 7: 
						case 14: 
						case 16: 
						default: // WW (11..14)
							m_pMapList[iMapIndex]->m_stSpotMobGenerator[iSMGRCfgIndex].iMobType = 33; 
							iAdjustMobNum = -1;
							strcpy(cNpcName,"WW"); 
							break;
						}	
						wsprintf(G_cTxt, "Random pit n°%d in %s (%d,%d). Type %d (%s)"
							, iSMGRCfgIndex
							, m_pMapList[iMapIndex]->m_cName
							, (m_pMapList[iMapIndex]->m_stSpotMobGenerator[iSMGRCfgIndex].rcRect.left + m_pMapList[iMapIndex]->m_stSpotMobGenerator[iSMGRCfgIndex].rcRect.right)/2
							, (m_pMapList[iMapIndex]->m_stSpotMobGenerator[iSMGRCfgIndex].rcRect.top + m_pMapList[iMapIndex]->m_stSpotMobGenerator[iSMGRCfgIndex].rcRect.bottom)/2
							, m_pMapList[iMapIndex]->m_stSpotMobGenerator[iSMGRCfgIndex].iMobType 
							, cNpcName);
						PutLogList(G_cTxt);	
						PutLogEventFileList(G_cTxt);
					}					
					cReadModeB = 8;
					break;

				case 8:	// Max Mobs
					if (_bGetIsStringIsNumber(token) == FALSE) 
					{	PutLogList("(!!!) CRITICAL ERROR! Map Info file error 28 - Wrong Data format.");
						delete pContents; delete pStrTok; return FALSE;
					}
					m_pMapList[iMapIndex]->m_stSpotMobGenerator[iSMGRCfgIndex].iMaxMobs = atoi(token);
					m_pMapList[iMapIndex]->m_stSpotMobGenerator[iSMGRCfgIndex].iCurMobs	= 0;
					if (m_pMapList[iMapIndex]->m_stSpotMobGenerator[iSMGRCfgIndex].cType < 0)
					{	m_pMapList[iMapIndex]->m_stSpotMobGenerator[iSMGRCfgIndex].iMaxMobs = 0;
					}
					if (m_pMapList[iMapIndex]->m_stSpotMobGenerator[iSMGRCfgIndex].iMaxMobs >=5)
						m_pMapList[iMapIndex]->m_stSpotMobGenerator[iSMGRCfgIndex].iMaxMobs	+= iAdjustMobNum;
					cReadModeA = 0;
					cReadModeB = 0;
					break;

				default:
					// WayPoint0~waypoint9
					if (_bGetIsStringIsNumber(token) == FALSE) 
					{	PutLogList("(!!!) CRITICAL ERROR! Map Info file error 29 - Wrong Data format.");
						delete pContents; delete pStrTok; return FALSE;
					}
					m_pMapList[iMapIndex]->m_stSpotMobGenerator[iSMGRCfgIndex].cWaypoint[cReadModeB - 9] = atoi(token);
					cReadModeB++;
			   		break;

				case 19:
					// Creature type
					if (_bGetIsStringIsNumber(token) == FALSE) 
					{	PutLogList("(!!!) CRITICAL ERROR! Map Info file error 30 - Wrong Data format.");
						delete pContents; delete pStrTok; return FALSE;
					}
					m_pMapList[iMapIndex]->m_stSpotMobGenerator[iSMGRCfgIndex].iMobType = atoi(token);
					cReadModeB = 20;
					break;

				case 20:
					if (_bGetIsStringIsNumber(token) == FALSE) 
					{	PutLogList("(!!!) CRITICAL ERROR! Map Info file error 31 - Wrong Data format.");
						delete pContents; delete pStrTok; return FALSE;
					}
					m_pMapList[iMapIndex]->m_stSpotMobGenerator[iSMGRCfgIndex].iMaxMobs = atoi(token);
					m_pMapList[iMapIndex]->m_stSpotMobGenerator[iSMGRCfgIndex].iCurMobs	= 0;
					cReadModeA = 0;
					cReadModeB = 0;
					break;
			  	}
				break;	
			case 24:// Item-Event, reintroduced and tweaked by Snoopy
				switch (cReadModeB) {
				case 1: //  index
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 78 - Wrong Data format.");
						delete pContents; delete pStrTok; return FALSE;
					}
					iIndex = atoi(token);					
					if (strlen(m_pMapList[iMapIndex]->m_stItemEventList[iIndex].cItemName) != NULL) {
						wsprintf(G_cTxt, "(!!!) CRITICAL ERROR! Map Info file error 79 - Duplicate Item-Event number(%d:%s)", iIndex, m_pMapList[iMapIndex]->m_stItemEventList[iIndex].cItemName);
						PutLogList(G_cTxt);
						delete pContents; delete pStrTok; return FALSE;
					}					
					m_pMapList[iMapIndex]->m_iTotalItemEvents++;
					cReadModeB = 2;
					break;				
				case 2: // item_name
					strcpy(m_pMapList[iMapIndex]->m_stItemEventList[iIndex].cItemName, token);
					cReadModeB = 3;
					break;
				case 3: // amount
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 81 - Wrong Data format.");
						delete pContents; delete pStrTok; return FALSE;
					}
					m_pMapList[iMapIndex]->m_stItemEventList[iIndex].iAmount = atoi(token);
					cReadModeB = 4;
					break;
				case 4: // total number (max number that can drop)
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 82 - Wrong Data format.");
						delete pContents; delete pStrTok; return FALSE;
					}
					m_pMapList[iMapIndex]->m_stItemEventList[iIndex].iTotalNum = atoi(token);					
					cReadModeB = 5;
					break;
				case 5: // Mounth
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 83 - Wrong Data format.");
						delete pContents; delete pStrTok; return FALSE;
					}
					m_pMapList[iMapIndex]->m_stItemEventList[iIndex].iMonth = atoi(token);					
					cReadModeB = 6;
					break;
				case 6: // Day
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 83 - Wrong Data format.");
						delete pContents; delete pStrTok; return FALSE;
					}
					m_pMapList[iMapIndex]->m_stItemEventList[iIndex].iDay = atoi(token);
					cReadModeB = 7;
					break;
				case 7: // type (always 0, unused)
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 83 - Wrong Data format.");
						delete pContents; delete pStrTok; return FALSE;
					}
					m_pMapList[iMapIndex]->m_stItemEventList[iIndex].iType = atoi(token);
					m_pMapList[iMapIndex]->m_stItemEventList[iIndex].iDropped = 0;
					cReadModeB = 8;
					break;
				case 8: // monster list
					if( strcmp(token, "EOL") == 0 ) 
					{	cReadModeA = 0;
						cReadModeB = 0;
					}else 
					{	iNbeMobItemEvent = m_pMapList[iMapIndex]->m_stItemEventList[iIndex].iNbeMob;						
						if( iNbeMobItemEvent >= 5 ) 
						{	cReadModeA = 0;
							cReadModeB = 0;
							PutLogList("(!!!) ERROR! Map Info file error 83 - ItemEvent EOL missing.");
							break;
						}
						m_pMapList[iMapIndex]->m_stItemEventList[iIndex].cMob[iNbeMobItemEvent] = new char[21];
						ZeroMemory(m_pMapList[iMapIndex]->m_stItemEventList[iIndex].cMob[iNbeMobItemEvent],
							sizeof(m_pMapList[iMapIndex]->m_stItemEventList[iIndex].cMob[iNbeMobItemEvent]) );
						strcpy(m_pMapList[iMapIndex]->m_stItemEventList[iIndex].cMob[iNbeMobItemEvent], token);
						m_pMapList[iMapIndex]->m_stItemEventList[iIndex].iNbeMob ++;
						cReadModeB = 8;
					}
					break;
				}
				break;
			case 25: // mobevent-amount
				switch (cReadModeB) {
				case 1:
					if (_bGetIsStringIsNumber(token) == FALSE) 
					{	PutLogList("(!!!) CRITICAL ERROR! Map Info file error 78 - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pMapList[iMapIndex]->sMobEventAmount = atoi(token);
					if (m_pMapList[iMapIndex]->sMobEventAmount > 25) m_pMapList[iMapIndex]->sMobEventAmount = 25;
					if (m_pMapList[iMapIndex]->sMobEventAmount < 1 ) m_pMapList[iMapIndex]->sMobEventAmount = 15;
					cReadModeA = 0;
					cReadModeB = 0;
					break;
				}
				break;
			case 38: // PKmode
				// SNOOPY: initialising PKmode
				// 0: All PK allowed
				// 1: no PK. EK allowed (safe from same city)
				// 2: Safe between Ares and Elvines; but "Evil" side can EK, be EKilled
				// 3: No EK/PK allowed at all
				// 4: Evil side can be victim but not attack
				// 5: no EK, but PK possible..(special events)
				// -1: no PK. EK allowed (safe from same city), crims treated as normal citizens
				// -2: Safe between Ares and Elvines; but "Evil" side can EK, be EKilled, crims treated as normal citizens
				// -3: No EK/PK allowed at all, crims treated as normal citizens
				// -4: Evil side can be victim but not attack, crims treated as normal citizens
				// -5: no EK, but PK possible..(special events), crims treated as normal citizens
				if (_bGetIsStringIsNumber(token) == FALSE) 
				{	PutLogList("(!!!) CRITICAL ERROR! Map Info file error pk-mode - Wrong Data format.");
					delete pContents;
					delete pStrTok;
					return FALSE;
				}
				m_pMapList[iMapIndex]->m_iPKmode = atoi(token);
				if (m_pMapList[iMapIndex]->m_iPKmode < -5) m_pMapList[iMapIndex]->m_iPKmode = 0;
				if (m_pMapList[iMapIndex]->m_iPKmode > 5)  m_pMapList[iMapIndex]->m_iPKmode = 0;
				cReadModeA = 0;
				cReadModeB = 0;
				break;

			case 39: // XP rate
				if (_bGetIsStringIsNumber(token) == FALSE) 
				{	PutLogList("(!!!) CRITICAL ERROR! Map Info file error XPRate - Wrong Data format.");
					delete pContents;
					delete pStrTok;
					return FALSE;
				}
				m_pMapList[iMapIndex]->m_iXPRate = atoi(token);
				if (m_pMapList[iMapIndex]->m_iXPRate < 1) m_pMapList[iMapIndex]->m_iXPRate = 100;
				if (m_pMapList[iMapIndex]->m_iXPRate > 1000)  m_pMapList[iMapIndex]->m_iXPRate = 100;
				if (m_pMapList[iMapIndex]->m_iXPRate != 100)
				{	m_iHourllyXP250 = 250*10*m_pMapList[iMapIndex]->m_iXPRate;
					m_iHourllyXP300 = 300*10*m_pMapList[iMapIndex]->m_iXPRate;
					m_iHourllyXP400 = 400*10*m_pMapList[iMapIndex]->m_iXPRate;
					if (m_iHourllyXP250 < 50000) m_iHourllyXP250 = 50000;
					if (m_iHourllyXP300 < 60000) m_iHourllyXP300 = 60000;
					if (m_iHourllyXP400 < 80000) m_iHourllyXP400 = 80000;
				}
				cReadModeA = 0;
				cReadModeB = 0;
				break;

			case 43: // extra-drop
				if (_bGetIsStringIsNumber(token) == FALSE) 
				{	PutLogList("(!!!) CRITICAL ERROR! Map Info file error ExtraDrop - Wrong Data format.");
					delete pContents; delete pStrTok; return FALSE;
				}
				m_pMapList[iMapIndex]->m_iExtraDrop = atoi(token);
				if (m_pMapList[iMapIndex]->m_iExtraDrop < 0) m_pMapList[iMapIndex]->m_iExtraDrop = 0;
				if (m_pMapList[iMapIndex]->m_iExtraDrop > 10000)  m_pMapList[iMapIndex]->m_iExtraDrop = 10000;
				cReadModeA = 0;
				cReadModeB = 0;
				break;	

			case 44: // boss-rate
				if (_bGetIsStringIsNumber(token) == FALSE) 
				{	PutLogList("(!!!) CRITICAL ERROR! Map Info file error boss-rate - Wrong Data format.");
					delete pContents; delete pStrTok; return FALSE;
				}
				m_pMapList[iMapIndex]->m_iBossAdjust = atoi(token);
				if (m_pMapList[iMapIndex]->m_iBossAdjust < 0) m_pMapList[iMapIndex]->m_iBossAdjust = 100;
				if (m_pMapList[iMapIndex]->m_iBossAdjust > 1000)  m_pMapList[iMapIndex]->m_iBossAdjust = 100;
				cReadModeA = 0;
				cReadModeB = 0;
				break;	

			default: 
				break;
			}
		}else 
		{	if (memcmp(token, "random-mob-generator", 20) == 0) 
			{	cReadModeA = 4;
				cReadModeB = 1;
			}			
			if (memcmp(token, "maximum-object", 14) == 0) 
			{	cReadModeA = 5;
			}			
			if (memcmp(token, "npc-avoidrect", 13) == 0) 
			{	cReadModeA = 6;
				cReadModeB = 1;
			}
			if (memcmp(token, "spot-mob-generator", 18) == 0) 
			{	cReadModeA = 7;
				cReadModeB = 1;
			}						
			if (memcmp(token, "item-event", 10) == 0) 
			{	cReadModeA = 24;
				cReadModeB = 1;
			}
			if (memcmp(token, "mobevent-amount", 15) == 0) 
			{	cReadModeA = 25;
				cReadModeB = 1;
			}
			// SNOOPY: Added pk-mode
			if (memcmp(token, "pk-mode", 7) == 0) 
			{	cReadModeA = 38;
				cReadModeB = 1;
			}
			// SNOOPY: Added xp-rate
			if (memcmp(token, "xp-rate", 7) == 0) 
			{	cReadModeA = 42;
				cReadModeB = 1;
			}
			// SNOOPY: Added extra-drop
			if (memcmp(token, "extra-drop", 10) == 0) 
			{	cReadModeA = 43;
				cReadModeB = 1;
			}
			// SNOOPY: Added boss-rate
			if (memcmp(token, "boss-rate", 9) == 0) 
			{	cReadModeA = 44;
				cReadModeB = 1;
			}
			if (memcmp(token, "[END-MAP-INFO]", 14) == 0) 
			{	cReadModeA = 0;
				cReadModeB = 0;
				goto RMI_SKIPDECODING;
			}
		}
		token = pStrTok->pGet();
	}	
RMI_SKIPDECODING:;

	delete pStrTok;
	delete pContents;
	if ((cReadModeA != 0) || (cReadModeB != 0)) {
		PutLogList("(!!!) CRITICAL ERROR! crusade map info file contents error!");
		return FALSE;
	}
	wsprintf(cTxt, "(!) Crusade Map info file decoding(%s) - success! MXO(%d) RMG(%d / %d)"
		, cFn
		, m_pMapList[iMapIndex]->m_iMaximumObject
		, m_pMapList[iMapIndex]->m_iRandomMobGeneratorSA
		, m_pMapList[iMapIndex]->m_cRandomMobGeneratorLevel);
	PutLogList(cTxt);
	m_pMapList[iMapIndex]->_SetupNoAttackArea();
	m_pMapList[iMapIndex]->m_bHpMpSpPopoEnabled = TRUE; 

	for (i = 0; i < DEF_MAXSPOTMOBGENERATOR; i++) 			// 7 SpotMogGenerator
	{	if (m_pMapList[iMapIndex]->m_stSpotMobGenerator[i].bDefined == TRUE)
		{	wsprintf(G_cTxt, "Random pit n°%d in %s (%d,%d). Type %d, MaxMobs(%d)"
				, i
				, m_pMapList[iMapIndex]->m_cName
				, (m_pMapList[iMapIndex]->m_stSpotMobGenerator[i].rcRect.left + m_pMapList[iMapIndex]->m_stSpotMobGenerator[i].rcRect.right)/2
				, (m_pMapList[iMapIndex]->m_stSpotMobGenerator[i].rcRect.top + m_pMapList[iMapIndex]->m_stSpotMobGenerator[i].rcRect.bottom)/2
				, m_pMapList[iMapIndex]->m_stSpotMobGenerator[i].iMobType 
				, m_pMapList[iMapIndex]->m_stSpotMobGenerator[i].iMaxMobs);
				PutLogList(G_cTxt);	
	}	}
	return TRUE;
}

BOOL CGame::__bReadMapInfo(int iMapIndex)
{char * pContents, * token,  cTxt[250], cFn[255];	 
 char seps[] = "= \t\n";	
 int i, iNbeMobItemEvent, iAdjustMobNum = 0;
 char cReadModeA = 0;
 char cReadModeB = 0;

	int  iTeleportLocIndex  = 0;							// 1
	for (i = 0; i < DEF_MAXTELEPORTLOC; i++)
		m_pMapList[iMapIndex]->m_pTeleportLoc[i] = NULL;
	int  iWayPointCfgIndex  = 0;							// 2
	for (i = 0; i < DEF_MAXWAYPOINTCFG; i++) 
	{	m_pMapList[iMapIndex]->m_WaypointList[i].x = -1;
		m_pMapList[iMapIndex]->m_WaypointList[i].y = -1;
	}
	int  iTotalNpcSetting   = 0;							// 3 Npc, will not remove existing npcs
	
	m_pMapList[iMapIndex]->m_cRandomMobGeneratorLevel = 0;	// 4 RandomMogGenerator
	m_pMapList[iMapIndex]->m_iRandomMobGeneratorSA    = 0;	
	m_pMapList[iMapIndex]->m_iNoSMRGKilledMobs = 0;
	m_pMapList[iMapIndex]->m_iMaximumObject = 100;			// 5 Maximum Object
	int  iMGARCfgIndex      = 0;							// 6 MobGen avoid rect
	for (i = 0; i < DEF_MAXMGAR; i++) 
	{	m_pMapList[iMapIndex]->m_rcMobGenAvoidRect[i].top  = -1;
		m_pMapList[iMapIndex]->m_rcMobGenAvoidRect[i].left = -1;
	}
	int  iSMGRCfgIndex      = 0;							// 7 SpotMogGenerator
	for (i = 0; i < DEF_MAXSPOTMOBGENERATOR; i++) 
	{	m_pMapList[iMapIndex]->m_stSpotMobGenerator[i].bDefined = FALSE;
		m_pMapList[iMapIndex]->m_stSpotMobGenerator[i].iTotalActiveMob = 0;
		m_pMapList[iMapIndex]->m_stSpotMobGenerator[i].cType = 0;		
		m_pMapList[iMapIndex]->m_stSpotMobGenerator[i].iKilledMobs = 0;
	}
															// 8 Location Name
	ZeroMemory(m_pMapList[iMapIndex]->m_cLocationName, sizeof(m_pMapList[iMapIndex]->m_cLocationName));
	for (i = 0; i < DEF_MAXINITIALPOINT; i++)				// 9 Initial points
	{	m_pMapList[iMapIndex]->m_pInitialPoint[i].x = -1;
		m_pMapList[iMapIndex]->m_pInitialPoint[i].y = -1;
	}
	int  iNMRCfgIndex       = 0;							// 10 NoAttackRect
	for (i = 0; i < DEF_MAXNMR; i++) {
		m_pMapList[iMapIndex]->m_rcNoAttackRect[i].top  = -1;
		m_pMapList[iMapIndex]->m_rcNoAttackRect[i].left = -1;
	}
	m_pMapList[iMapIndex]->m_bIsFixedDayMode = FALSE;		// 11 fixed dayNight
	int  iFishPointIndex 	 = 0;							// 12 Fish point list
	m_pMapList[iMapIndex]->m_iTotalFishPoint = 0;
	for (i = 0; i < DEF_MAXFISHPOINT; i++) 
	{	m_pMapList[iMapIndex]->m_FishPointList[i].x = -1;
		m_pMapList[iMapIndex]->m_FishPointList[i].y = -1;
	}
	m_pMapList[iMapIndex]->m_iMaxFish = 0;					// 13 Max fish
	m_pMapList[iMapIndex]->m_cType = 0;						// 14 Type (for BI)
	m_pMapList[iMapIndex]->m_iLevelLimit = 0;				// 15 Level Limite
	int  iMineralPointIndex = 0;							// 16 Mineral generator
	m_pMapList[iMapIndex]->m_bMineralGenerator = 0;	
	m_pMapList[iMapIndex]->m_cMineralGeneratorLevel = 0;
	for (i = 0; i < DEF_MAXMINERALPOINT; i++)				// 17 Mineral points
	{	m_pMapList[iMapIndex]->m_MineralPointList[i].x = -1;
		m_pMapList[iMapIndex]->m_MineralPointList[i].y = -1;
	}
	m_pMapList[iMapIndex]->m_iMaxMineral = 0;				// 18 Max minerals
	m_pMapList[iMapIndex]->m_iUpperLevelLimit = 0;			// 19 Upper level limit
	int  iStrategicPointIndex = 0;							// 20 Strategic Point 
	for (i = 0; i < DEF_MAXSTRATEGICPOINTS; i++)
		m_pMapList[iMapIndex]->m_pStrategicPointList[i] = NULL;
	m_pMapList[iMapIndex]->m_iTotalEnergySphereCreationPoint = 0;
	for (i = 0; i < DEF_MAXENERGYSPHERES; i++)				// 21 Energy-Sphere-Creation Point
	{	m_pMapList[iMapIndex]->m_stEnergySphereCreationList[i].cType = NULL;
		m_pMapList[iMapIndex]->m_stEnergySphereGoalList[i].cResult   = NULL;
	}
	m_pMapList[iMapIndex]->m_iTotalEnergySphereGoalPoint = 0; // 22 Energy-Sphere-Goal Point 
	for (i = 0; i < DEF_MAXSTRIKEPOINTS; i++) 				// 23 Strike point
	{	m_pMapList[iMapIndex]->m_stStrikePoint[i].dX  = 0;
		m_pMapList[iMapIndex]->m_stStrikePoint[i].dY  = 0;
		m_pMapList[iMapIndex]->m_stStrikePoint[i].iHP = 0;
		m_pMapList[iMapIndex]->m_stStrikePoint[i].iMapIndex = -1;
		ZeroMemory(m_pMapList[iMapIndex]->m_stStrikePoint[i].cRelatedMapName, sizeof(m_pMapList[iMapIndex]->m_stStrikePoint[i].cRelatedMapName));
	}
	m_pMapList[iMapIndex]->m_iTotalStrikePoints = 0;	
	m_pMapList[iMapIndex]->m_iTotalItemEvents = 0;			// 24 Item Events
	for (i = 0; i < DEF_MAXITEMEVENTS; i++) 	
	{	ZeroMemory(m_pMapList[iMapIndex]->m_stItemEventList[i].cItemName, sizeof(m_pMapList[iMapIndex]->m_stItemEventList[i].cItemName));
		m_pMapList[iMapIndex]->	m_stItemEventList[i].iAmount	= 0;
		m_pMapList[iMapIndex]->	m_stItemEventList[i].iTotalNum	= 0;
		m_pMapList[iMapIndex]->	m_stItemEventList[i].iDropped	= 0;
		m_pMapList[iMapIndex]->	m_stItemEventList[i].iMonth		= 0;
		m_pMapList[iMapIndex]->	m_stItemEventList[i].iDay		= 0;
		m_pMapList[iMapIndex]->	m_stItemEventList[i].iType		= 0;
		if (m_pMapList[iMapIndex]->m_stItemEventList[i].cMob[0] != NULL) delete m_pMapList[iMapIndex]->m_stItemEventList[i].cMob[0];
		if (m_pMapList[iMapIndex]->m_stItemEventList[i].cMob[1] != NULL) delete m_pMapList[iMapIndex]->m_stItemEventList[i].cMob[1];
		if (m_pMapList[iMapIndex]->m_stItemEventList[i].cMob[2] != NULL) delete m_pMapList[iMapIndex]->m_stItemEventList[i].cMob[2];
		if (m_pMapList[iMapIndex]->m_stItemEventList[i].cMob[3] != NULL) delete m_pMapList[iMapIndex]->m_stItemEventList[i].cMob[3];
		if (m_pMapList[iMapIndex]->m_stItemEventList[i].cMob[4] != NULL) delete m_pMapList[iMapIndex]->m_stItemEventList[i].cMob[4];
		m_pMapList[iMapIndex]->	m_stItemEventList[i].iNbeMob	= 0;
	}
	m_pMapList[iMapIndex]->sMobEventAmount = 15;			// 25 MobEvent amount
	m_pMapList[iMapIndex]->m_iApocalypseMobGenType = 0;		// 26 ApocalypseMobGenType
	m_pMapList[iMapIndex]->m_iApocalypseBossMobNpcID = 0;	// 27 ApocalypseBossMob
	m_pMapList[iMapIndex]->m_sApocalypseBossMobRect.left   =  0;
	m_pMapList[iMapIndex]->m_sApocalypseBossMobRect.top    =  0;
	m_pMapList[iMapIndex]->m_sApocalypseBossMobRect.right  =  0;
	m_pMapList[iMapIndex]->m_sApocalypseBossMobRect.bottom =  0;
	m_pMapList[iMapIndex]->m_cDynamicGateType = 0;			// 28 DynamicGateType
	m_pMapList[iMapIndex]->m_sDynamicGateCoordRectX1 = 	0;	// 29 DynamicGateCoord 
	m_pMapList[iMapIndex]->m_sDynamicGateCoordRectX2 = 	0;	 
	m_pMapList[iMapIndex]->m_sDynamicGateCoordRectY1 = 	0;	 
	m_pMapList[iMapIndex]->m_sDynamicGateCoordRectY2 = 	0;	 
	ZeroMemory(m_pMapList[iMapIndex]->m_cDynamicGateCoordDestMap, sizeof(m_pMapList[iMapIndex]->m_cDynamicGateCoordDestMap));
	m_pMapList[iMapIndex]->m_sDynamicGateCoordTgtX = 0;
	m_pMapList[iMapIndex]->m_sDynamicGateCoordTgtY = 0;
	m_pMapList[iMapIndex]->m_bIsRecallImpossible = FALSE;	// 30 Recal impossible
	m_pMapList[iMapIndex]->m_bIsApocalypseMap = FALSE;		// 31 ApocalypseMap 
	m_pMapList[iMapIndex]->m_bIsCitizenLimit = FALSE;		// 32 CitizenLimit
	m_pMapList[iMapIndex]->m_bIsHeldenianMap = FALSE;		// 33 HeldenianMap	
	for (i = 0; i < DEF_MAXHELDENIANTOWER; i++)				// 34 HeldenianTower
	{	m_pMapList[iMapIndex]->m_stHeldenianTower[i].sTypeID = 0;
		m_pMapList[iMapIndex]->m_stHeldenianTower[i].dX = 0;
		m_pMapList[iMapIndex]->m_stHeldenianTower[i].dY = 0;
		m_pMapList[iMapIndex]->m_stHeldenianTower[i].cSide = 0;
	}
	m_pMapList[iMapIndex]->m_cHeldenianModeMap = 0;			// 35 HeldenianModeMap
	m_pMapList[iMapIndex]->m_sHeldenianWinningZoneX = -1;	// 36 HeldenianWinningZone
	m_pMapList[iMapIndex]->m_sHeldenianWinningZoneY = -1;	// 36 HeldenianWinningZone
	for (i = 0; i < DEF_MAXHELDENIANDOOR; i++) 				// 37 HeldenianGateDoor  
	{	m_pMapList[iMapIndex]->m_stHeldenianGateDoor[i].cDir = 0;
		m_pMapList[iMapIndex]->m_stHeldenianGateDoor[i].dX = 0;
		m_pMapList[iMapIndex]->m_stHeldenianGateDoor[i].dY = 0;
	}
	m_pMapList[iMapIndex]->m_iPKmode = 0;					// 38 PKmode
	m_pMapList[iMapIndex]->m_nIsNotPermanentMap = FALSE;	// 39 IsNotParmanentMap;	
	m_pMapList[iMapIndex]->m_iDropType = 1;					// 40 DropType
	m_pMapList[iMapIndex]->m_bInsideBuildingLimitedCast = FALSE; // 41 m_bInsideBuildingLimitedCast
	m_pMapList[iMapIndex]->m_iXPRate = 100;					// 42 m_iXPRate = 100 (default)
	m_pMapList[iMapIndex]->m_iExtraDrop = 0;				// 43 m_iExtraDrop = 0 (default)
	m_pMapList[iMapIndex]->m_iBossAdjust = 100;				// 44 m_iBossAdjust = 100 (default)

 int  iIndex = 0, iIndexGD= 0, iIndexHT = 0;
 int  iNamingValue;
 class CStrTok * pStrTok;
 HANDLE hFile;
 DWORD  dwFileSize, dwReadSize;
 FILE * pFile;

 char cName[6], cNpcName[21], cNpcMoveType, cNpcWaypointIndex[10], cNamePrefix;
// SNOOPY: Strange warning here for a strange variable use. right variable should be iMapIndex. Corrected to iMapIndex...
 //char  cMapIndex;
 short sIPindex;
 int i5;
	if (memcmp(m_pMapList[iMapIndex]->m_cName, "fightzone", 9) == 0) 
		m_pMapList[iMapIndex]->m_bIsFightZone = TRUE;
	if (memcmp(m_pMapList[iMapIndex]->m_cName, "icebound", 8) == 0) 
		m_pMapList[iMapIndex]->m_bIsSnowEnabled = TRUE;
	ZeroMemory(cFn, sizeof(cFn));
	strcat(cFn, "mapdata\\");
	strcat(cFn, m_pMapList[iMapIndex]->m_cName);
	strcat(cFn, ".txt");
	
	hFile = CreateFile(cFn, GENERIC_READ, NULL, NULL, OPEN_EXISTING, NULL, NULL);
	if (hFile == INVALID_HANDLE_VALUE) return FALSE;
	dwFileSize = GetFileSize(hFile, NULL);
	CloseHandle(hFile);
	pContents = new char[dwFileSize+1];
	ZeroMemory(pContents, dwFileSize+1);
	pFile = fopen(cFn, "rt");
	if (pFile == NULL) 
	{	wsprintf(cTxt, "(!) Cannot open file : %s", cFn);
		PutLogList(cTxt);
		return FALSE;
	}else 
	{	wsprintf(cTxt, "(!) Reading Map info file : %s", cFn);
		PutLogList(cTxt);
		dwReadSize = fread(pContents, dwFileSize, 1, pFile);
		fclose(pFile);
	}
	pStrTok = new class CStrTok(pContents, seps);
	token = pStrTok->pGet();
	//token = strtok(pContents, seps);
	while( token != NULL ) {
		if (cReadModeA != 0) {
			switch (cReadModeA) {
			case 1:
				switch (cReadModeB) {
				case 1:	// Teleport loc
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 1 - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}					
					m_pMapList[iMapIndex]->m_pTeleportLoc[iTeleportLocIndex]->m_sSrcX = atoi(token);
					cReadModeB = 2;
					break;

				case 2:	// Teleport loc
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 2 - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					
					m_pMapList[iMapIndex]->m_pTeleportLoc[iTeleportLocIndex]->m_sSrcY = atoi(token);
					cReadModeB = 3;
					break;

				case 3:	// Teleport loc
					ZeroMemory(m_pMapList[iMapIndex]->m_pTeleportLoc[iTeleportLocIndex]->m_cDestMapName, 
						       sizeof(m_pMapList[iMapIndex]->m_pTeleportLoc[iTeleportLocIndex]->m_cDestMapName));
					strcpy(m_pMapList[iMapIndex]->m_pTeleportLoc[iTeleportLocIndex]->m_cDestMapName, token);
					cReadModeB = 4;
					break;

				case 4:	// Teleport loc
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 3 - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					
					m_pMapList[iMapIndex]->m_pTeleportLoc[iTeleportLocIndex]->m_sDestX = atoi(token);
					cReadModeB = 5;
					break;
				
				case 5: //  Teleport loc
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 4 - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					
					m_pMapList[iMapIndex]->m_pTeleportLoc[iTeleportLocIndex]->m_sDestY = atoi(token);
					cReadModeB = 6;
					break;
				
				case 6:	//  Teleport loc
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 5 - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					
					m_pMapList[iMapIndex]->m_pTeleportLoc[iTeleportLocIndex]->m_cDir = atoi(token);
					iTeleportLocIndex++;
					cReadModeA = 0;
					cReadModeB = 0;
					break;
				}
				break;

			case 2:// waypoints 
				switch (cReadModeB) {
				case 1:	// waypoints  
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 6 - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					iWayPointCfgIndex = atoi(token);

					if (m_pMapList[iMapIndex]->m_WaypointList[iWayPointCfgIndex].x != -1) 
					{	PutLogList("(!!!) CRITICAL ERROR! Map Info file error 7 - Duplicated waypoint");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					cReadModeB = 2;
					break;
				
				case 2:		// waypoint X  
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 8 - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pMapList[iMapIndex]->m_WaypointList[iWayPointCfgIndex].x = atoi(token);
					cReadModeB = 3;
					break;

				case 3:	// waypoint  Y  
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 9 - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pMapList[iMapIndex]->m_WaypointList[iWayPointCfgIndex].y = atoi(token);
					cReadModeA = 0;
					cReadModeB = 0;
					break;
				}
				break;

			case 3:	// Npc
				switch (cReadModeB) {
				case 1:			// NPC§. 
					ZeroMemory(cNpcName, sizeof(cNpcName));
					strcpy(cNpcName, token);
					cReadModeB = 2;
					break;
				case 2:			// NpcMoveType
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 10 - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					cNpcMoveType = atoi(token);
					cReadModeB = 3;
					break;
				default:	// WayPoint0~waypoint9
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 11 - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					cNpcWaypointIndex[cReadModeB-3] = atoi(token);
					cReadModeB++;
					break;
				case 13:	// cNamePrefix
					cNamePrefix = token[0];
					iNamingValue = m_pMapList[iMapIndex]->iGetEmptyNamingValue();
					if (iNamingValue == -1) 	//  NPC
					{}else	// NPC					
					 {	ZeroMemory(cName, sizeof(cName));
						wsprintf(cName, "XX%d", iNamingValue);
						cName[0] = cNamePrefix;
						cName[1] = iMapIndex+65;											
						if (bCreateNewNpc(cNpcName, cName, m_pMapList[iMapIndex]->m_cName, 0, 0, cNpcMoveType, NULL, NULL, cNpcWaypointIndex, NULL, NULL, -1, FALSE) == FALSE) 
						{	// NameValue
							m_pMapList[iMapIndex]->SetNamingValueEmpty(iNamingValue);	
						}else
						{	for (i5 = 1; i5 < DEF_MAXNPCS; i5++)
							if ((m_pNpcList[i5] != NULL) && (memcmp(m_pNpcList[i5]->m_cName, cName, 5) == 0) ) 
							{	switch (m_pNpcList[i5]->m_sType) {
								case 36: // AGT
								case 37: // CGT
								case 38: // MS
								case 39: // DT
									m_pNpcList[i5]->m_sAppr2 = 0;
									m_pNpcList[i5]->m_iBuildCount = 1;
									//SendEventToNearClient_TypeA(i5, DEF_OWNERTYPE_NPC, MSGID_EVENT_MOTION, DEF_OBJECTNULLACTION, NULL, NULL, NULL);
					}	}	}	} 
					cReadModeA = 0;
					cReadModeB = 0;
					iTotalNpcSetting++;
					break;
				}
				break;

			case 4:// Random-Mob-Generator 
				switch (cReadModeB) {
				case 1:					
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 12 - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					// Snoopy: Changed m_iRandomMobGeneratorSA to int
					m_pMapList[iMapIndex]->m_iRandomMobGeneratorSA = atoi(token);
					// 0 means no mobs (still used for zerking spot mobs)
					// Above 1 value will be used to remove npc every 5 minutes 
					// (5 minutes is Special event time)
					// Value beween 2% and 80% off all mobs
					// NB: Bigger than Ogre npc will not be removed
					if (m_pMapList[iMapIndex]->m_iRandomMobGeneratorSA < 0) m_pMapList[iMapIndex]->m_iRandomMobGeneratorSA = 0;
					if (m_pMapList[iMapIndex]->m_iRandomMobGeneratorSA >80) m_pMapList[iMapIndex]->m_iRandomMobGeneratorSA = 80;

					cReadModeB = 2;
					break;

				case 2:	// Mob- Level
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 13 - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pMapList[iMapIndex]->m_cRandomMobGeneratorLevel = atoi(token);
					m_pMapList[iMapIndex]->m_iMapLevel = 0;	
					switch (m_pMapList[iMapIndex]->m_cRandomMobGeneratorLevel) {
					case 1: // arefarm, elvfarm, aresden, elvine
						m_pMapList[iMapIndex]->m_iMapLevel = 0;		break;
					case 3:     // MiddleLand
						m_pMapList[iMapIndex]->m_iMapLevel = 3;		break;
					case 4: // Dungeon 1 
						m_pMapList[iMapIndex]->m_iMapLevel = 1;		break;
					case 5: // Dungeon 2 
						m_pMapList[iMapIndex]->m_iMapLevel = 2;		break;
					case 6: // huntzone3, huntzone4 (SW/DV) from HBChina351
						m_pMapList[iMapIndex]->m_iMapLevel = 4;		break;
					case 7: // areuni, elvuni
						m_pMapList[iMapIndex]->m_iMapLevel = 4;		break;
					case 8: // PL (HBChina351 uses RMG16)
						m_pMapList[iMapIndex]->m_iMapLevel = 1;		break;
					case 9: // D3 same HBChina351
						m_pMapList[iMapIndex]->m_iMapLevel = 6;		break;		// 30% zerk en pit
					case 10: // D4 Not same as China351 (Zombie replaced by Stone + Clops)
						m_pMapList[iMapIndex]->m_iMapLevel = 7;		break;		// 35% zerk en pit (DDs)
					case 11: // was tweaked for EF/RH on Revival/Equilibrium
						m_pMapList[iMapIndex]->m_iMapLevel = 2;		break;
					case 12: // Noob Dungeon from HBChina351
						m_pMapList[iMapIndex]->m_iMapLevel = 1;		break;
					case 13: // TOH1 from HBChina351
						m_pMapList[iMapIndex]->m_iMapLevel = 8;		break;		// 40% zerk en pit
					case 14: // TOH2: HBChina351 replaces DD by Ogres....
						m_pMapList[iMapIndex]->m_iMapLevel = 10;	break;		// 50% Zerk en pit
					case 15: //TOH3 from HBChina351
						m_pMapList[iMapIndex]->m_iMapLevel = 10;	break;		// 50% Zerk en pit
					case 16: // 2ndmiddle, huntzone1, huntzone2 from HBChina351 
						m_pMapList[iMapIndex]->m_iMapLevel = 1;		break;
					case 17: // SNOOPY: improved for Icebound 
						m_pMapList[iMapIndex]->m_iMapLevel = 5;		break;		// 25% Zerk en pit
					case 18: // druncncity Map from HBChina351
						m_pMapList[iMapIndex]->m_iMapLevel = 20;	break;		// 100% zerk en pit	
					case 19: // Maze Map from HBChina351
						m_pMapList[iMapIndex]->m_iMapLevel = 50;	break;		// All pit zerk, big chanbces for special spawn
					case 20: // Heldenian Map from HBChina351
						m_pMapList[iMapIndex]->m_iMapLevel = 30;	break;
					case 21: // ????????
						m_pMapList[iMapIndex]->m_iMapLevel = 4;		break;
					case 22: // SNOOPY: Catacombs
						m_pMapList[iMapIndex]->m_iMapLevel = 15;	break;		// 100% zerk en pit				
					case 23: // SNOOPY: Occupied cities
						m_pMapList[iMapIndex]->m_iMapLevel = 6; 	break;		// 30% zerk en pit				
					case 24: // Special design for QusMarch
						m_pMapList[iMapIndex]->m_iMapLevel = 8;		break;		// 40% zerk en pit
					}
					cReadModeA = 0;
					cReadModeB = 0;
					break;
				}
				break;

			case 5:	// Maximum object
				if (_bGetIsStringIsNumber(token) == FALSE) {
					PutLogList("(!!!) CRITICAL ERROR! Map Info file error 14 - Wrong Data format.");
					delete pContents;
					delete pStrTok;
					return FALSE;
				}
				m_pMapList[iMapIndex]->m_iMaximumObject = atoi(token);
				// Set a maximum to 980 to avoid objects over 999 (Crash risk?)
				if (m_pMapList[iMapIndex]->m_iMaximumObject >980) m_pMapList[iMapIndex]->m_iMaximumObject = 980;
				m_pMapList[iMapIndex]->m_iMaximumObjectDefault = m_pMapList[iMapIndex]->m_iMaximumObject;
				cReadModeA = 0;
				cReadModeB = 0;
				break;

			case 6:	// MGARC Mobgen Avoidrect
				switch (cReadModeB) {
				case 1:
					// Rect 
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 15 - Wrong Data format(MGAR num).");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					iMGARCfgIndex = atoi(token);
					if (m_pMapList[iMapIndex]->m_rcMobGenAvoidRect[iMGARCfgIndex].left != -1) {
						//  Waypoint 
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 16 - Duplicated Mob Gen Rect Number!");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}

					cReadModeB = 2;
					break;

				case 2:	// left
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 17 - Wrong Data format(MGAR num).");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pMapList[iMapIndex]->m_rcMobGenAvoidRect[iMGARCfgIndex].left = atoi(token);
					cReadModeB = 3;
					break;

				case 3:	// top
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 18 - Wrong Data format(MGAR num).");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pMapList[iMapIndex]->m_rcMobGenAvoidRect[iMGARCfgIndex].top = atoi(token);
					cReadModeB = 4;
					break;

				case 4:	// right
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 19 - Wrong Data format(MGAR num).");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pMapList[iMapIndex]->m_rcMobGenAvoidRect[iMGARCfgIndex].right = atoi(token);
					cReadModeB = 5;
					break;

				case 5:	// bottom
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 20 - Wrong Data format(MGAR num).");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pMapList[iMapIndex]->m_rcMobGenAvoidRect[iMGARCfgIndex].bottom = atoi(token);
					cReadModeA = 0;
					cReadModeB = 0;
					break;
				}
				break;
			
			case 7:// SpotMobGenerator
				switch (cReadModeB) {
				case 1:	// Rect  m_stSpotMobGenerator[]
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 21 - Wrong Data format(MGAR num).");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					iSMGRCfgIndex = atoi(token);
					if (m_pMapList[iMapIndex]->m_stSpotMobGenerator[iSMGRCfgIndex].bDefined == TRUE) 
					{	PutLogList("(!!!) CRITICAL ERROR! Map Info file error - Duplicate SpotMobGenerator");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					cReadModeB = 2;
					m_pMapList[iMapIndex]->m_stSpotMobGenerator[iSMGRCfgIndex].bDefined = TRUE;
					break;

				case 2: // SpotMobGen type
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 22 - Wrong Data format(SMGAR num).");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pMapList[iMapIndex]->m_stSpotMobGenerator[iSMGRCfgIndex].cType = atoi(token);
					if (m_pMapList[iMapIndex]->m_stSpotMobGenerator[iSMGRCfgIndex].cType < 0) 
					{	m_pMapList[iMapIndex]->m_stSpotMobGenerator[iSMGRCfgIndex].cType = -1 * iDice(1,19);
						m_pMapList[iMapIndex]->m_bHasMagicSMG = TRUE;
					}				
					if (   (m_pMapList[iMapIndex]->m_stSpotMobGenerator[iSMGRCfgIndex].cType >1 )
						&& (m_pMapList[iMapIndex]->m_stSpotMobGenerator[iSMGRCfgIndex].cType <4))
						cReadModeB = 9;  // Waypoint 
					else cReadModeB = 3;  // rect 
					break;

				case 3:	// left
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 23 - Wrong Data format(SMGAR num).");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pMapList[iMapIndex]->m_stSpotMobGenerator[iSMGRCfgIndex].rcRect.left = atoi(token);
					cReadModeB = 4;
					break;

				case 4:	// top
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 24 - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pMapList[iMapIndex]->m_stSpotMobGenerator[iSMGRCfgIndex].rcRect.top = atoi(token);
					cReadModeB = 5;
					break;

				case 5:	// right
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 25 - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pMapList[iMapIndex]->m_stSpotMobGenerator[iSMGRCfgIndex].rcRect.right = atoi(token);
					cReadModeB = 6;
					break;

				case 6:	// bottom
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 26 - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pMapList[iMapIndex]->m_stSpotMobGenerator[iSMGRCfgIndex].rcRect.bottom = atoi(token);
					cReadModeB = 7;
					break;
				case 7:	// creature type
					if (_bGetIsStringIsNumber(token) == FALSE) 
					{	PutLogList("(!!!) CRITICAL ERROR! Map Info file error 27 - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pMapList[iMapIndex]->m_stSpotMobGenerator[iSMGRCfgIndex].iMobType = atoi(token);
					iAdjustMobNum = 0;
					if (m_pMapList[iMapIndex]->m_stSpotMobGenerator[iSMGRCfgIndex].iMobType == -1)
					{	ZeroMemory(cNpcName, sizeof(cNpcName));
						switch (iDice(1,16)) {
						case 1: // 58MG 48SK 59Ettin 61Rudolf 80Tentocle 78Minaus
							switch (iDice(1,9)) {
							case 1: // Ettin
								m_pMapList[iMapIndex]->m_stSpotMobGenerator[iSMGRCfgIndex].iMobType = 59; 
								iAdjustMobNum = -2;  
								strcpy(cNpcName,"Ettin"); 
								break;
							case 2: // Tentocle
								m_pMapList[iMapIndex]->m_stSpotMobGenerator[iSMGRCfgIndex].iMobType = 80; 
								iAdjustMobNum = 3;   
								strcpy(cNpcName,"Tentocle"); 
								break;
							case 3: // Minaus
								m_pMapList[iMapIndex]->m_stSpotMobGenerator[iSMGRCfgIndex].iMobType = 78; 
								iAdjustMobNum = -3;   
								strcpy(cNpcName,"Minautor"); 
								break;
							case 4:
							case 5: // SK
								m_pMapList[iMapIndex]->m_stSpotMobGenerator[iSMGRCfgIndex].iMobType = 48;
								iAdjustMobNum = -1;  
								strcpy(cNpcName,"Stalker"); 
								break;
							default: // MG
								m_pMapList[iMapIndex]->m_stSpotMobGenerator[iSMGRCfgIndex].iMobType = 58; 
								iAdjustMobNum = 0; 
								strcpy(cNpcName,"MG"); 
								break;
							}
							break;
						case 2: 
						case 6:
						case 8: 
						case 9:
						case 12:
						case 13:  // Ogres 
							m_pMapList[iMapIndex]->m_stSpotMobGenerator[iSMGRCfgIndex].iMobType = 29;  
							iAdjustMobNum = 0;
								strcpy(cNpcName,"Ogre"); 
							break; 
						case 3:
						case 5:
						case 10: 
						case 11: 
						case 15: // Cyclops 
							m_pMapList[iMapIndex]->m_stSpotMobGenerator[iSMGRCfgIndex].iMobType = 13;  
							iAdjustMobNum = 2;
								strcpy(cNpcName,"Cyclop"); 
							break;
						case 4:  
						case 7: 
						case 14: 
						case 16: 
						default: // WW (11..14)
							m_pMapList[iMapIndex]->m_stSpotMobGenerator[iSMGRCfgIndex].iMobType = 33; 
							iAdjustMobNum = -1;
								strcpy(cNpcName,"WW"); 
							break;
						}	
						wsprintf(G_cTxt, "Random pit n°%d in %s (%d,%d). Type %d (%s)"
							, iSMGRCfgIndex
							, m_pMapList[iMapIndex]->m_cName
							, (m_pMapList[iMapIndex]->m_stSpotMobGenerator[iSMGRCfgIndex].rcRect.left + m_pMapList[iMapIndex]->m_stSpotMobGenerator[iSMGRCfgIndex].rcRect.right)/2
							, (m_pMapList[iMapIndex]->m_stSpotMobGenerator[iSMGRCfgIndex].rcRect.top + m_pMapList[iMapIndex]->m_stSpotMobGenerator[iSMGRCfgIndex].rcRect.bottom)/2
							, m_pMapList[iMapIndex]->m_stSpotMobGenerator[iSMGRCfgIndex].iMobType 
							, cNpcName);
						PutLogList(G_cTxt);		
						PutLogEventFileList(G_cTxt);		
					}
					cReadModeB = 8;
					break;

				case 8:	// Max Mobs
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 28 - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pMapList[iMapIndex]->m_stSpotMobGenerator[iSMGRCfgIndex].iMaxMobs = atoi(token);
					m_pMapList[iMapIndex]->m_stSpotMobGenerator[iSMGRCfgIndex].iCurMobs	= 0;
					if (m_pMapList[iMapIndex]->m_stSpotMobGenerator[iSMGRCfgIndex].cType < 0)
					{	m_pMapList[iMapIndex]->m_stSpotMobGenerator[iSMGRCfgIndex].iMaxMobs = 0;
					}
					if (m_pMapList[iMapIndex]->m_stSpotMobGenerator[iSMGRCfgIndex].iMaxMobs >=5)
						m_pMapList[iMapIndex]->m_stSpotMobGenerator[iSMGRCfgIndex].iMaxMobs	+= iAdjustMobNum;
					cReadModeA = 0;
					cReadModeB = 0;
					break;

				default:	// WayPoint0~waypoint9
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 29 - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pMapList[iMapIndex]->m_stSpotMobGenerator[iSMGRCfgIndex].cWaypoint[cReadModeB - 9] = atoi(token);
					cReadModeB++;
			   		break;

				case 19:// spot mob type
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 30 - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pMapList[iMapIndex]->m_stSpotMobGenerator[iSMGRCfgIndex].iMobType = atoi(token);
					cReadModeB = 20;
					break;

				case 20:
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 31 - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pMapList[iMapIndex]->m_stSpotMobGenerator[iSMGRCfgIndex].iMaxMobs = atoi(token);
					m_pMapList[iMapIndex]->m_stSpotMobGenerator[iSMGRCfgIndex].iCurMobs	= 0;
					cReadModeA = 0;
					cReadModeB = 0;
					break;
			  	}
				break;

			case 8:	// Location Map's location
				ZeroMemory(m_pMapList[iMapIndex]->m_cLocationName, sizeof(m_pMapList[iMapIndex]->m_cLocationName));
				memcpy(m_pMapList[iMapIndex]->m_cLocationName, token, 10);
				cReadModeA = 0;
				cReadModeB = 0;
				break;

			case 9: // Map's initial(s) point(s)
				switch (cReadModeB) {
				case 1:		// Initial-Point Index
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 32:1 - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					sIPindex = atoi(token);
					if (m_pMapList[iMapIndex]->m_pInitialPoint[sIPindex].x != -1) {
						PutLogList("(!!!) CRITICAL ERROR! Duplicate Initial Point Index!");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					cReadModeB = 2;
					break;
				
				case 2:
					// Initial-Point X
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 32 - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pMapList[iMapIndex]->m_pInitialPoint[sIPindex].x = atoi(token);
					cReadModeB = 3;
					break;

				case 3:
					// Initial-Point Y
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 33 - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pMapList[iMapIndex]->m_pInitialPoint[sIPindex].y = atoi(token);
					cReadModeA = 0;
					cReadModeB = 0;
					break;
				}
				break;
		
			case 10:// No Attack rect
				switch (cReadModeB) {
				case 1:
					if (_bGetIsStringIsNumber(token) == FALSE) 
					{	PutLogList("(!!!) CRITICAL ERROR! Map Info file error 34 - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					iNMRCfgIndex = atoi(token);	// No-Magic-Rect
					if (m_pMapList[iMapIndex]->m_rcNoAttackRect[iNMRCfgIndex].top != -1) 					
					{	PutLogList("(!!!) CRITICAL ERROR! Map Info file error 35 - Duplicate No-Magic-Rect number");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					cReadModeB = 2;
					break;

				case 2:
					if (_bGetIsStringIsNumber(token) == FALSE) 
					{	PutLogList("(!!!) CRITICAL ERROR! Map Info file error 36 - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pMapList[iMapIndex]->m_rcNoAttackRect[iNMRCfgIndex].left = atoi(token);
					cReadModeB = 3;
					break;

				case 3:
					if (_bGetIsStringIsNumber(token) == FALSE) 
					{	PutLogList("(!!!) CRITICAL ERROR! Map Info file error 37 - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pMapList[iMapIndex]->m_rcNoAttackRect[iNMRCfgIndex].top = atoi(token);
					cReadModeB = 4;
					break;

				case 4:
					if (_bGetIsStringIsNumber(token) == FALSE) 
					{	PutLogList("(!!!) CRITICAL ERROR! Map Info file error 38 - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pMapList[iMapIndex]->m_rcNoAttackRect[iNMRCfgIndex].right = atoi(token);
					cReadModeB = 5;
					break;

				case 5:
					if (_bGetIsStringIsNumber(token) == FALSE) 
					{	PutLogList("(!!!) CRITICAL ERROR! Map Info file error 39 - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pMapList[iMapIndex]->m_rcNoAttackRect[iNMRCfgIndex].bottom = atoi(token);
					cReadModeA = 0;
					cReadModeB = 0;
					break;
				}
				break;

			case 11: // fixed dayNight
				m_pMapList[iMapIndex]->m_bIsFixedDayMode = (BOOL)atoi(token);
				if (m_pMapList[iMapIndex]->m_bIsFixedDayMode == TRUE)
					m_pMapList[iMapIndex]->m_bIsSnowEnabled = FALSE;
				cReadModeA = 0;
				break;

			case 12: // Fish point list
				switch (cReadModeB) {
				case 1:
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 40 - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					iFishPointIndex = atoi(token);
					if (m_pMapList[iMapIndex]->m_FishPointList[iFishPointIndex].x != -1) {
						// Fish Point
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 41 - Duplicate FishPoint number");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}					
					m_pMapList[iMapIndex]->m_iTotalFishPoint++;
					cReadModeB = 2;
					break;

				case 2:
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 42 - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pMapList[iMapIndex]->m_FishPointList[iFishPointIndex].x = atoi(token);

					cReadModeB = 3;
					break;

				case 3:
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 43 - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pMapList[iMapIndex]->m_FishPointList[iFishPointIndex].y = atoi(token);

					cReadModeA = 0;
					cReadModeB = 0;
					break;
				}
				break;

			case 13: // maxfish
				if (_bGetIsStringIsNumber(token) == FALSE) {
					PutLogList("(!!!) CRITICAL ERROR! Map Info file error 44 - Wrong Data format.");
					delete pContents;
					delete pStrTok;
					return FALSE;
				}
				m_pMapList[iMapIndex]->m_iMaxFish = atoi(token);
				cReadModeA = 0;
				break;

			case 14: // Type (0=normal, 1=noPenaltyNoRward)
				if (_bGetIsStringIsNumber(token) == FALSE) {
					PutLogList("(!!!) CRITICAL ERROR! Map Info file error 45 - Wrong Data format.");
					delete pContents;
					delete pStrTok;
					return FALSE;
				}
				m_pMapList[iMapIndex]->m_cType = atoi(token);

				cReadModeA = 0;
				break;

			case 15: // Level limit
				if (_bGetIsStringIsNumber(token) == FALSE) {
					PutLogList("(!!!) CRITICAL ERROR! Map Info file error 46 - Wrong Data format.");
					delete pContents;
					delete pStrTok;
					return FALSE;
				}
				m_pMapList[iMapIndex]->m_iLevelLimit = atoi(token);

				cReadModeA = 0;
				break;

			case 16: // Minerals
				switch (cReadModeB) {
				case 1:
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 47 - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pMapList[iMapIndex]->m_bMineralGenerator = (BOOL)atoi(token);
					cReadModeB = 2;
					break;

				case 2:
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 48 - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pMapList[iMapIndex]->m_cMineralGeneratorLevel = atoi(token);
					cReadModeA = 0;
					cReadModeB = 0;
					break;
				}
				break;

			case 17:// Mineral Point
				switch (cReadModeB) {
				case 1:
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 49 - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					iMineralPointIndex = atoi(token);
					if (m_pMapList[iMapIndex]->m_MineralPointList[iMineralPointIndex].x != -1) {
						// Mineral Point
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 50 - Duplicate MineralPoint number");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					
					m_pMapList[iMapIndex]->m_iTotalMineralPoint++;
					cReadModeB = 2;
					break;

				case 2:
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 51 - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pMapList[iMapIndex]->m_MineralPointList[iMineralPointIndex].x = atoi(token);

					cReadModeB = 3;
					break;

				case 3:
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 52 - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pMapList[iMapIndex]->m_MineralPointList[iMineralPointIndex].y = atoi(token);

					cReadModeA = 0;
					cReadModeB = 0;
					break;
				}
				break;

			case 18: // maxmineral
				if (_bGetIsStringIsNumber(token) == FALSE) {
					PutLogList("(!!!) CRITICAL ERROR! Map Info file error 53 - Wrong Data format.");
					delete pContents;
					delete pStrTok;
					return FALSE;
				}
				m_pMapList[iMapIndex]->m_iMaxMineral = atoi(token);

				cReadModeA = 0;
				break;

			case 19: // Upper Level limit
				if (_bGetIsStringIsNumber(token) == FALSE) {
					PutLogList("(!!!) CRITICAL ERROR! Map Info file error 54 - Wrong Data format.");
					delete pContents;
					delete pStrTok;
					return FALSE;
				}
				m_pMapList[iMapIndex]->m_iUpperLevelLimit = atoi(token);

				cReadModeA = 0;
				break;

			case 20: // Strategic Point 
				switch (cReadModeB) {
				case 1:	// Strategic Point
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 55 - Wrong Data format.");
						delete pContents; delete pStrTok; return FALSE;
					}
					iStrategicPointIndex = atoi(token);
					if (m_pMapList[iMapIndex]->m_pStrategicPointList[iStrategicPointIndex] != NULL) 
					{	PutLogList("(!!!) CRITICAL ERROR! Map Info file error 56 - Duplicate Strategic Point number");
						delete pContents; delete pStrTok; return FALSE;
					}					
					m_pMapList[iMapIndex]->m_pStrategicPointList[iStrategicPointIndex] = new class CStrategicPoint;
					cReadModeB = 2;
					break;

				case 2:
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 57 - Wrong Data format.");
						delete pContents; delete pStrTok; return FALSE;
					}
					m_pMapList[iMapIndex]->m_pStrategicPointList[iStrategicPointIndex]->m_iSide = atoi(token);
					cReadModeB = 3;
					break;

				case 3:
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 58 - Wrong Data format.");
						delete pContents; delete pStrTok; return FALSE;
					}
					m_pMapList[iMapIndex]->m_pStrategicPointList[iStrategicPointIndex]->m_iValue = atoi(token);
					cReadModeB = 4;
					break;

				case 4:
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 59 - Wrong Data format.");
						delete pContents; delete pStrTok; return FALSE;
					}
					m_pMapList[iMapIndex]->m_pStrategicPointList[iStrategicPointIndex]->m_iX = atoi(token);
					cReadModeB = 5;
					break;

				case 5:
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 60 - Wrong Data format.");
						delete pContents; delete pStrTok; return FALSE;
					}
					m_pMapList[iMapIndex]->m_pStrategicPointList[iStrategicPointIndex]->m_iY = atoi(token);
					cReadModeA = 0;
					cReadModeB = 0;
					break;
				}
				break;

			case 21: // Energy-Sphere-Creation Point
				switch (cReadModeB) {
				case 1:
					if (_bGetIsStringIsNumber(token) == FALSE) 
					{	PutLogList("(!!!) CRITICAL ERROR! Map Info file error 61 - (Energy-Sphere-Creation Point) Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					iIndex = atoi(token);					
					if (m_pMapList[iMapIndex]->m_stEnergySphereCreationList[iIndex].cType != NULL) 
					{	PutLogList("(!!!) CRITICAL ERROR! Map Info file error 62 - Duplicate EnergySphereCreation number");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}					
					m_pMapList[iMapIndex]->m_iTotalEnergySphereCreationPoint++;
					cReadModeB = 2;
					break;
				
				case 2:
					if (_bGetIsStringIsNumber(token) == FALSE) 
					{	PutLogList("(!!!) CRITICAL ERROR! Map Info file error 63 - (Energy-Sphere-Creation Point Type) Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pMapList[iMapIndex]->m_stEnergySphereCreationList[iIndex].cType = atoi(token);
					cReadModeB = 3;
					break;

				case 3:
					if (_bGetIsStringIsNumber(token) == FALSE) 
					{	PutLogList("(!!!) CRITICAL ERROR! Map Info file error 64 - (Energy-Sphere-Creation Point X) Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pMapList[iMapIndex]->m_stEnergySphereCreationList[iIndex].sX = atoi(token);
					cReadModeB = 4;
					break;

				case 4:
					if (_bGetIsStringIsNumber(token) == FALSE) 
					{	PutLogList("(!!!) CRITICAL ERROR! Map Info file error 65 - (Energy-Sphere-Creation Point Y) Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pMapList[iMapIndex]->m_stEnergySphereCreationList[iIndex].sY = atoi(token);
					cReadModeA = 0;
					cReadModeB = 0;
					break;
				}
				break;

			case 22: // Energy-Sphere-Goal Point 
				switch (cReadModeB) {
				case 1:
					if (_bGetIsStringIsNumber(token) == FALSE) 
					{	PutLogList("(!!!) CRITICAL ERROR! Map Info file error 66 - (Energy-Sphere-Goal Point Index) Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					iIndex = atoi(token);
					
					if (m_pMapList[iMapIndex]->m_stEnergySphereGoalList[iIndex].cResult != NULL) 
					{	wsprintf(G_cTxt, "(!!!) CRITICAL ERROR! Map Info file error 67 - Duplicate EnergySphereGoal number(%d:%d)", iIndex, m_pMapList[iMapIndex]->m_stEnergySphereGoalList[iIndex].cResult);
						PutLogList(G_cTxt);
						delete pContents;
						delete pStrTok;
						return FALSE;
					}					
					m_pMapList[iMapIndex]->m_iTotalEnergySphereGoalPoint++;
					cReadModeB = 2;
					break;
				
				case 2:
					if (_bGetIsStringIsNumber(token) == FALSE) 
					{	PutLogList("(!!!) CRITICAL ERROR! Map Info file error 68 - (Energy-Sphere-Goal Point cResult) Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pMapList[iMapIndex]->m_stEnergySphereGoalList[iIndex].cResult = atoi(token);
					cReadModeB = 3;
					break;

				case 3:
					if (_bGetIsStringIsNumber(token) == FALSE) 
					{	PutLogList("(!!!) CRITICAL ERROR! Map Info file error 69 - (Energy-Sphere-Goal Point aresdenX) Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pMapList[iMapIndex]->m_stEnergySphereGoalList[iIndex].aresdenX = atoi(token);
					cReadModeB = 4;
					break;

				case 4:
					if (_bGetIsStringIsNumber(token) == FALSE) 
					{	PutLogList("(!!!) CRITICAL ERROR! Map Info file error 70 - (Energy-Sphere-Goal Point aresdenY) Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pMapList[iMapIndex]->m_stEnergySphereGoalList[iIndex].aresdenY = atoi(token);					
					cReadModeB = 5;
					break;

				case 5:
					if (_bGetIsStringIsNumber(token) == FALSE) 
					{	PutLogList("(!!!) CRITICAL ERROR! Map Info file error 71 - (Energy-Sphere-Goal Point elvineX) Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pMapList[iMapIndex]->m_stEnergySphereGoalList[iIndex].elvineX = atoi(token);					
					cReadModeB = 6;
					break;

				case 6:
					if (_bGetIsStringIsNumber(token) == FALSE) 
					{	PutLogList("(!!!) CRITICAL ERROR! Map Info file error 72 - (Energy-Sphere-Goal Point elvineY) Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pMapList[iMapIndex]->m_stEnergySphereGoalList[iIndex].elvineY = atoi(token);					
					cReadModeA = 0;
					cReadModeB = 0;
					break;
				}
				break;

			case 23: // Strike point
				switch (cReadModeB) {
				case 1:
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 73 - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					iIndex = atoi(token);
					
					if (strlen(m_pMapList[iMapIndex]->m_stStrikePoint[iIndex].cRelatedMapName) != NULL) 
					{	wsprintf(G_cTxt, "(!!!) CRITICAL ERROR! Map Info file error 74 - Duplicate Strike Point number(%d)", iIndex);
						PutLogList(G_cTxt);
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
										
					cReadModeB = 2;
					break;
				
				case 2:
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 75 - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pMapList[iMapIndex]->m_stStrikePoint[iIndex].dX = atoi(token);

					cReadModeB = 3;
					break;

				case 3:
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 76 - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pMapList[iMapIndex]->m_stStrikePoint[iIndex].dY = atoi(token);

					cReadModeB = 4;
					break;

				case 4:
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 77 - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pMapList[iMapIndex]->m_stStrikePoint[iIndex].iHP = atoi(token);
					m_pMapList[iMapIndex]->m_stStrikePoint[iIndex].iInitHP = atoi(token);
					cReadModeB = 5;
					break;


				case 5:
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 77 - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pMapList[iMapIndex]->m_stStrikePoint[iIndex].iEffectX[0] = atoi(token);
					
					cReadModeB = 6;
					break;

				case 6:
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 77 - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pMapList[iMapIndex]->m_stStrikePoint[iIndex].iEffectY[0] = atoi(token);
					
					cReadModeB = 7;
					break;

				case 7:
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 77 - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pMapList[iMapIndex]->m_stStrikePoint[iIndex].iEffectX[1] = atoi(token);
					
					cReadModeB = 8;
					break;

				case 8:
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 77 - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pMapList[iMapIndex]->m_stStrikePoint[iIndex].iEffectY[1] = atoi(token);
					
					cReadModeB = 9;
					break;

				case 9:
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 77 - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pMapList[iMapIndex]->m_stStrikePoint[iIndex].iEffectX[2] = atoi(token);
					
					cReadModeB = 10;
					break;

				case 10:
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 77 - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pMapList[iMapIndex]->m_stStrikePoint[iIndex].iEffectY[2] = atoi(token);
					
					cReadModeB = 11;
					break;

				case 11:
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 77 - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pMapList[iMapIndex]->m_stStrikePoint[iIndex].iEffectX[3] = atoi(token);
					
					cReadModeB = 12;
					break;

				case 12:
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 77 - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pMapList[iMapIndex]->m_stStrikePoint[iIndex].iEffectY[3] = atoi(token);
					
					cReadModeB = 13;
					break;

				case 13:
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 77 - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pMapList[iMapIndex]->m_stStrikePoint[iIndex].iEffectX[4] = atoi(token);
					
					cReadModeB = 14;
					break;

				case 14:
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 77 - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pMapList[iMapIndex]->m_stStrikePoint[iIndex].iEffectY[4] = atoi(token);
					
					cReadModeB = 15;
					break;

				case 15:
					ZeroMemory(m_pMapList[iMapIndex]->m_stStrikePoint[iIndex].cRelatedMapName, sizeof(m_pMapList[iMapIndex]->m_stStrikePoint[iIndex].cRelatedMapName));
					strcpy(m_pMapList[iMapIndex]->m_stStrikePoint[iIndex].cRelatedMapName, token);
					
					m_pMapList[iMapIndex]->m_iTotalStrikePoints++;
					cReadModeA = 0;
					cReadModeB = 0;
					break;

				}
				break; // end 23

			case 24:// Item-Event, reintroduced and tweaked by Snoopy
				switch (cReadModeB) {
				case 1: //  index
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 78 - Wrong Data format.");
						delete pContents; delete pStrTok; return FALSE;
					}
					iIndex = atoi(token);					
					if (strlen(m_pMapList[iMapIndex]->m_stItemEventList[iIndex].cItemName) != NULL) {
						wsprintf(G_cTxt, "(!!!) CRITICAL ERROR! Map Info file error 79 - Duplicate Item-Event number(%d:%s)", iIndex, m_pMapList[iMapIndex]->m_stItemEventList[iIndex].cItemName);
						PutLogList(G_cTxt);
						delete pContents; delete pStrTok; return FALSE;
					}					
					m_pMapList[iMapIndex]->m_iTotalItemEvents++;
					cReadModeB = 2;
					break;				
				case 2: // item_name
					strcpy(m_pMapList[iMapIndex]->m_stItemEventList[iIndex].cItemName, token);
					cReadModeB = 3;
					break;
				case 3: // amount
					if (_bGetIsStringIsNumber(token) == FALSE) 
					{	PutLogList("(!!!) CRITICAL ERROR! Map Info file error 81 - Wrong Data format.");
						delete pContents; delete pStrTok; return FALSE;
					}
					m_pMapList[iMapIndex]->m_stItemEventList[iIndex].iAmount = atoi(token);
					cReadModeB = 4;
					break;
				case 4: // total number (max number that can drop)
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 82 - Wrong Data format.");
						delete pContents; delete pStrTok; return FALSE;
					}
					m_pMapList[iMapIndex]->m_stItemEventList[iIndex].iTotalNum = atoi(token);					
					cReadModeB = 5;
					break;
				case 5: // Mounth
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 83 - Wrong Data format.");
						delete pContents; delete pStrTok; return FALSE;
					}
					m_pMapList[iMapIndex]->m_stItemEventList[iIndex].iMonth = atoi(token);					
					cReadModeB = 6;
					break;
				case 6: // Day
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 83 - Wrong Data format.");
						delete pContents; delete pStrTok; return FALSE;
					}
					m_pMapList[iMapIndex]->m_stItemEventList[iIndex].iDay = atoi(token);
					cReadModeB = 7;
					break;
				case 7: // type (always 0, unused)
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 83 - Wrong Data format.");
						delete pContents; delete pStrTok; return FALSE;
					}
					m_pMapList[iMapIndex]->m_stItemEventList[iIndex].iType = atoi(token);
					m_pMapList[iMapIndex]->m_stItemEventList[iIndex].iDropped = 0;
					cReadModeB = 8;
					break;
				case 8: // monster list
					if( strcmp(token, "EOL") == 0 ) 
					{	cReadModeA = 0;
						cReadModeB = 0;
					}else 
					{	iNbeMobItemEvent = m_pMapList[iMapIndex]->m_stItemEventList[iIndex].iNbeMob;						
						if( iNbeMobItemEvent >= 5 ) 
						{	cReadModeA = 0;
							cReadModeB = 0;
							PutLogList("(!!!) ERROR! Map Info file error 83 - ItemEvent EOL missing.");
							break;
						}
						m_pMapList[iMapIndex]->m_stItemEventList[iIndex].cMob[iNbeMobItemEvent] = new char[21];
						ZeroMemory(m_pMapList[iMapIndex]->m_stItemEventList[iIndex].cMob[iNbeMobItemEvent],
							sizeof(m_pMapList[iMapIndex]->m_stItemEventList[iIndex].cMob[iNbeMobItemEvent]) );
						strcpy(m_pMapList[iMapIndex]->m_stItemEventList[iIndex].cMob[iNbeMobItemEvent], token);
						m_pMapList[iMapIndex]->m_stItemEventList[iIndex].iNbeMob ++;
						cReadModeB = 8;
					}
					break;
				}
				break;
			case 25: // mobevent-amount
				switch (cReadModeB) {
				case 1:
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 78 - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pMapList[iMapIndex]->sMobEventAmount = atoi(token);
					if (m_pMapList[iMapIndex]->sMobEventAmount > 25) m_pMapList[iMapIndex]->sMobEventAmount = 25;
					if (m_pMapList[iMapIndex]->sMobEventAmount < 1 ) m_pMapList[iMapIndex]->sMobEventAmount = 15;
					cReadModeA = 0;
					cReadModeB = 0;
					break;
				}
				break;

			case 26: // ApocalypseMobGenType
				if (_bGetIsStringIsNumber(token) == FALSE) {
					PutLogList("(!!!) CRITICAL ERROR! Map Info file error ApocalypseMobGenType - Wrong Data format.");
					delete pContents;
					delete pStrTok;
					return FALSE;
				}
				m_pMapList[iMapIndex]->m_iApocalypseMobGenType = atoi(token);
				cReadModeA = 0;
				cReadModeB = 0;
				break;

			case 27: // ApocalypseBossMob //SNOOPY replaced coord by RECT structure.
				switch (cReadModeB) {
				case 1: // 3CB6Ch m_pMapList[]->m_ApocalypseBossMobNpcID
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error ApocalypseBossMob - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pMapList[iMapIndex]->m_iApocalypseBossMobNpcID = atoi(token);
					cReadModeB = 2;					
					break;
				case 2: // 3CB70h m_pMapList[]->ApocalypseBossMobRectX1
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error ApocalypseBossMob - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					//m_pMapList[iMapIndex]->m_sApocalypseBossMobRectX1 = atoi(token);
					m_pMapList[iMapIndex]->m_sApocalypseBossMobRect.left = atoi(token);
					cReadModeB = 3;					
					break;
				case 3: // 3CB74h m_pMapList[]->ApocalypseBossMobRectY1
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error ApocalypseBossMob - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					//m_pMapList[iMapIndex]->m_sApocalypseBossMobRectY1 = atoi(token);
					m_pMapList[iMapIndex]->m_sApocalypseBossMobRect.top = atoi(token);
					cReadModeB = 4;					
					break;
				case 4: // 3CB78h m_pMapList[]->ApocalypseBossMobRectX2
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error ApocalypseBossMob - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					//m_pMapList[iMapIndex]->m_sApocalypseBossMobRectX2 = atoi(token);
					m_pMapList[iMapIndex]->m_sApocalypseBossMobRect.right = atoi(token);
					cReadModeB = 5;					
					break;
				case 5: // 3CB7Ch m_pMapList[]->ApocalypseBossMobRectY2
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error ApocalypseBossMob - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					//m_pMapList[iMapIndex]->m_sApocalypseBossMobRectY2 = atoi(token);
					m_pMapList[iMapIndex]->m_sApocalypseBossMobRect.bottom = atoi(token);
					cReadModeA = 0;
					cReadModeB = 0;					
					break;
				}
				break;

			case 28: //DynamicGateType // 28
				if (_bGetIsStringIsNumber(token) == FALSE) {
					PutLogList("(!!!) CRITICAL ERROR! Map Info file error DynamicGateType - Wrong Data format.");
					delete pContents;
					delete pStrTok;
					return FALSE;
				}
				m_pMapList[iMapIndex]->m_cDynamicGateType = atoi(token);
				// DynamicGateType = 1: Opens Gate when Apoc begins
				// DynamicGateType = 2: Open the gate when map is empty
				// DynamicGateType = 3: Gate stays closed will change to 4 value to open it, along with a boss spawn.
				// DynamicGateType = 4: Gate is openned. (set by server when Abaddon is spawning)
				// DynamicGateType = 5: Gate is used by GM command

				cReadModeA = 0;
				cReadModeB = 0;
				break;
								
			case 29: //DynamicGateCoord // 29
				// DynamicGateCoord	= 59 196 60 197        abaddon	   -1  -1
				switch (cReadModeB) {
				case 1: // 3CA20h
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error ApocalypseBossMob - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pMapList[iMapIndex]->m_sDynamicGateCoordRectX1 = atoi(token);
					cReadModeB = 2;
					break;

				case 2: // 3CA24h
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error ApocalypseBossMob - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pMapList[iMapIndex]->m_sDynamicGateCoordRectY1 = atoi(token);
					cReadModeB = 3;
					break;

				case 3: // 3CA28h
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error ApocalypseBossMob - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pMapList[iMapIndex]->m_sDynamicGateCoordRectX2 = atoi(token);
					cReadModeB = 4;
					break;

				case 4: // 3CA2Ch
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error ApocalypseBossMob - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pMapList[iMapIndex]->m_sDynamicGateCoordRectY2 = atoi(token);
					cReadModeB = 5;
					break;

				case 5: // 3CA30h
					ZeroMemory(m_pMapList[iMapIndex]->m_cDynamicGateCoordDestMap, sizeof(m_pMapList[iMapIndex]->m_cDynamicGateCoordDestMap));
					memcpy(m_pMapList[iMapIndex]->m_cDynamicGateCoordDestMap, token, strlen(token));
					cReadModeB = 6;
					break;

				case 6: // 3CA3Ch
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error ApocalypseBossMob - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pMapList[iMapIndex]->m_sDynamicGateCoordTgtX = atoi(token);
					cReadModeB = 7;
					break;

				case 7: // (ty = 3CB60h) unknown (3CA3Eh)
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error ApocalypseBossMob - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pMapList[iMapIndex]->m_sDynamicGateCoordTgtY = atoi(token);
					cReadModeA = 0;
					cReadModeB = 0;
					break;
				}
				break;
			
			case 30: // RecallImpossible // 30
				if (_bGetIsStringIsNumber(token) == FALSE) {
					PutLogList("(!!!) CRITICAL ERROR! Map Info file error RecallImpossible -  Wrong Data format.");
					delete pContents;
					delete pStrTok;
					return FALSE;
				}
				m_pMapList[iMapIndex]->m_bIsRecallImpossible = (BOOL) atoi(token);
				cReadModeA = 0;
				cReadModeB = 0;
				break;

			case 31: // ApocalypseMap // 31
				if (_bGetIsStringIsNumber(token) == FALSE) {
					PutLogList("(!!!) CRITICAL ERROR! Map Info file error ApocalypseMap -  Wrong Data format.");
					delete pContents;
					delete pStrTok;
					return FALSE;
				}
				m_pMapList[iMapIndex]->m_bIsApocalypseMap = (BOOL) atoi(token);
				cReadModeA = 0;
				cReadModeB = 0;
				break;
			
			case 32: // CitizenLimit // 32 
				// (SNOOPY: Added to forbid civ instead of fixed limitation at ML & PL)
				if (_bGetIsStringIsNumber(token) == FALSE) {
					PutLogList("(!!!) CRITICAL ERROR! Map Info file error CitizenLimit -  Wrong Data format.");
					delete pContents;
					delete pStrTok;
					return FALSE;
				}
				m_pMapList[iMapIndex]->m_bIsCitizenLimit = (BOOL) atoi(token);
				cReadModeA = 0;
				cReadModeB = 0;
				break;
					
			case 33: // HeldenianMap
				if (_bGetIsStringIsNumber(token) == FALSE) 
				{	PutLogList("(!!!) CRITICAL ERROR! Map Info file error CitizenLimit -  Wrong Data format.");
					delete pContents;
					delete pStrTok;
					return FALSE;
				}
				m_pMapList[iMapIndex]->m_bIsHeldenianMap = atoi(token);
				cReadModeA = 0;
				cReadModeB = 0;
				break;

			case 34: // HeldenianTower
				switch (cReadModeB) {
				case 1: // NpcID
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error Hedenian tower type id - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pMapList[iMapIndex]->m_stHeldenianTower[iIndexHT].sTypeID = atoi(token);
					cReadModeB = 2;
					break;
				case 2: // side 
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error Hedenian Tower Side - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pMapList[iMapIndex]->m_stHeldenianTower[iIndexHT].cSide = atoi(token);
					cReadModeB = 3;
					break;
				case 3: // sX
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error Hedenian Tower X pos - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pMapList[iMapIndex]->m_stHeldenianTower[iIndexHT].dX = atoi(token);
					cReadModeB = 4;
					break;
				case 4: // sY
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error Hedenian Tower Y pos - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pMapList[iMapIndex]->m_stHeldenianTower[iIndexHT].dY = atoi(token);
					iIndexHT++;
					cReadModeA = 0;
					cReadModeB = 0;
					break;
				}
				break;

			case 35: // HeldenianModeMap
				if (_bGetIsStringIsNumber(token) == FALSE) {
					PutLogList("(!!!) CRITICAL ERROR! Map Info file error Hedenian Map Mode - Wrong Data format.");
					delete pContents;
					delete pStrTok;
					return FALSE;
				}
				m_pMapList[iMapIndex]->m_cHeldenianModeMap = atoi(token);
				cReadModeA = 0;
				cReadModeB = 0;
				break;

			case 36: // HeldenianWinningZone
				switch (cReadModeB) {
				case 1:
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error Hedenian Map Mode - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pMapList[iMapIndex]->m_sHeldenianWinningZoneX = atoi(token);
					cReadModeB = 2;
					break;
				case 2:
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error Hedenian Map Mode - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pMapList[iMapIndex]->m_sHeldenianWinningZoneY = atoi(token);
					cReadModeA = 0;
					cReadModeB = 0;
					break;
				}
				break;

			case 37: // HeldenianGateDoor // 37
				switch (cReadModeB) {
				case 1: 
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error Heldenian Door Direction - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pMapList[iMapIndex]->m_stHeldenianGateDoor[iIndexGD].cDir = atoi(token);
					cReadModeB = 2;
					break;
				case 2:
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error Heldenian Door X pos - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pMapList[iMapIndex]->m_stHeldenianGateDoor[iIndexGD].dX = atoi(token);
					cReadModeB = 3;
					break;
				case 3:
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error Heldenian Door Y pos - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pMapList[iMapIndex]->m_stHeldenianGateDoor[iIndexGD].dY = atoi(token);
					iIndexGD++;
					cReadModeA = 0;
					cReadModeB = 0;
					break;
				}
				break;

			case 38: // PKmode
				// SNOOPY: initialising PKmode
				// 0: All PK allowed
				// 1: no PK. EK allowed (safe from same city)
				// 2: Safe between Ares and Elvines; but "Evil" side can EK, be EKilled
				// 3: No EK/PK allowed at all
				// 4: Evil side can be victim but not attack
				// 5: no EK, but PK possible..(special events)
				// -1: no PK. EK allowed (safe from same city), crims treated as normal citizens
				// -2: Safe between Ares and Elvines; but "Evil" side can EK, be EKilled, crims treated as normal citizens
				// -3: No EK/PK allowed at all, crims treated as normal citizens
				// -4: Evil side can be victim but not attack, crims treated as normal citizens
				// -5: no EK, but PK possible..(special events), crims treated as normal citizens
				if (_bGetIsStringIsNumber(token) == FALSE) 
				{	PutLogList("(!!!) CRITICAL ERROR! Map Info file error pk-mode - Wrong Data format.");
					delete pContents;
					delete pStrTok;
					return FALSE;
				}
				m_pMapList[iMapIndex]->m_iPKmode = atoi(token);
				if (m_pMapList[iMapIndex]->m_iPKmode < -5) m_pMapList[iMapIndex]->m_iPKmode = 0;
				if (m_pMapList[iMapIndex]->m_iPKmode > 5)  m_pMapList[iMapIndex]->m_iPKmode = 0;
				cReadModeA = 0;
				cReadModeB = 0;
				break;	

			case 39: // SNOOPY: Added 	BOOL m_nIsNotParmanentMap;		
				if (_bGetIsStringIsNumber(token) == FALSE) 
				{	PutLogList("(!!!) CRITICAL ERROR! Map Info file error Not Permanent map - Wrong Data format.");
					delete pContents;
					delete pStrTok;
					return FALSE;
				} // not-permanent-map = 1/0
				m_pMapList[iMapIndex]->m_nIsNotPermanentMap = FALSE; 
				if (atoi(token) == 1) m_pMapList[iMapIndex]->m_nIsNotPermanentMap = TRUE;
				cReadModeA = 0;
				cReadModeB = 0;
				break;	

			case 40: // SNOOPY: Added 	int m_iDropType;		
				if (_bGetIsStringIsNumber(token) == FALSE) 
				{	PutLogList("(!!!) CRITICAL ERROR! Map Info file error Drop type - Wrong Data format.");
					delete pContents;
					delete pStrTok;						// -1 = only potion/food drops
					return FALSE;						// 0 = No drops
				}                                       // 2+ not implemented (<=> 1)           
				m_pMapList[iMapIndex]->m_iDropType = 1; // 1 = default, normal drops
				m_pMapList[iMapIndex]->m_iDropType = atoi(token);
				if (m_pMapList[iMapIndex]->m_iDropType  < -1) m_pMapList[iMapIndex]->m_iDropType = -1;  
				cReadModeA = 0;
				cReadModeB = 0;
				break;

			case 41: // SNOOPY: Added 	m_bInsideBuildingLimitedCast;		
				if (_bGetIsStringIsNumber(token) == FALSE) 
				{	PutLogList("(!!!) CRITICAL ERROR! Map Info file error Limited Cast - Wrong Data format.");
					delete pContents;
					delete pStrTok;					
					return FALSE;					
				}               
				m_pMapList[iMapIndex]->m_bInsideBuildingLimitedCast = FALSE; // = default = no limit
				if ( atoi(token) == 1 ) m_pMapList[iMapIndex]->m_bInsideBuildingLimitedCast = TRUE; 
				cReadModeA = 0;
				cReadModeB = 0;
				break;			
			case 42: // XP rate
				if (_bGetIsStringIsNumber(token) == FALSE) 
				{	PutLogList("(!!!) CRITICAL ERROR! Map Info file error XPRate - Wrong Data format.");
					delete pContents;
					delete pStrTok;
					return FALSE;
				}
				m_pMapList[iMapIndex]->m_iXPRate = atoi(token);
				if (m_pMapList[iMapIndex]->m_iXPRate < 1) m_pMapList[iMapIndex]->m_iXPRate = 100;
				if (m_pMapList[iMapIndex]->m_iXPRate > 1000)  m_pMapList[iMapIndex]->m_iXPRate = 100;
				if (m_pMapList[iMapIndex]->m_iXPRate != 100)
				{	m_iHourllyXP250 = 250*10*m_pMapList[iMapIndex]->m_iXPRate;
					m_iHourllyXP300 = 300*10*m_pMapList[iMapIndex]->m_iXPRate;
					m_iHourllyXP400 = 400*10*m_pMapList[iMapIndex]->m_iXPRate;
					if (m_iHourllyXP250 < 50000) m_iHourllyXP250 = 50000;
					if (m_iHourllyXP300 < 60000) m_iHourllyXP300 = 60000;
					if (m_iHourllyXP400 < 80000) m_iHourllyXP400 = 80000;
				}
				cReadModeA = 0;
				cReadModeB = 0;
				break;

			case 43: // extra-drop
				if (_bGetIsStringIsNumber(token) == FALSE) 
				{	PutLogList("(!!!) CRITICAL ERROR! Map Info file error DropRate - Wrong Data format.");
					delete pContents; delete pStrTok; return FALSE;
				}
				m_pMapList[iMapIndex]->m_iExtraDrop = atoi(token);
				if (m_pMapList[iMapIndex]->m_iExtraDrop < 0) m_pMapList[iMapIndex]->m_iExtraDrop = 0;
				if (m_pMapList[iMapIndex]->m_iExtraDrop > 10000)  m_pMapList[iMapIndex]->m_iExtraDrop = 10000;
				cReadModeA = 0;
				cReadModeB = 0;
				break;	
			case 44: // boss-rate
				if (_bGetIsStringIsNumber(token) == FALSE) 
				{	PutLogList("(!!!) CRITICAL ERROR! Map Info file error boss-rate - Wrong Data format.");
					delete pContents; delete pStrTok; return FALSE;
				}
				m_pMapList[iMapIndex]->m_iBossAdjust = atoi(token);
				if (m_pMapList[iMapIndex]->m_iBossAdjust < 0) m_pMapList[iMapIndex]->m_iBossAdjust = 100;
				if (m_pMapList[iMapIndex]->m_iBossAdjust > 1000)  m_pMapList[iMapIndex]->m_iBossAdjust = 100;
				cReadModeA = 0;
				cReadModeB = 0;
				break;	


			default: 
				break;
			}
		}else 
		{	if (memcmp(token, "teleport-loc", 12) == 0) 
			{	m_pMapList[iMapIndex]->m_pTeleportLoc[iTeleportLocIndex] = new class CTeleportLoc;
				cReadModeA = 1;
				cReadModeB = 1;
			}
			if (memcmp(token, "waypoint", 8) == 0) 
			{	cReadModeA = 2;
				cReadModeB = 1;
			}
			if (memcmp(token, "npc", 3) == 0) 
			{	cReadModeA = 3;
				cReadModeB = 1;
			}
			if (memcmp(token, "random-mob-generator", 20) == 0) 
			{	cReadModeA = 4;
				cReadModeB = 1;
			}			
			if (memcmp(token, "maximum-object", 14) == 0) 
				cReadModeA = 5;
			if (memcmp(token, "npc-avoidrect", 13) == 0) 
			{	cReadModeA = 6;
				cReadModeB = 1;
			}
			if (memcmp(token, "spot-mob-generator", 18) == 0) 
			{	cReadModeA = 7;
				cReadModeB = 1;
			}
			if (memcmp(token, "map-location", 12) == 0)	cReadModeA = 8;
			if (memcmp(token, "initial-point", 13) == 0) 
			{	cReadModeA = 9;
				cReadModeB = 1;
			}
			if (memcmp(token, "no-attack-area", 14) == 0) 
			{	cReadModeA = 10;
				cReadModeB = 1;
			}
			if (memcmp(token, "fixed-dayornight-mode", 21) == 0) cReadModeA = 11;
			if (memcmp(token, "fish-point", 10) == 0) 
			{	cReadModeA = 12;
				cReadModeB = 1;
			}
			if (memcmp(token, "max-fish", 8) == 0)		cReadModeA = 13;	
			if (memcmp(token, "type", 4) == 0)			cReadModeA = 14;	
			if (memcmp(token, "level-limit", 11) == 0)	cReadModeA = 15;	
			if (memcmp(token, "mineral-generator", 17) == 0) 
			{	cReadModeA = 16;
				cReadModeB = 1;
			}
			if (memcmp(token, "mineral-point", 13) == 0) 
			{	cReadModeA = 17;
				cReadModeB = 1;
			}
			if (memcmp(token, "max-mineral", 11) == 0)			cReadModeA = 18;	
			if (memcmp(token, "upper-level-limit", 17) == 0)	cReadModeA = 19;	// v1.4
			if (memcmp(token, "strategic-point", 15) == 0) 	// v1.41
			{	cReadModeA = 20;	
				cReadModeB = 1;
			}
			if (memcmp(token, "energy-sphere-creation-point", 28) == 0) 
			{	cReadModeA = 21;
				cReadModeB = 1;
			}
			if (memcmp(token, "energy-sphere-goal-point", 24) == 0) 
			{	cReadModeA = 22;
				cReadModeB = 1;
			}
			if (memcmp(token, "strike-point", 12) == 0) 
			{	cReadModeA = 23;
				cReadModeB = 1;
			}			
			if (memcmp(token, "item-event", 10) == 0) 
			{	cReadModeA = 24;
				cReadModeB = 1;
			}			
			if (memcmp(token, "mobevent-amount", 15) == 0) 
			{	cReadModeA = 25;
				cReadModeB = 1;
			}
			if (memcmp(token, "ApocalypseMobGenType", 20) == 0) 
			{	cReadModeA = 26;
				cReadModeB = 1;
			}
			if (memcmp(token, "ApocalypseBossMob", 17) == 0) 
			{	cReadModeA = 27;
				cReadModeB = 1;
			}
			if (memcmp(token, "DynamicGateType", 15) == 0) 
			{	cReadModeA = 28;
				cReadModeB = 1;
			}
			if (memcmp(token, "DynamicGateCoord", 16) == 0) 
			{	cReadModeA = 29;
				cReadModeB = 1;
			}
			if (memcmp(token, "RecallImpossible", 16) == 0) 
			{	cReadModeA = 30;
				cReadModeB = 1;
			}			
			if (memcmp(token, "ApocalypseMap", 13) == 0) 
			{	cReadModeA = 31;
				cReadModeB = 1;
			}			
			if (memcmp(token, "CitizenLimit", 12) == 0) 
			{	cReadModeA = 32;
				cReadModeB = 1;
			}
			if (memcmp(token, "HeldenianMap", 12) == 0) 
			{	cReadModeA = 33;
				cReadModeB = 1;
			}
			if (memcmp(token, "HeldenianTower", 14) == 0) 
			{	cReadModeA = 34;
				cReadModeB = 1;
			}
			if (memcmp(token, "HeldenianModeMap", 16) == 0) 
			{	cReadModeA = 35;
				cReadModeB = 1;
			}
			if (memcmp(token, "HeldenianWinningZone", 20) == 0) 
			{	cReadModeA = 36;
				cReadModeB = 1;
			}
			if (memcmp(token, "HeldenianGateDoor", 17) == 0) 
			{	cReadModeA = 37;
				cReadModeB = 1;
			}
			// SNOOPY: Added pk-mode
			if (memcmp(token, "pk-mode", 7) == 0) 
			{	cReadModeA = 38;
				cReadModeB = 1;
			}
			// SNOOPY: Added 	BOOL m_nIsNotParmanentMap;
			if (memcmp(token, "not-permanent-map", 17) == 0) 
			{	cReadModeA = 39;
				cReadModeB = 1;
			}
			// SNOOPY: Added 	int m_iDropType;
			if (memcmp(token, "drop-type", 9) == 0) 
			{	cReadModeA = 40;
				cReadModeB = 1;
			}
			// SNOOPY: Added 	m_bInsideBuildingLimitedCast
			if (memcmp(token, "limited-cast", 12) == 0) 
			{	cReadModeA = 41;
				cReadModeB = 1;
			}
			if (memcmp(token, "energy-sphere-auto-creation", 27) == 0) 
			{	cReadModeA = 0;
				cReadModeB = 0;
				m_pMapList[iMapIndex]->m_bIsEnergySphereAutoCreation = TRUE;
			}
			// SNOOPY: Added xp-rate
			if (memcmp(token, "xp-rate", 7) == 0) 
			{	cReadModeA = 42;
				cReadModeB = 1;
			}
			// SNOOPY: Added drop-rate
			if (memcmp(token, "extra-drop", 10) == 0) 
			{	cReadModeA = 43;
				cReadModeB = 1;
			}
			// SNOOPY: Added boss-rate
			if (memcmp(token, "boss-rate", 9) == 0) 
			{	cReadModeA = 44;
				cReadModeB = 1;
			}
			if (memcmp(token, "[END-MAP-INFO]", 14) == 0) 
			{	cReadModeA = 0;
				cReadModeB = 0;
				goto RMI_SKIPDECODING;
			}
		}
		token = pStrTok->pGet();
	}	
RMI_SKIPDECODING:;
	delete pStrTok;
	delete pContents;
	if ((cReadModeA != 0) || (cReadModeB != 0)) 
	{	PutLogList("(!!!) CRITICAL ERROR! map info file contents error!");
		return FALSE;
	}
	wsprintf(cTxt, "(!) Map info file decoding(%s) - success! TL(%d) WP(%d) LNPC(%d) MXO(%d) RMG(%d / %d)"
		, cFn
		, iTeleportLocIndex
		, iWayPointCfgIndex
		, iTotalNpcSetting
		, m_pMapList[iMapIndex]->m_iMaximumObject
		, m_pMapList[iMapIndex]->m_iRandomMobGeneratorSA
		, m_pMapList[iMapIndex]->m_cRandomMobGeneratorLevel);
	PutLogList(cTxt);
	// Crusade 
	m_pMapList[iMapIndex]->_SetupNoAttackArea();
	m_pMapList[iMapIndex]->m_bHpMpSpPopoEnabled = TRUE; 
	return TRUE;
}

void CGame::Quit()
{int i;	
	G_bIsThread = FALSE;
	Sleep(300);	
	if (m_pMainLogSock != NULL) delete m_pMainLogSock;
	if (m_pGateSock != NULL) delete m_pGateSock;

	for (i = 0; i < DEF_MAXSUBLOGSOCK; i++)	
	{	if (m_pSubLogSock[i] != NULL) 
		{	if (m_bIsSubLogSockAvailable[i] == FALSE) // Snoopy			
			{	wsprintf(G_cTxt,"Forgetting Socket(%d) (Not available) (binit) Pointer: %d - %d,", i,(int)m_pSubLogSock[i], m_bIsSubLogSockInitialPointer[i]);
				PutLogList(G_cTxt); 
			}else
			{	// Snoopy: test for valid pointer...
				if (m_bIsSubLogSockInitialPointer[i] != (int)m_pSubLogSock[i])
				{	wsprintf(G_cTxt,"Forgetting Socket(%d) (Just crashed) (binit) Pointer: %d - %d,", i,(int)m_pSubLogSock[i], m_bIsSubLogSockInitialPointer[i]);
					PutLogList(G_cTxt); 			
				}else
				{	wsprintf(G_cTxt,"Closing Socket(%d) (Was available) (binit) Pointer: %d - %d,", i,(int)m_pSubLogSock[i], m_bIsSubLogSockInitialPointer[i]);
					PutLogList(G_cTxt); 				
					try
					{	delete m_pSubLogSock[i]; // n°5 = EXCEPTION_ACCESS_VIOLATION
					}
					catch(int e) 
					{	wsprintf(G_cTxt,"Closing Socket(%d) CRASHED Exception code: %d ", i, e);
						PutLogList(G_cTxt); 
						Sleep(5000);
			}	}	}
			m_bIsSubLogSockInitialPointer[i] = 0;
			m_bIsSubLogSockAvailable[i] = FALSE;
	}	}
	PutLogList("Closed all Sockets..."); 

	for (i = 0; i < DEF_MAXCLIENTS; i++)
	if (m_pClientList[i] != NULL) delete m_pClientList[i];

	for (i = 0; i < DEF_MAXNPCS; i++)
	if (m_pNpcList[i] != NULL) delete m_pNpcList[i];

	for (i = 0; i < DEF_MAXMAPS; i++)
	if (m_pMapList[i] != NULL) delete m_pMapList[i];

	for (i = 0; i < DEF_MAXITEMTYPES; i++)
	if (m_pItemConfigList[i] != NULL) delete m_pItemConfigList[i];

	for (i = 0; i < DEF_MAXNPCTYPES; i++)
	if (m_pNpcConfigList[i] != NULL) delete m_pNpcConfigList[i];

	for (i = 0; i < DEF_MAXMAGICTYPE; i++)
	if (m_pMagicConfigList[i] != NULL) delete m_pMagicConfigList[i];

	for (i = 0; i < DEF_MAXSKILLTYPE; i++)
	if (m_pSkillConfigList[i] != NULL) delete m_pSkillConfigList[i];

	for (i = 0; i < DEF_MAXQUESTTYPE; i++)
	if (m_pQuestConfigList[i] != NULL) delete m_pQuestConfigList[i];

	for (i = 0; i < DEF_MAXDYNAMICOBJECTS; i++)
	if (m_pDynamicObjectList[i] != NULL) delete m_pDynamicObjectList[i];

	for (i = 0; i < DEF_MAXDELAYEVENTS; i++)
	if (m_pDelayEventList[i] != NULL) delete m_pDelayEventList[i];

	for (i = 0; i < DEF_MAXNOTIFYMSGS; i++)
	if (m_pNoticeMsgList[i] != NULL) delete m_pNoticeMsgList[i];

	for (i = 0; i < DEF_MAXFISHS; i++)
	if (m_pFish[i] != NULL) delete m_pFish[i];

	for (i = 0; i < DEF_MAXMINERALS; i++)
	if (m_pMineral[i] != NULL) delete m_pMineral[i];

	for (i = 0; i < DEF_MAXPORTIONTYPES; i++)
	{	if (m_pPortionConfigList[i] != NULL) delete m_pPortionConfigList[i];
		if (m_pCraftingConfigList[i] != NULL) delete m_pCraftingConfigList[i];	// Crafting
	}

	for (i = 0; i <  DEF_MAXTELEPORTLIST; i++)//#define DEF_MAXTELEPORTLIST	20
	if (m_pTeleportConfigList[i] != NULL) delete m_pTeleportConfigList[i];

	for (i = 0; i < DEF_MAXBUILDITEMS; i++) 
	if (m_pBuildItemList[i] != NULL) delete m_pBuildItemList[i];

	for (i = 0; i < DEF_MAXDUPITEMID; i++)
	if (m_pDupItemIDList[i] != NULL) delete m_pDupItemIDList[i];

	if (m_pNoticementData != NULL) delete m_pNoticementData;

}

int CGame::iGetLevelExp(int iLevel)
{
 int iRet;
	
	if (iLevel == 0) return 0;

	iRet = iGetLevelExp(iLevel - 1) + iLevel * ( 50 + (iLevel * (iLevel / 17) * (iLevel / 17) ) );

	return iRet;
}

int CGame::_iCalcSkillSSNpoint(int iLevel)
{
 int iRet;

	if (iLevel < 1) return 1;
	
	if (iLevel <= 50) 
		iRet = iLevel;
	else if (iLevel > 50) {
		iRet = ( iLevel * iLevel ) / 10;
	}

	return iRet;
}

BOOL CGame::bCheckLevelUp(int iClientH)
{BOOL bStr, bVit, bDex, bInt, bMag, bChr;
 char cLoopCnt;
	if (m_pClientList[iClientH] == NULL) return FALSE;
	if (m_pClientList[iClientH]->m_iExp < m_pClientList[iClientH]->m_iNextLevelExp) return FALSE;
	// No gizon for evil side
	if (   (m_pClientList[iClientH]->m_cSide == 4) 
		&& (m_pClientList[iClientH]->m_iLevel >= m_sEvilMaxPlayerLevel)) 		
	{	if (m_pClientList[iClientH]->m_iExp >= m_iLevelExpTable[m_sEvilMaxPlayerLevel+1]) 
		{	m_pClientList[iClientH]->m_iExp = m_iLevelExpTable[m_sEvilMaxPlayerLevel] + 1;
			wsprintf(G_cTxt, "(!) Excecutor get no Gizon point(%d): Player (%s) Level (%d) Experience(%d) Next Level Experience(%d)"
				, m_pClientList[iClientH]->m_iGizonItemUpgradeLeft
				, m_pClientList[iClientH]->m_cCharName
				, m_pClientList[iClientH]->m_iLevel
				, m_pClientList[iClientH]->m_iExp
				, m_pClientList[iClientH]->m_iNextLevelExp);
			PutLogList(G_cTxt);		
			PutLogFileList(G_cTxt);		
			ZeroMemory(G_cTxt,  sizeof(G_cTxt));	
			wsprintf(G_cTxt, "Executors cannot have Gizon point.");
			ShowClientMsg(iClientH,  "Gizons", G_cTxt);	
			//SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_IPACCOUNTINFO, NULL, NULL, NULL, G_cTxt);				
			return TRUE;
		}		
		return FALSE;
	}
	// Snoopy Implemented Gizon points increase above max server level...
	// Only 1 Gizon point is possible at a time
	if (   (m_pClientList[iClientH]->m_cSide != 4) 
		&& (m_pClientList[iClientH]->m_iLevel >= m_iPlayerMaxLevel)) {		
		if (m_pClientList[iClientH]->m_iExp >= m_pClientList[iClientH]->m_iNextLevelExp) {
			m_pClientList[iClientH]->m_iGizonItemUpgradeLeft ++;
			m_pClientList[iClientH]->m_iNextLevelExp = m_iLevelExpTable[m_iPlayerMaxLevel + 1];
			m_pClientList[iClientH]->m_iExp = m_iLevelExpTable[m_iPlayerMaxLevel] + 1;
			wsprintf(G_cTxt, "(!) Gizon point(%d): Player (%s) Level (%d) Experience(%d) Next Level Experience(%d)"
				, m_pClientList[iClientH]->m_iGizonItemUpgradeLeft
				, m_pClientList[iClientH]->m_cCharName
				, m_pClientList[iClientH]->m_iLevel
				, m_pClientList[iClientH]->m_iExp
				, m_pClientList[iClientH]->m_iNextLevelExp);
			PutLogList(G_cTxt);		
			PutLogFileList(G_cTxt);		
			ZeroMemory(G_cTxt,  sizeof(G_cTxt));	
			if (m_pClientList[iClientH]->m_iGizonItemUpgradeLeft == 1) {
				wsprintf(G_cTxt, "First gizon point obtained!");
			}else {
				wsprintf(G_cTxt, "Gizon point obtained!  ( Total: %d gizon points )"
				, m_pClientList[iClientH]->m_iGizonItemUpgradeLeft);
			}
			ShowClientMsg(iClientH,  "Gizons", G_cTxt);	
			//SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_IPACCOUNTINFO, NULL, NULL, NULL, G_cTxt);			
			SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_GIZONITEMUPGRADELEFT, m_pClientList[iClientH]->m_iGizonItemUpgradeLeft, NULL, NULL, NULL);
			return TRUE;
		}		
		return FALSE;
	}
	
	bStr = bVit = bDex = bInt = bMag = bChr = FALSE;
	cLoopCnt = 0;
	while (1) {
		if (cLoopCnt++ > 100) return FALSE; // 
		if (m_pClientList[iClientH]->m_iExp >= m_pClientList[iClientH]->m_iNextLevelExp) {
			m_pClientList[iClientH]->m_iLevel++;
			m_pClientList[iClientH]->m_iLU_Pool += 3; 
			if (m_pClientList[iClientH]->m_iStr > DEF_CHARPOINTLIMIT)      m_pClientList[iClientH]->m_iStr = DEF_CHARPOINTLIMIT;
			if (m_pClientList[iClientH]->m_iDex > DEF_CHARPOINTLIMIT)      m_pClientList[iClientH]->m_iDex = DEF_CHARPOINTLIMIT;
			if (m_pClientList[iClientH]->m_iVit > DEF_CHARPOINTLIMIT)      m_pClientList[iClientH]->m_iVit = DEF_CHARPOINTLIMIT;
			if (m_pClientList[iClientH]->m_iInt > DEF_CHARPOINTLIMIT)      m_pClientList[iClientH]->m_iInt = DEF_CHARPOINTLIMIT;
			if (m_pClientList[iClientH]->m_iMag > DEF_CHARPOINTLIMIT)      m_pClientList[iClientH]->m_iMag = DEF_CHARPOINTLIMIT;
			if (m_pClientList[iClientH]->m_iCharisma > DEF_CHARPOINTLIMIT) m_pClientList[iClientH]->m_iCharisma = DEF_CHARPOINTLIMIT;
			// Remove civ above lvl 100
			if (m_pClientList[iClientH]->m_iLevel > 100)
				if (m_pClientList[iClientH]->m_bIsPlayerCivil == TRUE)
					ForceChangePlayMode(iClientH, TRUE);
			SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_LEVELUP, NULL, NULL, NULL, NULL);
			m_pClientList[iClientH]->m_iNextLevelExp = m_iLevelExpTable[m_pClientList[iClientH]->m_iLevel + 1]; 
			// Don't change for Extra levels
			// You will not get a gizon point if having lvl 150 and 1st gizon at same time!
			if (m_pClientList[iClientH]->m_cSide == 4) 
			{	if (m_pClientList[iClientH]->m_iLevel >= m_sEvilMaxPlayerLevel)
				{	m_pClientList[iClientH]->m_iNextLevelExp = m_iLevelExpTable[m_sEvilMaxPlayerLevel + 1];
				}				
			}else
			{	if (m_pClientList[iClientH]->m_iLevel >= m_iPlayerMaxLevel) 
				{	m_pClientList[iClientH]->m_iNextLevelExp = m_iLevelExpTable[m_iPlayerMaxLevel + 1];
				}
			}
			CalcTotalItemEffect(iClientH, -1, FALSE);
			wsprintf(G_cTxt, "(!) Level up: Player (%s) Level (%d) Experience(%d) Next Level Experience(%d)", m_pClientList[iClientH]->m_cCharName,m_pClientList[iClientH]->m_iLevel, m_pClientList[iClientH]->m_iExp, m_pClientList[iClientH]->m_iNextLevelExp);
			PutLogList(G_cTxt);
			PutLogFileList(G_cTxt);
		}
		else { return TRUE; }
	}
	return FALSE;
}
// 2003-04-14 .
/////////////////////////////////////////////////////////////////////////////////////
//  StateChangeHandler(int iClientH, char * pData, DWORD dwMsgSize)
//  desc		 :: .
//	return value :: void
//  date		 :: [2003-04-14]    stupid koreans
/////////////////////////////////////////////////////////////////////////////////////
void CGame::StateChangeHandler(int iClientH, char * pData, DWORD dwMsgSize)
{char * cp, cStateChange1, cStateChange2, cStateChange3;
 char cStr, cVit, cDex, cInt, cMag, cChar;
 char cStateTxt[512];
 int iOldStr, iOldVit, iOldDex, iOldInt, iOldMag, iOldChar;
 int iTotalSetting = 0;	
	if (m_pClientList[iClientH] == NULL) return;
	if (m_pClientList[iClientH]->m_bIsInitComplete == FALSE) return;
	if (m_pClientList[iClientH]->m_iGizonItemUpgradeLeft <= 0) return;
	cStr = cVit = cDex = cInt = cMag = cChar = 0;
	cp = (char *)(pData + DEF_INDEX2_MSGTYPE + 2);
	cStateChange1 = *cp;
	cp++;
	cStateChange2 = *cp;
	cp++;
	cStateChange3 = *cp;
	cp++;
	iOldStr	= m_pClientList[iClientH]->m_iStr;
	iOldVit	= m_pClientList[iClientH]->m_iVit;
	iOldDex = m_pClientList[iClientH]->m_iDex;
	iOldInt = m_pClientList[iClientH]->m_iInt;
	iOldMag = m_pClientList[iClientH]->m_iMag;
	iOldChar = m_pClientList[iClientH]->m_iCharisma;	
	
	wsprintf(G_cTxt, "(*) Char(%s) Str(%d) Vit(%d) Dex(%d) Int(%d) Mag(%d) Chr(%d) ", m_pClientList[iClientH]->m_cCharName, m_pClientList[iClientH]->m_iStr, m_pClientList[iClientH]->m_iVit, m_pClientList[iClientH]->m_iDex, m_pClientList[iClientH]->m_iInt, m_pClientList[iClientH]->m_iMag, m_pClientList[iClientH]->m_iCharisma);
	PutLogList(G_cTxt);	
	if(!bChangeState(cStateChange1,&cStr,&cVit,&cDex,&cInt,&cMag,&cChar))
	{	// SNOOPY: Stats order was wrong here !
		SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_STATECHANGE_FAILED, NULL, NULL, NULL, NULL);
		return;
	}
	if(!bChangeState(cStateChange2,&cStr,&cVit,&cDex,&cInt,&cMag,&cChar))
	{	// SNOOPY: Stats order was wrong here !
		SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_STATECHANGE_FAILED, NULL, NULL, NULL, NULL);
		return;
	}
	if(!bChangeState(cStateChange3,&cStr,&cVit,&cDex,&cInt,&cMag,&cChar))
	{	// SNOOPY: Stats order was wrong here !
		SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_STATECHANGE_FAILED, NULL, NULL, NULL, NULL);
		return;
	}

	if(m_pClientList[iClientH]->m_iGuildRank == 0 )
	{	if(m_pClientList[iClientH]->m_iCharisma - cChar < 20)
		{	// gm cn't drop charisma below 20
			SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_STATECHANGE_FAILED, NULL, NULL, NULL, NULL);
			return;
	}	}
	//SNOOPY: Changed to fit actual character level
	//if(iOldStr +iOldVit	+iOldDex +iOldInt +iOldMag +iOldChar != (179*3 + 70))
	if(iOldStr +iOldVit	+iOldDex +iOldInt +iOldMag +iOldChar != (m_pClientList[iClientH]->m_iLevel*3 + 67))
	{	return;
	}
	if(cStr < 0 || cVit < 0 || cDex < 0 || cInt < 0 || cMag < 0 || cChar < 0
		|| cStr + cVit + cDex + cInt + cMag + cChar != 3)
	{	SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_STATECHANGE_FAILED, NULL, NULL, NULL, NULL);
		return;
	}
	if ((m_pClientList[iClientH]->m_iStr - cStr > DEF_CHARPOINTLIMIT) 
		 || (m_pClientList[iClientH]->m_iStr - cStr < 10)) 
	{	SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_STATECHANGE_FAILED, NULL, NULL, NULL, NULL);
		return;
	}

	if ((m_pClientList[iClientH]->m_iDex - cDex > DEF_CHARPOINTLIMIT) 
		 || (m_pClientList[iClientH]->m_iDex - cDex < 10)) 
	{	SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_STATECHANGE_FAILED, NULL, NULL, NULL, NULL);
		return;
	}
	if ((m_pClientList[iClientH]->m_iInt - cInt > DEF_CHARPOINTLIMIT) 
		 || (m_pClientList[iClientH]->m_iInt - cInt < 10)) 
	{	SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_STATECHANGE_FAILED, NULL, NULL, NULL, NULL);
		return;
	}
	if ((m_pClientList[iClientH]->m_iVit - cVit > DEF_CHARPOINTLIMIT) 
		 || (m_pClientList[iClientH]->m_iVit - cVit < 10)) 
	{	SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_STATECHANGE_FAILED, NULL, NULL, NULL, NULL);
		return;
	}
	if ((m_pClientList[iClientH]->m_iMag - cMag > DEF_CHARPOINTLIMIT) 
		 || (m_pClientList[iClientH]->m_iMag - cMag < 10)) 
	{	SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_STATECHANGE_FAILED, NULL, NULL, NULL, NULL);
		return;
	}
	if ((m_pClientList[iClientH]->m_iCharisma - cChar > DEF_CHARPOINTLIMIT)
		 || (m_pClientList[iClientH]->m_iCharisma - cChar < 10)) 
	{	SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_STATECHANGE_FAILED, NULL, NULL, NULL, NULL);
		return;
	}
	if (m_pClientList[iClientH]->m_iLU_Pool < 3) m_pClientList[iClientH]->m_iLU_Pool = 3;
	//m_pClientList[iClientH]->m_iLU_Pool += 3;	
	m_pClientList[iClientH]->m_iGizonItemUpgradeLeft--;
	m_pClientList[iClientH]->m_iStr  -= cStr;
	m_pClientList[iClientH]->m_iVit  -= cVit;
	m_pClientList[iClientH]->m_iDex  -= cDex;
	m_pClientList[iClientH]->m_iInt  -= cInt;
	m_pClientList[iClientH]->m_iMag  -= cMag;
	m_pClientList[iClientH]->m_iCharisma -= cChar;
	// Snoopy: Check max values here or character will be considered as hacker if reducing mana or vit
	if (m_pClientList[iClientH]->m_iHP > iGetMaxHP(iClientH)) m_pClientList[iClientH]->m_iHP = iGetMaxHP(iClientH, FALSE);
	if (m_pClientList[iClientH]->m_iMP > iGetMaxMP(iClientH)) m_pClientList[iClientH]->m_iMP = iGetMaxMP(iClientH);
	if (m_pClientList[iClientH]->m_iSP > iGetMaxSP(iClientH)) m_pClientList[iClientH]->m_iSP = iGetMaxSP(iClientH);
	ZeroMemory(cStateTxt,sizeof(cStateTxt));
	wsprintf(cStateTxt, "STR(%d->%d)VIT(%d->%d)DEX(%d->%d)INT(%d->%d)MAG(%d->%d)CHARISMA(%d->%d)",
		iOldStr, m_pClientList[iClientH]->m_iStr,
		iOldVit, m_pClientList[iClientH]->m_iVit,
		iOldDex, m_pClientList[iClientH]->m_iDex,
		iOldInt, m_pClientList[iClientH]->m_iInt,
		iOldMag, m_pClientList[iClientH]->m_iMag,
		iOldChar,m_pClientList[iClientH]->m_iCharisma				
		);
	PutLogList(cStateTxt);
	//_bCustomLog(DEF_ITEMLOG_CUSTOM,iClientH,NULL,cStateTxt);
	// SNOOPY: Check this, and notify client if no Spell change
	if  (bCheckMagicInt(iClientH) == FALSE)
		SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_STATECHANGE_SUCCESS, NULL, NULL, NULL, NULL);

}

// SNOOPY: revamped completlly this function...
/////////////////////////////////////////////////////////////////////////////////////
//  BOOL CGame::bCheckMagicInt(int iClientH)  
//  desc		 :: removes wrong spells, and add Priest/special spell if applicable
//	return value :: TRUE if has been notified to client (in case of changes)
//  date		 :: 2003-04-21
/////////////////////////////////////////////////////////////////////////////////////
BOOL CGame::bCheckMagicInt(int iClientH)
{	int sItemIndex;
	sItemIndex = m_pClientList[iClientH]->m_sItemEquipmentStatus[DEF_EQUIPPOS_HEAD];
	register int i; 
	int iCheckSum1, iCheckSum2;
	short sMagicCircle; // = (sType / 10) + 1;


	iCheckSum1 = 0;
	for(i = 0;i < DEF_MAXMAGICTYPE ;i++)
	{	if (   (m_pMagicConfigList[i] != NULL)
			&& (m_pClientList[iClientH]->m_cMagicMastery[i] != 0) )
		{	iCheckSum1 += i;
		}
	}

	for(i = 0;i < DEF_MAXMAGICTYPE ;i++)
	{	if(m_pMagicConfigList[i] != NULL) 
		{   // Remove hacked Mage spells
			if(    (m_pMagicConfigList[i]->m_sIntLimit > (m_pClientList[iClientH]->m_iInt + m_pClientList[iClientH]->m_iAngelicInt)) // SNOOPY: Don't apply to GMs
				&& (m_pClientList[iClientH]->m_iAdminUserLevel == 0))
			{	m_pClientList[iClientH]->m_cMagicMastery[i] = 0;	
			}			
			if(    (m_pMagicConfigList[i]->m_sIntLimit == 10) // SNOOPY: Don't apply to GMs
				&& (m_pClientList[iClientH]->m_iAdminUserLevel == 0))
			{	m_pClientList[iClientH]->m_cMagicMastery[i] = 0;	
			}
			// Add spells to Druids
			sMagicCircle = (i / 10) + 1;
			if (   (m_pClientList[iClientH]->m_iPriestDruidID == 2) //  Druid
				&& (m_pClientList[iClientH]->m_bSpecialFeatureAllowed)
				&& (m_pClientList[iClientH]->m_iCharisma >= sMagicCircle * 10)
				&& (m_pClientList[iClientH]->m_iDex >= sMagicCircle * 10)				
				&& (m_pMagicConfigList[i]->m_sIntLimit > 10))
			{	switch (m_pMagicConfigList[i]->m_iAttribute) {
				case 1: // Earth
					if (m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_bIsFixedDayMode != FALSE)
					m_pClientList[iClientH]->m_cMagicMastery[i] = 1;
					break;
				case 2: // Lightning
					break;
				case 3: // Fire
					if (m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_bIsFixedDayMode == FALSE)
					m_pClientList[iClientH]->m_cMagicMastery[i] = 1;
					break;
				case 4: // Ice
					break;
				default: // Misc spells
					break;
				}
			}
// This routine is intended to give those spells automatically to characters (and remove them if needed)
// Notice the reset of skills for Priests.

			// Allocate Paladin's spells
			switch(i){
			// 30 Char + Str
			case 1:  // Heal
				if ((m_pClientList[iClientH]->m_iCharisma > 29)
					&& ((m_pClientList[iClientH]->m_iStr + m_pClientList[iClientH]->m_iAngelicStr) > 29))
				{	m_pClientList[iClientH]->m_cMagicMastery[i] = 1;
				}
				break;
			case 2:  // Create food
				if ((m_pClientList[iClientH]->m_iCharisma > 29)
					&& ((m_pClientList[iClientH]->m_iStr + m_pClientList[iClientH]->m_iAngelicStr) > 29))
				{	m_pClientList[iClientH]->m_cMagicMastery[i] = 1;
				}
				break;
			case 12: // Recall
				if ((m_pClientList[iClientH]->m_iCharisma > 29)
					&& ((m_pClientList[iClientH]->m_iStr + m_pClientList[iClientH]->m_iAngelicStr) > 29))
				{	m_pClientList[iClientH]->m_cMagicMastery[i] = 1;
				}
				break;
			case 14: // Celebrating Light
				if ((m_pClientList[iClientH]->m_iCharisma > 29)
					&& ((m_pClientList[iClientH]->m_iStr + m_pClientList[iClientH]->m_iAngelicStr) > 29))
				{	m_pClientList[iClientH]->m_cMagicMastery[i] = 1;
				}
				break;

			// 35 Char+Str
			case 13: // Defence Shield
				if ((m_pClientList[iClientH]->m_iCharisma > 34)
					&& ((m_pClientList[iClientH]->m_iStr + m_pClientList[iClientH]->m_iAngelicStr) > 34))
				{	m_pClientList[iClientH]->m_cMagicMastery[i] = 1; 
				}
				break;
			case 15: // Stamina recovery
				if ((m_pClientList[iClientH]->m_iCharisma > 34)
					&& ((m_pClientList[iClientH]->m_iStr + m_pClientList[iClientH]->m_iAngelicStr) > 34))
				{	m_pClientList[iClientH]->m_cMagicMastery[i] = 1; 
				}
				break;
			case 33: // PFM
				if ((m_pClientList[iClientH]->m_iCharisma > 34)
					&& ((m_pClientList[iClientH]->m_iStr + m_pClientList[iClientH]->m_iAngelicStr) > 34))
				{	m_pClientList[iClientH]->m_cMagicMastery[i] = 1;
				}
				break;
			case 21: // Great Heal 
				if ((m_pClientList[iClientH]->m_iCharisma > 34)
					&& ((m_pClientList[iClientH]->m_iStr + m_pClientList[iClientH]->m_iAngelicStr) > 34))
				{	m_pClientList[iClientH]->m_cMagicMastery[i] = 1;
				}
				break;
			case 25: // Hold-Person 
				if ((m_pClientList[iClientH]->m_iCharisma > 34)
					&& ((m_pClientList[iClientH]->m_iStr + m_pClientList[iClientH]->m_iAngelicStr) > 34))
				{	m_pClientList[iClientH]->m_cMagicMastery[i] = 1;
				}
				break;
			case 36: // Cure 
				if ((m_pClientList[iClientH]->m_iCharisma > 34)
					&& ((m_pClientList[iClientH]->m_iStr + m_pClientList[iClientH]->m_iAngelicStr) > 34))
				{	m_pClientList[iClientH]->m_cMagicMastery[i] = 1;
				}
				break;

			// 40 Char+Str				
			case 24:  // PFA
				if ((m_pClientList[iClientH]->m_iCharisma > 39)
					&& ((m_pClientList[iClientH]->m_iStr + m_pClientList[iClientH]->m_iAngelicStr) > 39))
				{	m_pClientList[iClientH]->m_cMagicMastery[i] = 1;
				}
				if (   (m_pClientList[iClientH]->m_iPriestDruidID == 2)// Automatic for Druid
					&& (m_pClientList[iClientH]->m_bSpecialFeatureAllowed) )	
					m_pClientList[iClientH]->m_cMagicMastery[i] = 1;
				break;		
			case 17:  // Wood Mantle for druids only
				if (   (m_pClientList[iClientH]->m_iPriestDruidID == 2)// Automatic for Druid
					&& (m_pClientList[iClientH]->m_bSpecialFeatureAllowed) )	
					m_pClientList[iClientH]->m_cMagicMastery[i] = 1;
				break;
			case 22: // Tremor 
				if ((m_pClientList[iClientH]->m_iCharisma > 39)
					&& ((m_pClientList[iClientH]->m_iStr + m_pClientList[iClientH]->m_iAngelicStr) > 39))
				{	m_pClientList[iClientH]->m_cMagicMastery[i] = 1;
				}				
				if (   (m_pClientList[iClientH]->m_iPriestDruidID == 2)// Automatic for Druid
					&& (m_pClientList[iClientH]->m_bSpecialFeatureAllowed) )
					m_pClientList[iClientH]->m_cMagicMastery[i] = 1;
				break;
			case 23: // Great Stamina rec. 
				if ((m_pClientList[iClientH]->m_iCharisma > 39)
					&& ((m_pClientList[iClientH]->m_iStr + m_pClientList[iClientH]->m_iAngelicStr) > 39))
				{	m_pClientList[iClientH]->m_cMagicMastery[i] = 1;
				}
				break;

			// 45 Char+Str
			case 28: // Mass-Stamina-Recovery 
				if ((m_pClientList[iClientH]->m_iCharisma > 44)
					&& ((m_pClientList[iClientH]->m_iStr + m_pClientList[iClientH]->m_iAngelicStr) > 44))
				{	m_pClientList[iClientH]->m_cMagicMastery[i] = 1;
				}
				break;
			case 42:  // Confuse Langage
				if ((m_pClientList[iClientH]->m_iCharisma > 44)
					&& ((m_pClientList[iClientH]->m_iStr + m_pClientList[iClientH]->m_iAngelicStr) > 44))
				{	m_pClientList[iClientH]->m_cMagicMastery[i] = 1;
				}
				break;
			case 44: // Great Def Shield 
				if ((m_pClientList[iClientH]->m_iCharisma > 44)
					&& ((m_pClientList[iClientH]->m_iStr + m_pClientList[iClientH]->m_iAngelicStr) > 44))
				{	m_pClientList[iClientH]->m_cMagicMastery[i] = 1;
				}
				break;

			// 50 Char+Str
			case 38: // Prayer 
				if ((m_pClientList[iClientH]->m_iCharisma > 49)
					&& ((m_pClientList[iClientH]->m_iStr + m_pClientList[iClientH]->m_iAngelicStr) > 49))
				{	m_pClientList[iClientH]->m_cMagicMastery[i] = 1;
				}
				break;
			case 40: // Fire-Wall 
				if ((m_pClientList[iClientH]->m_iCharisma > 49)
					&& ((m_pClientList[iClientH]->m_iStr + m_pClientList[iClientH]->m_iAngelicStr) > 49))
				{	m_pClientList[iClientH]->m_cMagicMastery[i] = 1;
				}
				break;
			case 41: // Fire-Field 
				if ((m_pClientList[iClientH]->m_iCharisma > 49)
					&& ((m_pClientList[iClientH]->m_iStr + m_pClientList[iClientH]->m_iAngelicStr) > 49))
				{	m_pClientList[iClientH]->m_cMagicMastery[i] = 1;
				}
				break;
			case 48: // Critical-Heal 
				if ((m_pClientList[iClientH]->m_iCharisma > 49)
					&& ((m_pClientList[iClientH]->m_iStr + m_pClientList[iClientH]->m_iAngelicStr) > 49))
				{	m_pClientList[iClientH]->m_cMagicMastery[i] = 1;
				}
				break;
			case 50: // Berserk 
				if ((m_pClientList[iClientH]->m_iCharisma > 49)
					&& ((m_pClientList[iClientH]->m_iStr + m_pClientList[iClientH]->m_iAngelicStr) > 49))
				{	m_pClientList[iClientH]->m_cMagicMastery[i] = 1;
				}
				break;

			// 60 Char+Str
			case 16: // Peace
				if ((m_pClientList[iClientH]->m_iCharisma > 59)
					&& ((m_pClientList[iClientH]->m_iStr + m_pClientList[iClientH]->m_iAngelicStr) > 59))
				{	m_pClientList[iClientH]->m_cMagicMastery[i] = 1;
				}
				break;
			case 31:  // Summon Creature
				if ((m_pClientList[iClientH]->m_iCharisma > 59)
					&& ((m_pClientList[iClientH]->m_iStr + m_pClientList[iClientH]->m_iAngelicStr) > 59))
				{	m_pClientList[iClientH]->m_cMagicMastery[i] = 1;
				}
				if ((m_pClientList[iClientH]->m_iCharisma > 39)
					&& ((m_pClientList[iClientH]->m_iDex + m_pClientList[iClientH]->m_iAngelicDex) > 39)
					&& (m_pClientList[iClientH]->m_iPriestDruidID == 2)
					&& (m_pClientList[iClientH]->m_bSpecialFeatureAllowed))// Automatic for Druid
					m_pClientList[iClientH]->m_cMagicMastery[i] = 1;
				break;
			case 35:  // Paralyse
				if ((m_pClientList[iClientH]->m_iCharisma > 59)
					&& ((m_pClientList[iClientH]->m_iStr + m_pClientList[iClientH]->m_iAngelicStr) > 59))
				{	m_pClientList[iClientH]->m_cMagicMastery[i] = 1;
				}
				if ((m_pClientList[iClientH]->m_iCharisma > 39)
					&& ((m_pClientList[iClientH]->m_iDex + m_pClientList[iClientH]->m_iAngelicDex) > 39)
					&& (m_pClientList[iClientH]->m_iPriestDruidID == 2)
					&& (m_pClientList[iClientH]->m_bSpecialFeatureAllowed))// Automatic for Druid
					m_pClientList[iClientH]->m_cMagicMastery[i] = 1;
				break;
			case 52: // Polymorth 
				if ((m_pClientList[iClientH]->m_iCharisma > 59)
					&& ((m_pClientList[iClientH]->m_iStr + m_pClientList[iClientH]->m_iAngelicStr) > 59))
				{	m_pClientList[iClientH]->m_cMagicMastery[i] = 1;
				}
				break;

			// 70 Char+Str
			case 67:  // Scan
				if ((m_pClientList[iClientH]->m_iCharisma > 69)
					&& ((m_pClientList[iClientH]->m_iStr + m_pClientList[iClientH]->m_iAngelicStr) > 69))
				{	m_pClientList[iClientH]->m_cMagicMastery[i] = 1;
				}
				break;
			case 68: // Mass-Heal
				if ((m_pClientList[iClientH]->m_iCharisma > 69)
					&& ((m_pClientList[iClientH]->m_iStr + m_pClientList[iClientH]->m_iAngelicStr) > 69))
				{	m_pClientList[iClientH]->m_cMagicMastery[i] = 1;
				}
				break;
			case 75:  // Trance
				if ((m_pClientList[iClientH]->m_iCharisma > 69)
					&& ((m_pClientList[iClientH]->m_iStr + m_pClientList[iClientH]->m_iAngelicStr) > 69))
				{	m_pClientList[iClientH]->m_cMagicMastery[i] = 1;
				}
				break;

			// 80 Char+Str
			case 86: // Regenerate 
				if ((m_pClientList[iClientH]->m_iCharisma > 79)
					&& ((m_pClientList[iClientH]->m_iStr + m_pClientList[iClientH]->m_iAngelicStr) > 79))
				{	m_pClientList[iClientH]->m_cMagicMastery[i] = 1;
				}
				break;
			case 65:  // APFM
				if ((m_pClientList[iClientH]->m_iCharisma > 79)
					&& ((m_pClientList[iClientH]->m_iStr + m_pClientList[iClientH]->m_iAngelicStr) > 79))
				{	m_pClientList[iClientH]->m_cMagicMastery[i] = 1;
				}
				break;

			// 85 Char+Str
			case 87:  // Magic-Mantle
				if ((m_pClientList[iClientH]->m_iCharisma > 84)
					&& ((m_pClientList[iClientH]->m_iStr + m_pClientList[iClientH]->m_iAngelicStr) > 84)
					&& (m_pClientList[iClientH]->m_iPriestDruidID == 1))
				{	m_pClientList[iClientH]->m_cMagicMastery[i] = 1;
				}
				break;
			case 88: // Entangle
				if ((m_pClientList[iClientH]->m_iCharisma > 84)
					&& ((m_pClientList[iClientH]->m_iStr + m_pClientList[iClientH]->m_iAngelicStr) > 84)
					&& (m_pClientList[iClientH]->m_iPriestDruidID == 1))
				{	m_pClientList[iClientH]->m_cMagicMastery[i] = 1; 
				}
				if ((m_pClientList[iClientH]->m_iCharisma > 89)
					&& ((m_pClientList[iClientH]->m_iDex + m_pClientList[iClientH]->m_iAngelicDex) > 89)
					&& (m_pClientList[iClientH]->m_iPriestDruidID == 2)
					&& (m_pClientList[iClientH]->m_bSpecialFeatureAllowed) )// Automatic for Druid
					m_pClientList[iClientH]->m_cMagicMastery[i] = 1;
				break;
			// 90 Char+Str
			case 78:  // Divine-Revenge
				if ((m_pClientList[iClientH]->m_iCharisma > 89)
					&& ((m_pClientList[iClientH]->m_iStr + m_pClientList[iClientH]->m_iAngelicStr) > 89)
					&& (m_pClientList[iClientH]->m_iPriestDruidID == 1))
				{	m_pClientList[iClientH]->m_cMagicMastery[i] = 1;
				}else
				{	if (m_pClientList[iClientH]->m_iAdminUserLevel == 0) m_pClientList[iClientH]->m_cMagicMastery[i] = 0;
				}
				break;
			case 94: // 94 Resurection
				if ((m_pClientList[iClientH]->m_iCharisma > 89)
					&& ((m_pClientList[iClientH]->m_iStr + m_pClientList[iClientH]->m_iAngelicStr) > 89)
					&& (m_pClientList[iClientH]->m_iPriestDruidID == 1)
					&&  (m_pClientList[iClientH]->m_iSpecialAbilityTime < 1))
				{	m_pClientList[iClientH]->m_cMagicMastery[i] = 1; // Resurection
					//SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_STATECHANGE_SUCCESS, NULL, NULL, NULL, NULL);
				}
				break;

// FINALLY ALCHEMISTS & MANUF SPELLS
			// Alchemist Spell
			case 5:  // Ultimate-Elixir 
				if (m_pClientList[iClientH]->m_cSkillMastery[12] > 89)
				{	m_pClientList[iClientH]->m_cMagicMastery[i] = 1; // Ultimate-Elixir 
				}
				break;
			case 6: // Manuf Spell
				if (m_pClientList[iClientH]->m_cSkillMastery[13] > 79)
				{	m_pClientList[iClientH]->m_cMagicMastery[i] = 1; // Forge-Breath 
				}
				break;
			} // End of spell number loop
		}
	}
	iCheckSum2 = 0;
	for(i = 0;i < DEF_MAXMAGICTYPE ;i++)
	{	if (   (m_pMagicConfigList[i] != NULL)
			&& (m_pClientList[iClientH]->m_cMagicMastery[i] != 0) )
		{	iCheckSum2 += i;
		}
	}	
	if (iCheckSum1 != iCheckSum2)
	{	// Only notify if has changed
		SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_STATECHANGE_SUCCESS, NULL, NULL, NULL, NULL);
		return TRUE;
	}else return FALSE;
}

// 2003-04-14 .
/////////////////////////////////////////////////////////////////////////////////////
//  bChangeState(char cStateChange 
//  		  ,char* cStr, char *cVit,char *cDex,char *cInt,char *cMag,char *cChar)
//	return value :: BOOL(FASLE)
//  date		 :: [2003-04-14] 
/////////////////////////////////////////////////////////////////////////////////////
BOOL CGame::bChangeState(char cStateChange, char* cStr, char *cVit,char *cDex,char *cInt,char *cMag,char *cChar)
{	if(cStateChange == DEF_STR)
	{	*cStr += 1;
	}else if(cStateChange == DEF_VIT)
	{	*cVit += 1;
	}else if(cStateChange == DEF_DEX)
	{	*cDex += 1;
	}else if(cStateChange == DEF_INT)
	{	*cInt += 1;
	}else if(cStateChange == DEF_MAG)
	{	*cMag += 1;
	}else if(cStateChange == DEF_CHR)
	{	*cChar += 1;
	}else
	{	return FALSE;
	}
	return cStateChange;
}

void CGame::LevelUpSettingsHandler(int iClientH, char * pData, DWORD dwMsgSize)
{char * cp, cStr, cVit, cDex, cInt, cMag, cChar;
 int iTotalSetting = 0;
	if (m_pClientList[iClientH] == NULL) return;
	if (m_pClientList[iClientH]->m_bIsInitComplete == FALSE) return;
	if (m_pClientList[iClientH]->m_iLU_Pool <= 0) 
	{	SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_SETTING_FAILED, NULL, NULL, NULL, NULL);
		return ;
	}
	cp = (char *)(pData + DEF_INDEX2_MSGTYPE + 2);
	cStr = *cp;
	cp++;
	cVit = *cp;
	cp++;
	cDex = *cp;
	cp++;
	cInt = *cp;
	cp++;
	cMag = *cp;
	cp++;
	cChar = *cp;
	cp++;
	if ( (cStr + cVit + cDex + cInt + cMag + cChar) > m_pClientList[iClientH]->m_iLU_Pool)  // -3
	{	SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_SETTING_FAILED, NULL, NULL, NULL, NULL);
			return;
	}

	// Level-Up Setting
	if ((m_pClientList[iClientH]->m_iStr + cStr > DEF_CHARPOINTLIMIT) || (cStr < 0)) 
	{	SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_SETTING_FAILED, NULL, NULL, NULL, NULL);
		return;
	}
	if ((m_pClientList[iClientH]->m_iDex + cDex > DEF_CHARPOINTLIMIT) || (cDex < 0)) 
	{	SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_SETTING_FAILED, NULL, NULL, NULL, NULL);
		return;
	}
	if ((m_pClientList[iClientH]->m_iInt + cInt > DEF_CHARPOINTLIMIT) || (cInt < 0)) 
	{	SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_SETTING_FAILED, NULL, NULL, NULL, NULL);
		return;
	}
	if ((m_pClientList[iClientH]->m_iVit + cVit > DEF_CHARPOINTLIMIT) || (cVit < 0)) 
	{	SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_SETTING_FAILED, NULL, NULL, NULL, NULL);
		return;
	}
	if ((m_pClientList[iClientH]->m_iMag + cMag > DEF_CHARPOINTLIMIT) || (cMag < 0)) 
	{	SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_SETTING_FAILED, NULL, NULL, NULL, NULL);
		return;
	}
	if ((m_pClientList[iClientH]->m_iCharisma + cChar > DEF_CHARPOINTLIMIT) || (cChar < 0))
	{	SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_SETTING_FAILED, NULL, NULL, NULL, NULL);
		return;
	} 
	iTotalSetting = m_pClientList[iClientH]->m_iStr + m_pClientList[iClientH]->m_iDex + m_pClientList[iClientH]->m_iVit + 
		m_pClientList[iClientH]->m_iInt + m_pClientList[iClientH]->m_iMag + m_pClientList[iClientH]->m_iCharisma;

	if (iTotalSetting + m_pClientList[iClientH]->m_iLU_Pool -3 > ((m_pClientList[iClientH]->m_iLevel-1)*3 + 70))
	{	int bobdole;
		bobdole = 3;
		m_pClientList[iClientH]->m_iLU_Pool = 3 + (m_pClientList[iClientH]->m_iLevel-1)*3 + 70 - iTotalSetting;
		if(m_pClientList[iClientH]->m_iLU_Pool < 3)
			m_pClientList[iClientH]->m_iLU_Pool = 3;
		SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_SETTING_FAILED, NULL, NULL, NULL, NULL);
		return ;
	}
	if (iTotalSetting + (cStr + cVit + cDex + cInt + cMag + cChar)
		>	((m_pClientList[iClientH]->m_iLevel-1)*3 + 70)) 
	{	SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_SETTING_FAILED, NULL, NULL, NULL, NULL);
		return;
	}
	m_pClientList[iClientH]->m_iLU_Pool = m_pClientList[iClientH]->m_iLU_Pool - (cStr + cVit + cDex + cInt + cMag + cChar);
	m_pClientList[iClientH]->m_iStr  += cStr;
	m_pClientList[iClientH]->m_iVit  += cVit;
	m_pClientList[iClientH]->m_iDex  += cDex;
	m_pClientList[iClientH]->m_iInt  += cInt;
	m_pClientList[iClientH]->m_iMag  += cMag;
	m_pClientList[iClientH]->m_iCharisma += cChar;	
	//bCheckMagicInt(iClientH); // SNOOPY: Will notify client if Spell change
	//SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_SETTING_SUCCESS, NULL, NULL, NULL, NULL);
	//DEF_NOTIFY_STATECHANGE_SUCCESS
	// SNOOPY: Check this, and notify client if no Spell change
	if  (bCheckMagicInt(iClientH) == FALSE)
		SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_STATECHANGE_SUCCESS, NULL, NULL, NULL, NULL);
}

void CGame::FightzoneReserveHandler(int iClientH, char * pData, DWORD dwMsgSize)
{
 char cData[100];
 int iFightzoneNum ,* ip ,  iEnableReserveTime ;
 DWORD * dwp, dwGoldCount ;
 WORD  * wp, wResult;
 int     iRet, iResult=1, iCannotReserveDay;
 SYSTEMTIME SysTime;
 
	if (m_pClientList[iClientH] == NULL) return;
	if (m_pClientList[iClientH]->m_bIsInitComplete == FALSE) return; 
	GetLocalTime(&SysTime);
	iEnableReserveTime  = 2*20*60 - ((SysTime.wHour%2)*20*60 + SysTime.wMinute*20) - 5*20;	
	dwGoldCount = dwGetItemCount(iClientH, "Gold");		
	ip = (int *)(pData + DEF_INDEX2_MSGTYPE + 2);
	iFightzoneNum = *ip;
	if ((iFightzoneNum < 1) || (iFightzoneNum > DEF_MAXFIGHTZONE)) return;
	iCannotReserveDay = (SysTime.wDay + m_pClientList[iClientH]->m_cSide + iFightzoneNum ) % 2 ;
	if (iEnableReserveTime <= 0 )
	{	wResult = DEF_MSGTYPE_REJECT;
		iResult = 0 ;
	}else if (m_iFightZoneReserve[iFightzoneNum-1] != 0)
	{	wResult = DEF_MSGTYPE_REJECT;
		iResult = -1 ;
	}else if ( dwGoldCount < 1500 ) 
	{	wResult = DEF_MSGTYPE_REJECT;
		iResult = -2 ;	           
	}else if( iCannotReserveDay ) 
	{	wResult = DEF_MSGTYPE_REJECT;
		iResult = -3 ;
	}else if( m_pClientList[iClientH]-> m_iFightzoneNumber != 0 ) 
	{	wResult = DEF_MSGTYPE_REJECT;
		iResult = -4 ;
	}else 
	{	wResult = DEF_MSGTYPE_CONFIRM;
		SetItemCount(iClientH, "Gold", dwGoldCount - 1500);
		iCalcTotalWeight(iClientH);
		m_iFightZoneReserve[iFightzoneNum-1] = iClientH;		
		m_pClientList[iClientH]->m_iFightzoneNumber  = iFightzoneNum ;
		m_pClientList[iClientH]->m_iReserveTime	 =  SysTime.wMonth*10000 + SysTime.wDay*100 + SysTime.wHour ;  
		if (SysTime.wHour%2 )	m_pClientList[iClientH]->m_iReserveTime  += 1  ;
		else					m_pClientList[iClientH]->m_iReserveTime  += 2  ; 
		wsprintf(G_cTxt, "(*) Reserve FIGHTZONETICKET : Char(%s) TICKENUMBER (%d)", m_pClientList[iClientH]->m_cCharName, m_pClientList[iClientH]->m_iReserveTime);		
		PutLogList(G_cTxt);
		PutLogEventFileList(G_cTxt);
		m_pClientList[iClientH]->m_iFightZoneTicketNumber  = 50 ;  
		iResult = 1 ;
	}  
	ZeroMemory(cData, sizeof(cData));
	dwp = (DWORD *)(cData + DEF_INDEX4_MSGID);
	*dwp = MSGID_RESPONSE_FIGHTZONE_RESERVE;
	wp = (WORD *)(cData + DEF_INDEX2_MSGTYPE);
	*wp =  wResult ;
	ip  = (int *)(cData + DEF_INDEX2_MSGTYPE+2) ; 
	*ip =  iResult ;
	ip+= 4;			
	iRet = m_pClientList[iClientH]->m_pXSock->iSendMsg(cData, 10); 
	switch (iRet) {
		case DEF_XSOCKEVENT_QUENEFULL:
		case DEF_XSOCKEVENT_SOCKETERROR:
		case DEF_XSOCKEVENT_CRITICALERROR:
		case DEF_XSOCKEVENT_SOCKETCLOSED:
		DeleteClient(iClientH, TRUE, TRUE);
		return;
	}
}

BOOL CGame::bCheckLimitedUser(int iClientH)
{	if (m_pClientList[iClientH] == NULL) return FALSE;	
	if (    (m_pClientList[iClientH]->m_cSide == 0)
		 && (m_pClientList[iClientH]->m_iExp >= m_iLevelExp20)) 
	{	m_pClientList[iClientH]->m_iExp = m_iLevelExp20 - 1;	
		SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_TRAVELERLIMITEDLEVEL, NULL, NULL, NULL, NULL);
		return TRUE;
	}
	return FALSE;
}

BOOL CGame::bCheckPLRaider(int iClientH)
{	if (m_pClientList[iClientH] == NULL) return FALSE;	
	if (   (m_pClientList[iClientH]->m_bIsLimitedUser == TRUE)
		&& ((m_pClientList[iClientH]->m_cSide == 1) || (m_pClientList[iClientH]->m_cSide == 2))
		&& (m_pClientList[iClientH]->m_iExp >= m_iLimitedUserExp) ) 
	{	m_pClientList[iClientH]->m_iExp = m_iLimitedUserExp - 1;	
		SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_TRAVELERLIMITEDLEVEL, NULL, NULL, NULL, NULL);
		return TRUE;
	}
	return FALSE;
}
void CGame::RequestCivilRightHandler(int iClientH, char *pData)
{
 char * cp, cData[100];
 DWORD * dwp;
 WORD * wp, wResult;
 int  iRet;
	if (m_pClientList[iClientH] == NULL) return;
	if (m_pClientList[iClientH]->m_bIsInitComplete == FALSE) return;
	if ((m_bAdminSecurity == TRUE) && (m_pClientList[iClientH]->m_iAdminUserLevel > 0)) return;
	if (memcmp(m_pClientList[iClientH]->m_cLocation, "NONE", 4) != 0) wResult = 0;
	else wResult = 1;
	if (m_pClientList[iClientH]->m_iLevel < 5) wResult = 0;	

	if (wResult == 1)  // Request citizenship
	{	ZeroMemory(m_pClientList[iClientH]->m_cLocation, sizeof(m_pClientList[iClientH]->m_cLocation));
		strcpy(m_pClientList[iClientH]->m_cLocation, m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cLocationName);
	}
	// Side 
	if (memcmp(m_pClientList[iClientH]->m_cLocation, "are", 3) == 0) 
		m_pClientList[iClientH]->m_cSide = 1;

	if (memcmp(m_pClientList[iClientH]->m_cLocation, "elv", 3) == 0) 
		m_pClientList[iClientH]->m_cSide = 2;

	//SNOOPY, for Equilibrium's William
	if (m_pClientList[iClientH]->m_cSide == 0)
	{	ZeroMemory(m_pClientList[iClientH]->m_cLocation, sizeof(m_pClientList[iClientH]->m_cLocation));
		strcpy(m_pClientList[iClientH]->m_cLocation, "NONE"); 
		return;
	}
	dwp  = (DWORD *)(cData + DEF_INDEX4_MSGID);
	*dwp = MSGID_RESPONSE_CIVILRIGHT;
	wp   = (WORD *)(cData + DEF_INDEX2_MSGTYPE);
	*wp  = wResult;

	// v1.41 
	cp = (char *)(cData + DEF_INDEX2_MSGTYPE + 2);
	memcpy(cp, m_pClientList[iClientH]->m_cLocation, 10);
	cp += 10;

	iRet = m_pClientList[iClientH]->m_pXSock->iSendMsg(cData, 16);
	switch (iRet) {
	case DEF_XSOCKEVENT_QUENEFULL:
	case DEF_XSOCKEVENT_SOCKETERROR:
	case DEF_XSOCKEVENT_CRITICALERROR:
	case DEF_XSOCKEVENT_SOCKETCLOSED:
		DeleteClient(iClientH, TRUE, TRUE);
		return;
	}
	SendEventToNearClient_TypeA(iClientH, DEF_OWNERTYPE_PLAYER, MSGID_EVENT_MOTION, DEF_OBJECTNULLACTION, NULL, NULL, NULL);
}

void CGame::RequestRetrieveItemHandler(int iClientH, char *pData)
{
 char * cp, cBankItemIndex, cMsg[100];
 register int i, j, iRet, iItemWeight;
 DWORD * dwp;
 WORD * wp;

	if (m_pClientList[iClientH] == NULL) return;
	if (m_pClientList[iClientH]->m_bIsInitComplete == FALSE) return;

	cp = (char *)(pData + DEF_INDEX2_MSGTYPE + 2);
	cBankItemIndex = *cp;
	if (m_pClientList[iClientH]->m_bIsInsideWarehouse == FALSE) return;

	if ((cBankItemIndex < 0) || (cBankItemIndex >= DEF_MAXBANKITEMS)) return;
	if (m_pClientList[iClientH]->m_pItemInBankList[cBankItemIndex] == NULL) {
		// 
		ZeroMemory(cMsg, sizeof(cMsg));
			
		dwp  = (DWORD *)(cMsg + DEF_INDEX4_MSGID);
		*dwp = MSGID_RESPONSE_RETRIEVEITEM;
		wp   = (WORD *)(cMsg + DEF_INDEX2_MSGTYPE);
		*wp  = DEF_MSGTYPE_REJECT;

		iRet = m_pClientList[iClientH]->m_pXSock->iSendMsg(cMsg, 8);
	}
	else {
		/*
		if ( (m_pClientList[iClientH]->m_pItemInBankList[cBankItemIndex]->m_cItemType == DEF_ITEMTYPE_CONSUME) ||
			 (m_pClientList[iClientH]->m_pItemInBankList[cBankItemIndex]->m_cItemType == DEF_ITEMTYPE_ARROW) ) {
			//iItemWeight = m_pClientList[iClientH]->m_pItemInBankList[cBankItemIndex]->m_wWeight * m_pClientList[iClientH]->m_pItemInBankList[cBankItemIndex]->m_dwCount;
			iItemWeight = iGetItemWeight(m_pClientList[iClientH]->m_pItemInBankList[cBankItemIndex], m_pClientList[iClientH]->m_pItemInBankList[cBankItemIndex]->m_dwCount);
		}
		else iItemWeight = iGetItemWeight(m_pClientList[iClientH]->m_pItemInBankList[cBankItemIndex], 1); //m_pClientList[iClientH]->m_pItemInBankList[cBankItemIndex]->m_wWeight;
		*/
		// v1.432
		iItemWeight = iGetItemWeight(m_pClientList[iClientH]->m_pItemInBankList[cBankItemIndex], m_pClientList[iClientH]->m_pItemInBankList[cBankItemIndex]->m_dwCount);
		
		if ( (iItemWeight + m_pClientList[iClientH]->m_iCurWeightLoad) > _iCalcMaxLoad(iClientH)) {
			ZeroMemory(cMsg, sizeof(cMsg));
			
			dwp  = (DWORD *)(cMsg + DEF_INDEX4_MSGID);
			*dwp = MSGID_NOTIFY;
			wp   = (WORD *)(cMsg + DEF_INDEX2_MSGTYPE);
			*wp  = DEF_NOTIFY_CANNOTCARRYMOREITEM;
			
			iRet = m_pClientList[iClientH]->m_pXSock->iSendMsg(cMsg, 6);
			switch (iRet) {
			case DEF_XSOCKEVENT_QUENEFULL:
			case DEF_XSOCKEVENT_SOCKETERROR:
			case DEF_XSOCKEVENT_CRITICALERROR:
			case DEF_XSOCKEVENT_SOCKETCLOSED:
				DeleteClient(iClientH, TRUE, TRUE);
				break;
			}
			return;
		}
		
		//!!!
		if ( (m_pClientList[iClientH]->m_pItemInBankList[cBankItemIndex]->m_cItemType == DEF_ITEMTYPE_CONSUME) || 
			 (m_pClientList[iClientH]->m_pItemInBankList[cBankItemIndex]->m_cItemType == DEF_ITEMTYPE_ARROW) ) {
			for (i = 0; i < DEF_MAXITEMS; i++)
			if ( (m_pClientList[iClientH]->m_pItemList[i] != NULL) && 
				 (m_pClientList[iClientH]->m_pItemList[i]->m_cItemType == m_pClientList[iClientH]->m_pItemInBankList[cBankItemIndex]->m_cItemType) && 
			 	 (memcmp(m_pClientList[iClientH]->m_pItemList[i]->m_cName, m_pClientList[iClientH]->m_pItemInBankList[cBankItemIndex]->m_cName, 20) == 0) ) {
				// 
				// v1.41 !!! 
				SetItemCount(iClientH, i, m_pClientList[iClientH]->m_pItemList[i]->m_dwCount + m_pClientList[iClientH]->m_pItemInBankList[cBankItemIndex]->m_dwCount);
				
				delete m_pClientList[iClientH]->m_pItemInBankList[cBankItemIndex];
				m_pClientList[iClientH]->m_pItemInBankList[cBankItemIndex] = NULL;

				for ( j = 0; j <= DEF_MAXBANKITEMS - 2; j++) {
					if ((m_pClientList[iClientH]->m_pItemInBankList[j+1] != NULL) && (m_pClientList[iClientH]->m_pItemInBankList[j] == NULL)) {
						m_pClientList[iClientH]->m_pItemInBankList[j] = m_pClientList[iClientH]->m_pItemInBankList[j+1];	
						
						m_pClientList[iClientH]->m_pItemInBankList[j+1] = NULL;
					}
				}
				
				ZeroMemory(cMsg, sizeof(cMsg));
					
				dwp  = (DWORD *)(cMsg + DEF_INDEX4_MSGID);
				*dwp = MSGID_RESPONSE_RETRIEVEITEM;
				wp   = (WORD *)(cMsg + DEF_INDEX2_MSGTYPE);
				*wp  = DEF_MSGTYPE_CONFIRM;
					
				cp = (char *)(cMsg + DEF_INDEX2_MSGTYPE + 2);
				*cp = cBankItemIndex;
				cp++;
				*cp = i;
				cp++;
			
				iCalcTotalWeight(iClientH);
				m_pClientList[iClientH]->m_cArrowIndex = _iGetArrowItemIndex(iClientH);
								
				iRet = m_pClientList[iClientH]->m_pXSock->iSendMsg(cMsg, 8);
				switch (iRet) {
				case DEF_XSOCKEVENT_QUENEFULL:
				case DEF_XSOCKEVENT_SOCKETERROR:
				case DEF_XSOCKEVENT_CRITICALERROR:
				case DEF_XSOCKEVENT_SOCKETCLOSED:
					DeleteClient(iClientH, TRUE, TRUE);
					return;
				}
				return;
			}

			goto RRIH_NOQUANTITY;
		} 
		else {
RRIH_NOQUANTITY:;
			for (i = 0; i < DEF_MAXITEMS; i++)
			if (m_pClientList[iClientH]->m_pItemList[i] == NULL) {
				m_pClientList[iClientH]->m_pItemList[i] = m_pClientList[iClientH]->m_pItemInBankList[cBankItemIndex];
				// v1.3 1-27 12:22
				m_pClientList[iClientH]->m_ItemPosList[i].x = 40;
				m_pClientList[iClientH]->m_ItemPosList[i].y = 30;
			
				m_pClientList[iClientH]->m_bIsItemEquipped[i] = FALSE;
				
				m_pClientList[iClientH]->m_pItemInBankList[cBankItemIndex] = NULL;
				
				for ( j = 0; j <= DEF_MAXBANKITEMS - 2; j++) {
					if ((m_pClientList[iClientH]->m_pItemInBankList[j+1] != NULL) && (m_pClientList[iClientH]->m_pItemInBankList[j] == NULL)) {
						m_pClientList[iClientH]->m_pItemInBankList[j] = m_pClientList[iClientH]->m_pItemInBankList[j+1];	
						
						m_pClientList[iClientH]->m_pItemInBankList[j+1] = NULL;
					}
				}
								
				ZeroMemory(cMsg, sizeof(cMsg));
					
				dwp  = (DWORD *)(cMsg + DEF_INDEX4_MSGID);
				*dwp = MSGID_RESPONSE_RETRIEVEITEM;
				wp   = (WORD *)(cMsg + DEF_INDEX2_MSGTYPE);
				*wp  = DEF_MSGTYPE_CONFIRM;
					
				cp = (char *)(cMsg + DEF_INDEX2_MSGTYPE + 2);
				*cp = cBankItemIndex;
				cp++;
				*cp = i;
				cp++;
					
				iCalcTotalWeight(iClientH);
				m_pClientList[iClientH]->m_cArrowIndex = _iGetArrowItemIndex(iClientH);
				iRet = m_pClientList[iClientH]->m_pXSock->iSendMsg(cMsg, 8);
				switch (iRet) {
				case DEF_XSOCKEVENT_QUENEFULL:
				case DEF_XSOCKEVENT_SOCKETERROR:
				case DEF_XSOCKEVENT_CRITICALERROR:
				case DEF_XSOCKEVENT_SOCKETCLOSED:
					DeleteClient(iClientH, TRUE, TRUE);
					return;
				}
				return;
			}
			ZeroMemory(cMsg, sizeof(cMsg));
			
			dwp  = (DWORD *)(cMsg + DEF_INDEX4_MSGID);
			*dwp = MSGID_RESPONSE_RETRIEVEITEM;
			wp   = (WORD *)(cMsg + DEF_INDEX2_MSGTYPE);
			*wp  = DEF_MSGTYPE_REJECT;
			
			iRet = m_pClientList[iClientH]->m_pXSock->iSendMsg(cMsg, 8);
		}
	}

	switch (iRet) {
	case DEF_XSOCKEVENT_QUENEFULL:
	case DEF_XSOCKEVENT_SOCKETERROR:
	case DEF_XSOCKEVENT_CRITICALERROR:
	case DEF_XSOCKEVENT_SOCKETCLOSED:
		DeleteClient(iClientH, TRUE, TRUE);
		return;
	}
}

BOOL CGame::bSetItemToBankItem(int iClientH, short sItemIndex)
{
 register int i, iRet;
 DWORD * dwp;
 WORD  * wp;
 char  * cp;
 short * sp;
 char cData[100];
 class CItem * pItem;

	
	// 
	if (m_pClientList[iClientH] == NULL) return FALSE;
	if ((sItemIndex < 0) || (sItemIndex >= DEF_MAXITEMS)) return FALSE;
	if (m_pClientList[iClientH]->m_pItemList[sItemIndex] == NULL) return FALSE;
	if (m_pClientList[iClientH]->m_bIsInsideWarehouse == FALSE) return FALSE;

	for (i = 0; i < DEF_MAXBANKITEMS; i++)
	if (m_pClientList[iClientH]->m_pItemInBankList[i] == NULL) {
		// 				
		m_pClientList[iClientH]->m_pItemInBankList[i] = m_pClientList[iClientH]->m_pItemList[sItemIndex];
		pItem = m_pClientList[iClientH]->m_pItemInBankList[i];
		// !!! 
		m_pClientList[iClientH]->m_pItemList[sItemIndex] = NULL;
		
		iCalcTotalWeight(iClientH);

		dwp  = (DWORD *)(cData + DEF_INDEX4_MSGID);			   
		*dwp = MSGID_NOTIFY;
		wp   = (WORD *)(cData + DEF_INDEX2_MSGTYPE);		       
		*wp  = DEF_NOTIFY_ITEMTOBANK;
				
		cp = (char *)(cData + DEF_INDEX2_MSGTYPE + 2);

		*cp = i; 
		cp++;

		*cp = 1;
		cp++;						    

		memcpy(cp, pItem->m_cName, 20);
		cp += 20;

		dwp  = (DWORD *)cp;
		*dwp = pItem->m_dwCount;
		cp += 4;

		*cp = pItem->m_cItemType;
		cp++;

		*cp = pItem->m_cEquipPos;
		cp++;

		*cp = (char)0; // Item is not equiped
		cp++;

		sp  = (short *)cp;
		*sp = pItem->m_sLevelLimit;
		cp += 2;
	
		*cp = pItem->m_cGenderLimit;
		cp++;
		
		wp = (WORD *)cp;
		*wp = pItem->m_wCurLifeSpan;
		cp += 2;

		wp = (WORD *)cp;
		*wp = pItem->m_wWeight;
		cp += 2;

		sp  = (short *)cp;
		*sp = pItem->m_sSprite;
		cp += 2;

		sp  = (short *)cp;
		*sp = pItem->m_sSpriteFrame;
		cp += 2;

		*cp = pItem->m_cItemColor;
		cp++;

		sp = (short *)cp;
		*sp = pItem->m_sItemEffectValue2;
		cp += 2;

		// v1.42
		dwp = (DWORD *)cp;
		*dwp = pItem->m_dwAttribute;
		cp += 4;

		//SNOOPY: Completion/Purity fix ?
		sp = (short *)cp;
		*cp = pItem->m_sItemSpecEffectValue2;
		cp += 2;


		// 	iRet = m_pClientList[iClientH]->m_pXSock->iSendMsg(cData, 55);
		iRet = m_pClientList[iClientH]->m_pXSock->iSendMsg(cData, 57);

		switch (iRet) {
		case DEF_XSOCKEVENT_QUENEFULL:
		case DEF_XSOCKEVENT_SOCKETERROR:
		case DEF_XSOCKEVENT_CRITICALERROR:
		case DEF_XSOCKEVENT_SOCKETCLOSED:
			// DeleteClient(iClientH, TRUE, TRUE);
			return TRUE; // v1.41 FALSE
		}

		return TRUE;
	}

	return FALSE;
}
// 05/21/2004 - Hypnotoad - send player to jail
void CGame::ApplyPKpenalty(short sAttackerH, short sVictumH)
{	if (m_pClientList[sAttackerH] == NULL) return;
	if (m_pClientList[sVictumH] == NULL) return;
	// Snoopy: GM do not become crim..
	if (m_pClientList[sAttackerH]->m_iAdminUserLevel >0) return;
	// No PK if in safe mode (usefull for arenas maps)
	if (   (m_pClientList[sAttackerH]->m_bIsSafeAttackMode == TRUE) 
		&& (m_pClientList[sAttackerH]->m_iPKCount == 0)) return;	
	// Snoopy: No PK point possible if map Type prevents it	
	if (m_pMapList[m_pClientList[sAttackerH]->m_cMapIndex]->m_cType == DEF_MAPTYPE_NOPCDROP_NOPK) return;
	// Snoopy: Suicide is not PK
	if (sVictumH == sAttackerH) 
	{	_bPKLog(DEF_PKLOG_BYSELF,sAttackerH,sVictumH,NULL) ;
		return; 
	}
	if (m_pClientList[sAttackerH]->m_cSide == 0) 
	{}else // Snoopy Traveller will not become crim (seen as Executors)
	{	m_pClientList[sAttackerH]->m_iPKCount++;
	}

	_bPKLog(DEF_PKLOG_BYPK,sAttackerH,sVictumH,NULL) ;

	int iV1, iV2;
	iV1 = iDice((m_pClientList[sVictumH]->m_iLevel/2)+1, 50); 
	iV2 = iDice((m_pClientList[sAttackerH]->m_iLevel/2)+1, 50);
	m_pClientList[sAttackerH]->m_iExp -= iV1; 
	m_pClientList[sAttackerH]->m_iExp -= iV2;
	if (m_pClientList[sAttackerH]->m_iExp < 0) m_pClientList[sAttackerH]->m_iExp = 0;
	SendNotifyMsg(NULL, sAttackerH, DEF_NOTIFY_PKPENALTY, NULL, NULL, NULL, NULL);	
	SendEventToNearClient_TypeA(sAttackerH, DEF_OWNERTYPE_PLAYER, MSGID_EVENT_MOTION, DEF_OBJECTNULLACTION, NULL, NULL, NULL);
	m_stCityStatus[m_pClientList[sAttackerH]->m_cSide].iCrimes++;
	// v1.41 Rating 
	m_pClientList[sAttackerH]->m_iRating -= 10;
	if (m_pClientList[sAttackerH]->m_iRating > 10000)  m_pClientList[sAttackerH]->m_iRating =  10000;
	if (m_pClientList[sAttackerH]->m_iRating < -10000) m_pClientList[sAttackerH]->m_iRating = -10000;
	AdjustClientDropRate(sAttackerH);
	
	// SNOOPY: Going to jail for crims depend on map-mode
	if (m_bMapModeEquilibrium)  // Equilibrium mode no Jail in cities, but no PK allowed in EQUI
	// Go to jail from: Equilibrium, EF, Garden, QM, Catacombs, and farms
	{	if (   (strcmp(m_pMapList[m_pClientList[sAttackerH]->m_cMapIndex]->m_cName, "lost")      == 0)  
			|| (strcmp(m_pMapList[m_pClientList[sAttackerH]->m_cMapIndex]->m_cName, "aresden")   == 0)   
			|| (strcmp(m_pMapList[m_pClientList[sAttackerH]->m_cMapIndex]->m_cName, "huntzone2") == 0) 
			|| (strcmp(m_pMapList[m_pClientList[sAttackerH]->m_cMapIndex]->m_cName, "areuni")    == 0)    
			|| (strcmp(m_pMapList[m_pClientList[sAttackerH]->m_cMapIndex]->m_cName, "qusmarsh")  == 0) 
			|| (strcmp(m_pMapList[m_pClientList[sAttackerH]->m_cMapIndex]->m_cName, "catacombs") == 0)    
			|| (strcmp(m_pMapList[m_pClientList[sAttackerH]->m_cMapIndex]->m_cName, "elvfarm")   == 0)    
			|| (strcmp(m_pMapList[m_pClientList[sAttackerH]->m_cMapIndex]->m_cName, "arefarm")   == 0)) 			
			// Go to Jail
		{	ZeroMemory(m_pClientList[sAttackerH]->m_cLockedMapName, sizeof(m_pClientList[sAttackerH]->m_cLockedMapName));
			if (m_pClientList[sAttackerH]->m_cSide == 1)
			{	strcpy(m_pClientList[sAttackerH]->m_cLockedMapName, "arejail");
				m_pClientList[sAttackerH]->m_iLockedMapTime = 60*3;
				RequestTeleportHandler(sAttackerH, "2   ", "arejail", -1, -1);
			}else if (m_pClientList[sAttackerH]->m_cSide == 2)		
			{	strcpy(m_pClientList[sAttackerH]->m_cLockedMapName, "elvjail");
				m_pClientList[sAttackerH]->m_iLockedMapTime = 60*3;
				RequestTeleportHandler(sAttackerH, "2   ", "elvjail", -1, -1);
			}else if (m_pClientList[sAttackerH]->m_cSide == 4)		
			{	strcpy(m_pClientList[sAttackerH]->m_cLockedMapName, "elvjail");
				m_pClientList[sAttackerH]->m_iLockedMapTime = 60*3;
				RequestTeleportHandler(sAttackerH, "2   ", "elvjail", -1, -1);
			}
			return;		
		}	
	}else  // Classic mode and criminals going to jail
	{	if (m_pClientList[sAttackerH]->m_cSide == 1) 
		{	if (   (strcmp(m_pMapList[m_pClientList[sAttackerH]->m_cMapIndex]->m_cName, "arebrk11") == 0) 
				|| (strcmp(m_pMapList[m_pClientList[sAttackerH]->m_cMapIndex]->m_cName, "arebrk12") == 0)  
				|| (strcmp(m_pMapList[m_pClientList[sAttackerH]->m_cMapIndex]->m_cName, "arebrk21") == 0)  
				|| (strcmp(m_pMapList[m_pClientList[sAttackerH]->m_cMapIndex]->m_cName, "arebrk22") == 0)  
				|| (strcmp(m_pMapList[m_pClientList[sAttackerH]->m_cMapIndex]->m_cName, "aresden")  == 0)   
				|| (strcmp(m_pMapList[m_pClientList[sAttackerH]->m_cMapIndex]->m_cName, "huntzone2")== 0) 
				|| (strcmp(m_pMapList[m_pClientList[sAttackerH]->m_cMapIndex]->m_cName, "areuni")   == 0)    
				|| (strcmp(m_pMapList[m_pClientList[sAttackerH]->m_cMapIndex]->m_cName, "arefarm")  == 0)) 
				// Go to Jail
			{	ZeroMemory(m_pClientList[sAttackerH]->m_cLockedMapName, sizeof(m_pClientList[sAttackerH]->m_cLockedMapName));
				strcpy(m_pClientList[sAttackerH]->m_cLockedMapName, "arejail");
				m_pClientList[sAttackerH]->m_iLockedMapTime = 60*3;
				RequestTeleportHandler(sAttackerH, "2   ", "arejail", -1, -1);
				return;	
		}	}
		if (m_pClientList[sAttackerH]->m_cSide == 2) 
		{	if (   (strcmp(m_pMapList[m_pClientList[sAttackerH]->m_cMapIndex]->m_cName, "elvbrk11") == 0)  
				|| (strcmp(m_pMapList[m_pClientList[sAttackerH]->m_cMapIndex]->m_cName, "elvbrk12") == 0)  
				|| (strcmp(m_pMapList[m_pClientList[sAttackerH]->m_cMapIndex]->m_cName, "elvbrk21") == 0)  
				|| (strcmp(m_pMapList[m_pClientList[sAttackerH]->m_cMapIndex]->m_cName, "elvbrk22") == 0)  
				|| (strcmp(m_pMapList[m_pClientList[sAttackerH]->m_cMapIndex]->m_cName, "elvine")   == 0)    
				|| (strcmp(m_pMapList[m_pClientList[sAttackerH]->m_cMapIndex]->m_cName, "huntzone1")== 0) 
				|| (strcmp(m_pMapList[m_pClientList[sAttackerH]->m_cMapIndex]->m_cName, "elvuni")   == 0)    
				|| (strcmp(m_pMapList[m_pClientList[sAttackerH]->m_cMapIndex]->m_cName, "elvfarm")  == 0)) 			
				// Go to Jail
			{	ZeroMemory(m_pClientList[sAttackerH]->m_cLockedMapName, sizeof(m_pClientList[sAttackerH]->m_cLockedMapName));
				strcpy(m_pClientList[sAttackerH]->m_cLockedMapName, "elvjail");
				m_pClientList[sAttackerH]->m_iLockedMapTime = 60*3;
				RequestTeleportHandler(sAttackerH, "2   ", "elvjail", -1, -1);
				return;	
	}	}	}
	if (   (m_bIsHeldenianMode == TRUE) 
		&& (m_pMapList[m_pClientList[sAttackerH]->m_cMapIndex]->m_bIsHeldenianMap == TRUE))
	{	ZeroMemory(m_pClientList[sAttackerH]->m_cLockedMapName, sizeof(m_pClientList[sAttackerH]->m_cLockedMapName));
		if (m_pClientList[sAttackerH]->m_cSide == 1)
		{	strcpy(m_pClientList[sAttackerH]->m_cLockedMapName, "arejail");
			m_pClientList[sAttackerH]->m_iLockedMapTime = 60*3;
			RequestTeleportHandler(sAttackerH, "2   ", "arejail", -1, -1);
		}else if (m_pClientList[sAttackerH]->m_cSide == 2)		
		{	strcpy(m_pClientList[sAttackerH]->m_cLockedMapName, "elvjail");
			m_pClientList[sAttackerH]->m_iLockedMapTime = 60*3;
			RequestTeleportHandler(sAttackerH, "2   ", "elvjail", -1, -1);
	}	}
}

// 05/17/2004 - Hypnotoad - register pk log
void CGame::PK_KillRewardHandler(short sAttackerH, short sVictumH)
{	if (m_pClientList[sAttackerH] == NULL) return;
	if (m_pClientList[sVictumH] == NULL)   return;
	_bPKLog(DEF_PKLOG_BYPLAYER,sAttackerH,sVictumH,NULL) ;
	if (m_pClientList[sAttackerH]->m_iPKCount != 0) 
	{}else 	// No effect if PK count is 0
	{	m_pClientList[sAttackerH]->m_iRewardGold += iGetExpLevel(m_pClientList[sVictumH]->m_iExp) * 3;
		if (m_pClientList[sAttackerH]->m_iRewardGold > DEF_MAXREWARDGOLD) 
			m_pClientList[sAttackerH]->m_iRewardGold = DEF_MAXREWARDGOLD;
		if (m_pClientList[sAttackerH]->m_iRewardGold < 0) 
			m_pClientList[sAttackerH]->m_iRewardGold = 0;
		SendNotifyMsg(NULL, sAttackerH, DEF_NOTIFY_PKCAPTURED, m_pClientList[sVictumH]->m_iPKCount, m_pClientList[sVictumH]->m_iLevel, NULL, m_pClientList[sVictumH]->m_cCharName);
	}
}

void CGame::EnemyKillRewardHandler(int iAttackerH, int iClientH)
{	// enemy-kill-mode = 1 | 0
	// DEATHMATCH MODE (1):
	// Aresden kills Elvine in Aresden and gets EK
	// Elvine kills Aresden in Aresden and gets an EK 
	// Elvine kills Aresden in Elvine and gets an EK
	// Aresden kills Elvine in Elvine and gets an EK
	// CLASSIC MODE (0):
	// Aresden kills Elvine in Aresden and gets EK
	// Elvine kills Aresden in Aresden and doesnt get an EK 
	// Elvine kills Aresden in Elvine and gets an EK
	// Aresden kills Elvine in Elvine and doesnt get an EK
	int iRewardExp, iEK_Level;
	// if the attacker doesnt exist no result
	if (m_pClientList[iAttackerH] == NULL) return;
	// if the target doesnt exist no result
	if (m_pClientList[iClientH] == NULL)   return;

	//Snoopy81: Variable EKs pts depending on Level difference
	int KillerLvl, DeadLvl, PKpoints;
	KillerLvl = m_pClientList[iAttackerH]->m_iLevel;
	DeadLvl = m_pClientList[iClientH]->m_iLevel;
	PKpoints = 0;
// SNOOPY: Tweaked EK points to be 1 per 10 lvl difference
// lvl 100 killing lvl 125, gets 2 points (may be mulptiplyed by m_iEnemyKillAdjust...
// victim lower lvl than killer gives 1pts regardless of m_iEnemyKillAdjust.
// victim lvl "servermax -10" always count normal EK points (with m_iEnemyKillAdjust)

// EK Levels set to 60(end of barracks) and 100(end of PL/Noob Dungeon)
	if (KillerLvl<=DeadLvl) 
	{	PKpoints = m_iEnemyKillAdjust+((DeadLvl-KillerLvl)/* *m_iEnemyKillAdjust*/)/10;
	} else 
	{	PKpoints = 1;	// lvl 140+ always count for a full XP point count	
		if ((m_iPlayerMaxLevel-10)<=DeadLvl) PKpoints = m_iEnemyKillAdjust;
	}	
	// set EK level to 60
	iEK_Level = 60;
	// if attacker's level is greater than 100, set ek level to 100
	if (m_pClientList[iAttackerH]->m_iLevel >= 100) iEK_Level = 100;
	// in this case give XP for the killing
	if (m_pClientList[iAttackerH]->m_iPKCount <= 0) // Criminals will not get EK points or XP, Gold, War contribution reward	 
	{	iRewardExp = (iDice(3, (3*iGetExpLevel(m_pClientList[iClientH]->m_iExp))) + iGetExpLevel(m_pClientList[iClientH]->m_iExp))/ 3 ;
		// No reward XP for lvl 150+
		if (   (m_pClientList[iAttackerH]->m_iLevel >= m_iPlayerMaxLevel) 
			&& (m_pClientList[iAttackerH]->m_cSide <3) // XP for executors 150+
			&& (m_bIsCrusadeMode == FALSE)) iRewardExp = 1;
		// In crusade time
		if (m_bIsCrusadeMode == TRUE) 
		{	m_pClientList[iAttackerH]->m_iExp += (iRewardExp * 2);
			m_pClientList[iAttackerH]->m_iConstructionPoint += (m_pClientList[iClientH]->m_iLevel / 2);
			m_pClientList[iAttackerH]->m_iWarContribution += (iRewardExp *8);
			if (m_pClientList[iAttackerH]->m_iConstructionPoint > DEF_MAXCONSTRUCTIONPOINT) 
				m_pClientList[iAttackerH]->m_iConstructionPoint = DEF_MAXCONSTRUCTIONPOINT;
			if (m_pClientList[iAttackerH]->m_iWarContribution > DEF_MAXWARCONTRIBUTION)
				m_pClientList[iAttackerH]->m_iWarContribution = DEF_MAXWARCONTRIBUTION;
			if (m_pClientList[iAttackerH]->m_iWarContribution >= 256*128)
				SendNotifyMsg(NULL, iAttackerH, DEF_NOTIFY_CONSTRUCTIONPOINT, m_pClientList[iAttackerH]->m_iConstructionPoint, (m_pClientList[iAttackerH]->m_iWarContribution %(256*128)), 1, NULL);
			wsprintf(G_cTxt, "Enemy Player Killed  : PC(%s) - WarContribution +%d - WarSummon +%d"
				, m_pClientList[iAttackerH]->m_cCharName
				, (iRewardExp *8)
				, (m_pClientList[iClientH]->m_iLevel / 2));		
			PutLogList(G_cTxt);
			PutLogEventFileList(G_cTxt);
			SendNotifyMsg(NULL, iAttackerH, DEF_NOTIFY_CONSTRUCTIONPOINT, m_pClientList[iAttackerH]->m_iConstructionPoint, m_pClientList[iAttackerH]->m_iWarContribution, NULL, NULL);
		}else if (   (m_bIsHeldenianMode == TRUE) 
					&& (m_pMapList[m_pClientList[iAttackerH]->m_cMapIndex]->m_bIsHeldenianMap == TRUE))
		{	m_pClientList[iAttackerH]->m_iExp += (iRewardExp * 6);
		}else //neither Crusade nor Heldenian			
		{	m_pClientList[iAttackerH]->m_iExp += (iRewardExp * 2);
		}
		// Enemy Kill count
		if (iGetExpLevel(m_pClientList[iClientH]->m_iExp) >= iEK_Level) 
		{	if (memcmp(m_pClientList[iClientH]->m_cLocation, m_pClientList[iClientH]->m_cMapName, 10) != 0)
			{	m_pClientList[iAttackerH]->m_iEnemyKillCount += PKpoints;
			}else if (m_bEnemyKillMode == TRUE) 
			{	m_pClientList[iAttackerH]->m_iEnemyKillCount += PKpoints;
			}else PKpoints = 0;
		}else PKpoints = 0;
		// Reward Gold 
		m_pClientList[iAttackerH]->m_iRewardGold += iDice(10, (iGetExpLevel(m_pClientList[iClientH]->m_iExp)));
		if (m_pClientList[iAttackerH]->m_iRewardGold > DEF_MAXREWARDGOLD) 
			m_pClientList[iAttackerH]->m_iRewardGold = DEF_MAXREWARDGOLD;
		if (m_pClientList[iAttackerH]->m_iRewardGold < 0) 
			m_pClientList[iAttackerH]->m_iRewardGold = 0;

		SendNotifyMsg(NULL, iAttackerH, DEF_NOTIFY_ENEMYKILLREWARD, iClientH, NULL, NULL, NULL);
		bCheckLevelUp(iAttackerH);
		m_stCityStatus[m_pClientList[iAttackerH]->m_cSide].iWins++;
	}	
	char  cTxt[200]; 
	ZeroMemory(cTxt, sizeof(cTxt));	
	// Check if EK from same IP !
	if (memcmp(m_pClientList[iClientH]->m_cIPaddress, m_pClientList[iAttackerH]->m_cIPaddress, 20) == 0)
	{	_bPKLog(DEF_PKLOG_BYENEMY_SAME_IP, iAttackerH, iClientH, NULL);
		wsprintf(cTxt, "%-10s(%3d) killed %-10s(%3d): EK pts +%2d = %4d \tWARNING EK IS ON SAME IP"
			, m_pClientList[iAttackerH]->m_cCharName
			, m_pClientList[iAttackerH]->m_iLevel
			, m_pClientList[iClientH]->m_cCharName
			, m_pClientList[iClientH]->m_iLevel
			, PKpoints
			, m_pClientList[iAttackerH]->m_iEnemyKillCount);
		_bCrusadeLog(DEF_CRUSADELOG_EK_LOG, NULL, 0, cTxt) ;
		ZeroMemory(m_cBugText, sizeof(m_cBugText));
		wsprintf(m_cBugText, "IMPORTANT NOTICE: EK by same IP: %s killed by %s."
			, m_pClientList[iClientH]->m_cCharName
			, m_pClientList[iAttackerH]->m_cCharName);
		m_iBugWarning = 1;
	}else // Log the EK (killed by enemy)
	{	_bPKLog(DEF_PKLOG_BYENEMY,iAttackerH,iClientH,NULL);
		wsprintf(cTxt, "%-10s(%3d) killed %-10s(%3d): EK pts +%2d = %4d"
			, m_pClientList[iAttackerH]->m_cCharName
			, m_pClientList[iAttackerH]->m_iLevel
			, m_pClientList[iClientH]->m_cCharName
			, m_pClientList[iClientH]->m_iLevel
			, PKpoints
			, m_pClientList[iAttackerH]->m_iEnemyKillCount);
		_bCrusadeLog(DEF_CRUSADELOG_EK_LOG, NULL, 0, cTxt) ;
	}
}
// 05/22/2004 - Hypnotoad - register in pk log
void CGame::ApplyCombatKilledPenalty(int iClientH, int cPenaltyLevel, BOOL bIsSAattacked)
{int iExp;
	if (m_pClientList[iClientH] == NULL) return;
	if (m_pClientList[iClientH]->m_bIsInitComplete == FALSE) return;
	// Crusade
	if (   (m_bIsCrusadeMode == TRUE) 
		|| (   (m_bIsHeldenianMode == TRUE) 
			&& (m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_bIsHeldenianMap == 1)))
	{	if (m_pClientList[iClientH]->m_iPKCount > 0) 
		{	m_pClientList[iClientH]->m_iPKCount--;
			SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_PKPENALTY, NULL, NULL, NULL, NULL);	
			_bPKLog(DEF_PKLOG_REDUCECRIMINAL,NULL,iClientH,NULL) ;
		}
		return;
	}else 
	{	if (m_pClientList[iClientH]->m_iPKCount > 0) 
		{	m_pClientList[iClientH]->m_iPKCount--;
			SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_PKPENALTY, NULL, NULL, NULL, NULL);	
			_bPKLog(DEF_PKLOG_REDUCECRIMINAL,NULL,iClientH,NULL) ;
		}
		iExp = iDice(1, (5*cPenaltyLevel*m_pClientList[iClientH]->m_iLevel));
		if (m_pClientList[iClientH]->m_bIsNeutral == TRUE) iExp = iExp / 3;
		// if (m_pClientList[iClientH]->m_iLevel == DEF_PLAYERMAXLEVEL) iExp = 0;
		m_pClientList[iClientH]->m_iExp -= iExp;
		if (m_pClientList[iClientH]->m_iExp < 0) m_pClientList[iClientH]->m_iExp = 0;
		SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_EXP, NULL, NULL, NULL, NULL);
		if (m_pClientList[iClientH]->m_bIsNeutral != TRUE) 
		{	if (m_pClientList[iClientH]->m_iLevel < 80) 
			{	cPenaltyLevel--;
				if (cPenaltyLevel <= 0) cPenaltyLevel = 1;
				_PenaltyItemDrop(iClientH, cPenaltyLevel, bIsSAattacked);
			}else _PenaltyItemDrop(iClientH, cPenaltyLevel, bIsSAattacked);
	}	}
}

// 05/29/2004 - Hypnotoad - Limits some items from not dropping
void CGame::_PenaltyItemDrop(int iClientH, int iTotal, BOOL bIsSAattacked)
{	register int i, j, iRemainItem;
	char cItemIndexList[DEF_MAXITEMS], cItemIndex;
	if (m_pClientList[iClientH] == NULL) return;
	if (m_pClientList[iClientH]->m_bIsInitComplete == FALSE) return;
// Drop this item even before any ZEMStone, special item for events, will be dropped regardless of any map setting
	// And normal ZEM or Item drop can happen after
	if (   (m_pClientList[iClientH]->m_iEventItemDropIndex != -1) 
		&& (m_pClientList[iClientH]->m_pItemList[m_pClientList[iClientH]->m_iEventItemDropIndex] != NULL)) 
	{	if (m_pClientList[iClientH]->m_pItemList[m_pClientList[iClientH]->m_iEventItemDropIndex]->m_sItemEffectType == DEF_ITEMEFFECTTYPE_EVENT_ITEMDROP) 
		{	DropItemHandler(iClientH, m_pClientList[iClientH]->m_iEventItemDropIndex, -1, m_pClientList[iClientH]->m_pItemList[m_pClientList[iClientH]->m_iEventItemDropIndex]->m_cName, FALSE);
			m_pClientList[iClientH]->m_iEventItemDropIndex = -1;
	}	}
	if (m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_iDropType == 0) return; 
// Snoopy:no Player drop possible if map Type prevents it
	if (m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cType == DEF_MAPTYPE_NOPCDROP) return;
	if (m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cType == DEF_MAPTYPE_NOPCDROP_NOPK) return;
// SNOOPY: Lucky effect will prevent drops,  even of a ZEM.
	if ((m_pClientList[iClientH]->m_bIsLuckyEffect > 0) && ((iDice(1,100) <= m_pClientList[iClientH]->m_bIsLuckyEffect))) 
	{	return;
	}
	if (   (m_pClientList[iClientH]->m_iAlterItemDropIndex != -1) 
		&& (m_pClientList[iClientH]->m_pItemList[m_pClientList[iClientH]->m_iAlterItemDropIndex] != NULL)) 
	{	if (m_pClientList[iClientH]->m_pItemList[m_pClientList[iClientH]->m_iAlterItemDropIndex]->m_sItemEffectType == DEF_ITEMEFFECTTYPE_ALTERITEMDROP) 
		{	if (m_pClientList[iClientH]->m_pItemList[m_pClientList[iClientH]->m_iAlterItemDropIndex]->m_wCurLifeSpan > 0)
				m_pClientList[iClientH]->m_pItemList[m_pClientList[iClientH]->m_iAlterItemDropIndex]->m_wCurLifeSpan--;
			DropItemHandler(iClientH, m_pClientList[iClientH]->m_iAlterItemDropIndex, -1, m_pClientList[iClientH]->m_pItemList[m_pClientList[iClientH]->m_iAlterItemDropIndex]->m_cName, FALSE);
			m_pClientList[iClientH]->m_iAlterItemDropIndex = -1;
			return;
		}else // v2.04 testcode			
		{	PutLogList("Alter Drop Item Index Error1");
			PutLogFileList("Alter Drop Item Index Error1");
			for (i = 0; i < DEF_MAXITEMS; i++) 
			{	if ((m_pClientList[iClientH]->m_pItemList[i] != NULL) && (m_pClientList[iClientH]->m_pItemList[i]->m_sItemEffectType == DEF_ITEMEFFECTTYPE_ALTERITEMDROP)) {
					m_pClientList[iClientH]->m_iAlterItemDropIndex = i;
					if (m_pClientList[iClientH]->m_pItemList[m_pClientList[iClientH]->m_iAlterItemDropIndex]->m_wCurLifeSpan > 0)
						m_pClientList[iClientH]->m_pItemList[m_pClientList[iClientH]->m_iAlterItemDropIndex]->m_wCurLifeSpan--;
					DropItemHandler(iClientH, m_pClientList[iClientH]->m_iAlterItemDropIndex, -1, m_pClientList[iClientH]->m_pItemList[m_pClientList[iClientH]->m_iAlterItemDropIndex]->m_cName, FALSE);	
					m_pClientList[iClientH]->m_iAlterItemDropIndex = -1;
					return;
			}	}
			goto PID_DROP;
	}	}
PID_DROP:;
	for (i = 1; i <= iTotal; i++) 
	{	iRemainItem = 0;
		ZeroMemory(cItemIndexList, sizeof(cItemIndexList));		
		for (j = 0; j < DEF_MAXITEMS; j++) 
		{	if (m_pClientList[iClientH]->m_pItemList[j] != NULL) 
			{	// Don't drop if not allowed by map's drop type -1
				if (   (m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_iDropType == -1) 
					&& (   (m_pClientList[iClientH]->m_pItemList[j]->m_sItemEffectType <4)
						|| (m_pClientList[iClientH]->m_pItemList[j]->m_sItemEffectType >7)) )			
				{	continue;}
				// Don't drop personal items
				if (   (m_pClientList[iClientH]->m_pItemList[j]->m_sTouchEffectType != 0) 
					&& (m_pClientList[iClientH]->m_pItemList[j]->m_sTouchEffectValue1 == m_pClientList[iClientH]->m_sCharIDnum1) 
					&& (m_pClientList[iClientH]->m_pItemList[j]->m_sTouchEffectValue2 == m_pClientList[iClientH]->m_sCharIDnum2) 
					&& (m_pClientList[iClientH]->m_pItemList[j]->m_sTouchEffectValue3 == m_pClientList[iClientH]->m_sCharIDnum3)) 
				{	continue;}			
				// Don't drop hero items
				if (   (m_pClientList[iClientH]->m_pItemList[j]->m_sIDnum >= 398)  // Do not Drop hero armors
					&& (m_pClientList[iClientH]->m_pItemList[j]->m_sIDnum <= 428)  // Changed 400 to 398 for Contribution capes
					&& (m_pClientList[iClientH]->m_pItemList[j]->m_sIDnum != 402)) // but drop normal cape			
				{	continue;}				
				// Don't drop Executors items			
				if (   (m_pClientList[iClientH]->m_pItemList[j]->m_sIDnum >= 700)  // Do not Drop DarkKnight items
					&& (m_pClientList[iClientH]->m_pItemList[j]->m_sIDnum <= 710)) 
				{	continue;}								
				// Don't drop valuable if killed by player Killer
				if (   (m_pClientList[iClientH]->m_bKilledByPlayerKiller == TRUE) 
					&& (   (m_pClientList[iClientH]->m_pItemList[j]->m_sItemEffectType <4)
						|| (m_pClientList[iClientH]->m_pItemList[j]->m_sItemEffectType >7)) )			
				{	continue;}	
				// Don't drop equiped activable items.
				if (   (   (m_pClientList[iClientH]->m_pItemList[j]->m_sItemEffectType == DEF_ITEMEFFECTTYPE_ATTACK_SPECABLTY) 
						|| (m_pClientList[iClientH]->m_pItemList[j]->m_sItemEffectType == DEF_ITEMEFFECTTYPE_DEFENSE_SPECABLTY)) 
					&& (bIsSAattacked == FALSE)) 	
				{	continue;}			
				cItemIndexList[iRemainItem] = j;
				iRemainItem++;
		}	}	
		if (iRemainItem == 0) return;
		cItemIndex = cItemIndexList[ iDice(1, iRemainItem) - 1 ];				
		DropItemHandler(iClientH, cItemIndex, -1, m_pClientList[iClientH]->m_pItemList[cItemIndex]->m_cName, FALSE);
	}
}

void CGame::GetRewardMoneyHandler(int iClientH)		    
{
 int iRet, iEraseReq, iWeightLeft, iRewardGoldLeft;
 DWORD * dwp;
 WORD  * wp;
 char  * cp, cData[100], cItemName[21];
 class CItem * pItem;
 short * sp;

	if (m_pClientList[iClientH] == NULL) return;
	if (m_pClientList[iClientH]->m_bIsInitComplete == FALSE) return;

	iWeightLeft = _iCalcMaxLoad(iClientH) - iCalcTotalWeight(iClientH);
		
	if (iWeightLeft <= 0) return;
	iWeightLeft = iWeightLeft / 2;
	if (iWeightLeft <= 0) return;

	pItem = new class CItem;
	ZeroMemory(cItemName, sizeof(cItemName));
	wsprintf(cItemName, "Gold");
	_bInitItemAttr(pItem, cItemName);
	//pItem->m_dwCount = m_pClientList[iClientH]->m_iRewardGold;
	
	if ((iWeightLeft / iGetItemWeight(pItem, 1)) >= m_pClientList[iClientH]->m_iRewardGold) 
	{	pItem->m_dwCount = m_pClientList[iClientH]->m_iRewardGold;
		iRewardGoldLeft = 0;
	}else // (iWeightLeft / pItem->m_wWeight)Â
	{	pItem->m_dwCount = (iWeightLeft / iGetItemWeight(pItem, 1));
		iRewardGoldLeft = m_pClientList[iClientH]->m_iRewardGold - (iWeightLeft / iGetItemWeight(pItem, 1));
	}

	if (_bAddClientItemList(iClientH, pItem, &iEraseReq) == TRUE) 
	{	m_pClientList[iClientH]->m_iRewardGold = iRewardGoldLeft;		
		dwp  = (DWORD *)(cData + DEF_INDEX4_MSGID);
		*dwp = MSGID_NOTIFY;
		wp   = (WORD *)(cData + DEF_INDEX2_MSGTYPE);
		*wp  = DEF_NOTIFY_ITEMOBTAINED;		
		cp = (char *)(cData + DEF_INDEX2_MSGTYPE + 2);
		*cp = 1;
		cp++;
		memcpy(cp, pItem->m_cName, 20);
		cp += 20;
		dwp  = (DWORD *)cp;
		*dwp = pItem->m_dwCount;
		cp += 4;
		*cp = pItem->m_cItemType;
		cp++;
		*cp = pItem->m_cEquipPos;
		cp++;
		*cp = (char)0; 
		cp++;
		sp  = (short *)cp;
		*sp = pItem->m_sLevelLimit;
		cp += 2;
		*cp = pItem->m_cGenderLimit;
		cp++;
		wp = (WORD *)cp;
		*wp = pItem->m_wCurLifeSpan;
		cp += 2;
		wp = (WORD *)cp;
		*wp = pItem->m_wWeight;
		cp += 2;
		sp  = (short *)cp;
		*sp = pItem->m_sSprite;
		cp += 2;
		sp  = (short *)cp;
		*sp = pItem->m_sSpriteFrame;
		cp += 2;
		*cp = pItem->m_cItemColor;
		cp++;
		*cp = (char)pItem->m_sItemSpecEffectValue2; // v1.41 
		cp++;		
		dwp = (DWORD *)cp;
		*dwp = pItem->m_dwAttribute;
		cp += 4;
		/*
		*cp = (char)(pItem->m_dwAttribute & 0x00000001); // Custom-ItemÃ€ÃŽÃÃ¶Ã€Ã‡ Â¿Â©ÂºÃŽ 
		cp++;
		*/

		if (iEraseReq == 1) delete pItem;		
		iRet = m_pClientList[iClientH]->m_pXSock->iSendMsg(cData, 53);						
		switch (iRet) {
		case DEF_XSOCKEVENT_QUENEFULL:
		case DEF_XSOCKEVENT_SOCKETERROR:
		case DEF_XSOCKEVENT_CRITICALERROR:
			DeleteClient(iClientH, TRUE, TRUE);
			return;
		}
		SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_REWARDGOLD, NULL, NULL, NULL, NULL);
	}else {}
}

int CGame::_iCalcMaxLoad(int iClientH)
{	if (m_pClientList[iClientH] == NULL) return 0;
	return ((m_pClientList[iClientH]->m_iStr + m_pClientList[iClientH]->m_iAngelicStr) * 500 + m_pClientList[iClientH]->m_iLevel*500);
}

int CGame::iAddDynamicObjectList(short sOwner, char cOwnerType, short sType, char cMapIndex, short sX, short sY, DWORD dwLastTime, int iV1)
{register int i; 
 short sPreType;
 DWORD dwTime, dwRegisterTime;
	m_pMapList[cMapIndex]->bGetDynamicObject(sX, sY, &sPreType, &dwRegisterTime);
	if (sPreType != NULL) return NULL;
	switch (sType) {	
	case DEF_DYNAMICOBJECT_FIRE3:
	case DEF_DYNAMICOBJECT_FIRE:
		if (m_pMapList[cMapIndex]->bGetIsMoveAllowedTile(sX, sY) == FALSE)
			return NULL;
		if (dwLastTime != NULL)  {
			switch (m_pMapList[cMapIndex]->m_cWhetherStatus) {
			case 1:	dwLastTime = dwLastTime - (dwLastTime / 2);       break;
			case 2:	dwLastTime = (dwLastTime / 2) - (dwLastTime / 3); break;
			case 3:	dwLastTime = (dwLastTime / 3) - (dwLastTime / 4); break;
			// SNOOPY: Added reduced duration if snow whether
			case 4:	dwLastTime = dwLastTime - (dwLastTime / 6);       break;
			case 5:	dwLastTime = dwLastTime - (dwLastTime / 4);		  break;
			case 6:	dwLastTime = dwLastTime - (dwLastTime / 2);		  break;
			default:break;
			}
			if (dwLastTime == NULL) dwLastTime = 1000;
		}
		break;
	// SNOOPY: Increased duration if snow whether
	case DEF_DYNAMICOBJECT_ICESTORM:
		if (dwLastTime != NULL)  {
			switch (m_pMapList[cMapIndex]->m_cWhetherStatus) {
			case 1:	break;
			// Reduced duration if heavy rain
			case 2:	dwLastTime = dwLastTime  - (dwLastTime / 8); break;
			case 3:	dwLastTime = dwLastTime  - (dwLastTime / 4); break;
			// Increased duration if snow whether
			case 4:	dwLastTime = dwLastTime + (dwLastTime / 2);       break;
			case 5:	dwLastTime = dwLastTime *2;		  break;
			case 6:	dwLastTime = dwLastTime *4;		  break;
			default:break;
			}
			if (dwLastTime == NULL) dwLastTime = 1000;
		}
		break;	

	case DEF_DYNAMICOBJECT_FISHOBJECT:
	case DEF_DYNAMICOBJECT_FISH:
		if (m_pMapList[cMapIndex]->bGetIsWater(sX, sY) == FALSE)
			return NULL;
		break;

	case DEF_DYNAMICOBJECT_ARESDENFLAG1:
	case DEF_DYNAMICOBJECT_ELVINEFLAG1:
	case DEF_DYNAMICOBJECT_MINERAL1:
	case DEF_DYNAMICOBJECT_MINERAL2:		
		if (m_pMapList[cMapIndex]->bGetMoveable(sX, sY) == FALSE)
			return NULL;
		m_pMapList[cMapIndex]->SetTempMoveAllowedFlag(sX, sY, FALSE);
		break;	
		
	case DEF_DYNAMICOBJECT_STATUE1://		15 // Snoopy Avatar quest
	case DEF_DYNAMICOBJECT_STATUE2://		16 // Snoopy Avatar quest
	case DEF_DYNAMICOBJECT_STATUE3://		17 // Snoopy Avatar quest
	case DEF_DYNAMICOBJECT_STATUE4://		18 // Snoopy Avatar quest
	case DEF_DYNAMICOBJECT_STATUE5://		19 // Snoopy Avatar quest
	case DEF_DYNAMICOBJECT_STATUE6://		20 // Snoopy Avatar quest
	case DEF_DYNAMICOBJECT_STATUE7://		20 // Snoopy Avatar quest
		if (m_pMapList[cMapIndex]->bGetMoveable(sX, sY) == FALSE)
			return NULL;
		m_pMapList[cMapIndex]->SetTempMoveAllowedFlag(sX, sY, FALSE);
		m_pMapList[cMapIndex]->SetTempMoveAllowedFlag(sX+1, sY, FALSE);
		break;

	case DEF_DYNAMICOBJECT_FIRE2:
		break;
	}   	
	for (i = 1; i < DEF_MAXDYNAMICOBJECTS; i++) 
	if (m_pDynamicObjectList[i] == NULL) 
	{	dwTime = timeGetTime();		
		if (dwLastTime != NULL) 
			dwLastTime += (iDice(1,4)*1000);
		m_pDynamicObjectList[i] = new class CDynamicObject(sOwner, cOwnerType, sType, cMapIndex, sX, sY, dwTime, dwLastTime, iV1);
		if ((cOwnerType == DEF_OWNERTYPE_PLAYER_INDIRECT) && (m_pClientList[sOwner] != NULL))
			strcpy(m_pDynamicObjectList[i]->cOwnerName, m_pClientList[sOwner]->m_cCharName);
		m_pMapList[cMapIndex]->SetDynamicObject(i, sType, sX, sY, dwTime);
		SendEventToNearClient_TypeB(MSGID_DYNAMICOBJECT, DEF_MSGTYPE_CONFIRM, cMapIndex, sX, sY, sType, i, NULL);
		return i;
	}
	return NULL;
}

void CGame::CheckDynamicObjectList()
{register int i;
 DWORD dwTime = timeGetTime(), dwRegisterTime;
 short sType;
	for (i = 1; i < DEF_MAXDYNAMICOBJECTS; i++)  
	{	if ( (m_pDynamicObjectList[i] != NULL) && (m_pDynamicObjectList[i]->m_dwLastTime != NULL) ) 
		{	switch (m_pDynamicObjectList[i]->m_sType) {
			case DEF_DYNAMICOBJECT_FIRE3:
			case DEF_DYNAMICOBJECT_FIRE:
				switch (m_pMapList[m_pDynamicObjectList[i]->m_cMapIndex]->m_cWhetherStatus) {
				case 0: break;
				case 1: 
				case 2:
				case 3:
					m_pDynamicObjectList[i]->m_dwLastTime = m_pDynamicObjectList[i]->m_dwLastTime - 
(m_pDynamicObjectList[i]->m_dwLastTime/10) * m_pMapList[m_pDynamicObjectList[i]->m_cMapIndex]->m_cWhetherStatus;
					break;
				case 4: 	// SNOOPY: Added snow whether
				case 5:
				case 6:
					m_pDynamicObjectList[i]->m_dwLastTime = m_pDynamicObjectList[i]->m_dwLastTime - 
(m_pDynamicObjectList[i]->m_dwLastTime/20) * m_pMapList[m_pDynamicObjectList[i]->m_cMapIndex]->m_cWhetherStatus;
				}
				break;
	}	}	}
	for (i = 1; i < DEF_MAXDYNAMICOBJECTS; i++) 
	{ 	if (   (m_pDynamicObjectList[i] != NULL) && (m_pDynamicObjectList[i]->m_dwLastTime != NULL) 
			&& ((dwTime - m_pDynamicObjectList[i]->m_dwRegisterTime) >= m_pDynamicObjectList[i]->m_dwLastTime) ) 
		{	m_pMapList[ m_pDynamicObjectList[i]->m_cMapIndex ]->bGetDynamicObject( m_pDynamicObjectList[i]->m_sX, m_pDynamicObjectList[i]->m_sY, &sType, &dwRegisterTime );
			if (dwRegisterTime == m_pDynamicObjectList[i]->m_dwRegisterTime) 
			{	SendEventToNearClient_TypeB(MSGID_DYNAMICOBJECT, DEF_MSGTYPE_REJECT, m_pDynamicObjectList[i]->m_cMapIndex, m_pDynamicObjectList[i]->m_sX, m_pDynamicObjectList[i]->m_sY, m_pDynamicObjectList[i]->m_sType, i, NULL);
				m_pMapList[m_pDynamicObjectList[i]->m_cMapIndex]->SetDynamicObject(NULL, NULL, m_pDynamicObjectList[i]->m_sX, m_pDynamicObjectList[i]->m_sY, dwTime);
			}
			switch (sType) {
			case DEF_DYNAMICOBJECT_FISHOBJECT:
			case DEF_DYNAMICOBJECT_FISH:
				bDeleteFish(m_pDynamicObjectList[i]->m_sOwner, 2);
				break;
			}	
			delete m_pDynamicObjectList[i];
			m_pDynamicObjectList[i] = NULL;
	}	}
}

void CGame::CalculateSSN_ItemIndex(int iClientH, short sWeaponIndex, int iValue)
{
 short sSkillIndex;
 int   iOldSSN, iSSNpoint, iWeaponIndex;

	if (m_pClientList[iClientH] == NULL) return;
	if (m_pClientList[iClientH]->m_bIsInitComplete == FALSE) return;
	if (m_pClientList[iClientH]->m_pItemList[sWeaponIndex] == NULL) return;
	if (m_pClientList[iClientH]->m_bIsKilled == TRUE) return;
	
	sSkillIndex = m_pClientList[iClientH]->m_pItemList[sWeaponIndex]->m_sRelatedSkill;
	if ((sSkillIndex < 0) || (sSkillIndex >= DEF_MAXSKILLTYPE)) return;
	if (m_pClientList[iClientH]->m_cSkillMastery[sSkillIndex] == 0) return;

	iOldSSN = m_pClientList[iClientH]->m_iSkillSSN[sSkillIndex];
	m_pClientList[iClientH]->m_iSkillSSN[sSkillIndex] += iValue;
	
	iSSNpoint = m_iSkillSSNpoint[ m_pClientList[iClientH]->m_cSkillMastery[sSkillIndex]+1 ];

	if ( (m_pClientList[iClientH]->m_cSkillMastery[sSkillIndex] < 100) &&
		 (m_pClientList[iClientH]->m_iSkillSSN[sSkillIndex] > iSSNpoint) ) {		
		m_pClientList[iClientH]->m_cSkillMastery[sSkillIndex]++; 		
		switch (sSkillIndex) {
		case 0:  // Mining
		case 13: // Manufacturing   	
		case 14: // Hammer 
			if (m_pClientList[iClientH]->m_cSkillMastery[sSkillIndex] > ((m_pClientList[iClientH]->m_iStr + m_pClientList[iClientH]->m_iAngelicStr) * 2)) 
			{	m_pClientList[iClientH]->m_cSkillMastery[sSkillIndex]--;
				m_pClientList[iClientH]->m_iSkillSSN[sSkillIndex] = iOldSSN;
			}else m_pClientList[iClientH]->m_iSkillSSN[sSkillIndex] = 0;
			break;

		case 3: // Magic-Resistance
			if (m_pClientList[iClientH]->m_cSkillMastery[sSkillIndex] > (m_pClientList[iClientH]->m_iLevel * 2)) 
			{	m_pClientList[iClientH]->m_cSkillMastery[sSkillIndex]--;
				m_pClientList[iClientH]->m_iSkillSSN[sSkillIndex] = iOldSSN;
			}else m_pClientList[iClientH]->m_iSkillSSN[sSkillIndex] = 0;
			break;

		case 4:  // Magic
		case 21: // Staff-Attack
			if (m_pClientList[iClientH]->m_cSkillMastery[sSkillIndex] > ((m_pClientList[iClientH]->m_iMag + m_pClientList[iClientH]->m_iAngelicMag) * 2)) {
				m_pClientList[iClientH]->m_cSkillMastery[sSkillIndex]--;
				m_pClientList[iClientH]->m_iSkillSSN[sSkillIndex] = iOldSSN;
			}
			else m_pClientList[iClientH]->m_iSkillSSN[sSkillIndex] = 0;
			break;

		case 1:  // Fishing
		case 6:  // Archery
		case 7:  // Short-Sword
		case 8:  // Long-Sword
		case 9:  // Fencing 
		case 10: // Axe-Attack
		case 11: // Shield     
		case 20: // Dual-Wielding    
			if (m_pClientList[iClientH]->m_cSkillMastery[sSkillIndex] > ((m_pClientList[iClientH]->m_iDex + m_pClientList[iClientH]->m_iAngelicDex) * 2)) {
				m_pClientList[iClientH]->m_cSkillMastery[sSkillIndex]--;
				m_pClientList[iClientH]->m_iSkillSSN[sSkillIndex] = iOldSSN;
			}
			else m_pClientList[iClientH]->m_iSkillSSN[sSkillIndex] = 0;
			break;

		case 12: // Alchemy
		case 15: // Unknown
			if (m_pClientList[iClientH]->m_cSkillMastery[sSkillIndex] > ((m_pClientList[iClientH]->m_iInt + m_pClientList[iClientH]->m_iAngelicInt) * 2)) {
				m_pClientList[iClientH]->m_cSkillMastery[sSkillIndex]--;
				m_pClientList[iClientH]->m_iSkillSSN[sSkillIndex] = iOldSSN;
			}
			else m_pClientList[iClientH]->m_iSkillSSN[sSkillIndex] = 0;
			break;

		case 2:	 // Farming
		case 5:  // Hand-Attack
		case 19: // Pretend-Corpse
		case 23: // Poison-Resistance
			if (m_pClientList[iClientH]->m_cSkillMastery[sSkillIndex] > (m_pClientList[iClientH]->m_iVit * 2)) {
				m_pClientList[iClientH]->m_cSkillMastery[sSkillIndex]--;
				m_pClientList[iClientH]->m_iSkillSSN[sSkillIndex] = iOldSSN;
			}
			else m_pClientList[iClientH]->m_iSkillSSN[sSkillIndex] = 0;
			break;

		default:
			m_pClientList[iClientH]->m_iSkillSSN[sSkillIndex] = 0;
			break;
		}
		
		if (m_pClientList[iClientH]->m_iSkillSSN[sSkillIndex] == 0) {
			if (m_pClientList[iClientH]->m_sItemEquipmentStatus[ DEF_EQUIPPOS_TWOHAND ] != -1) 
			{	iWeaponIndex = m_pClientList[iClientH]->m_sItemEquipmentStatus[ DEF_EQUIPPOS_TWOHAND ];
				if (m_pClientList[iClientH]->m_pItemList[iWeaponIndex]->m_sRelatedSkill == sSkillIndex) 
				{	m_pClientList[iClientH]->m_iHitRatio++;
				}
			}
			if (m_pClientList[iClientH]->m_sItemEquipmentStatus[ DEF_EQUIPPOS_RHAND ] != -1) 
			{	iWeaponIndex = m_pClientList[iClientH]->m_sItemEquipmentStatus[ DEF_EQUIPPOS_RHAND ];
				if (m_pClientList[iClientH]->m_pItemList[iWeaponIndex]->m_sRelatedSkill == sSkillIndex) 
				{	m_pClientList[iClientH]->m_iHitRatio++;
				}
			}
		}
	 		
		if (m_pClientList[iClientH]->m_iSkillSSN[sSkillIndex] == 0) {
			bCheckTotalSkillMasteryPoints(iClientH, sSkillIndex);

			// SNOOPY: Reintroduced to log High skill characters	
			switch (sSkillIndex) {
			case 1: // Fishing
				if (m_pClientList[iClientH]->m_cSkillMastery[sSkillIndex] >= 60)
				{	wsprintf(G_cTxt, "PC(%s)\t%s Skill increased (%d%%)\t%s(%d %d)\tIP(%s)"
						, m_pClientList[iClientH]->m_cCharName
						, m_pSkillConfigList[sSkillIndex]->m_cName
						, m_pClientList[iClientH]->m_cSkillMastery[sSkillIndex]
						, m_pClientList[iClientH]->m_cMapName
						, m_pClientList[iClientH]->m_sX
						, m_pClientList[iClientH]->m_sY
						, m_pClientList[iClientH]->m_cIPaddress);
					PutLogList(G_cTxt);
					PutLogFileList(G_cTxt);
					PutSkillLogFileList(G_cTxt);
				}
				break;
			case 2: // Farming
				if (m_pClientList[iClientH]->m_cSkillMastery[sSkillIndex] >= 70)
				{	wsprintf(G_cTxt, "PC(%s)\t%s Skill increased (%d%%)\t%s(%d %d)\tIP(%s)"
						, m_pClientList[iClientH]->m_cCharName
						, m_pSkillConfigList[sSkillIndex]->m_cName
						, m_pClientList[iClientH]->m_cSkillMastery[sSkillIndex]
						, m_pClientList[iClientH]->m_cMapName
						, m_pClientList[iClientH]->m_sX
						, m_pClientList[iClientH]->m_sY
						, m_pClientList[iClientH]->m_cIPaddress);
					PutLogList(G_cTxt);
					PutLogFileList(G_cTxt);
					PutSkillLogFileList(G_cTxt);
				}
				break;
			case 12: // Alchemy
				if (m_pClientList[iClientH]->m_cSkillMastery[sSkillIndex] >= 60){
					wsprintf(G_cTxt, "PC(%s)\t%s Skill increased (%d%%)\t%s(%d %d)\tIP(%s)"
						, m_pClientList[iClientH]->m_cCharName
						, m_pSkillConfigList[sSkillIndex]->m_cName
						, m_pClientList[iClientH]->m_cSkillMastery[sSkillIndex]
						, m_pClientList[iClientH]->m_cMapName
						, m_pClientList[iClientH]->m_sX
						, m_pClientList[iClientH]->m_sY
						, m_pClientList[iClientH]->m_cIPaddress);
					PutLogList(G_cTxt);
					PutLogFileList(G_cTxt);	
					PutSkillLogFileList(G_cTxt);
				}
				break;
			case 13: // Manufacturing
				if (m_pClientList[iClientH]->m_cSkillMastery[sSkillIndex] >= 50){
					wsprintf(G_cTxt, "PC(%s)\t%s Skill increased (%d%%)\t%s(%d %d)\tIP(%s)"
						, m_pClientList[iClientH]->m_cCharName
						, m_pSkillConfigList[sSkillIndex]->m_cName
						, m_pClientList[iClientH]->m_cSkillMastery[sSkillIndex]
						, m_pClientList[iClientH]->m_cMapName
						, m_pClientList[iClientH]->m_sX
						, m_pClientList[iClientH]->m_sY
						, m_pClientList[iClientH]->m_cIPaddress);
					PutLogList(G_cTxt);
					PutLogFileList(G_cTxt);
					PutSkillLogFileList(G_cTxt);
				}
				break;
			default: // All skills.
				if (m_pClientList[iClientH]->m_cSkillMastery[sSkillIndex] >= 99){
					wsprintf(G_cTxt, "PC(%s)\t%s Skill increased (%d%%)\t%s(%d %d)\tIP(%s)"
						, m_pClientList[iClientH]->m_cCharName
						, m_pSkillConfigList[sSkillIndex]->m_cName
						, m_pClientList[iClientH]->m_cSkillMastery[sSkillIndex] 
						, m_pClientList[iClientH]->m_cMapName
						, m_pClientList[iClientH]->m_sX
						, m_pClientList[iClientH]->m_sY
						, m_pClientList[iClientH]->m_cIPaddress);
					PutLogList(G_cTxt);
					PutLogFileList(G_cTxt);
					PutSkillLogFileList(G_cTxt);
				}
				break;	
			}
			SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_SKILL, sSkillIndex, m_pClientList[iClientH]->m_cSkillMastery[sSkillIndex], NULL, NULL);	
		}
	}
}

// SNOPY Added this function in case of manual or automated characteristic changes
void CGame::Check_Skill_Is_Valid(int iClientH)
{	if (m_pClientList[iClientH] == NULL) return;
	int sSkillIndex;
	BOOL bSkillReduced = FALSE;
	for (sSkillIndex = 0; sSkillIndex < DEF_MAXSKILLTYPE; sSkillIndex++)
	{	switch (sSkillIndex) {
		case 0:  // Mining
		case 13: // Manufacturing 
		case 14: // Hammer
			if (m_pClientList[iClientH]->m_cSkillMastery[sSkillIndex] > ((m_pClientList[iClientH]->m_iStr + m_pClientList[iClientH]->m_iAngelicStr) * 2)) 
			{	m_pClientList[iClientH]->m_cSkillMastery[sSkillIndex] = (m_pClientList[iClientH]->m_iStr + m_pClientList[iClientH]->m_iAngelicStr) * 2;
				m_pClientList[iClientH]->m_iSkillSSN[sSkillIndex] = 0;
				bSkillReduced = TRUE;
				SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_SKILL, sSkillIndex, m_pClientList[iClientH]->m_cSkillMastery[sSkillIndex], NULL, NULL);
			}
			break;

		case 3:  // Magic-Resistance
			if (m_pClientList[iClientH]->m_cSkillMastery[sSkillIndex] > (m_pClientList[iClientH]->m_iLevel * 2)) 
			{	m_pClientList[iClientH]->m_cSkillMastery[sSkillIndex] = m_pClientList[iClientH]->m_iLevel * 2;
				m_pClientList[iClientH]->m_iSkillSSN[sSkillIndex] = 0;
				bSkillReduced = TRUE;
				SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_SKILL, sSkillIndex, m_pClientList[iClientH]->m_cSkillMastery[sSkillIndex], NULL, NULL);
			}
			break;

		case 4:  // Magic
		case 18: // Crafting
		case 21: // Staff-Attack
			if (m_pClientList[iClientH]->m_cSkillMastery[sSkillIndex] > ((m_pClientList[iClientH]->m_iMag + m_pClientList[iClientH]->m_iAngelicMag) * 2)) 
			{	m_pClientList[iClientH]->m_cSkillMastery[sSkillIndex] = (m_pClientList[iClientH]->m_iMag + m_pClientList[iClientH]->m_iAngelicMag) * 2;
				m_pClientList[iClientH]->m_iSkillSSN[sSkillIndex] = 0;
				bSkillReduced = TRUE;
				SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_SKILL, sSkillIndex, m_pClientList[iClientH]->m_cSkillMastery[sSkillIndex], NULL, NULL);
			}
			break;

		case 1:  // Fishing
		case 6:  // Archery
		case 7:  // Short-Sword
		case 8:  // Long-Sword
		case 9:  // Fencing 
		case 10: // Axe-Attack
		case 11: // Shield 
		case 20: // SNOOPY: Dual-Wielding
			if (m_pClientList[iClientH]->m_cSkillMastery[sSkillIndex] > ((m_pClientList[iClientH]->m_iDex + m_pClientList[iClientH]->m_iAngelicDex) * 2)) 
			{	m_pClientList[iClientH]->m_cSkillMastery[sSkillIndex] = (m_pClientList[iClientH]->m_iDex + m_pClientList[iClientH]->m_iAngelicDex) * 2;
				m_pClientList[iClientH]->m_iSkillSSN[sSkillIndex] = 0;
				bSkillReduced = TRUE;
				SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_SKILL, sSkillIndex, m_pClientList[iClientH]->m_cSkillMastery[sSkillIndex], NULL, NULL);
			}
			break;

		case 12: // Alchemy
		case 15: // ???
			if (m_pClientList[iClientH]->m_cSkillMastery[sSkillIndex] > ((m_pClientList[iClientH]->m_iInt + m_pClientList[iClientH]->m_iAngelicInt) * 2)) 
			{	m_pClientList[iClientH]->m_cSkillMastery[sSkillIndex] = (m_pClientList[iClientH]->m_iInt  + m_pClientList[iClientH]->m_iAngelicInt) * 2;
				m_pClientList[iClientH]->m_iSkillSSN[sSkillIndex] = 0;
				bSkillReduced = TRUE;
				SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_SKILL, sSkillIndex, m_pClientList[iClientH]->m_cSkillMastery[sSkillIndex], NULL, NULL);
			}
			break;

		case 2:  // Farming
		case 5:  // Hand-Attack
		case 19: // Pretend-Corpse
		case 23: // Poison resistance
			if (m_pClientList[iClientH]->m_cSkillMastery[sSkillIndex] > (m_pClientList[iClientH]->m_iVit * 2)) 
			{	m_pClientList[iClientH]->m_cSkillMastery[sSkillIndex] = m_pClientList[iClientH]->m_iVit * 2;
				m_pClientList[iClientH]->m_iSkillSSN[sSkillIndex] = 0;
				bSkillReduced = TRUE;
				SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_SKILL, sSkillIndex, m_pClientList[iClientH]->m_cSkillMastery[sSkillIndex], NULL, NULL);
			}
			break;
		case 22: // Taming
			if (m_pClientList[iClientH]->m_cSkillMastery[sSkillIndex] > (m_pClientList[iClientH]->m_iCharisma * 2)) 
			{	m_pClientList[iClientH]->m_cSkillMastery[sSkillIndex] = m_pClientList[iClientH]->m_iCharisma * 2;
				m_pClientList[iClientH]->m_iSkillSSN[sSkillIndex] = 0;
				bSkillReduced = TRUE;
				SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_SKILL, sSkillIndex, m_pClientList[iClientH]->m_cSkillMastery[sSkillIndex], NULL, NULL);
			}
			break;
		default:
			m_pClientList[iClientH]->m_iSkillSSN[sSkillIndex] = 0;
			break;
		}
	}
	bCheckTotalSkillMasteryPoints(iClientH, -1); // Will check total skill % as well.	

	// Log Skill reduction
	if (bSkillReduced == TRUE) 
	{	wsprintf(G_cTxt, "PC(%s)\t A skill was too high, reduced.\t%s(%d %d)\tIP(%s)"
			, m_pClientList[iClientH]->m_cCharName
			, m_pClientList[iClientH]->m_cMapName
			, m_pClientList[iClientH]->m_sX
			, m_pClientList[iClientH]->m_sY
			, m_pClientList[iClientH]->m_cIPaddress);
		PutLogList(G_cTxt);
		PutSkillLogFileList(G_cTxt);	
	}
}

void CGame::CalculateSSN_SkillIndex(int iClientH, short sSkillIndex, int iValue)
{
 int   iOldSSN, iSSNpoint, iWeaponIndex;
	if (m_pClientList[iClientH] == NULL) return;
	if (m_pClientList[iClientH]->m_bIsInitComplete == FALSE) return;
	if ((sSkillIndex < 0) || (sSkillIndex >= DEF_MAXSKILLTYPE)) return;
	if (m_pClientList[iClientH]->m_bIsKilled == TRUE) return;
	if (m_pClientList[iClientH]->m_cSkillMastery[sSkillIndex] == 0) return;

#ifdef DEF_TESTSERVER
	iValue = iValue *100;
#endif

	iOldSSN = m_pClientList[iClientH]->m_iSkillSSN[sSkillIndex];
	m_pClientList[iClientH]->m_iSkillSSN[sSkillIndex] += iValue;	
	iSSNpoint = m_iSkillSSNpoint[ m_pClientList[iClientH]->m_cSkillMastery[sSkillIndex]+1 ];

	if ( (m_pClientList[iClientH]->m_cSkillMastery[sSkillIndex] < 100) &&
		(m_pClientList[iClientH]->m_iSkillSSN[sSkillIndex] > iSSNpoint) ) {
		
		m_pClientList[iClientH]->m_cSkillMastery[sSkillIndex]++; 

		switch (sSkillIndex) {
		case 0:  // Mining
		case 13: // Manufacturing 
		case 14: // Hammer
			if (m_pClientList[iClientH]->m_cSkillMastery[sSkillIndex] > ((m_pClientList[iClientH]->m_iStr + m_pClientList[iClientH]->m_iAngelicStr) * 2)) 
			{	m_pClientList[iClientH]->m_cSkillMastery[sSkillIndex]--;
				m_pClientList[iClientH]->m_iSkillSSN[sSkillIndex] = iOldSSN;
			}
			else m_pClientList[iClientH]->m_iSkillSSN[sSkillIndex] = 0;
			break;

		case 3:  // Magic-Resistance
			if (m_pClientList[iClientH]->m_cSkillMastery[sSkillIndex] > (m_pClientList[iClientH]->m_iLevel * 2)) 
			{	m_pClientList[iClientH]->m_cSkillMastery[sSkillIndex]--;
				m_pClientList[iClientH]->m_iSkillSSN[sSkillIndex] = iOldSSN;
			}
			else m_pClientList[iClientH]->m_iSkillSSN[sSkillIndex] = 0;
			break;

		case 4:  // Magic			
		case 18: // Crafting
		case 21: // Staff-Attack
			if (m_pClientList[iClientH]->m_cSkillMastery[sSkillIndex] > ((m_pClientList[iClientH]->m_iMag + m_pClientList[iClientH]->m_iAngelicMag) * 2)) 
			{	m_pClientList[iClientH]->m_cSkillMastery[sSkillIndex]--;
				m_pClientList[iClientH]->m_iSkillSSN[sSkillIndex] = iOldSSN;
			}
			else m_pClientList[iClientH]->m_iSkillSSN[sSkillIndex] = 0;
			break;

		case 1:  // Fishing
		case 6:  // Archery
		case 7:  // Short-Sword
		case 8:  // Long-Sword
		case 9:  // Fencing 
		case 10: // Axe-Attack
		case 11: // Shield 
		case 20: // SNOOPY: Dual-Wielding
			if (m_pClientList[iClientH]->m_cSkillMastery[sSkillIndex] > ((m_pClientList[iClientH]->m_iDex + m_pClientList[iClientH]->m_iAngelicDex) * 2)) 
			{	m_pClientList[iClientH]->m_cSkillMastery[sSkillIndex]--;
				m_pClientList[iClientH]->m_iSkillSSN[sSkillIndex] = iOldSSN;
			}
			else m_pClientList[iClientH]->m_iSkillSSN[sSkillIndex] = 0;
			break;

		case 12: // Alchemy
		case 15: // ???
			if (m_pClientList[iClientH]->m_cSkillMastery[sSkillIndex] > ((m_pClientList[iClientH]->m_iInt + m_pClientList[iClientH]->m_iAngelicInt) * 2)) 
			{	m_pClientList[iClientH]->m_cSkillMastery[sSkillIndex]--;
				m_pClientList[iClientH]->m_iSkillSSN[sSkillIndex] = iOldSSN;
			}
			else m_pClientList[iClientH]->m_iSkillSSN[sSkillIndex] = 0;
			break;

		case 2:  // Farming
		case 5:  // Hand-Attack
		case 19: // Pretend-Corpse
		case 23: // Poison resistance
			if (m_pClientList[iClientH]->m_cSkillMastery[sSkillIndex] > (m_pClientList[iClientH]->m_iVit * 2)) {
				m_pClientList[iClientH]->m_cSkillMastery[sSkillIndex]--;
				m_pClientList[iClientH]->m_iSkillSSN[sSkillIndex] = iOldSSN;
			}
			else m_pClientList[iClientH]->m_iSkillSSN[sSkillIndex] = 0;
			break;

		case 22: // SNOOPY:Taming
			if (m_pClientList[iClientH]->m_cSkillMastery[sSkillIndex] > (m_pClientList[iClientH]->m_iCharisma * 2)) {
				m_pClientList[iClientH]->m_cSkillMastery[sSkillIndex]--;
				m_pClientList[iClientH]->m_iSkillSSN[sSkillIndex] = iOldSSN;
			}
			else m_pClientList[iClientH]->m_iSkillSSN[sSkillIndex] = 0;
			break;

		default:
			m_pClientList[iClientH]->m_iSkillSSN[sSkillIndex] = 0;
			break;
		}
		 
		if (m_pClientList[iClientH]->m_iSkillSSN[sSkillIndex] == 0) {
			if (m_pClientList[iClientH]->m_sItemEquipmentStatus[ DEF_EQUIPPOS_TWOHAND ] != -1) {
				iWeaponIndex = m_pClientList[iClientH]->m_sItemEquipmentStatus[ DEF_EQUIPPOS_TWOHAND ];
				if (m_pClientList[iClientH]->m_pItemList[iWeaponIndex]->m_sRelatedSkill == sSkillIndex) {
					m_pClientList[iClientH]->m_iHitRatio++;
				}
			}

			if (m_pClientList[iClientH]->m_sItemEquipmentStatus[ DEF_EQUIPPOS_RHAND ] != -1) {
				iWeaponIndex = m_pClientList[iClientH]->m_sItemEquipmentStatus[ DEF_EQUIPPOS_RHAND ];
				if (m_pClientList[iClientH]->m_pItemList[iWeaponIndex]->m_sRelatedSkill == sSkillIndex) {
					m_pClientList[iClientH]->m_iHitRatio++;
				}
			}
		}
			
		if (m_pClientList[iClientH]->m_iSkillSSN[sSkillIndex] == 0) {
			bCheckTotalSkillMasteryPoints(iClientH, sSkillIndex);

			// SNOOPY: Reintroduced to log High skill characters	
			switch (sSkillIndex) {
			case 1: // Fishing
				if (m_pClientList[iClientH]->m_cSkillMastery[sSkillIndex] >= 60){
					wsprintf(G_cTxt, "PC(%s)\t%s Skill increased (%d%%)\t%s(%d %d)\tIP(%s)"
						, m_pClientList[iClientH]->m_cCharName
						, m_pSkillConfigList[sSkillIndex]->m_cName
						, m_pClientList[iClientH]->m_cSkillMastery[sSkillIndex]
						, m_pClientList[iClientH]->m_cMapName
						, m_pClientList[iClientH]->m_sX
						, m_pClientList[iClientH]->m_sY
						, m_pClientList[iClientH]->m_cIPaddress);
					PutLogList(G_cTxt);
					PutLogFileList(G_cTxt);	
					PutSkillLogFileList(G_cTxt);
				}
				break;
			case 2: // Farming
				if (m_pClientList[iClientH]->m_cSkillMastery[sSkillIndex] >= 70){
					wsprintf(G_cTxt, "PC(%s)\t%s Skill increased (%d%%)\t%s(%d %d)\tIP(%s)"
						, m_pClientList[iClientH]->m_cCharName
						, m_pSkillConfigList[sSkillIndex]->m_cName
						, m_pClientList[iClientH]->m_cSkillMastery[sSkillIndex]
						, m_pClientList[iClientH]->m_cMapName
						, m_pClientList[iClientH]->m_sX
						, m_pClientList[iClientH]->m_sY
						, m_pClientList[iClientH]->m_cIPaddress);
					PutLogList(G_cTxt);
					PutLogFileList(G_cTxt);
					PutSkillLogFileList(G_cTxt);
				}
				break;
			case 12: // Alchemy
				if (m_pClientList[iClientH]->m_cSkillMastery[sSkillIndex] >= 60){
					wsprintf(G_cTxt, "PC(%s)\t%s Skill increased (%d%%)\t%s(%d %d)\tIP(%s)"
						, m_pClientList[iClientH]->m_cCharName
						, m_pSkillConfigList[sSkillIndex]->m_cName
						, m_pClientList[iClientH]->m_cSkillMastery[sSkillIndex]
						, m_pClientList[iClientH]->m_cMapName
						, m_pClientList[iClientH]->m_sX
						, m_pClientList[iClientH]->m_sY
						, m_pClientList[iClientH]->m_cIPaddress);
					PutLogList(G_cTxt);
					PutLogFileList(G_cTxt);
					PutSkillLogFileList(G_cTxt);
				}
				break;
			case 13: // Manufacturing
				if (m_pClientList[iClientH]->m_cSkillMastery[sSkillIndex] >= 50){
					wsprintf(G_cTxt, "PC(%s)\t%s Skill increased (%d%%)\t%s(%d %d)\tIP(%s)"
						, m_pClientList[iClientH]->m_cCharName
						, m_pSkillConfigList[sSkillIndex]->m_cName
						, m_pClientList[iClientH]->m_cSkillMastery[sSkillIndex]
						, m_pClientList[iClientH]->m_cMapName
						, m_pClientList[iClientH]->m_sX
						, m_pClientList[iClientH]->m_sY
						, m_pClientList[iClientH]->m_cIPaddress);
					PutLogList(G_cTxt);
					PutLogFileList(G_cTxt);
					PutSkillLogFileList(G_cTxt);
				}
				break;
			case 18: // Crafting
				if (m_pClientList[iClientH]->m_cSkillMastery[sSkillIndex] >= 50){
					wsprintf(G_cTxt, "PC(%s)\t%s Skill increased (%d%%)\t%s(%d %d)\tIP(%s)"
						, m_pClientList[iClientH]->m_cCharName
						, m_pSkillConfigList[sSkillIndex]->m_cName
						, m_pClientList[iClientH]->m_cSkillMastery[sSkillIndex]
						, m_pClientList[iClientH]->m_cMapName
						, m_pClientList[iClientH]->m_sX
						, m_pClientList[iClientH]->m_sY
						, m_pClientList[iClientH]->m_cIPaddress);
					PutLogList(G_cTxt);
					PutLogFileList(G_cTxt);
					PutSkillLogFileList(G_cTxt);
				}
				break;
			case 22: // Taming
				if (m_pClientList[iClientH]->m_cSkillMastery[sSkillIndex] >= 50){
					wsprintf(G_cTxt, "PC(%s)\t%s Skill increased (%d%%)\t%s(%d %d)\tIP(%s)"
						, m_pClientList[iClientH]->m_cCharName
						, m_pSkillConfigList[sSkillIndex]->m_cName
						, m_pClientList[iClientH]->m_cSkillMastery[sSkillIndex]
						, m_pClientList[iClientH]->m_cMapName
						, m_pClientList[iClientH]->m_sX
						, m_pClientList[iClientH]->m_sY
						, m_pClientList[iClientH]->m_cIPaddress);
					PutLogList(G_cTxt);
					PutLogFileList(G_cTxt);
					PutSkillLogFileList(G_cTxt);
				}
				break;
			default: // All skills.
				if (m_pClientList[iClientH]->m_cSkillMastery[sSkillIndex] >= 99){
					wsprintf(G_cTxt, "PC(%s)\t%s Skill increased (%d%%)\t%s(%d %d)\tIP(%s)"
						, m_pClientList[iClientH]->m_cCharName
						, m_pSkillConfigList[sSkillIndex]->m_cName
						, m_pClientList[iClientH]->m_cSkillMastery[sSkillIndex] 
						, m_pClientList[iClientH]->m_cMapName
						, m_pClientList[iClientH]->m_sX
						, m_pClientList[iClientH]->m_sY
						, m_pClientList[iClientH]->m_cIPaddress);
					PutLogList(G_cTxt);
					PutLogFileList(G_cTxt);
					PutSkillLogFileList(G_cTxt);
				}
				break;	
			}
		
			SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_SKILL, sSkillIndex, m_pClientList[iClientH]->m_cSkillMastery[sSkillIndex], NULL, NULL);
		}
	}
}

void CGame::MagicSMG()
{char cNpcName[21];
 int i, j;
	for ( i = 0; i < DEF_MAXMAPS; i++) 	
	{	if (m_pMapList[i] != NULL) 
		{	if (m_pMapList[i]->m_sSizeX <124) continue;
			if (m_pMapList[i]->m_sSizeY <124) continue;
			for (j = 0; j < DEF_MAXSPOTMOBGENERATOR; j++)
			{	if (m_pMapList[i]->m_stSpotMobGenerator[j].bDefined == TRUE)
				{	if (m_pMapList[i]->m_stSpotMobGenerator[j].cType < 0)
					{	m_pMapList[i]->m_stSpotMobGenerator[j].cType ++; // executed every 3 minutes
					}else if (m_pMapList[i]->m_stSpotMobGenerator[j].cType == 0)
					{	// Free all previous mobs from pit
						register int k;
						for (k = 0; k <DEF_MAXNPCS ; k++)  
						{	// Then remove monsters from current Spot Mob
							if (m_pNpcList[k] != NULL) 
							{	if (   (m_pNpcList[k]->m_cMapIndex == i)
									&& (m_pNpcList[k]->m_iSpotMobIndex == j))
								{	m_pNpcList[k]->m_iSpotMobIndex = 0;
						}	}	}
						m_pMapList[i]->m_stSpotMobGenerator[j].iCurMobs = 0;						
						m_pMapList[i]->m_stSpotMobGenerator[j].iKilledMobs = 0;
						// New location	(30x30 <=> Standard ML zombie pit)
						m_pMapList[i]->m_stSpotMobGenerator[j].rcRect.left   = 25 + iDice (1, (m_pMapList[i]->m_sSizeX-75)); 
						m_pMapList[i]->m_stSpotMobGenerator[j].rcRect.top    = 25 + iDice (1, (m_pMapList[i]->m_sSizeY-75));
						m_pMapList[i]->m_stSpotMobGenerator[j].rcRect.right  = m_pMapList[i]->m_stSpotMobGenerator[j].rcRect.left +25;
						m_pMapList[i]->m_stSpotMobGenerator[j].rcRect.bottom = m_pMapList[i]->m_stSpotMobGenerator[j].rcRect.top +25;						
						// reset duration (beware, it's char value ! )
						m_pMapList[i]->m_stSpotMobGenerator[j].cType = (char)(-1 * iDice(2,29));	// average duration 1h30
						// New mobtype and number
						ZeroMemory(cNpcName, sizeof(cNpcName));
						switch (iDice(1,150)) {// 1/4 chances of presence.
						case 1: 
						case 2:
						case 3: 
						case 4: // Slime 10
							strcpy(cNpcName,"Slime");
							m_pMapList[i]->m_stSpotMobGenerator[j].iMobType = 10;
							m_pMapList[i]->m_stSpotMobGenerator[j].iMaxMobs = 40;
							break; 
						case 5:
						case 6:  // Orc-Mage 6
							strcpy(cNpcName,"Orc-Mage");
							m_pMapList[i]->m_stSpotMobGenerator[j].iMobType = 6;
							m_pMapList[i]->m_stSpotMobGenerator[j].iMaxMobs = 20;
							break;
						case 7: 
						case 8: // Skeleton 11
							strcpy(cNpcName,"Skeleton");
							m_pMapList[i]->m_stSpotMobGenerator[j].iMobType = 11;
							m_pMapList[i]->m_stSpotMobGenerator[j].iMaxMobs = 30;
							break;
						case 9: 
						case 10: // Scorpion 17 
							strcpy(cNpcName,"Scorpion");
							m_pMapList[i]->m_stSpotMobGenerator[j].iMobType = 17;
							m_pMapList[i]->m_stSpotMobGenerator[j].iMaxMobs = 30;
							break;
						case 11: 
						case 12:  // Orc 14
							strcpy(cNpcName,"Orc");
							m_pMapList[i]->m_stSpotMobGenerator[j].iMobType = 14;
							m_pMapList[i]->m_stSpotMobGenerator[j].iMaxMobs = 30;
							break;
						case 13: 
						case 14: 
						case 15: 
						case 16: 
						case 17: // Stone-Golem 
							strcpy(cNpcName,"Stone-Golem");
							m_pMapList[i]->m_stSpotMobGenerator[j].iMobType = 12;
							m_pMapList[i]->m_stSpotMobGenerator[j].iMaxMobs = 20;	
							break;
						case 18: 
						case 19: 
						case 20:
						case 21: 
						case 22:  // Clay-Golem 
							strcpy(cNpcName,"Clay-Golem");
							m_pMapList[i]->m_stSpotMobGenerator[j].iMobType = 23;
							m_pMapList[i]->m_stSpotMobGenerator[j].iMaxMobs = 20;	
							break;
						case 23: 
						case 24:
						case 25:  // Frog
							strcpy(cNpcName,"Frog");
							m_pMapList[i]->m_stSpotMobGenerator[j].iMobType = 57;
							m_pMapList[i]->m_stSpotMobGenerator[j].iMaxMobs = 20;	
							break;
						case 26: // Cyclops 13
							strcpy(cNpcName,"Cyclops");
							m_pMapList[i]->m_stSpotMobGenerator[j].iMobType = 13;
							m_pMapList[i]->m_stSpotMobGenerator[j].iMaxMobs = 15;
							break; 
						case 27: 
						case 28: 
						case 29: // Troll
							strcpy(cNpcName,"Troll");
							m_pMapList[i]->m_stSpotMobGenerator[j].iMobType = 28;
							m_pMapList[i]->m_stSpotMobGenerator[j].iMaxMobs = 15;	
							break;
						case 30: 
						case 31: // Hellbound
							strcpy(cNpcName,"HH");
							m_pMapList[i]->m_stSpotMobGenerator[j].iMobType = 27;
							m_pMapList[i]->m_stSpotMobGenerator[j].iMaxMobs = 20;	
							break;
						case 32: // Mountain-Giant
							strcpy(cNpcName,"MG");
							m_pMapList[i]->m_stSpotMobGenerator[j].iMobType = 58;
							m_pMapList[i]->m_stSpotMobGenerator[j].iMaxMobs = 10;	
							break;
						case 33: // Hellclaw 49
							strcpy(cNpcName,"Hellclaw");
							m_pMapList[i]->m_stSpotMobGenerator[j].iMobType = 49;
							m_pMapList[i]->m_stSpotMobGenerator[j].iMaxMobs = 3;
							break;
						case 34: // Tentocle 80
							strcpy(cNpcName,"Tentocle");
							m_pMapList[i]->m_stSpotMobGenerator[j].iMobType = 80;
							m_pMapList[i]->m_stSpotMobGenerator[j].iMaxMobs = 15;
							break;
						case 35: // Stalker 48
							strcpy(cNpcName,"Stalker");
							m_pMapList[i]->m_stSpotMobGenerator[j].iMobType = 48;
							m_pMapList[i]->m_stSpotMobGenerator[j].iMaxMobs = 10;
							break;
						case 36: // Demon 31
							strcpy(cNpcName,"Demon");
							m_pMapList[i]->m_stSpotMobGenerator[j].iMobType = 31;
							m_pMapList[i]->m_stSpotMobGenerator[j].iMaxMobs = 5;
							break;
						default: // Empty pit...
							m_pMapList[i]->m_stSpotMobGenerator[j].iMobType = -1; //no mob
							m_pMapList[i]->m_stSpotMobGenerator[j].iMaxMobs = 0;							
							break;
						}
						if (m_pMapList[i]->m_stSpotMobGenerator[j].iMobType >0)
						{	wsprintf(G_cTxt, "Magic pit n°%d creation in %s (%d,%d), for %d min. Type %d (%s)"
								, j
								, m_pMapList[i]->m_cName
								, m_pMapList[i]->m_stSpotMobGenerator[j].rcRect.left + 12
								, m_pMapList[i]->m_stSpotMobGenerator[j].rcRect.top +12
								, -3 * m_pMapList[i]->m_stSpotMobGenerator[j].cType
								, m_pMapList[i]->m_stSpotMobGenerator[j].iMobType 
								, cNpcName);
							PutLogEventFileList(G_cTxt);
							PutLogList(G_cTxt);
						}else 
						{	wsprintf(G_cTxt, "Magic pit n°%d creation in %s (%d,%d), for %d min. Empty"
								, j
								, m_pMapList[i]->m_cName
								, m_pMapList[i]->m_stSpotMobGenerator[j].rcRect.left + 12
								, m_pMapList[i]->m_stSpotMobGenerator[j].rcRect.top +12
								, -3 * m_pMapList[i]->m_stSpotMobGenerator[j].cType	);
							PutLogList(G_cTxt);
	}	}	}	}	}	}
}

void CGame::MobGenerator() // executed every 600ms
{	register int i, x, j, iNamingValue, iResult, iTotalMob;
	char cNpcName[21], cName_Master[11], cName_Slave[11], cWaypoint[11];
	char cSpawnDefinition[127];
	char cSA;
	int  pX, pY, iProbSA, iKindSA, iResultNum, iNpcID;
	BOOL bMaster, bFirmBerserk = FALSE, bIsSpecialEvent, bIsABossNow = FALSE;
	if (m_bOnExitProcess == TRUE) return;
	char bExecutorFriendMob = -1; // Put another side value if needed.
	// Snoopy: Added support for dextructing some npcs if we want the map to respawn monsters
	// (ie: single player at D2 XPing at Clops pit will never see spawns! )	
	int debugcompteur;
	int i_ToRemoveAObj;
	int i5;
	DWORD wX, wY;
	
	for (i = 0; i < DEF_MAXMAPS; i++) 
	{	debugcompteur = 0;		
		if ( (m_pMapList[i] != NULL) 
			&& (m_pMapList[i]->m_iRandomMobGeneratorSA > 1)	// If maps wants to remove mobs...
			&& (m_pMapList[i]->m_bIsApocalypseMap	== FALSE)	
			&& (m_pMapList[i]->m_bIsHeldenianMap	== FALSE)
			&& (m_pMapList[i]->m_nIsNotPermanentMap	== FALSE)
			&& (m_bIsSpecialEventTime	== TRUE)
			&& (m_cSpecialEventType == 99) //Special event n° 99
			&& ((CalcCityStr(2, (char)i, TRUE, FALSE) + CalcCityStr(2, (char)i, TRUE, FALSE)) >0) // Need somebody on the map
			&& (m_pMapList[i]->m_iTotalActiveObject > (m_pMapList[i]->m_iMaximumObject - 60)) ) 
		{	m_bIsSpecialEventTime = FALSE;
			// m_cSpecialEventType  to 99 will notify not to remove again until after next spawn
			for (j = 0; j <DEF_MAXNPCS ; j++)  
			{	// Then remove monsters
				if (m_pNpcList[j] != NULL) 
				{	if (   (m_pNpcList[j]->m_bIsSummoned == FALSE)	// Not a summon				
						&& (m_pNpcList[j]->m_dwTamingTime == 0)		// Not a tamed mob
						&& (m_pNpcList[j]->m_bIsKilled == FALSE)	// Not already Killed
						&& (m_pNpcList[j]->m_cMapIndex == i)		// On proper map
						&& (m_pNpcList[j]->m_iSpotMobIndex == 0)	// Not in a pit (woul spawn Boos over time...
						// Remove X % of npcs
						&& ( iDice(1,100) < m_pMapList[i]->m_iRandomMobGeneratorSA) )
					{	// but never remove topLevel NPCs
						// All npcs stronger than Orge will not be removed
						if (m_pNpcList[j]->m_iHitDice <= 115) 
						{	// Prevent 2nd drops							
							m_pNpcList[j]->m_bIsUnsummoned = TRUE; 	
							NpcKilledHandler(j, DEF_OWNERTYPE_NPC, j, 0);
							DeleteNpc(j);
							debugcompteur ++;
			}	}	}	}
			// Log that
			wsprintf(G_cTxt, "(!) Auto - Removing %d %% of mobs, to generate spawns. Map(%s) (removed %d)"
				, m_pMapList[i]->m_iRandomMobGeneratorSA
				, m_pMapList[i]->m_cName
				, debugcompteur);
			PutLogList(G_cTxt);
		}
		// Then remove some mobs if too much mobs after Magic pit ending.
		debugcompteur = 0;		
		if ( (m_pMapList[i] != NULL) 
			&& (m_pMapList[i]->m_bHasMagicSMG == TRUE)	// Only map containing on Magic Pit
			&& (m_pMapList[i]->m_iRandomMobGeneratorSA <= 1) 
			&& (m_bIsSpecialEventTime == TRUE)
			&& (m_cSpecialEventType == 99) //Special event n° 99
			&& (m_pMapList[i]->m_iTotalActiveObject > (m_pMapList[i]->m_iMaximumObject - 15)) ) 
		{	i_ToRemoveAObj = 20 + m_pMapList[i]->m_iTotalActiveObject - m_pMapList[i]->m_iMaximumObject;
			m_bIsSpecialEventTime = FALSE;
			// m_cSpecialEventType  to 99 will notify not to remove again until after next spawn
			for (j = 0; j <DEF_MAXNPCS ; j++)  
			{	// Then remove monsters
				if (m_pNpcList[j] != NULL) 
				{	if (   (m_pNpcList[j]->m_bIsSummoned == FALSE)	// Not a summon		
						&& (m_pNpcList[j]->m_dwTamingTime == 0)		// Not a tamed mob
						&& (m_pNpcList[j]->m_bIsKilled == FALSE)	// Not already Killed
						&& (m_pNpcList[j]->m_iSpotMobIndex == 0)	// Not in a pit
						&& (m_pNpcList[j]->m_iHitDice <= 115)		// All npcs stronger than Orge will not be removed
						&& (m_pNpcList[j]->m_cMapIndex == i))		// On proper map
					{	// Prevent 2nd drops							
						m_pNpcList[j]->m_bIsUnsummoned = TRUE; 	
						NpcKilledHandler(j, DEF_OWNERTYPE_NPC, j, 0);
						DeleteNpc(j);
						i_ToRemoveAObj -= 1;
						debugcompteur ++;
				}	}
				if (i_ToRemoveAObj <=0) break;				
			}// Log that
			wsprintf(G_cTxt, "(!) Auto - Removing some mobs, because Magic pit generated too much. Map(%s) (removed %d)"
				, m_pMapList[i]->m_cName
				, debugcompteur);
			PutLogList(G_cTxt);	
	}	}
	for (i = 0; i < DEF_MAXMAPS; i++)
	{	iResultNum = 0;
// First, Random Mob Generator			
		bExecutorFriendMob = -1;
		bIsABossNow = FALSE;
		if (m_pMapList[i] != NULL) 
		{	if (m_bIsCrusadeMode == TRUE) iResultNum = (m_pMapList[i]->m_iMaximumObject - 10) / 3;
			else iResultNum = (m_pMapList[i]->m_iMaximumObject - 30);
			if (iResultNum < 0) iResultNum = 0; 
		}
		if (   (m_pMapList[i] != NULL) && (m_pMapList[i]->m_iRandomMobGeneratorSA > 0) 
			&& (iResultNum > m_pMapList[i]->m_iTotalActiveObject) ) 
		{	if ((m_iMiddlelandMapIndex != -1) && (m_iMiddlelandMapIndex == i) && (m_bIsCrusadeMode == TRUE)) continue;
			iNamingValue = m_pMapList[i]->iGetEmptyNamingValue();
			if (iNamingValue != -1) // Master Mob????????				
			{	ZeroMemory(cName_Master, sizeof(cName_Master));
				wsprintf(cName_Master, "XX%d", iNamingValue);
				cName_Master[0] = '_';
				cName_Master[1] = i + 65;
				ZeroMemory(cNpcName, sizeof(cNpcName));
				bFirmBerserk = FALSE;
				iResult = iDice(1,100);
				switch (m_pMapList[i]->m_cRandomMobGeneratorLevel) {
// Snoopy: Tweaked Ramdom-Mobs...
				case 1: // arefarm, elvfarm, aresden, elvine
					if ((iResult >= 1) && (iResult < 20)) 
					{	iResult = 1; // Slime
					}else if ((iResult >= 20) && (iResult < 40)) 
					{	iResult = 2; // Giant-Ant
					}else if ((iResult >= 40) && (iResult < 85)) 
					{	iResult = 24; // Rabbit
					}else if ((iResult >= 85) && (iResult < 95)) 
					{	iResult = 25; // Cat
					}else if ((iResult >= 95) && (iResult <= 100)) 
					{	iResult = 3;  // Orc
					}
					break;

				case 2: // Same without Cats/Rabbits
					if ((iResult >= 1) && (iResult < 44)) 
					{	iResult = 1; // Slime
					}else if ((iResult >= 44) && (iResult < 88)) 
					{	iResult = 2; // Giant-Ant
					}else iResult = 3; // Orc
					break;

				case 3:     // MiddleLand
					if ((iResult >= 1) && (iResult < 10)) 
					{	iResult = 3; // Orc
					}else if ((iResult >= 10) && (iResult < 20)) 
					{	iResult = 4; // Zombie
					}else if ((iResult >= 20) && (iResult < 50)) 
					{	switch (iDice(1,3)) 
					{	case 1: iResult = 5;  break; // Skeleton
						case 2: iResult = 6;  break; // Orc-Mage
						case 3:	iResult = 7;  break; // Scorpion
						}
					}else if ((iResult >= 50) && (iResult < 75)) 
					{	switch (iDice(1,7)) {
						case 1:
						case 2:	iResult = 8;  break; // Stone-Golem
						case 3:	iResult = 11; break; // Clay-Golem
						case 4: iResult = 12; break; // Troll
						case 5:	iResult = 18; break; // WereWolf
						case 6:	iResult = 26; break; // Frog
						case 7: iResult = 28; break; // Ettin
						}
					}else if ((iResult >= 75) && (iResult <= 100)) 
					{	switch (iDice(1,5)) {	
						case 1:
						case 2: iResult = 9;  break; // Cyclops
						case 3:	iResult = 13; break; // Ogre
						case 4: iResult = 14; break; // Hellbound
						case 5:	iResult = 27; break; // Mountain-Giant
						}
					}
					break;

				case 4: // Dungeon 1 
					if ((iResult >= 1) && (iResult < 50)) 
					{	switch (iDice(1,2)) {
						case 1:	iResult = 2;  break; // Giant-Ant
						case 2: iResult = 10; break; // Amphis
						}
					}else if ((iResult >= 50) && (iResult < 80)) 
					{	switch (iDice(1,2)) {
						case 1: iResult = 8;  break; // Stone-Golem
						case 2: iResult = 11; break; // Clay-Golem
						}
					}else if ((iResult >= 80) && (iResult <= 100)) 
					{	switch (iDice(1,2)) {
						case 1: iResult = 14; break; // Hellbound
						case 2:	iResult = 9;  break; // Cyclops
						}
					}
					break;

				case 5: // Dungeon 2 
					if ((iResult >= 1) && (iResult < 30)) 
					{	iResult = 2;  // Giant-Ant
					}else if ((iResult >= 30) && (iResult < 45)) 
					{	iResult = 3; // Orc
					}else if ((iResult >= 45) && (iResult < 60)) 
					{	iResult = 4; // Zombie
					}else if ((iResult >= 60) && (iResult < 70)) 
					{	iResult = 5; // Skeleton
					}else if ((iResult >= 70) && (iResult < 80)) 
					{	iResult = 7; // Scorpion
					}else if ((iResult >= 80) && (iResult < 95)) 
					{	switch (iDice(1,3)) {
						case 1:
						case 2: iResult = 8;  break; // Stone-Golem
						case 3:	iResult = 11; break; // Clay-Golem
						}
					}else if ((iResult >= 95) && (iResult <= 100)) 
					{	switch (iDice(1,3)) {
						case 1: iResult = 11; break; // Clay-Golem
						case 2: iResult = 14; break; // Hellbound
						case 3: iResult = 9;  break; // Cyclops
						}
					}
					break;

				case 6: // huntzone3, huntzone4 (SW/DV) from HBChina351
					if ((iResult >= 1) && (iResult < 60)) 
					{	switch (iDice(1,4)) {
						case 1: iResult = 5;  break; // Skeleton
						case 2:	iResult = 6;  break; // Orc-Mage
						case 3: iResult = 12; break; // Troll
						case 4: iResult = 11; break; // Clay
						}
					}else if ((iResult >= 60) && (iResult < 90)) 
					{	switch (iDice(1,5)) {
						case 1:
						case 2: iResult = 8;  break; // Stone-Golem
						case 3:	iResult = 11; break; // Clay
						case 4:	iResult = 12; break; // Troll 
						case 5:	iResult = 39; break; // Tentocle
						}
					}else if ((iResult >= 90) && (iResult <= 100)) 
					{	switch (iDice(1,8)) {
						case 1:	iResult = 26; break; // Frog
						case 2:	iResult = 9;  break; // Cyclops
						case 3: iResult = 13; break; // Ogre
						case 4: iResult = 14; break; // Hellbound
						case 5:	iResult = 18; break; // WereWolf
						case 6:	iResult = 28; break; // Ettin
						case 7: iResult = 27; break; // Mountain-Giant
						case 8: iResult = 29; break; // Plant
						}
					}
					break;

				case 7: // areuni, elvuni
					/*if ((iResult >= 1) && (iResult 50)) //HBChina351 version
					{	switch (iDice(1,5)) {
						case 1:	
						case 2: iResult = 3;  break; // Orc
						case 3:	iResult = 6;  break; // OrcMage
						case 4: iResult = 10; break; // Ant
						case 5:	iResult = 46; break; // Giant-Tree
						}
					}else if ((iResult >= 50) && (iResult < 60)) 
					{	iResult = 30; break; // Ruddolf						
					}else if ((iResult >= 60) && (iResult < 85)) 
					{	switch ( iDice(1,4) ) {
						case 1: iResult = 46;  break; // Giant-Tree
						case 2:  
						case 3: iResult = 6;  break; // Orc-Mage
						case 4: iResult = 12; break; // Troll 
						}
					}else if ((iResult >= 85) && (iResult <= 100)) 
					{	switch ( iDice(1,4) ) {
						case 1: iResult = 29; break; // Plant 
						case 2: iResult = 12; break; // Troll
						case 3: 
						case 4:  
							if (iDice(1,100)<3) iResult = 17; // Unicorn
							else iResult = 12; break; // Troll 
						}
					}*/
					if ((iResult >= 1) && (iResult < 70)) 
					{	switch (iDice(1,7)) {
						case 1: iResult = 1;  break; // Slime
						case 2: iResult = 2;  break; // Giant-Ant
						case 3: iResult = 10; break; // Amphis
						case 4: iResult = 3;  break; // Orc
						case 5: iResult = 6;  break; // Orc-Mage					
						case 6: iResult = 30; break; // Ruddolf
						case 7: iResult = 29; break; // Plant
						}
					}else if ((iResult >= 70) && (iResult < 95)) 
					{ 	switch (iDice(1,10)) {
						case 1: 
						case 2: 
						case 3: iResult = 46; break; // Giant-Tree 7.5%
						case 4: 
						case 5: 
						case 6: 
						case 7: iResult = 12; break; // Troll 10%
						case 8: 
						case 9: iResult = 6;  break; // Orc-Mage 20%
						case 10: iResult = 24;  break; //  Rabbit
						}
					}else if ((iResult >= 95) && (iResult <= 100)) 
					{	if (iDice(1,100) < 5) 
							iResult = 17; // Unicorn
						else iResult = 6; // Orc-Mage
					}
					break;

				case 8: // PL (HBChina351 uses RMG16)
					if ((iResult >= 1) && (iResult < 70)) 
					{	switch (iDice(1,2)) {
						case 1:	iResult = 4;  break; // Zombie
						case 2: iResult = 5;  break; // Skelleton
						}
					}else if ((iResult >= 70) && (iResult < 90)) 
					{	switch (iDice(1,3)) {
						case 1: iResult = 8;  break; // Stone-Golem
						case 2: iResult = 11; break; // Clay-Golem
						case 3: iResult = 14; break; // Hellbound
						}
					}else if ((iResult >= 90) && (iResult <= 100)) 
					{	switch ( iDice(1,2) ) {
						case 1: iResult = 9;  break; // Cyclops
						case 2: iResult = 30; break; // Rudolfs (was HH on HBChina351)
						}
					}
					break;

				case 9: // D3 same HBChina351
					if ((iResult >= 1) && (iResult < 70)) 
					{	switch (iDice(1,2)) {
						case 1:	iResult = 4;  break; // Zombie
						case 2: iResult = 5;  break; // Skelleton
						}
					}else if ((iResult >= 70) && (iResult < 95)) 
					{	switch (iDice(1,3)) {
						case 1: iResult = 8;  break; // Stone-Golem
						case 2: iResult = 9;  break; // Cyclops
						case 3: iResult = 13; break; // Ogre
						}
					}else if ((iResult >= 95) && (iResult <= 100)) 
					{	switch (iDice(1,6)) {
						case 1: 
						case 2: 
						case 3: iResult = 9;  break; // Cyclops
						case 4: 
						case 5: iResult = 14; break; // Hellbound
						case 6: iResult = 15; break; // Liche
						}
					}
					if (iDice(1,3) == 1)  bFirmBerserk = TRUE;
					break;

				case 10: // D4 Not same as China351 (Zombie replaced by Stone+Clops)
					if ((iResult >= 1) && (iResult < 70)) 
					{	switch (iDice(1,2)) {
						case 1:	iResult = 4; break; // Zombie
						case 2: iResult = 5; break; // Skeleton
						}
					}else if ((iResult >= 70) && (iResult < 95)) 
					{	switch (iDice(1,3)) {
					case 1:
					case 2:	iResult = 13; break; // Ogre
					case 3: iResult = 14; break; // Hellbound
						}
					}else if ((iResult >= 95) && (iResult <= 100)) 
					{	switch (iDice(1,3)) {
						case 1:
						case 2: iResult = 14; break; // Hellbound
						case 3: iResult = 15; break; // Liche
						}
					}
					// Demon?? Berserk ????? ??? ?????
					if (iDice(1,3) == 1)  bFirmBerserk = TRUE;
					break;

				case 11: // was tweaked for EF/RH on Revival/Equilibrium
					// Was really strange but unused on HBChina351....
					if ((iResult >= 1) && (iResult < 15)) 
					{	iResult = 2; break; // Ant
					}else if ((iResult >= 15) && (iResult < 45)) 
					{	switch (iDice(1,2)) {
						case 1: iResult = 1;  break; // Slime
						case 2: iResult = 10; break; // Snake
						}
					}else if ((iResult >= 45) && (iResult < 65)) 
					{	switch (iDice(1,2)) {
						case 1: iResult = 8;  break; // Stone-Golem
						case 2: iResult = 11; break; // Clay-Golem
						}
					}else if ((iResult >= 65) && (iResult < 80)) 
					{	switch (iDice(1,2)) {
						case 1: iResult = 30; break; // Ruddolf
						case 2: iResult = 26; break; // Frog	
						}
					}else if ((iResult >= 80) && (iResult <= 100)) 
					{	switch (iDice(1,3)) {
						case 1: iResult = 4; break; // Zombie
						case 2: iResult = 5; break; // Skeletton
						case 3: iResult = 3; break; // Orc
						}
					}
					break;

				case 12: // Noob Dungeon from HBChina351
					if ((iResult >= 1) && (iResult < 50)) 
					{	switch (iDice(1,3)) {
						case 1:	iResult = 1 ; break; // Slime
						case 2: iResult = 2 ; break; // Ant
						case 3: iResult = 10; break; // Snake
						}
					}else if ((iResult >= 50) && (iResult < 85)) 
					{	switch (iDice(1,2)) {
						case 1: iResult = 5; break; // Skeletton
						case 2: iResult = 4; break; // Zombie
						}
					}else if ((iResult >= 85) && (iResult <= 100))
					{	switch (iDice(1,3)) {
						case 1: iResult = 8;  break; // Stone-Golem
						case 2: iResult = 11; break; // Clay-Golem
						case 3: iResult = 26; break; // Frog 
						}
					}
					break;

				case 13: // TOH1 from HBChina351
					if ((iResult >= 1) && (iResult < 15)) 
					{	iResult = 4; // Zombie
						bFirmBerserk = TRUE;
						iTotalMob = 4 - (iDice(1,2) - 1);
					}else if ((iResult >= 15) && (iResult < 40)) 
					{	iResult = 14; // HH
						if (iDice(1,3) > 1) bFirmBerserk = TRUE;
						iTotalMob = 4 - (iDice(1,2) - 1);
					}else if ((iResult >= 40) && (iResult < 60)) 
					{	iResult = 9; // Cyclops
						if (iDice(1,3) > 1) bFirmBerserk = TRUE;
						bFirmBerserk = TRUE;
						iTotalMob = 4 - (iDice(1,2) - 1);
					}else if ((iResult >= 60) && (iResult < 75)) 
					{	iResult = 13; // Ogre
						if (iDice(1,2) == 1) bFirmBerserk = TRUE;
						iTotalMob = 4 - (iDice(1,2) - 1);
					}else if ((iResult >= 75) && (iResult < 95)) 
					{	iResult = 23; // Dark-Elf
					}else if ((iResult >= 95) && (iResult <= 100)) 
					{	iResult = 22; // Beholder
					}
					break;

				case 14: // TOH2: HBChina351 replaces DD by Ogres....
					if ((iResult >= 1) && (iResult < 30)) 
					{	iResult = 23; // Dark-Elf
					}else if ((iResult >= 30) && (iResult < 50)) 
					{	iResult = 22; // Beholder
					}else if ((iResult >= 50) && (iResult < 70)) 
					{	iResult = 15; // Liche
						bFirmBerserk = TRUE;
						iTotalMob = 4 - (iDice(1,2) - 1);
					}else if ((iResult >= 70) && (iResult < 90)) 
					{	iResult = 16; // Demon
					}else if ((iResult >= 90) && (iResult <= 100)) 
					{	iResult = 21; // GG
					}
					break;

				case 15: //TOH3 from HBChina351
					if ((iResult >= 1) && (iResult < 35)) 
					{	iResult = 23; // Dark-Elf 
						bFirmBerserk = TRUE;
					}else if ((iResult >= 35) && (iResult < 50)) 
					{	iResult = 22; // Beholder
						bFirmBerserk = TRUE;
					}else if ((iResult >= 50) && (iResult < 80)) 
					{	iResult = 15; // Liche
					}else if ((iResult >= 80) && (iResult <= 100)) 
					{	iResult = 21; // Gagoyle
					}
					break;

				case 16: // 2ndmiddle, huntzone1, huntzone2 from HBChina351 
						 // SNOOPY: Using n°11 instead
					if ((iResult >= 1) && (iResult < 40)) 
					{	switch (iDice(1,3)) {
						case 1:	iResult = 7;  break; // Scorpion
						case 2: iResult = 2;  break; // Giant-Ant
						case 3: iResult = 10; break; // Amphis
						}
					}else if ((iResult >= 40) && (iResult < 50)) 
					{	iResult = 30; // Rudolph
					}else if ((iResult >= 50) && (iResult < 85)) 
					{	switch (iDice(1,2)) {
						case 1: iResult = 5;  break; // Skeleton
						case 2: iResult = 4;  break; // Zombie
						}
					}else if ((iResult >= 85) && (iResult <= 100)) 
					{	switch (iDice(1,3)) {
						case 1: iResult = 8;  break; // Stone-Golem
						case 2: iResult = 11; break; // Clay-Golem
						case 3: iResult = 7;  break; // Scorpion
						}
					}
					break;

				case 17: // SNOOPY: improved for Icebound 
					//CHina3.51:
					// 1..30% StoneG, Rabbit, Skel, Beholder
					// 31..40% Ruddolf
					// 41..70% DireBoard
					// 71..90% IceGolem
					// 90..100% Frost	
					// Reduced Rabbit (quest)
					// Added rares mobs: HC, TW, Wyverns, MG, Ettin, & some Rabbits 
					if ((iResult >= 1) && (iResult < 30)) 
					{	switch (iDice(1,4)) {
						case 1:	iResult = 22; break; // Beholder 
						case 2: iResult = 8;  break; // Stone-Golem
						case 3: iResult = 5;  break; // Skeleton
						case 4: iResult = 26; break; // Frog
						}						
						if (iDice(1,3) != 1) bFirmBerserk = TRUE;						
					}else if ((iResult >= 30) && (iResult < 40)) 
					{	iResult = 30; // Ruddolf
					}else if ((iResult >= 40) && (iResult < 65)) 
					{	iResult = 32; // DireBoar
					}else if ((iResult >= 65) && (iResult < 85)) 
					{	iResult = 31; // Ice-Golem
						if (iDice(1,4) == 1) bFirmBerserk = TRUE;
					}else if ((iResult >= 85) && (iResult <= 100)) 
					{	switch (iDice(1,30)) {
						case 1:	
						case 2:	
						case 3:	iResult = 27; break; // MG
						case 4:	
						case 5:	iResult = 28; break; // Ettin
						case 6:	
						case 7:	iResult = 24; break; // Rabbit
						case 8:	
						case 9:	iResult = 35; // HC
							iTotalMob = 1;							
							break;
						case 10:iResult = 49; // TW
							iTotalMob = 1;
							break; 	
						case 11:	
						case 12:
						case 13: iResult = 36;// Wyvern
							iTotalMob = 1; break; 
						default:iResult = 33; // Frost;
							if (iDice(1,4) == 1) 
							{	bFirmBerserk = TRUE;
							}
							break; 
						}
					}
					break;

				case 18: // druncncity Map from HBChina351
					if ((iResult == 1) || (iResult == 2)) 
					{	iResult = 35; // Hellclaw
					}else if ((iResult > 2) && (iResult <= 12)) 
					{	iResult = 48; // Nizie
					}else if ((iResult > 12) && (iResult <= 50)) 
					{	iResult = 44; // ClawTurtle
					}else if ((iResult > 50) && (iResult <= 85)) 
					{	iResult = 45; // Giant-Crayfish
					}else if ((iResult > 85) && (iResult <= 95)) 
					{	iResult = 34; // Stalker							
					}else if ((iResult > 95) && (iResult <= 100)) 
					{	iResult = 26; // Frog
					}
					break;

				case 19: // Maze Map from HBChina351
					if ((iResult >= 1) && (iResult <= 15)) 
					{	iResult = 40; // Centaur
					}else if ((iResult > 15) && (iResult <= 25)) 
					{	iResult = 42; // Minaus
					}else if ((iResult > 25) && (iResult <= 35)) 
					{	iResult = 21; // Gagoyle
					}else if ((iResult > 35) && (iResult <= 60)) 
					{	iResult = 43; // Tentocle					
					}else if ((iResult > 60) && (iResult < 90)) 
					{	iResult = 23; // Dark-Elf					
					}else if ((iResult >= 90) && (iResult <= 100)) 
					{	iResult = 22; // Beholder
					}
					break;

				case 20: // Heldenian Map from HBChina351
					if (iResult == 1)  
					{	iResult = 37; // Fire-Wyvern
					}else if ((iResult > 1) && (iResult <=3)) 
					{	iResult = 36; // Wyvern
					}else if ((iResult > 3) && (iResult <= 8)) 
					{	iResult = 49; // TigerWorm
					}else if ((iResult == 9)) 
					{	iResult = 38; // HC
					}else if ((iResult > 9) && (iResult <= 20)) 
					{	iResult = 21; // Gagoyle
					}else if ((iResult > 20) && (iResult <= 35)) 
					{	iResult = 16; // Demon
					}else if ((iResult > 35) && (iResult <= 45)) 
					{	iResult = 40; // Centaurus
					}else if ((iResult > 45) && (iResult <= 55)) 
					{	iResult = 41; // Giant Lizard
					}else if ((iResult > 55) && (iResult <= 75)) 
					{	iResult = 28; // Ettin					
					}else if ((iResult > 75) && (iResult <= 95)) 
					{	iResult = 43; // Tentocle
					}else if ((iResult > 95) && (iResult <= 100)) 
					{	iResult = 22; // Beholder
					}
					break;

				case 21: // ????????
					if ((iResult >= 1) && (iResult < 94)) 
					{	iResult = 17; // Unicorn
						bFirmBerserk = TRUE;
					}else if ((iResult >= 94) && (iResult < 95)) 
					{	iResult = 36; // Wyvern
					}else if ((iResult >= 95) && (iResult < 96)) 
					{	iResult = 37; // Fire-Wyvern
					}else if ((iResult >= 96) && (iResult < 97)) 
					{	iResult = 47; // MasterMage-Orc
					}else if ((iResult >= 97) && (iResult < 98)) 
					{	iResult = 35; // Hellclaw
					}else if ((iResult >= 98) && (iResult < 99)) 
					{	iResult = 49; // Tigerworm
					}else if ((iResult >= 99) && (iResult <= 100)) 
					{	iResult = 51; // Abaddon
					}
					break;

				case 22: // SNOOPY: Catacombs
					if ((iResult >= 1) && (iResult < 5)) 
					{ 	iResult = 101; /// Hellcat
						if (iDice(1,3) == 1) bFirmBerserk = TRUE;
					}else if ((iResult >= 5) && (iResult < 30)) 
					{	iResult = 14; // HH
						if (iDice(1,3) == 1) bFirmBerserk = TRUE;
					}else if ((iResult >= 30) && (iResult < 40)) 
					{	iResult = 38; // Dragon
						if (iDice(1,10) == 1) bFirmBerserk = TRUE;
					}else if ((iResult >= 40) && (iResult < 55)) 
					{	iResult = 28; // Ettin
						if (iDice(1,5) == 1) bFirmBerserk = TRUE;
					}else if ((iResult >= 55) && (iResult < 75)) 
					{	iResult = 4; // Zombie
						if (iDice(1,2) == 1) bFirmBerserk = TRUE;
					}else if ((iResult >= 75) && (iResult < 100)) 
					{	iResult = 5; // Skeleton
						if (iDice(1,2) == 1) bFirmBerserk = TRUE;
					}else switch (iDice(1,10)) { //1 in 100
						case 1:  
						case 2:  
						case 3:  
						case 4:	 iResult = 42; break; // Minotaurs
						case 5:  
						case 6:	 iResult = 23; break; // Dark-Elf
						case 7:  
						case 8:  iResult = 15; break; // Liche
						case 9:  iResult = 16; break; // Demon
						case 10: iResult = 22; break; // Beholder 
					}
					break;
				
				case 23: // SNOOPY: Occupied cities
					// npc 1 to 14: 1%   Slime, Ant, Rudolf, Zombie, Skeleton, Orc-Mage, Scorp,
					//	                 Stone, Snk, Clay, Troll, HH
					// Note this n° (23) is used to prevent eggs and rare drops in occupied cities
					if ((iResult >= 15) && (iResult < 31)) 
					{	iResult = 102; // City-Cyclops
						if (iDice(1,2) == 1) bFirmBerserk = TRUE;
					}else if ((iResult >= 31) && (iResult < 47)) 
					{	iResult = 103; // City-Ogre
						if (iDice(1,4) == 1) bFirmBerserk = TRUE;
					}else if ((iResult >= 47) && (iResult < 52)) 
					{	iResult = 104; // City-Dark-Elf
						if (iDice(1,6) == 1) bFirmBerserk = TRUE;
					}else if ((iResult >= 52) && (iResult < 73)) 
					{	iResult = 105; // War-Elvine
						if (iDice(1,3) == 1) bFirmBerserk = TRUE;
					}else if ((iResult >= 73) && (iResult < 94)) 
					{	iResult = 106; // War-Aresden
						if (iDice(1,3) == 1) bFirmBerserk = TRUE;
					}else if ((iResult >= 94) && (iResult <= 100)) 
					{	iResult = 101; // Hellcat
					}else bExecutorFriendMob = 4; // Will work for 1..14 values...
					break;
					
				case 24: // Special design for QusMarch
					if ((iResult >= 1) && (iResult < 58)) 
					{	switch (iDice(1,4)) {
						case 1: iResult = 5;  break; // Skeleton
						case 2:	iResult = 6;  break; // Orc-Mage
						case 3: iResult = 7;  break; // Scorpions
						case 4: iResult = 4;  break; // Zombie
						}
					}else if ((iResult >= 58) && (iResult < 88)) 
					{	switch (iDice(1,6)) {
						case 1:
						case 2: iResult = 8;  break; // Stone-Golem
						case 3:
						case 4:	iResult = 11; break; // Clay
						case 5:	iResult = 12; break; // Troll 
						case 6:	iResult = 39; break; // Tentocle (1)
						}
					}else if ((iResult >= 88) && (iResult < 99))
					{	switch (iDice(1,10)) {
						case 1:	iResult = 26; break; // Frog
						case 2:	iResult = 9;  break; // Cyclops
						case 3: iResult = 13; break; // Ogre
						case 4: iResult = 14; break; // Hellbound
						case 5:	iResult = 18; break; // WereWolf
						case 6: 
						case 7:	
						case 8: iResult = 28; break; // Ettin
						case 9: iResult = 27; break; // Mountain-Giant
						case 10:iResult = 29; break; // Plant 
						}
					}else if ((iResult >= 99) && (iResult <= 100)) 
					{	switch (iDice(1,20)) {
						case 1: 
						case 2:	 
						case 3:
						case 4:	  
						case 5:  
						case 6:  
						case 7:
						case 8:  iResult = 38; break; // Dragon
						case 9:  
						case 10: 
						case 11: 
						case 12: 
						case 13: 
						case 14: iResult = 32; break; // DireBoar
						case 15: 
						case 16: 
						case 17: iResult = 34; break; // Stalker
						case 18: iResult = 40; break; // Centaurus
						case 19: iResult = 41; break; // Giant-Lizard	  
						case 20: iResult = 47; break; // MasterMage-Orc 
						}
					}
					break;
				}	
				pX = NULL;
				pY = NULL;
				bIsSpecialEvent = FALSE;
				// This iDice is used to give some delay to the event, if condition not matched,
				// Special event is still on, and may happen next time ::MobGenerator is called.
				if ((m_bIsSpecialEventTime == TRUE) && (iDice(1,10) == 3)) bIsSpecialEvent = TRUE;
				if (bIsSpecialEvent == TRUE) 
				{	ZeroMemory(cSpawnDefinition, sizeof(cSpawnDefinition));
					switch (m_cSpecialEventType) {
					case 3: // Special Boss with spawn, spawn only if someone on the map					
						if ((CalcCityStr(2, (char)i, TRUE, FALSE) + CalcCityStr(2, (char)i, TRUE, FALSE)) >0) // Need somebody on the map
						{	// Spawns the current creature of the Random-Mob indicated
							if (m_pMapList[i]->m_iMaxPx != 0) 	// spawn near activity						
							{	pX = m_pMapList[i]->m_iMaxPx*20 +10;
								pY = m_pMapList[i]->m_iMaxPy*20 +10;
								if (pX < 0) pX = 0;
								if (pY < 0) pY = 0;
								// Log Mob spawning
								wsprintf(cSpawnDefinition, "(On player activity)");
								bIsABossNow = TRUE;
								break;												
						}	} // If nobody on map, treat as Type 1
					case 1: // Normal spawn  
						// Spawns the creature of the current Random-Mob indicated
						if (m_pMapList[i]->m_iMaxPx != 0) // If player activity, spawn near activity						
						{	pX = m_pMapList[i]->m_iMaxPx*20 +10;
							pY = m_pMapList[i]->m_iMaxPy*20 +10;
							if (pX < 0) pX = 0;
							if (pY < 0) pY = 0;
							if (   (m_bIsCrusadeMode == TRUE) 
								&& (timeGetTime() > (m_dwCrusadeStartTime + 15*60*1000)))
							{ // Crusade time, spawning mercenaries in cities, 20min after crusade start
								if (strcmp(m_pMapList[i]->m_cName, "aresden") == 0)
								{	switch(iDice(1,6)) {
									case 1: iResult = 20; break; //Mercenaries
									case 2: iResult = 53; break;
									case 3: iResult = 55; break;
									case 4: iResult = 57; break;
									case 5: iResult = 59; break;
									case 6: iResult = 61; break;
									}
								}else if (strcmp(m_pMapList[i]->m_cName, "elvine") == 0)
								{	switch(iDice(1,6)) {
									case 1: iResult = 19; break; //Mercenaries
									case 2: iResult = 52; break;
									case 3: iResult = 54; break;
									case 4: iResult = 56; break;
									case 5: iResult = 58; break;
									case 6: iResult = 60; break;
								}	}
								// Log Mob spawning cSpawnDefinition
								wsprintf(cSpawnDefinition, "(On player activity - Mercenaries)");
							}else
							// Log Mob spawning
							{	wsprintf(cSpawnDefinition, "(On player activity)");
							}
						}
						// SNOOPY, spot-mobs that attract Spawns!
						// Spot-mob-generator type >3 indicates the ncp type (type as random-mob list above...)
						for (j = 0; j < DEF_MAXSPOTMOBGENERATOR; j++)
						{	if (   (m_pMapList[i]->m_stSpotMobGenerator[j].bDefined == TRUE) 
								&& ((CalcCityStr(2, (char)i, TRUE, FALSE) + CalcCityStr(2, (char)i, TRUE, FALSE)) >0) // Need somebody on the map
								&& (iDice(1,8) == 2) )
							{	if (m_pMapList[i]->m_stSpotMobGenerator[j].cType >3) 
								{	iResult = m_pMapList[i]->m_stSpotMobGenerator[j].cType;
									pX = m_pMapList[i]->m_stSpotMobGenerator[j].rcRect.left 
										+ iDice(1, (m_pMapList[i]->m_stSpotMobGenerator[j].rcRect.right - m_pMapList[i]->m_stSpotMobGenerator[j].rcRect.left));
									pY = m_pMapList[i]->m_stSpotMobGenerator[j].rcRect.top 
										+ iDice(1,(m_pMapList[i]->m_stSpotMobGenerator[j].rcRect.bottom - m_pMapList[i]->m_stSpotMobGenerator[j].rcRect.top));
									// Log Mob spawning
									wsprintf(cSpawnDefinition, "(Special pit spawn)");
									if (pX < 0) pX = 0;
									if (pY < 0) pY = 0;	
									m_bIsSpecialEventTime = FALSE;
									break; // Leave for(... loop
						}	}	}
						break;
					case 2: // Special big creature spawn
						if (iDice(1,3) != 2) 
						{	if ((memcmp(m_pMapList[i]->m_cLocationName, "aresden", 7)   == 0) ||
								(memcmp(m_pMapList[i]->m_cLocationName, "middled1n", 9) == 0) ||
								(memcmp(m_pMapList[i]->m_cLocationName, "arefarm", 7) == 0) ||
								(memcmp(m_pMapList[i]->m_cLocationName, "elvfarm", 7) == 0) ||
								//SNOOPY: Added Equilibrium here !
								(memcmp(m_pMapList[i]->m_cLocationName, "lost", 7) == 0) ||
								(memcmp(m_pMapList[i]->m_cLocationName, "elvine", 6)    == 0)) 
							{	if (iDice(1,10) == 5) 
								{	iResult = 35; // SNOOPY: Changed to HC 					
								}else 
								{	iResult = 16; // SNOOPY: Changed to Demon
								}
							}else 
							{	switch (iDice(1,16)) {
								case 1: iResult = 35; break;// HC	
								case 2: iResult = 38; break;// DG	
								case 3: iResult = 40; break;// Centaurus	
								case 4: iResult = 41; break;// GiLizard	
								case 5: iResult = 42; break;// Minos
								case 7: iResult = 47; break;// MasterMageOrc	
								case 8: iResult = 21; break;// Gagoyle	
								case 9:
								case 10:
								case 11:
								case 12:iResult = 101; break;// Helcat	
								default: iResult = 16; break;// DD								
							}	}
						}else 
						{	iResult = 17; // Uni					
						}		
						m_bIsSpecialEventTime = FALSE; // SpecialEvent performed
						break;
				}	}

				ZeroMemory(cNpcName, sizeof(cNpcName));
				//Random Monster Spawns........................Show on minimap
				switch (iResult) {
				case 1:  strcpy(cNpcName, "Slime");				iNpcID = 10; iProbSA = 5;  iKindSA = 1; break;
				case 2:  strcpy(cNpcName, "Giant-Ant");			iNpcID = 16; iProbSA = 10; iKindSA = 2; break;
				case 3:  strcpy(cNpcName, "Orc");				iNpcID = 14; iProbSA = 15; iKindSA = 10; break;
				case 4:  strcpy(cNpcName, "Zombie");			iNpcID = 18; iProbSA = 15; iKindSA = 3; break;
				case 5:  strcpy(cNpcName, "Skeleton");			iNpcID = 11; iProbSA = 35; iKindSA = 8; break;
				case 6:  strcpy(cNpcName, "Orc-Mage");			iNpcID = 14; iProbSA = 30; iKindSA = 13; break;
				case 7:  strcpy(cNpcName, "Scorpion");			iNpcID = 17; iProbSA = 15; iKindSA = 3; break;
				case 8:  strcpy(cNpcName, "Stone-Golem");		iNpcID = 12; iProbSA = 25; iKindSA = 5; break;
				case 9:  strcpy(cNpcName, "Cyclops");			iNpcID = 13; iProbSA = 35; iKindSA = 8; break;
				case 10: strcpy(cNpcName, "Amphis");			iNpcID = 22; iProbSA = 20; iKindSA = 3; break;
				case 11: strcpy(cNpcName, "Clay-Golem");		iNpcID = 23; iProbSA = 20; iKindSA = 5; break;
				case 12: strcpy(cNpcName, "Troll");				iNpcID = 28; iProbSA = 25; iKindSA = 3; break; 
				case 13: strcpy(cNpcName, "Ogre");				iNpcID = 29; iProbSA = 25; iKindSA = 10; break;
				case 14: strcpy(cNpcName, "Hellbound");			iNpcID = 27; iProbSA = 25; iKindSA = 12; break;
				case 15: strcpy(cNpcName, "Liche");				iNpcID = 30; iProbSA = 30; iKindSA = 12; break;
				case 16: strcpy(cNpcName, "Demon");				iNpcID = 31; iProbSA = 20; iKindSA = 8; break;
				case 17: strcpy(cNpcName, "Unicorn");			iNpcID = 32; iProbSA = 35; iKindSA = 7; break;
				case 18: strcpy(cNpcName, "WereWolf");			iNpcID = 33; iProbSA = 25; iKindSA = 11; break;
				case 19: strcpy(cNpcName, "YB-Aresden");		iNpcID = -1; iProbSA = 15; iKindSA = 10; break;
				case 20: strcpy(cNpcName, "YB-Elvine");			iNpcID = -1; iProbSA = 15; iKindSA = 10; break;
				case 21: strcpy(cNpcName, "Gagoyle");			iNpcID = 52; iProbSA = 20; iKindSA = 12; break;
				case 22: strcpy(cNpcName, "Beholder");			iNpcID = 53; iProbSA = 20; iKindSA = 5; break;
				case 23: strcpy(cNpcName, "Dark-Elf");			iNpcID = 54; iProbSA = 20; iKindSA = 14; break;
				case 24: strcpy(cNpcName, "Rabbit");			iNpcID = -1; iProbSA = 5;  iKindSA = 1; break;
				case 25: strcpy(cNpcName, "Cat");				iNpcID = -1; iProbSA = 10; iKindSA = 2; break;
				case 26: strcpy(cNpcName, "Frog");				iNpcID = 57; iProbSA = 10; iKindSA = 2; break;
				case 27: strcpy(cNpcName, "Mountain-Giant");	iNpcID = 58; iProbSA = 25; iKindSA = 10; break;
				case 28: strcpy(cNpcName, "Ettin");				iNpcID = 59; iProbSA = 20; iKindSA = 11; break;
				case 29: strcpy(cNpcName, "Plant");				iNpcID = 60; iProbSA = 20; iKindSA = 5; break;
				case 30: strcpy(cNpcName, "Rudolph");			iNpcID = 61; iProbSA = 20; iKindSA = 5; break;
				case 31: strcpy(cNpcName, "Ice-Golem");			iNpcID = 65; iProbSA = 35; iKindSA = 5; break;
				case 32: strcpy(cNpcName, "DireBoar");			iNpcID = 62; iProbSA = 20; iKindSA = 5; break;
				case 33: strcpy(cNpcName, "Frost");				iNpcID = 63; iProbSA = 30; iKindSA = 12; break;
				case 34: strcpy(cNpcName, "Stalker");           iNpcID = 48; iProbSA = 20; iKindSA = 1; break;
				case 35: strcpy(cNpcName, "Hellclaw");			iNpcID = 49; iProbSA = 20; iKindSA = 8; break;
				case 36: strcpy(cNpcName, "Wyvern");			iNpcID = 66; iProbSA = 20; iKindSA = 1; break;
				case 37: strcpy(cNpcName, "Fire-Wyvern");		iNpcID = 73; iProbSA = 20; iKindSA = 1; break; 
				case 38: strcpy(cNpcName, "Dragon");			iNpcID = 70; iProbSA = 20; iKindSA = 13; break;
				//case 39 Tentocle, but almost always one only				
				case 39: strcpy(cNpcName, "Tentocle");			iNpcID = 80; iProbSA = 20; iKindSA = 1; break;				
				case 40: strcpy(cNpcName, "Centaurus");			iNpcID = 71; iProbSA = 20; iKindSA = 11; break;
				case 41: strcpy(cNpcName, "Giant-Lizard");		iNpcID = 75; iProbSA = 20; iKindSA = 11; break;
				case 42: strcpy(cNpcName, "Minotaurs");			iNpcID = 78; iProbSA = 20; iKindSA = 11; break;
				//case 43: Tentocle maybe more than one
				case 43: strcpy(cNpcName, "Tentocle");			iNpcID = 80; iProbSA = 20; iKindSA = 1; break;
				case 44: strcpy(cNpcName, "Claw-Turtle");		iNpcID = 72; iProbSA = 20; iKindSA = 1; break;
				case 45: strcpy(cNpcName, "Giant-Crayfish");	iNpcID = 74; iProbSA = 20; iKindSA = 1; break;
				case 46: strcpy(cNpcName, "Giant-Tree");		iNpcID = 76; iProbSA = 20; iKindSA = 1; break;
				case 47: strcpy(cNpcName, "MasterMage-Orc");	iNpcID = 77; iProbSA = 20; iKindSA = 11; break;
				case 48: strcpy(cNpcName, "Nizie");				iNpcID = 79; iProbSA = 20; iKindSA = 11; break;
				case 49: strcpy(cNpcName, "Tigerworm");			iNpcID = 50; iProbSA = 20; iKindSA = 8; break;
				//case 50: /*strcpy(cNpcName, "Giant-Tree");		iNpcID = 76; iProbSA = 20; iKindSA = 1;*/ break;
				case 51: strcpy(cNpcName, "Abaddon");			iNpcID = 81; iProbSA = 20; iKindSA = 1; break;
				case 52: strcpy(cNpcName, "YW-Aresden");		iNpcID = -1; iProbSA = 15; iKindSA = 10; break;
				case 53: strcpy(cNpcName, "YW-Elvine");			iNpcID = -1; iProbSA = 15; iKindSA = 10; break;
				case 54: strcpy(cNpcName, "YY-Aresden");		iNpcID = -1; iProbSA = 15; iKindSA = 10; break;
				case 55: strcpy(cNpcName, "YY-Elvine");			iNpcID = -1; iProbSA = 15; iKindSA = 10; break;
				case 56: strcpy(cNpcName, "XB-Aresden");		iNpcID = -1; iProbSA = 15; iKindSA = 10; break;
				case 57: strcpy(cNpcName, "XB-Elvine");			iNpcID = -1; iProbSA = 15; iKindSA = 10; break;
				case 58: strcpy(cNpcName, "XW-Aresden");		iNpcID = -1; iProbSA = 15; iKindSA = 10; break;
				case 59: strcpy(cNpcName, "XW-Elvine");			iNpcID = -1; iProbSA = 15; iKindSA = 10; break;
				case 60: strcpy(cNpcName, "XY-Aresden");		iNpcID = -1; iProbSA = 15; iKindSA = 10; break;
				case 61: strcpy(cNpcName, "XY-Elvine");			iNpcID = -1; iProbSA = 15; iKindSA = 10; break;
// New creature by SNOOPY
				case 101: strcpy(cNpcName, "Hellcat");			iNpcID = 56; iProbSA = 75; iKindSA = 7; break;
				case 102: strcpy(cNpcName, "City-Cyclops");		iNpcID = 13; iProbSA = 35; iKindSA = 8; break;
				case 103: strcpy(cNpcName, "City-Ogre");		iNpcID = 29; iProbSA = 35; iKindSA = 10; break;
				case 104: strcpy(cNpcName, "City-Dark-Elf");	iNpcID = 54; iProbSA = 45; iKindSA = 14; break;
				case 105: strcpy(cNpcName, "War-Elvine");		iNpcID = -1; iProbSA = 25; iKindSA = 15; break;
				case 106: strcpy(cNpcName, "War-Aresden");		iNpcID = -1; iProbSA = 25; iKindSA = 15; break;

				default: strcpy(cNpcName, "Orc");				iNpcID = 14; iProbSA = 15; iKindSA = 10; break;
				}
				// Change npc names for special Apocalypse maps versions
				if (m_pMapList[i]->m_bIsApocalypseMap == TRUE)
				{	switch (iResult) {
					case 35: ZeroMemory(cNpcName, sizeof(cNpcName));strcpy(cNpcName, "ApocHellclaw");	break;
					case 49: ZeroMemory(cNpcName, sizeof(cNpcName));strcpy(cNpcName, "ApocTigerworm");  break;
					case 36: ZeroMemory(cNpcName, sizeof(cNpcName));strcpy(cNpcName, "ApocWyvern");		break;
					case 37: ZeroMemory(cNpcName, sizeof(cNpcName));strcpy(cNpcName, "ApocFire-Wyvern");break; 
					case 51: ZeroMemory(cNpcName, sizeof(cNpcName));strcpy(cNpcName, "ApocAbaddon");	break;
					}	
				}
				cSA = 0;
				if (iDice(1,100) <= iProbSA) 
				{	cSA = _cGetSpecialAbility(iKindSA);	
				}
				// If many mobs killed, fetch a Boss !
				if (   (m_pMapList[i]->m_iNoSMRGKilledMobs >= ((DEF_NBE_MOBS_BEFORE_BOSS*m_pMapList[i]->m_iBossAdjust)/100)) // Many mobs killed: Spawn a boss
					&& (bIsSpecialEvent == FALSE)) // Type 4
				{	bIsABossNow = TRUE;
					m_pMapList[i]->m_iNoSMRGKilledMobs = 0;		
				}
				if (bIsABossNow == TRUE) // Spawn a Boss (By type 3, or Type 4)
				{	cSA =  -1 * _cGetSpecialAbility(iKindSA);				
				}
				// Create 1st npc (MasterNPC)
				if ((bMaster = bCreateNewNpc(cNpcName, cName_Master, m_pMapList[i]->m_cName, (rand() % 3), cSA, DEF_MOVETYPE_RANDOM, &pX, &pY, cWaypoint, NULL, NULL, bExecutorFriendMob, FALSE, FALSE, bFirmBerserk, TRUE)) == FALSE) 
				{	m_pMapList[i]->SetNamingValueEmpty(iNamingValue);
					bIsSpecialEvent = FALSE; // If spawn failed, no need to log the event below
				}else 
				{	//NB: Snoopy reduced the number of wrong spawns by testing for accessibility of maps coordinates
					//    prior creation, and trying different one instead of cancelling npc creation.
					if ((bIsABossNow == TRUE) && (bIsSpecialEvent == FALSE))
					{	wsprintf(G_cTxt, "(!) Mob-Event Type 4 (Boss comming to help) - %s(%d %d) [%d - %s]"
							, m_pMapList[i]->m_cName
							, pX
							, pY
							, iResult
							, cNpcName);
						PutLogList(G_cTxt);
						PutLogEventFileList(G_cTxt);
						//SNOOPY: Show Spawns type 4 on minimap					
						wX = (WORD) pX;
						wY = (WORD) pY;
						for (x = 1; x < DEF_MAXCLIENTS; x++)
						if (   (iNpcID != -1) 
							&& (m_pClientList[x] != NULL) 
							&& (m_pClientList[x]->m_bIsInitComplete == TRUE)						
							&& (memcmp(m_pMapList[i]->m_cName, m_pMapList[m_pClientList[x]->m_cMapIndex]->m_cName, strlen(m_pMapList[i]->m_cName)) == 0)) 
						{	SendNotifyMsg(NULL, x, DEF_NOTIFY_SPAWNEVENT, wX, wY, iNpcID, NULL, NULL, NULL);
			}	}	}	}	
			switch (iResult) {
			case 1:	 iTotalMob = iDice(1,5)-1; break;
			case 2:	 iTotalMob = iDice(1,5)-1; break;
			case 3:	 iTotalMob = iDice(1,5)-1; break;
			case 4:	 iTotalMob = iDice(1,3)-1; break;
			case 5:	 iTotalMob = iDice(1,3)-1; break;

			case 6:  iTotalMob = iDice(1,3)-1; break;
			case 7:  iTotalMob = iDice(1,3)-1; break;
			case 8:  iTotalMob = iDice(1,2)-1; break;
			case 9:  iTotalMob = iDice(1,2)-1; break;
			case 10: iTotalMob = iDice(1,5)-1; break;
			case 11: iTotalMob = iDice(1,3)-1; break;
			case 12: iTotalMob = iDice(1,5)-1; break;
			case 13: iTotalMob = iDice(1,3)-1; break;
			case 14: iTotalMob = iDice(1,2)-1; break;
			case 15: iTotalMob = iDice(1,3)-1; break;
			case 16: iTotalMob = iDice(1,2)-1; break;
			case 17: iTotalMob = iDice(1,2)-1; break;

			case 18: iTotalMob = iDice(1,5)-1; break;
			case 19: iTotalMob = iDice(1,2)-1; break;
			case 20: iTotalMob = iDice(1,2)-1; break;
			case 21: iTotalMob = iDice(1,5)-1; break;
			case 22: iTotalMob = iDice(1,2)-1; break;
			case 23: iTotalMob = iDice(1,2)-1; break;

			case 24: iTotalMob = iDice(1,4)-1; break;
			case 25: iTotalMob = iDice(1,2)-1; break;
			case 26: iTotalMob = iDice(1,3)-1; break;
			case 27: iTotalMob = iDice(1,3)-1; break;

			case 28: iTotalMob = iDice(1,3)-1; break;
			case 29: iTotalMob = iDice(1,5)-1; break;
			case 30: iTotalMob = iDice(1,3)-1; break;
			case 31: iTotalMob = iDice(1,3)-1; break;

			case 32: iTotalMob = 0; break;
			case 33: iTotalMob = 0; break;
			case 34: iTotalMob = 0; break;
			case 35: iTotalMob = 0; break;
			case 36: iTotalMob = 0; break;

			case 37: iTotalMob = 0; break;
			case 38: iTotalMob = 0; break;
			case 39: iTotalMob = 0; break;
			case 40: iTotalMob = 0; break;
			case 41: iTotalMob = 0; break; // single mob

			case 42: iTotalMob = iDice(1,3)-1; break;
			case 43: iTotalMob = 0; break;
			case 44: iTotalMob = iDice(1,3)-1; break; 
			case 45: iTotalMob = 0; break;
			default: iTotalMob = 0; break;
			}
			if (bMaster == FALSE) iTotalMob = 0; // Just failed spawning 1st mob
			if (iTotalMob > 2) {
				switch (iResult) {
				case 1:  // Slime 
				case 2:  // Giant-Ant
				case 3:  // Orc
				case 4:  // Zombie
				case 5:  // Skeleton
				case 6:  // Orc-Mage
				case 7:  // Scorpion
				case 8:  // Stone-Golem
				case 9:  // Cyclops
				case 10: // Amphis
				case 11: // Clay-Golem
				case 12: // Troll
				case 13: // Ogre
				case 14: // Hellbound
				case 15: // Liche
				case 16: // Demon
				case 17: // Unicorn
				case 18: // WereWolf
				case 19: // YB-Aresden
				case 20: // YB-Elvine
				case 21: // Gagoyle
				case 22: // Beholder
				case 23: // Dark-Elf
				case 24: // Rabbit
				case 25: // Cat
				case 26: // Frog
				case 27: // Mountain-Giant
				case 28: // Ettin
				case 29: // Plant
				case 30: // Rudolph
				case 31: // Ice-Golem
				case 32: // DireBoar
				case 43: // Tentocle
				case 102: // City-Cyclops
				case 103: // City-Ogre
				case 104: // City-Dark-Elf
				case 105: // War-Elvine
				case 106: // War-Aresden
					if (iDice(1,5) == 1) iTotalMob = 0;  // 20% to be alone ?
					break;
				case 33: // Frost
				case 34: // Stalker
				case 38: // Dragon
				case 39: // Tentocle
				case 40: // Centaurus
				case 41: // Giant-Lizard
				case 42: // Minotaurs
				case 44: // Claw-Turtle
				case 45: // Giant-Crayfish
				case 46: // Giant-Tree
				case 47: // MasterMage-Orc
				case 48: // Nizie
				case 52: // YW-Aresden
				case 53: // YW-Elvine
				case 54: // YY-Aresden
				case 55: // YY-Elvine
				case 56: // XB-Aresden
				case 57: // XB-Elvine
				case 58: // XW-Aresden
				case 59: // XW-Elvine
				case 60: // XY-Aresden
				case 61: // XY-Elvine
				case 101: // Hellcat
					if (iDice(1,5) != 1) iTotalMob = 0;  // 80% to be alone
					break;
				case 35: // Hellclaw
				case 36: // Wyvern
				case 37: // Fire-Wyvern
				case 49: // Tigerworm
				case 51: // Abaddon
					iTotalMob = 0;  // always alone....
					break;
				}
			}			
			// Step2, compute npc slaves number and create them.
			if (bIsSpecialEvent == TRUE) 
			{	switch (m_cSpecialEventType) {
				case 3: // Boss spawning
				case 1: // Normal event
					// SNOOPY: No evil big monsters spawns
					if ((iResult != 15) && (iResult != 16) && (iResult != 17) && (iResult != 21) // DD, Liche, Uni,GG						
						&& (iResult != 35) && (iResult != 36) && (iResult != 37) // HC, Wyv, FWyv
						&& (iResult != 38) && (iResult != 49) && (iResult != 51) // Dragon, TW, Abaddon
						&& (iResult != 40) && (iResult != 41) && (iResult != 42) // Centaur, Liz, Minos
						&& (iResult != 47) && (iResult != 48) ) // MasterOrc, Nizie 
					{	iTotalMob = 15;
						if (m_pMapList[i]->sMobEventAmount > 0) iTotalMob = m_pMapList[i]->sMobEventAmount;
					}// SNOOPY: Old cities: Smaller spawns for npc wars or monsters
					if (   (iResult == 101) || (iResult == 102) || (iResult == 103) // Cities 
						|| (iResult == 104) || (iResult == 105) || (iResult == 106)) 
					{	iTotalMob = 2 + iDice(1,4);
					}
					if ((m_cSpecialEventType == 3) && (bIsABossNow == TRUE)) // Log Mob spawning
					{	wsprintf(G_cTxt, "(!) Mob-Event Type 3 %s - %s(%d %d) [%d - %s]"
							, cSpawnDefinition
							, m_pMapList[i]->m_cName
							, pX
							, pY
							, iResult
							, cNpcName);	
						PutLogEventFileList(G_cTxt);
					}else
					{	wsprintf(G_cTxt, "(!) Mob-Event Type 1 %s - %s(%d %d) [%d - %s]"
							, cSpawnDefinition
							, m_pMapList[i]->m_cName
							, pX
							, pY
							, iResult
							, cNpcName);
						if (strcmp(cSpawnDefinition, "(On player activity - Mercenaries)") == 0)
							PutLogEventFileList(G_cTxt);
					}	
					PutLogList(G_cTxt);
					//SNOOPY: Show Spawns on minimap					
					wX = (WORD) pX;
					wY = (WORD) pY;
					for (x = 1; x < DEF_MAXCLIENTS; x++)
					if (   (iNpcID != -1) 
						&& (m_pClientList[x] != NULL) 
						&& (m_pClientList[x]->m_bIsInitComplete == TRUE)						
						&& (memcmp(m_pMapList[i]->m_cName, m_pMapList[m_pClientList[x]->m_cMapIndex]->m_cName, strlen(m_pMapList[i]->m_cName)) == 0)
						) 
					{	SendNotifyMsg(NULL, x, DEF_NOTIFY_SPAWNEVENT, wX, wY, iNpcID, NULL, NULL, NULL);
					}	
					break;
				case 2:
					if ((memcmp(m_pMapList[i]->m_cLocationName, "aresden", 7) == 0) ||
						(memcmp(m_pMapList[i]->m_cLocationName, "middled1n", 9) == 0) ||
						(memcmp(m_pMapList[i]->m_cLocationName, "elvine",  6) == 0) ||
						(memcmp(m_pMapList[i]->m_cLocationName, "elvfarm",  7) == 0) ||
						// SNOOPY: Added Equilibrium here
						(memcmp(m_pMapList[i]->m_cLocationName, "lost",  7) == 0) ||
						(memcmp(m_pMapList[i]->m_cLocationName, "arefarm",  7) == 0) ) 
					{	iTotalMob = 0;
					}
					// Log Mob spawning
					wsprintf(G_cTxt, "(!) Mob-Event Type 2 - %s(%d %d) [%d - %s]"
						, m_pMapList[i]->m_cName
						, pX
						, pY
						, iResult
						, cNpcName);
					PutLogList(G_cTxt);	
					PutLogEventFileList(G_cTxt);
					//SNOOPY: Show Spawns on minimap					
					wX = (WORD) pX;
					wY = (WORD) pY;
					for (x = 1; x < DEF_MAXCLIENTS; x++)
					if (   (iNpcID != -1) 
						&& (m_pClientList[x] != NULL) 
						&& (m_pClientList[x]->m_bIsInitComplete == TRUE)						
						&& (memcmp(m_pMapList[i]->m_cName, m_pMapList[m_pClientList[x]->m_cMapIndex]->m_cName, strlen(m_pMapList[i]->m_cName)) == 0)
						) 
					{	SendNotifyMsg(NULL, x, DEF_NOTIFY_SPAWNEVENT, wX, wY, iNpcID, NULL, NULL, NULL);
					}
					break;	
				default:
					break;
				}
				m_bIsSpecialEventTime = FALSE;
			} // End of SpecialEvent case...
			if (bIsABossNow == TRUE) // Type 3 & 4 have 2x mobs
			{	iTotalMob *=2;
				if (iDice(1,4)==2) bFirmBerserk = TRUE;
			}
			for (j = 0; j < iTotalMob; j++) 
			{	iNamingValue = m_pMapList[i]->iGetEmptyNamingValue();
				if (iNamingValue != -1) 
				{	ZeroMemory(cName_Slave, sizeof(cName_Slave));
					wsprintf(cName_Slave, "XX%d", iNamingValue);
					cName_Slave[0] = 95; // original '_';
					cName_Slave[1] = i + 65;				
					if (bIsABossNow == TRUE)
					{	cSA = abs(cSA);
					}else
					{	cSA = 0;
						if (iDice(1,100) <= iProbSA) 
						{	cSA = _cGetSpecialAbility(iKindSA);
					}	}	
					if (bCreateNewNpc(cNpcName, cName_Slave, m_pMapList[i]->m_cName, (rand() % 3), cSA, DEF_MOVETYPE_RANDOM, &pX, &pY, cWaypoint, NULL, NULL, bExecutorFriendMob, FALSE, FALSE, bFirmBerserk) == FALSE) 
					{	m_pMapList[i]->SetNamingValueEmpty(iNamingValue);
					}else 
					{	bSetNpcFollowMode(cName_Slave, cName_Master, DEF_OWNERTYPE_NPC);
		}	}	}	}
// Then SpotMobGenerators....
		if (   (m_pMapList[i] != NULL) 
			&& ((m_pMapList[i]->m_iMaximumObject) > m_pMapList[i]->m_iTotalActiveObject) ) 
		{	for (j = 0; j < DEF_MAXSPOTMOBGENERATOR; j++)
			if (   (iDice(1,3) == 2) 
				&& (m_pMapList[i]->m_stSpotMobGenerator[j].bDefined == TRUE) 
				&& (m_pMapList[i]->m_stSpotMobGenerator[j].iMobType >= 0) // Negative MobType used by empty temporary random pits
				&& (m_pMapList[i]->m_stSpotMobGenerator[j].iMaxMobs > m_pMapList[i]->m_stSpotMobGenerator[j].iCurMobs) ) 
			{	iNamingValue = m_pMapList[i]->iGetEmptyNamingValue();
				if (iNamingValue != -1) 
				{	ZeroMemory(cNpcName, sizeof(cNpcName));
					switch (m_pMapList[i]->m_stSpotMobGenerator[j].iMobType) {
					// spot-mob-generator, Snoopy: Added iNpcID to show Boss Spawns on mini-map
					case 6:   strcpy(cNpcName,"Orc-Mage");			iNpcID = 14; iProbSA = 30; iKindSA = 12;  break;
					case 10:  strcpy(cNpcName,"Slime");				iNpcID = 10; iProbSA = 5;  iKindSA = 1;  break;
					case 11:  strcpy(cNpcName,"Skeleton");			iNpcID = 11; iProbSA = 35; iKindSA = 8;  break;
					case 12:  strcpy(cNpcName,"Stone-Golem");		iNpcID = 12; iProbSA = 25; iKindSA = 5;  break;
					case 13:  strcpy(cNpcName,"Cyclops");			iNpcID = 13; iProbSA = 35; iKindSA = 8;  break;
					case 14:  strcpy(cNpcName,"Orc");				iNpcID = 14; iProbSA = 15; iKindSA = 10;  break;
					case 16:  strcpy(cNpcName,"Giant-Ant");			iNpcID = 16; iProbSA = 10; iKindSA = 2;  break;
					case 17:  strcpy(cNpcName,"Scorpion");			iNpcID = 17; iProbSA = 15; iKindSA = 3;  break;
					case 18:  strcpy(cNpcName,"Zombie");			iNpcID = 18; iProbSA = 15; iKindSA = 3;  break;
					case 22:  strcpy(cNpcName,"Amphis");			iNpcID = 22; iProbSA = 20; iKindSA = 3;  break;
					case 23:  strcpy(cNpcName,"Clay-Golem");		iNpcID = 23; iProbSA = 20; iKindSA = 5;  break;
					case 24:  strcpy(cNpcName,"Guard-Aresden");		iNpcID = -1; iProbSA = 20; iKindSA = 15;  break;
					case 25:  strcpy(cNpcName,"Guard-Elvine");		iNpcID = -1; iProbSA = 20; iKindSA = 15;  break;
					case 26:  strcpy(cNpcName,"Guard-Neutral");		iNpcID = -1; iProbSA = 20; iKindSA = 15;  break;
					case 27:  strcpy(cNpcName,"Hellbound");			iNpcID = 27; iProbSA = 20; iKindSA = 15;  break;
					case 28:  strcpy(cNpcName,"Troll");				iNpcID = 28; iProbSA = 25; iKindSA = 3;  break; 
					case 29:  strcpy(cNpcName,"Ogre");              iNpcID = 29; iProbSA = 20; iKindSA = 10;  break;
					case 30:  strcpy(cNpcName,"Liche");				iNpcID = 30; iProbSA = 30; iKindSA = 12;  break;
					case 31:  strcpy(cNpcName,"Demon");				iNpcID = 31; iProbSA = 20; iKindSA = 12;  break;
					case 32:  strcpy(cNpcName,"Unicorn");			iNpcID = 32; iProbSA = 35; iKindSA = 7;  break;
					case 33:  strcpy(cNpcName,"WereWolf");			iNpcID = 33; iProbSA = 25; iKindSA = 10;  break;
					case 34:  strcpy(cNpcName,"Dummy");				iNpcID = -1; iProbSA = 5;  iKindSA = 1;  break;
					case 35:  strcpy(cNpcName,"Attack-Dummy");		iNpcID = -1; iProbSA = 5;  iKindSA = 1;  break;
					// SNOOPY: Added Evil Crusade structures
					case 36:  strcpy(cNpcName,"Evil-AGT");			iNpcID = -1; iProbSA = 20; iKindSA = 1;  break;
					case 37:  strcpy(cNpcName,"Evil-CGT");			iNpcID = -1; iProbSA = 20; iKindSA = 1;  break;
					case 39:  strcpy(cNpcName,"Evil-DT");		    iNpcID = -1; iProbSA = 20; iKindSA = 1;  break;
					case 42:  strcpy(cNpcName,"ManaStone");			iNpcID = -1; iProbSA = 20; iKindSA = 1;  break;
					case 43:  strcpy(cNpcName,"Evil-LWB");			iNpcID = -1; iProbSA = 20; iKindSA = 15;  break;
					case 44:  strcpy(cNpcName,"Evil-GHK");			iNpcID = -1; iProbSA = 20; iKindSA = 15;  break;
					case 45:  strcpy(cNpcName,"Evil-GHKABS");		iNpcID = -1; iProbSA = 20; iKindSA = 15;  break;
					case 46:  strcpy(cNpcName,"Evil-TK");			iNpcID = -1; iProbSA = 20; iKindSA = 15;  break;
					case 47:  strcpy(cNpcName,"Evil-BG");			iNpcID = -1; iProbSA = 20; iKindSA = 15;  break;					
					case 48:  strcpy(cNpcName,"Stalker");			iNpcID = 48; iProbSA = 20; iKindSA = 3;  break;
					case 49:  strcpy(cNpcName,"Hellclaw");			iNpcID = 49; iProbSA = 20; iKindSA = 8;  break;
					case 50:  strcpy(cNpcName,"Tigerworm");			iNpcID = 50; iProbSA = 20; iKindSA = 8;  break;
					case 52:  strcpy(cNpcName,"Gagoyle");			iNpcID = 52; iProbSA = 20; iKindSA = 12;  break;
					case 53:  strcpy(cNpcName,"Beholder");			iNpcID = 53; iProbSA = 20; iKindSA = 5;  break;
					case 54:  strcpy(cNpcName,"Dark-Elf");			iNpcID = 54; iProbSA = 20; iKindSA = 14;  break;
					case 55:  strcpy(cNpcName,"Rabbit");			iNpcID = -1; iProbSA = 20; iKindSA = 1;  break;
					case 56:  strcpy(cNpcName,"Cat");				iNpcID = -1; iProbSA = 15; iKindSA = 2;  break;
					case 57:  strcpy(cNpcName,"Frog");				iNpcID = 57; iProbSA = 10; iKindSA = 2;  break;
					case 58:  strcpy(cNpcName,"Mountain-Giant");	iNpcID = 58; iProbSA = 25; iKindSA = 10;  break;
					case 59:  strcpy(cNpcName,"Ettin");				iNpcID = 59; iProbSA = 20; iKindSA = 11;  break;
					case 60:  strcpy(cNpcName,"Plant");				iNpcID = 60; iProbSA = 20; iKindSA = 5;  break;
					case 61:  strcpy(cNpcName,"Rudolph");			iNpcID = 61; iProbSA = 20; iKindSA = 5;  break;
					case 62:  strcpy(cNpcName,"DireBoar");			iNpcID = 62; iProbSA = 20; iKindSA = 5;  break;
					case 63:  strcpy(cNpcName,"Frost");				iNpcID = 63; iProbSA = 20; iKindSA = 12;  break;
					// case 64:  Crops
					case 65:  strcpy(cNpcName,"Ice-Golem");			iNpcID = 65; iProbSA = 20; iKindSA = 5;  break;
					case 66:  strcpy(cNpcName,"Wyvern");			iNpcID = 66; iProbSA = 20; iKindSA = 1;  break;
					case 67:  strcpy(cNpcName,"McGaffin");			iNpcID = -1; iProbSA = 20; iKindSA = 1;  break;
					case 68:  strcpy(cNpcName,"Perry");				iNpcID = -1; iProbSA = 20; iKindSA = 1;  break;
					case 69:  strcpy(cNpcName,"Devlin");			iNpcID = -1; iProbSA = 20; iKindSA = 1;  break;
					case 70:  strcpy(cNpcName,"Dragon");			iNpcID = 70; iProbSA = 20; iKindSA = 13;  break;
					case 71:  strcpy(cNpcName,"Centaurus");			iNpcID = 71; iProbSA = 20; iKindSA = 11;  break;
					case 72:  strcpy(cNpcName,"Claw-Turtle");		iNpcID = 72; iProbSA = 20; iKindSA = 1;  break;
					case 73:  strcpy(cNpcName,"Fire-Wyvern");		iNpcID = 73; iProbSA = 20; iKindSA = 1;  break;
					case 74:  strcpy(cNpcName,"Giant-Crayfish");	iNpcID = 74; iProbSA = 20; iKindSA = 1;  break;
					case 75:  strcpy(cNpcName,"Giant-Lizard");		iNpcID = 75; iProbSA = 20; iKindSA = 11;  break;
					case 76:  strcpy(cNpcName,"Giant-Tree");		iNpcID = 76; iProbSA = 20; iKindSA = 1;  break;
					case 77:  strcpy(cNpcName,"MasterMage-Orc");	iNpcID = 77; iProbSA = 20; iKindSA = 11;  break;
					case 78:  strcpy(cNpcName,"Minotaurs");			iNpcID = 78; iProbSA = 20; iKindSA = 11;  break;
					case 79:  strcpy(cNpcName,"Nizie");				iNpcID = 79; iProbSA = 20; iKindSA = 11;  break;
					case 80:  strcpy(cNpcName,"Tentocle");			iNpcID = 80; iProbSA = 20; iKindSA = 1;  break;
					case 81:  strcpy(cNpcName,"Abaddon");			iNpcID = 81; iProbSA = 20; iKindSA = 1;  break;
							
					case 82:  strcpy(cNpcName,"Evil-Sorceress");	iNpcID = 82; iProbSA = 20; iKindSA = 15;  break;
					case 83:  strcpy(cNpcName,"Evil-ATK");			iNpcID = 83; iProbSA = 20; iKindSA = 15;  break;
					case 84:  strcpy(cNpcName,"Evil-Elf");			iNpcID = 84; iProbSA = 20; iKindSA = 15;  break;
					case 85:  strcpy(cNpcName,"Evil-DSK");			iNpcID = 85; iProbSA = 20; iKindSA = 15;  break;
					case 88:  strcpy(cNpcName,"Evil-Barbarian");	iNpcID = 86; iProbSA = 20; iKindSA = 15;  break;
					case 101:  strcpy(cNpcName,"Guard-Equi");		iNpcID = -1; iProbSA = 20; iKindSA = 15;  break;
					case 102:  strcpy(cNpcName,"Hellcat");			iNpcID = 56; iProbSA = 75; iKindSA = 7;  break;
					case 103:  strcpy(cNpcName,"City-Cyclops");		iNpcID = 13; iProbSA = 35; iKindSA = 8;  break;
					case 104:  strcpy(cNpcName,"City-Ogre");		iNpcID = 29; iProbSA = 35; iKindSA = 10;  break;
					case 105:  strcpy(cNpcName,"City-Dark-Elf");	iNpcID = 54; iProbSA = 45; iKindSA = 14;  break;
					case 106:  strcpy(cNpcName,"War-Elvine");		iNpcID = -1; iProbSA = 20; iKindSA = 15;  break;
					case 107:  strcpy(cNpcName,"War-Aresden");		iNpcID = -1; iProbSA = 20; iKindSA = 15;  break;
					case 108:  strcpy(cNpcName,"BigHellclaw");		iNpcID = 49; iProbSA = 20; iKindSA = 8;  break;
					case 109:  strcpy(cNpcName,"BigTigerworm");		iNpcID = 50; iProbSA = 20; iKindSA = 8;  break;
					case 112:  strcpy(cNpcName,"City-Stone-Golem");	iNpcID = 12; iProbSA = 25; iKindSA = 5;  break;
					
					// Boss spawning... sometimes !					
					case 149:  // executed 6000 times per hour
						if (iDice(1,12000) == 76) 
						{	strcpy(cNpcName,"Hellclaw");
							iNpcID = 49;
							iProbSA = 20;
							iKindSA = 8;
						}
						break;
					case 150: // executed if alternate mob is killed.... 
						if (iDice(1, 50) == 37) 
						{	strcpy(cNpcName,"Tigerworm");
							iNpcID  = 50;
							iProbSA = 20;
							iKindSA = 8;
						}else 
						{	strcpy(cNpcName, "Troll");
							iNpcID  = 28;
							iProbSA = 25;
							iKindSA = 3;
						}
						break;					
					case 166:  // executed 6000 times per hour
						if (iDice(1,12000) == 78) 
						{	strcpy(cNpcName,"Wyvern");
							iNpcID  = 66;
							iProbSA = 20;
							iKindSA = 8;
						}
						break;
					case 173: // executed if alternate mob is killed....   
						if (iDice(1,100) == 79) 
						{	strcpy(cNpcName,"Fire-Wyvern");
							iNpcID  = 73;
							iProbSA = 20;
							iKindSA = 1;
						}else 
						{	strcpy(cNpcName, "Stalker");
							iNpcID  = 48;
							iProbSA = 15;
							iKindSA = 1;
						}
						break;					
					// Special Random-Mobs for Apoc maps....	
					case 249:  strcpy(cNpcName,"ApocHellclaw");		iNpcID = 49; iProbSA = 20; iKindSA = 8;  break;
					case 250:  strcpy(cNpcName,"ApocTigerworm");	iNpcID = 50; iProbSA = 20; iKindSA = 8;  break;
					case 266:  strcpy(cNpcName,"ApocWyvern");		iNpcID = 66; iProbSA = 20; iKindSA = 1;  break;
					case 273:  strcpy(cNpcName,"ApocFire-Wyvern");	iNpcID = 73; iProbSA = 20; iKindSA = 1;  break;
					case 281:  strcpy(cNpcName,"ApocAbaddon");		iNpcID = 81; iProbSA = 20; iKindSA = 1;  break;
					default: 
						strcpy(cNpcName, "Orc");
						iNpcID  = 14; 
						iProbSA = 15; 
						iKindSA = 10; 
						break;
					} // End switch MobType
				
					/* NPCs not spawning in pits: 
					// 15 ShopKeeper-W
					// 19 Gandlf          
					// 20 Howard
					// 36 Arrow Gaurd Tower Kit - Aresden, Elvine
					// 37 Cannon Gaurd Tower Kit - Aresden, Elvine
					// 38 Mana Collector Kit - Aresden, Elvine
					// 39 Detector Constructor Kit - Aresden, Elvine
					// 40 Energy Shield Generator - Aresden, Elvine
					// 41 Grand Master Generator - Aresden Elvine
					// 43 Light War Beetle - Aresden, Elvine
					// 44 God's Hand Knight
					// 45 Mounted God's Hand Knight
					// 46 Temple Knight
					// 47 Battle Golem
					// 51 Catapult
					// 64 Crops
					*/					
					bFirmBerserk = FALSE; // Spot Mob Generator FirmBersek
					if ((m_pMapList[i]->m_iMapLevel >= 5) && (iDice(1,20) <= m_pMapList[i]->m_iMapLevel)) bFirmBerserk = TRUE;
					ZeroMemory(cName_Master, sizeof(cName_Master));
					wsprintf(cName_Master, "XX%d", iNamingValue);
					cName_Master[0] = 95; // original '_';
					cName_Master[1] = i + 65;
					cSA = 0;
					if ((m_pMapList[i]->m_stSpotMobGenerator[j].iMobType != 34) && (iDice(1,100) <= iProbSA)) // Dummies never have special abilities
					{	cSA = _cGetSpecialAbility(iKindSA); 						
						if (m_pMapList[i]->m_stSpotMobGenerator[j].iKilledMobs >= DEF_NBE_MOBS_BEFORE_BOSS) 
						{	cSA = 0 - cSA; // Generate a Boss....
							m_pMapList[i]->m_stSpotMobGenerator[j].iKilledMobs = 0;	
					}	}
					switch (m_pMapList[i]->m_stSpotMobGenerator[j].cType) {
					case 2: // WayPoint Spotmob
						if (bCreateNewNpc(cNpcName, cName_Master, m_pMapList[i]->m_cName, (rand() % 3), cSA, DEF_MOVETYPE_RANDOMWAYPOINT, NULL, NULL, m_pMapList[i]->m_stSpotMobGenerator[j].cWaypoint, NULL, j, -1, FALSE, FALSE, bFirmBerserk) == FALSE) 
						{	m_pMapList[i]->SetNamingValueEmpty(iNamingValue);	
						}else 
						{	m_pMapList[i]->m_stSpotMobGenerator[j].iCurMobs++;
						}
						break;
					case 3: // WayPoint Spotmob DEF_MOVETYPE_SEQWAYPOINT
						if (bCreateNewNpc(cNpcName, cName_Master, m_pMapList[i]->m_cName, (rand() % 3), cSA, DEF_MOVETYPE_SEQWAYPOINT, NULL, NULL, m_pMapList[i]->m_stSpotMobGenerator[j].cWaypoint, NULL, j, -1, FALSE, FALSE, bFirmBerserk) == FALSE) 
						{	m_pMapList[i]->SetNamingValueEmpty(iNamingValue);	
						}else 
						{	m_pMapList[i]->m_stSpotMobGenerator[j].iCurMobs++;
						}
						break;
					default: // Snoopy, added support for Other types than 1 or 2
						// 4+: Will attract romdom mob spawns of specified creature by type, inside the spot mob 
						// 0-: Special temporary random pits
					case 1: // Area SpotMob
						if (bCreateNewNpc(cNpcName, cName_Master, m_pMapList[i]->m_cName, (rand() % 3), cSA, DEF_MOVETYPE_RANDOMAREA, &pX, &pY, cWaypoint, &m_pMapList[i]->m_stSpotMobGenerator[j].rcRect, j, -1, FALSE, FALSE, bFirmBerserk) == FALSE) 
						{	m_pMapList[i]->SetNamingValueEmpty(iNamingValue);
						}else 
						{	m_pMapList[i]->m_stSpotMobGenerator[j].iCurMobs++;	
						// SNOOPY: Added support for evil crusade structures spawning already built in pits.
							switch (m_pMapList[i]->m_stSpotMobGenerator[j].iMobType) {
							case 36: // AGT
							case 37: // CGT
							case 39: // DT
								for (i5 = 1; i5 < DEF_MAXNPCS; i5++)
								if ((m_pNpcList[i5] != NULL) && (memcmp(m_pNpcList[i5]->m_cName, cName_Master, 5) == 0) ) 
								{	m_pNpcList[i5]->m_sAppr2 = 0;
									m_pNpcList[i5]->m_iBuildCount = 1;
									SendEventToNearClient_TypeA(i5, DEF_OWNERTYPE_NPC, MSGID_EVENT_MOTION, DEF_OBJECTNULLACTION, NULL, NULL, NULL);
								}
								break;
						}	}
						break;
					}// End switch (m_pMapList[i]->m_stSpotMobGenerator[j].cType
					if (cSA <0)
					{	cSA = abs(cSA); // All the same kind than Boss
						iTotalMob = iDice(2,4);
						for (j = 0; j < iTotalMob ; j++) // Give some followers to Boss
						{	iNamingValue = m_pMapList[i]->iGetEmptyNamingValue();
							if (iNamingValue != -1) {
								ZeroMemory(cName_Slave, sizeof(cName_Slave));
								wsprintf(cName_Slave, "XX%d", iNamingValue);
								cName_Slave[0] = 95; // original '_';
								cName_Slave[1] = i + 65;
								if (bCreateNewNpc(cNpcName, cName_Slave, m_pMapList[i]->m_cName, (rand() % 3), cSA, DEF_MOVETYPE_RANDOM, &pX, &pY, cWaypoint, NULL, NULL, bExecutorFriendMob, FALSE, FALSE, bFirmBerserk) == FALSE) 
								{	m_pMapList[i]->SetNamingValueEmpty(iNamingValue);
								}else 
								{	bSetNpcFollowMode(cName_Slave, cName_Master, DEF_OWNERTYPE_NPC);						
						}	}	}	
						// Log Boss spawning
						wsprintf(G_cTxt, "(!) Boss spawn - %s(%d %d) [%s]"
							, m_pMapList[i]->m_cName
							, pX
							, pY
							, cNpcName);
						PutLogList(G_cTxt);	
						PutLogEventFileList(G_cTxt);
						//SNOOPY: Show Spawns on minimap
						wX = (WORD) pX;
						wY = (WORD) pY;
						for (x = 1; x < DEF_MAXCLIENTS; x++)
						if (   (iNpcID != -1) 
							&& (m_pClientList[x] != NULL) 
							&& (m_pClientList[x]->m_bIsInitComplete == TRUE)						
							&& (memcmp(m_pMapList[i]->m_cName, m_pMapList[m_pClientList[x]->m_cMapIndex]->m_cName, strlen(m_pMapList[i]->m_cName)) == 0)
							) 
						{	SendNotifyMsg(NULL, x, DEF_NOTIFY_SPAWNEVENT, wX, wY, iNpcID, NULL, NULL, NULL);
	}	}	}	}	}	}
}

void CGame::CalcNextWayPointDestination(int iNpcH)
{short sRange, sX, sY;
 register int i, j, iMapIndex;
 BOOL bFlag;
	switch (m_pNpcList[iNpcH]->m_cMoveType) {
	case DEF_MOVETYPE_GUARD:
		break;
	
	case DEF_MOVETYPE_SEQWAYPOINT: 
		m_pNpcList[iNpcH]->m_cCurWaypoint++;
		if (m_pNpcList[iNpcH]->m_cCurWaypoint >= m_pNpcList[iNpcH]->m_cTotalWaypoint)
			m_pNpcList[iNpcH]->m_cCurWaypoint = 1;
		m_pNpcList[iNpcH]->m_dX  = (short)(m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->m_WaypointList[ m_pNpcList[iNpcH]->m_iWayPointIndex[ m_pNpcList[iNpcH]->m_cCurWaypoint ] ].x);
		m_pNpcList[iNpcH]->m_dY  = (short)(m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->m_WaypointList[ m_pNpcList[iNpcH]->m_iWayPointIndex[ m_pNpcList[iNpcH]->m_cCurWaypoint ] ].y);
		break;

	case DEF_MOVETYPE_RANDOMWAYPOINT:	
		m_pNpcList[iNpcH]->m_cCurWaypoint = (short)((rand() % (m_pNpcList[iNpcH]->m_cTotalWaypoint - 1)) + 1);
		m_pNpcList[iNpcH]->m_dX  = (short)(m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->m_WaypointList[ m_pNpcList[iNpcH]->m_iWayPointIndex[ m_pNpcList[iNpcH]->m_cCurWaypoint ] ].x);
		m_pNpcList[iNpcH]->m_dY  = (short)(m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->m_WaypointList[ m_pNpcList[iNpcH]->m_iWayPointIndex[ m_pNpcList[iNpcH]->m_cCurWaypoint ] ].y);
		break;

	case DEF_MOVETYPE_RANDOMAREA:				
		sRange = (short)(m_pNpcList[iNpcH]->m_rcRandomArea.right - m_pNpcList[iNpcH]->m_rcRandomArea.left);
		m_pNpcList[iNpcH]->m_dX = (short)((rand() % sRange) + m_pNpcList[iNpcH]->m_rcRandomArea.left);
		sRange = (short)(m_pNpcList[iNpcH]->m_rcRandomArea.bottom - m_pNpcList[iNpcH]->m_rcRandomArea.top);
		m_pNpcList[iNpcH]->m_dY = (short)((rand() % sRange) + m_pNpcList[iNpcH]->m_rcRandomArea.top);
		break;

	case DEF_MOVETYPE_RANDOM:
		//m_pNpcList[iNpcH]->m_dX = (rand() % (m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->m_sSizeX - 50)) + 15;
		//m_pNpcList[iNpcH]->m_dY = (rand() % (m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->m_sSizeY - 50)) + 15;
		iMapIndex = m_pNpcList[iNpcH]->m_cMapIndex;
		for ( i = 0; i <= 30; i++) {
			sX = (rand() % (m_pMapList[iMapIndex]->m_sSizeX - 50)) + 15;
			sY = (rand() % (m_pMapList[iMapIndex]->m_sSizeY - 50)) + 15;
			bFlag = TRUE;
			for (j = 0; j < DEF_MAXMGAR; j++)
			if (m_pMapList[iMapIndex]->m_rcMobGenAvoidRect[j].left != -1) 
			{	if ((sX >= m_pMapList[iMapIndex]->m_rcMobGenAvoidRect[j].left) &&
					(sX <= m_pMapList[iMapIndex]->m_rcMobGenAvoidRect[j].right) &&
					(sY >= m_pMapList[iMapIndex]->m_rcMobGenAvoidRect[j].top) &&
					(sY <= m_pMapList[iMapIndex]->m_rcMobGenAvoidRect[j].bottom)) 
				{	bFlag = FALSE;
			
			}	}
			if (bFlag == TRUE) goto CNW_GET_VALIDLOC_SUCCESS;
		}	// Fail! 
		m_pNpcList[iNpcH]->m_tmp_iError  = 0; 
		return;

CNW_GET_VALIDLOC_SUCCESS:;
		m_pNpcList[iNpcH]->m_dX = sX;
		m_pNpcList[iNpcH]->m_dY = sY;
		break;
	}
	m_pNpcList[iNpcH]->m_tmp_iError  = 0; // @@@ !!! @@@
}

void CGame::DeleteNpc(int iNpcH)
{	int  i, iNamingValue, iNumItem, iItemID, iItemIDs[MAX_NPCITEMDROP], iSlateID;
	char cTmp[21], cItemName[21];
	class CItem * pItem, * pItem2;
	DWORD dwCount, dwTime;
    POINT ItemPositions[MAX_NPCITEMDROP];
	char cTemp[256];
	SYSTEMTIME SysTime;
	BOOL NoEggs = FALSE;
	if (m_pNpcList[iNpcH] == NULL) return;
	dwTime = timeGetTime();
	//Init number of items to 1 unless its a multidrop;
	iNumItem = 0;
	iItemID = 0; // No current item
	SendEventToNearClient_TypeA(iNpcH, DEF_OWNERTYPE_NPC, MSGID_EVENT_LOG, DEF_MSGTYPE_REJECT, NULL, NULL, NULL);
	m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->ClearOwner(11, iNpcH, DEF_OWNERTYPE_NPC, m_pNpcList[iNpcH]->m_sX, m_pNpcList[iNpcH]->m_sY);

	ZeroMemory(cTmp, sizeof(cTmp));
	strcpy(cTmp, (char *)(m_pNpcList[iNpcH]->m_cName + 2));
	// NPC NamigValue
	iNamingValue = atoi(cTmp);

	// NamingValue
	m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->SetNamingValueEmpty(iNamingValue);
	m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->m_iTotalActiveObject--;
	if (m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->m_iTotalActiveObject == 0) 
	{	if (m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->m_iApocalypseMobGenType == 1)
		{	// See if we need to open a dynamic Gate, then tell clients
			Open_EmptyMap_Gate(m_pNpcList[iNpcH]->m_cMapIndex);
		}
		if (m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->m_iApocalypseMobGenType == 2)
		{	// generate Abaddon and open Dynamic Gate
			GenerateApocalypseBoss(m_pNpcList[iNpcH]->m_cMapIndex);
			// Then change m_iApocalypseMobGenType to 1 for Gate openning when this boss is dead
			m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->m_iApocalypseMobGenType = 1;	
	}	}

// SNOOPY: Test if map is available for Eggs dropping
	if (m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->m_cRandomMobGeneratorLevel == 23) 
	{	NoEggs = TRUE;
	}

	// Spot-mob-generator
	if ( m_pNpcList[iNpcH]->m_iSpotMobIndex != NULL )
	{	m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->m_stSpotMobGenerator[m_pNpcList[iNpcH]->m_iSpotMobIndex].iCurMobs--;
		if ((NoEggs == FALSE) && (m_pNpcList[iNpcH]->m_bIsUnsummoned == FALSE))			
			m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->m_stSpotMobGenerator[m_pNpcList[iNpcH]->m_iSpotMobIndex].iKilledMobs += m_pNpcList[iNpcH]->m_iHitDice;
	}else if ((NoEggs == FALSE) && (m_pNpcList[iNpcH]->m_bIsUnsummoned == FALSE))	
				m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->m_iNoSMRGKilledMobs += m_pNpcList[iNpcH]->m_iHitDice; 
	RemoveFromTarget(iNpcH, DEF_OWNERTYPE_NPC);

	switch (m_pNpcList[iNpcH]->m_sOriginalType) {
	case 40: // ESG // Allow Tile behind 
	case 41: // GMG
		m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->SetStayAllowedFlag(m_pNpcList[iNpcH]->m_sX, m_pNpcList[iNpcH]->m_sY-1, TRUE); // Allow case behind structure
		break;	
	case 36: // AGT  Crusade structures
	case 37: // CGT
	case 38: // MS
	case 39: // DT
	case 42: // ManaStone
		m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->bRemoveCrusadeStructureInfo(m_pNpcList[iNpcH]->m_sX, m_pNpcList[iNpcH]->m_sY);
		// Allow Tile behind
		m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->SetStayAllowedFlag(m_pNpcList[iNpcH]->m_sX, m_pNpcList[iNpcH]->m_sY-1, TRUE); // Allow case behind structure
		for (i = 0; i < DEF_MAXGUILDS; i++) 
		{	if (m_pGuildTeleportLoc[i].m_iV1 == m_pNpcList[iNpcH]->m_iGuildGUID) 
			{	m_pGuildTeleportLoc[i].m_dwTime = dwTime;
				m_pGuildTeleportLoc[i].m_iV2--;
				if (m_pGuildTeleportLoc[i].m_iV2 < 0) m_pGuildTeleportLoc[i].m_iV2 = 0;
				break;	
			}
		}
		break;
	case 64: m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->bRemoveCropsTotalSum(); break;

	}
	// DelayEvent
	bRemoveFromDelayEventList(iNpcH, DEF_OWNERTYPE_NPC, NULL);
	if ((m_pNpcList[iNpcH]->m_bIsSummoned == FALSE) && (m_pNpcList[iNpcH]->m_bIsUnsummoned == FALSE)) 
	{	pItem = new class CItem;
		ZeroMemory(cItemName, sizeof(cItemName));
		//switch (m_pNpcList[iNpcH]->m_sType) {
		switch (m_pNpcList[iNpcH]->m_sOriginalType) {
/*SlimeJelly 1/25 -> 1/15
AntLeg 1/9 -> 1/6
AntAntenna 1/10 -> 1/6
SnakeToungue 1/17 -> 1/10
SnakeSkin 1/16 -> 1/20
Snake Meat 1/15 -> 1/20
Snake Teeth 1/16 -> 1/20
Demon eye Heart Meat -> 1/100
Demon meat corrigé (proba zero!)
Demon Skin - 1/75*/
		case 10: // Slime
			if (iDice(1,15) == 1) iItemID = 220; break; // SlimeJelly 
			break;

		case 11: // Skeleton
			switch(iDice(1,2))	{
			case 1:if (iDice(1,20) == 1) iItemID = 219; break; // SkeletonBones
			case 2: if (!NoEggs) bGetItemNameWhenDeleteNpc(iItemID, m_pNpcList[iNpcH]->m_sOriginalType); break;
			default: break;
			}
			break;
			
		case 12: // Stone-Golem
		switch(iDice(1,2)){
			case 1:	if (iDice(1,30) == 1) iItemID = 221; break; // StoneGolemPiece
			case 2: if (!NoEggs) bGetItemNameWhenDeleteNpc(iItemID, m_pNpcList[iNpcH]->m_sOriginalType); break;
			default: break;
			}	
			break;

		case 13: // Cyclops
			switch(iDice(1,6)){
			case 1:	if (iDice(1,36) == 1) iItemID = 194; break; // CyclopsEye
			case 2:	if (iDice(1,40) == 1) iItemID = 195; break; // CyclopsHandEdge
			case 3:	if (iDice(1,30) == 1) iItemID = 196; break; // CyclopsHeart
			case 4:	if (iDice(1,22) == 1) iItemID = 197; break; // CyclopsMeat
			case 5:	if (iDice(1,40) == 1) iItemID = 198; break; // CyclopsLeather
			case 6: if (!NoEggs) bGetItemNameWhenDeleteNpc(iItemID, m_pNpcList[iNpcH]->m_sOriginalType); break;
			default: break;
			}
			break;

		case 14: // Orc, Orc-Mage
			switch(iDice(1,4)){
			case 1:	if (iDice(1,11) == 1) iItemID = 206; break; // OrcMeat
			case 2:	if (iDice(1,20) == 1) iItemID = 207; break; // OrcLeather
			case 3:	if (iDice(1,21) == 1) iItemID = 208; break; // OrcTeeth
			case 4: if (!NoEggs) bGetItemNameWhenDeleteNpc(iItemID, m_pNpcList[iNpcH]->m_sOriginalType); break;
			default: break;
			}
			break;
			
		case 16: //Giant-Ant
			switch(iDice(1,3)){
			case 1:	if (iDice(1,6) == 1) iItemID = 192; break; // AntLeg
			case 2:	if (iDice(1,6) == 1) iItemID = 193; break; // AntAntena
			case 3: if (!NoEggs) bGetItemNameWhenDeleteNpc(iItemID, m_pNpcList[iNpcH]->m_sOriginalType); break;
			default: break;
			}
			break;

		case 17: //Scorpion
			switch(iDice(1,5)){
			case 1:	if (iDice(1,50) == 1) iItemID = 215; break; // ScorpionPincers
			case 2:	if (iDice(1,20) == 1) iItemID = 216; break; // ScorpionMeat
			case 3: if (iDice(1,50) == 1) iItemID = 217; break; // ScorpionSting
			case 4: if (iDice(1,40) == 1) iItemID = 218; break; // ScorpionSkin
			case 5: if (!NoEggs) bGetItemNameWhenDeleteNpc(iItemID, m_pNpcList[iNpcH]->m_sOriginalType); break;
			default: break;
			}
			break;

		case 18: //Zombie
			if (!NoEggs) bGetItemNameWhenDeleteNpc(iItemID, m_pNpcList[iNpcH]->m_sOriginalType); break;
			break;

		case 22: //Amphis
			switch(iDice(1,5)){
			case 1: if (iDice(1,20) == 1) iItemID = 188; break; // SnakeMeat
			case 2:	if (iDice(1,10) == 1) iItemID = 189; break; // SnakeSkin
			case 3:	if (iDice(1,20) == 1) iItemID = 190; break; // SnakeTeeth
			case 4:	if (iDice(1,10) == 1) iItemID = 191; break; // SnakeTongue
			case 5: if (!NoEggs) bGetItemNameWhenDeleteNpc(iItemID, m_pNpcList[iNpcH]->m_sOriginalType); break;
			default: break;
			}
			break;

		case 23: //Clay-Golem
			switch(iDice(1,2)){
			case 1: if (iDice(1,30) == 1) iItemID = 205; break; // LumpofClay
			case 2: if (!NoEggs) bGetItemNameWhenDeleteNpc(iItemID, m_pNpcList[iNpcH]->m_sOriginalType); break;
			default: break;
			}
			break;


		case 27: //Hellbound
			switch(iDice(1,7)){
			case 1:	if (iDice(1,40) == 1) iItemID = 199; break; // HelboundHeart
			case 2:	if (iDice(1,38) == 1) iItemID = 200; break; // HelboundLeather
			case 3:	if (iDice(1,38) == 1) iItemID = 201; break; // HelboundTail
			case 4:	if (iDice(1,36) == 1) iItemID = 202; break; // HelboundTeeth
			case 5:	if (iDice(1,36) == 1) iItemID = 203; break; // HelboundClaw
			case 6:	if (iDice(1,50) == 1) iItemID = 204; break; // HelboundTongue
			case 7: if (!NoEggs) bGetItemNameWhenDeleteNpc(iItemID, m_pNpcList[iNpcH]->m_sOriginalType); break;
			default: break;
			}
			break;

		case 28: //Troll
			switch(iDice(1,5)){
			case 1:	if (iDice(1,35) == 1) iItemID = 222; break; // TrollHeart
			case 2:	if (iDice(1,23) == 1) iItemID = 223; break; // TrollMeat
			case 3:	if (iDice(1,25) == 1) iItemID = 224; break; // TrollLeather
			case 4:	if (iDice(1,27) == 1) iItemID = 225; break; // TrollClaw
			case 5: if (!NoEggs) bGetItemNameWhenDeleteNpc(iItemID, m_pNpcList[iNpcH]->m_sOriginalType); break;
			default: break;
			}
			break;

		case 29: //Ogre
			switch(iDice(1,7)){
			case 1:	if (iDice(1,20) == 1) iItemID = 209; break; // OgreHair
			case 2:	if (iDice(1,22) == 1) iItemID = 210; break; // OgreHeart
			case 3:	if (iDice(1,25) == 1) iItemID = 211; break; // OgreMeat
			case 4:	if (iDice(1,25) == 1) iItemID = 212; break; // OgreLeather
			case 5:	if (iDice(1,28) == 1) iItemID = 213; break; // OgreTeeth
			case 6:	if (iDice(1,28) == 1) iItemID = 214; break; // OgreClaw
			case 7: if (!NoEggs) bGetItemNameWhenDeleteNpc(iItemID, m_pNpcList[iNpcH]->m_sOriginalType); break;
			default: break;
			}
			break;

		case 30: //Liche
			bGetItemNameWhenDeleteNpc(iItemID, m_pNpcList[iNpcH]->m_sOriginalType); break;
			break;

		case 31: //Demon
			switch(iDice(1,5)){
			case 1:	if (iDice(1,40) == 13) iItemID = 541; break; // DemonHeart
			case 2:	if (iDice(1,30) == 13) iItemID = 542; break; // DemonMeat
			case 3:	if (iDice(1,20) == 13) iItemID = 543; break; // DemonLeather
			case 4:	if (iDice(1,25) == 13) iItemID = 540; break; // DemonEye
			case 5: if (!NoEggs) bGetItemNameWhenDeleteNpc(iItemID, m_pNpcList[iNpcH]->m_sOriginalType); break;
			default: break;
			}
			break;

		case 32: //Unicorn
			switch(iDice(1,5)){
			case 1:	if (iDice(1,40) == 13) iItemID = 544; break; // UnicornHeart
			case 2:	if (iDice(1,25) == 13) iItemID = 545; break; // UnicornHorn
			case 3:	if (iDice(1,30) == 13) iItemID = 546; break; // UnicornMeat
			case 4:	if (iDice(1,20) == 13) iItemID = 547; break; // UnicornLeather
			case 5: if (!NoEggs) bGetItemNameWhenDeleteNpc(iItemID, m_pNpcList[iNpcH]->m_sOriginalType); break;
			default: break;
			}
			break;

		case 33: //WereWolf
			switch(iDice(1,8)){
			case 1: if (iDice(1,30) == 3) iItemID = 551; break; // WerewolfTail
			case 2:	if (iDice(1,28) == 3) iItemID = 548; break; // WerewolfHeart
			case 3:	if (iDice(1,25) == 3) iItemID = 550; break; // WerewolfMeat
			case 4:	if (iDice(1,35) == 3) iItemID = 553; break; // WerewolfLeather
			case 5:	if (iDice(1,28) == 3) iItemID = 552; break; // WerewolfTeeth
			case 6:	if (iDice(1,28) == 3) iItemID = 554; break; // WerewolfClaw
			case 7:	if (iDice(1,38) == 3) iItemID = 549; break; // WerewolfNail
			case 8: if (!NoEggs) bGetItemNameWhenDeleteNpc(iItemID, m_pNpcList[iNpcH]->m_sOriginalType); break;
			default: break;
			}
			break;
		case 53: // Beholder
			switch(iDice(1,2)){
			case 1: if (iDice(1,50) == 3) iItemID = 555; break; // BeholderEye
			case 2: if (!NoEggs) bGetItemNameWhenDeleteNpc(iItemID, m_pNpcList[iNpcH]->m_sOriginalType); break;
			default: 
				break;
			}	
			break;

		case 48: //Stalker
		case 52: //Gagoyle
		case 54: //Dark-Elf
		case 55: //Rabbit
		case 56: //Cat
		case 57: //Frog
		case 58: //Mountain-Giant
		case 59: //Ettin
		case 60: //Plant
		case 61: //Rudolph
		case 62: //DireBoar
		case 63: //Frost
		case 65: //IceGolem
		case 70: //Dragon
		case 71: //Centaurus
		case 72: //ClawTurtle
		case 74: //GiantCrayFish
		case 75: //Giant-Lizard
		case 76: //Giant-Tree
		case 77: //MasterMageOrc
		case 78: //Minautors
		case 79: //Nizie
		case 80: //Tentocle
		case 82: //Sorceress
		case 83: //Ancient Kinght
		case 84: //Master Elf
		case 85: //Dark Knight
		case 87: //Barbarian
		case 88: //DarkKnight
			if (!NoEggs) bGetItemNameWhenDeleteNpc(iItemID, m_pNpcList[iNpcH]->m_sOriginalType); 
			break;	

// SNOOPY: HC and TW are entitled to 2nd Drops even in occupied cities (Random-mob 23 )
		case 49: //Hellclaw
	//	case 50: //Tigerworm
			bGetItemNameWhenDeleteNpc(iItemID, m_pNpcList[iNpcH]->m_sOriginalType); 
			break;
//SNOOPY added a Small Multidrop for TW
		case 50: //Tigerworm
			bGetMultipleItemNamesWhenDeleteNpc( m_pNpcList[iNpcH]->m_sOriginalType,	// NPC Type
												30,							// iProbability 
												3,							// iMin
												9,							// iMax
												m_pNpcList[iNpcH]->m_sX,	// sBaseX
												m_pNpcList[iNpcH]->m_sY,	// sBaseY
												DEF_ITEMSPREAD_RANDOM,		// (1:RANDOM, 2:FIXED)
												3,							// iSpreadRange
												iItemIDs,					// Item table
												ItemPositions,				// Positions table
												&iNumItem);					// Item number
			break;
		case 66: // Wyvern
			bGetMultipleItemNamesWhenDeleteNpc( m_pNpcList[iNpcH]->m_sOriginalType,	// NPC Type
												40,							// iProbability 
												4,							// iMin
												12,							// iMax
												m_pNpcList[iNpcH]->m_sX,	// sBaseX
												m_pNpcList[iNpcH]->m_sY,	// sBaseY
												DEF_ITEMSPREAD_FIXED,		// (1:RANDOM, 2:FIXED)
												3,							// iSpreadRange
												iItemIDs,					// Item table
												ItemPositions,				// Positions table
												&iNumItem);					// Item number
			break;
		case 73: // Fire-Wyvern
			bGetMultipleItemNamesWhenDeleteNpc( m_pNpcList[iNpcH]->m_sOriginalType,	// NPC Type
												60,							// iProbability 
												5,							// iMin
												15,							// iMax
												m_pNpcList[iNpcH]->m_sX,	// sBaseX
												m_pNpcList[iNpcH]->m_sY,	// sBaseY
												DEF_ITEMSPREAD_FIXED,		// RANDOM, DEF_ITEMSPREAD_FIXED
												4,							// iSpreadRange 
												iItemIDs,					// Item table
												ItemPositions,				// Positions table
												&iNumItem);					// Item number
			break;
		case 81: // Abaddon
			bGetMultipleItemNamesWhenDeleteNpc( m_pNpcList[iNpcH]->m_sOriginalType,	// NPC Type
												90,							// iProbability
												12,							// iMin
												25,							// iMax
												m_pNpcList[iNpcH]->m_sX,	// sBaseX
												m_pNpcList[iNpcH]->m_sY,	// sBaseY
												DEF_ITEMSPREAD_FIXED,		// (RANDOM, FIXED)
												4,							// iSpreadRange
												iItemIDs,					// Item table
												ItemPositions,				// Positions table
												&iNumItem);					// Item number
			break;
		}
		dwCount = 1;

// Snoopy: Restored Gold Drop for Liches, DD, & Unis
		// but not in occupied cities (Random-mob 23)
		if ((iItemID == 0) && (!NoEggs))  
		{	switch (m_pNpcList[iNpcH]->m_sOriginalType) {
			case 30: // Liche
				iItemID = 90; 
				dwCount = (DWORD)(iDice(4, 300));
				break;
			case 31: // DD
				iItemID = 90; 
				dwCount = (DWORD)(iDice(4, 1200));
				break;
			case 32: // Uni
				iItemID = 90; 
				dwCount = (DWORD)(iDice(4, 600));
				break;
		}	}

		if (iNumItem > 0) 
		{	GetLocalTime(&SysTime);
			wsprintf(cTemp, "%d%02d%", SysTime.wMonth, SysTime.wDay);
			for(int j = 0; j < iNumItem; j++)
			{	if (pItem == NULL) 
				{	pItem = new class CItem;
				}
				if (   (_bInitItemAttr(pItem, iItemIDs[j]) == FALSE) 
					|| (m_pMapList[ m_pNpcList[iNpcH]->m_cMapIndex ]->bGetIsMoveAllowedTile(ItemPositions[j].x, ItemPositions[j].y) == FALSE)) 
				{	delete pItem;
					pItem = NULL;
				}else 
				{	if (iItemIDs[j] == 90) // Gold for Multidrop
					{	switch (m_pNpcList[iNpcH]->m_sOriginalType) {
						case 66: // Wyvern
							pItem->m_dwCount = iDice(10, 3000);
							break;
						case 73: // Fire-Wyvern
							pItem->m_dwCount = iDice(10, 5000);
							break;
						case 81:// Abaddon
							pItem->m_dwCount = iDice(10, 15000);
							break;
						case 50: // TW
						default: 
							pItem->m_dwCount = iDice(10, 1500);
							break;
						}
					}else pItem->m_dwCount = dwCount;

					pItem->m_sTouchEffectType   = DEF_ITET_ID;
					pItem->m_sTouchEffectValue1 = iDice(1,100000);
					pItem->m_sTouchEffectValue2 = iDice(1,100000);
					///pItem->m_sTouchEffectValue3 = (short)timeGetTime();
					if (pItem->m_cItemType == DEF_ITEMTYPE_MATERIAL)
					{	pItem->m_sItemSpecEffectValue2 = iDice (1, 40) +20;
						pItem->m_dwAttribute = 1;
						pItem->m_sItemSpecEffectValue1 = pItem->m_wCurLifeSpan;
					}
					SYSTEMTIME SysTime;
					// Alreaddy declared  char cTemp[256];
					GetLocalTime(&SysTime);
					ZeroMemory(cTemp, sizeof(cTemp));
					wsprintf(cTemp, "%d%2d",  (short)SysTime.wMonth, (short)SysTime.wDay);
					pItem->m_sTouchEffectValue3 = atoi(cTemp);

					m_pMapList[ m_pNpcList[iNpcH]->m_cMapIndex ]->bSetItem(ItemPositions[j].x, ItemPositions[j].y, pItem);
					SendEventToNearClient_TypeB(MSGID_EVENT_COMMON, DEF_COMMONTYPE_ITEMDROP, m_pNpcList[iNpcH]->m_cMapIndex,
												ItemPositions[j].x, ItemPositions[j].y,	pItem->m_sSprite, pItem->m_sSpriteFrame, pItem->m_cItemColor);
					_bItemLog(DEF_ITEMLOG_NEWGENDROP, NULL, m_pNpcList[iNpcH]->m_cNpcName, pItem);
					//SNOOPY: Logging special 2nd drops here
					if(_bCheckGoodItem( pItem ) == TRUE) 
					{	wsprintf(G_cTxt, "NPC(%s)\t2nd Drop\t%s(%d %d %d %d %x)\t%s(%d %d)"
							, m_pNpcList[iNpcH]->m_cNpcName
							, pItem->m_cName
							, pItem->m_dwCount
							, pItem->m_sTouchEffectValue1
							, pItem->m_sTouchEffectValue2
							, pItem->m_sTouchEffectValue3
							, pItem->m_dwAttribute
							, m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->m_cName
							, m_pNpcList[iNpcH]->m_sX
							, m_pNpcList[iNpcH]->m_sY);
						// SNOOPY: Added special Item events Logging
						PutItemLogFileList(G_cTxt);
					}	
					pItem = NULL;			
			}	}
		}else
		{	if (_bInitItemAttr(pItem, iItemID) == FALSE) 
			{		delete pItem;
					pItem = NULL;
			}else 
			{	pItem->m_dwCount = dwCount;
				pItem->m_sTouchEffectType   = DEF_ITET_ID;
				pItem->m_sTouchEffectValue1 = iDice(1,100000);
				pItem->m_sTouchEffectValue2 = iDice(1,100000);
				//pItem->m_sTouchEffectValue3 = (short)timeGetTime();
				if (pItem->m_cItemType == DEF_ITEMTYPE_MATERIAL)
				{	pItem->m_sItemSpecEffectValue2 = iDice (1, 40) +20;
					pItem->m_dwAttribute = 1;
					pItem->m_sItemSpecEffectValue1 = pItem->m_wCurLifeSpan;
				}
				SYSTEMTIME SysTime;
				// Alreaddy declared char cTemp[256];
				GetLocalTime(&SysTime);
				ZeroMemory(cTemp, sizeof(cTemp));
				wsprintf(cTemp, "%d%2d",  (short)SysTime.wMonth, (short)SysTime.wDay);
				pItem->m_sTouchEffectValue3 = atoi(cTemp);
				m_pMapList[ m_pNpcList[iNpcH]->m_cMapIndex ]->bSetItem(m_pNpcList[iNpcH]->m_sX, m_pNpcList[iNpcH]->m_sY, pItem);
				SendEventToNearClient_TypeB(MSGID_EVENT_COMMON, DEF_COMMONTYPE_ITEMDROP, m_pNpcList[iNpcH]->m_cMapIndex,
					m_pNpcList[iNpcH]->m_sX, m_pNpcList[iNpcH]->m_sY, pItem->m_sSprite, pItem->m_sSpriteFrame, pItem->m_cItemColor);
				_bItemLog(DEF_ITEMLOG_NEWGENDROP, NULL, m_pNpcList[iNpcH]->m_cNpcName, pItem);
				//SNOOPY: Logging special 2nd drops here
				if(_bCheckGoodItem( pItem ) == TRUE) {
					wsprintf(G_cTxt, "NPC(%s)\t2nd Drop\t%s(%d %d %d %d %x)\t%s(%d %d)"
						, m_pNpcList[iNpcH]->m_cNpcName
						, pItem->m_cName
						, pItem->m_dwCount
						, pItem->m_sTouchEffectValue1
						, pItem->m_sTouchEffectValue2
						, pItem->m_sTouchEffectValue3
						, pItem->m_dwAttribute
						, m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->m_cName
						, m_pNpcList[iNpcH]->m_sX
						, m_pNpcList[iNpcH]->m_sY);
					// SNOOPY: Added special Item events Logging
					PutItemLogFileList(G_cTxt);
				}

			}				
		}
// Snoppy: I need to study those....
// Gives a chance to get Ancient Slates
		if ((iDice(1, 1000) == 93) && (iDice(1, 100) == 17)){ // 1 chance/10 000 
			pItem2 = new class CItem;
			switch(iDice(1,4)){
				case 1:	iSlateID = 868; break;
				case 2: iSlateID = 869; break;
				case 3: iSlateID = 870; break;
				case 4: iSlateID = 871; break;
			}
			if (_bInitItemAttr(pItem2, iSlateID) == FALSE) 
			{		delete pItem2;
					pItem2 = NULL;
			}else 
			{	pItem2->m_dwCount = 1;
				pItem2->m_sTouchEffectType   = DEF_ITET_ID;
				pItem2->m_sTouchEffectValue1 = iDice(1,100000);
				pItem2->m_sTouchEffectValue2 = iDice(1,100000);
				//pItem2->m_sTouchEffectValue3 = (short)timeGetTime();	
				SYSTEMTIME SysTime;
				// Alreaddy declared char cTemp[256];
				GetLocalTime(&SysTime);
				ZeroMemory(cTemp, sizeof(cTemp));
				wsprintf(cTemp, "%d%2d",  (short)SysTime.wMonth, (short)SysTime.wDay);
				pItem2->m_sTouchEffectValue3 = atoi(cTemp);
				m_pMapList[ m_pNpcList[iNpcH]->m_cMapIndex ]->bSetItem(m_pNpcList[iNpcH]->m_sX, m_pNpcList[iNpcH]->m_sY, pItem2);
				SendEventToNearClient_TypeB(MSGID_EVENT_COMMON, DEF_COMMONTYPE_ITEMDROP, m_pNpcList[iNpcH]->m_cMapIndex,
					m_pNpcList[iNpcH]->m_sX, m_pNpcList[iNpcH]->m_sY, pItem2->m_sSprite, pItem2->m_sSpriteFrame, pItem2->m_cItemColor);
				_bItemLog(DEF_ITEMLOG_NEWGENDROP, NULL, m_pNpcList[iNpcH]->m_cNpcName, pItem2);
				//SNOOPY: Logging special 2nd drops here
				if(_bCheckGoodItem( pItem2 ) == TRUE) 
				{	wsprintf(G_cTxt, "NPC(%s)\t2nd Drop\t%s(%d %d %d %d %x)\t%s(%d %d)"
						, m_pNpcList[iNpcH]->m_cNpcName
						, pItem2->m_cName
						, pItem2->m_dwCount
						, pItem2->m_sTouchEffectValue1
						, pItem2->m_sTouchEffectValue2
						, pItem2->m_sTouchEffectValue3
						, pItem2->m_dwAttribute
						, m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->m_cName
						, m_pNpcList[iNpcH]->m_sX
						, m_pNpcList[iNpcH]->m_sY);
					// SNOOPY: Added special Item events Logging
					PutItemLogFileList(G_cTxt);
				}
			}
		}
	}
    delete m_pNpcList[iNpcH];
	m_pNpcList[iNpcH] = NULL;
}

void CGame::RequestFullObjectData(int iClientH, char *pData)
{DWORD * dwp;
 WORD  * wp, wObjectID;
 char  * cp, cData[100];
 short * sp, sX, sY;
 int     iTemp, iTemp2;
 int   * ip, iRet;
 BOOL bTransparentInvi = FALSE;
	if (m_pClientList[iClientH] == NULL) return;
	if (m_pClientList[iClientH]->m_bIsInitComplete == FALSE) return;
	wp = (WORD *)(pData + DEF_INDEX2_MSGTYPE);
	wObjectID = *wp;	
	ZeroMemory(cData, sizeof(cData));
	dwp  = (DWORD *)(cData + DEF_INDEX4_MSGID);
	*dwp = MSGID_EVENT_MOTION;
	wp   = (WORD *)(cData + DEF_INDEX2_MSGTYPE);
	*wp  = DEF_OBJECTSTOP;	
	cp = (char *)(cData + DEF_INDEX2_MSGTYPE + 2);
	if (wObjectID < 10000) // PC
	{	if ( (wObjectID == 0) || (wObjectID >= DEF_MAXCLIENTS) ) return;
		if (m_pClientList[wObjectID] == NULL) return;		
		wp  = (WORD *)cp;
		*wp = wObjectID;			// ObjectID
		cp += 2;
		sp  = (short *)cp;
		sX  = m_pClientList[wObjectID]->m_sX;
		*sp = sX;
		cp += 2;
		sp  = (short *)cp;
		sY  = m_pClientList[wObjectID]->m_sY;
		*sp = sY;
		cp += 2;
		sp  = (short *)cp;
		*sp = m_pClientList[wObjectID]->m_sType;
		cp += 2;
		*cp = m_pClientList[wObjectID]->m_cDir;
		cp++;
		memcpy(cp, m_pClientList[wObjectID]->m_cCharName, 10);
		cp += 10;
		sp  = (short *)cp;
		*sp = m_pClientList[wObjectID]->m_sAppr1;
		cp += 2;
		sp  = (short *)cp;
		*sp = m_pClientList[wObjectID]->m_sAppr2;
		cp += 2;
		sp  = (short *)cp;
		*sp = m_pClientList[wObjectID]->m_sAppr3;
		cp += 2;
		sp  = (short *)cp;
		*sp = m_pClientList[wObjectID]->m_sAppr4;
		cp += 2;
		//v1.4 ApprColor
		ip = (int *)cp;
		*ip = m_pClientList[wObjectID]->m_iApprColor;
		cp += 4;		
		ip  = (int *)cp;
		iTemp = m_pClientList[wObjectID]->m_iStatus;
		iTemp = 0x0FFBFFFF & iTemp;
		bTransparentInvi = FALSE;
		iTemp2 = iGetPlayerABSStatus(wObjectID, iClientH, bTransparentInvi); 
		if (bTransparentInvi == TRUE) iTemp = (iTemp | 0x00040000);
		iTemp  = (iTemp | (iTemp2 << 28));//Original : 12		
		*ip = iTemp;
		cp += 4;//Original 2		
		if (m_pClientList[wObjectID]->m_bIsKilled == TRUE) // v1.4
			 *cp = 1;
		else *cp = 0;
		cp++;
		iRet = m_pClientList[iClientH]->m_pXSock->iSendMsg(cData, 41); // v1.4
	}else 	// NPC
	{	if ( ((wObjectID - 10000) == 0) || ((wObjectID - 10000) >= DEF_MAXNPCS) ) return;
		if (m_pNpcList[wObjectID - 10000] == NULL) return;		
		wp  = (WORD *)cp;
		*wp = wObjectID;			
		cp += 2;
		wObjectID -= 10000;
		sp  = (short *)cp;
		sX  = m_pNpcList[wObjectID]->m_sX;
		*sp = sX;
		cp += 2;
		sp  = (short *)cp;
		sY  = m_pNpcList[wObjectID]->m_sY;
		*sp = sY;
		cp += 2;
		sp  = (short *)cp;
		*sp = m_pNpcList[wObjectID]->m_sType;
		cp += 2;
		*cp = m_pNpcList[wObjectID]->m_cDir;
		cp++;
		memcpy(cp, m_pNpcList[wObjectID]->m_cName, 5);
		cp += 5;
		sp  = (short *)cp;
		*sp = m_pNpcList[wObjectID]->m_sAppr2;
		cp += 2;		
		ip  = (int *)cp;	
		iTemp = m_pNpcList[wObjectID]->m_iStatus;
		iTemp = 0x0FFBFFFF & iTemp;//Original : sTemp = 0x0FFF & sTemp;	
		bTransparentInvi = FALSE;	
		iTemp2 = iGetNpcRelationship(wObjectID, iClientH, bTransparentInvi);
		if (bTransparentInvi == TRUE) iTemp = iTemp | 0x00040000;
		iTemp  = (iTemp | (iTemp2 << 28));//Original : 12	
		*ip = iTemp;
		cp += 4;//Original 2
		if (m_pNpcList[wObjectID]->m_bIsKilled == TRUE) // v1.4
			 *cp = 1;
		else *cp = 0;
		cp++;
		iRet = m_pClientList[iClientH]->m_pXSock->iSendMsg(cData, 27); // v1.4 //Original : 25
	}
	switch (iRet) {
	case DEF_XSOCKEVENT_QUENEFULL:
	case DEF_XSOCKEVENT_SOCKETERROR:
	case DEF_XSOCKEVENT_CRITICALERROR:
	case DEF_XSOCKEVENT_SOCKETCLOSED:
		DeleteClient(iClientH, TRUE, TRUE);
		return;
	}
}

int CGame::_iGetArrowItemIndex(int iClientH)
{
 register int i;

	if (m_pClientList[iClientH] == NULL) return -1;

	for (i = 0; i < DEF_MAXITEMS; i++)
	if (m_pClientList[iClientH]->m_pItemList[i] != NULL) {

		// Arrow Â¾Ã†Ã€ÃŒÃ…Ã›Ã€ÃŒ 1Â°Â³ Ã€ÃŒÂ»Ã³ Ã€Ã–Ã€Â¸Â¸Ã© Ã€ÃŽÂµÂ¦Â½Âº Â°ÂªÃ€Â» Â¹ÃÃˆÂ¯Ã‡Ã‘Â´Ã™.
		if ( (m_pClientList[iClientH]->m_pItemList[i]->m_cItemType == DEF_ITEMTYPE_ARROW) &&
			 (m_pClientList[iClientH]->m_pItemList[i]->m_dwCount > 0) )
			return i;	
	}

	return -1;
}
//********************************************************************************
// SNOOPY: Added a variable bDontLog, to prevent double log when selling item    *
//         Default value is FALSE                                                *
//********************************************************************************
void CGame::ItemDepleteHandler(int iClientH, short sItemIndex, BOOL bIsUseItemResult, BOOL bDontLog)
{
	if (m_pClientList[iClientH] == NULL) return;
	if (m_pClientList[iClientH]->m_bIsInitComplete == FALSE) return;
	if ((sItemIndex < 0) || (sItemIndex >= DEF_MAXITEMS)) return;
	if (m_pClientList[iClientH]->m_pItemList[sItemIndex] == NULL) return;
	
	// SNOOPY: Needing more precise log ( Selled items would log twice)
	if (bDontLog != TRUE) _bItemLog(DEF_ITEMLOG_DEPLETE, iClientH, NULL, m_pClientList[iClientH]->m_pItemList[sItemIndex]);

	ReleaseItemHandler(iClientH, sItemIndex, TRUE);
	SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_ITEMDEPLETED_ERASEITEM, sItemIndex, (int)bIsUseItemResult, NULL, NULL);
	delete m_pClientList[iClientH]->m_pItemList[sItemIndex];
	m_pClientList[iClientH]->m_pItemList[sItemIndex] = NULL;
	m_pClientList[iClientH]->m_bIsItemEquipped[sItemIndex] = FALSE;
	m_pClientList[iClientH]->m_cArrowIndex = _iGetArrowItemIndex(iClientH);
	iCalcTotalWeight(iClientH);
}

void CGame::NpcBehavior_Stop(int iNpcH)
{
 char  cTargetType;
 short sTarget = NULL;
 BOOL  bFlag;
	if (m_pNpcList[iNpcH] == NULL) return; 
	m_pNpcList[iNpcH]->m_sBehaviorTurnCount++;
	switch (m_pNpcList[iNpcH]->m_cActionLimit) {
	case 5:		
		switch (m_pNpcList[iNpcH]->m_sType) {
		case 38:// Mana Collector
			// Collects mana 1 / 3times
			if (m_pNpcList[iNpcH]->m_sBehaviorTurnCount >= 3) 
			{	m_pNpcList[iNpcH]->m_sBehaviorTurnCount = 0;
				bFlag = _bNpcBehavior_ManaCollector(iNpcH);
				if (bFlag == TRUE) 
				{	SendEventToNearClient_TypeA(iNpcH, DEF_OWNERTYPE_NPC, MSGID_EVENT_MOTION, DEF_OBJECTATTACK, m_pNpcList[iNpcH]->m_sX, m_pNpcList[iNpcH]->m_sY, 1); 
				}
			}
			break;
		case 39: // Detector
			if (m_pNpcList[iNpcH]->m_sBehaviorTurnCount >= 3) 
			{	m_pNpcList[iNpcH]->m_sBehaviorTurnCount = 0;
				bFlag = _bNpcBehavior_Detector(iNpcH);				
				if (bFlag == TRUE) 
				{	SendEventToNearClient_TypeA(iNpcH, DEF_OWNERTYPE_NPC, MSGID_EVENT_MOTION, DEF_OBJECTATTACK, m_pNpcList[iNpcH]->m_sX, m_pNpcList[iNpcH]->m_sY, 1); 
				}
			}
			break;
		case 40: // Energy Shield Generator
			break;
		case 41: // Grand Magic Generator
			if (m_pNpcList[iNpcH]->m_sBehaviorTurnCount >= 3) {
				m_pNpcList[iNpcH]->m_sBehaviorTurnCount = 0;
				_NpcBehavior_GrandMagicGenerator(iNpcH);
			}
			break;
		case 42: // ManaStone: v2.05 
			// Increase mana by 5  everytime
			m_pNpcList[iNpcH]->m_sBehaviorTurnCount = 0;
			m_pNpcList[iNpcH]->m_iV1 += 10;
			if (m_pNpcList[iNpcH]->m_iV1 >= 100) m_pNpcList[iNpcH]->m_iV1 = 100;
			break;

		//case 87: // CT (Crossbow Turret)  Helnenian bases
		case 89: // AGC (Ancient Grand Cannon)	will turn as detectors	
			if (   (m_bIsHeldenianMode == TRUE) 
				&& (m_bHeldenianWarInitiated == FALSE))
			{	if (m_pNpcList[iNpcH]->m_sBehaviorTurnCount >= 3) 
				{	m_pNpcList[iNpcH]->m_sBehaviorTurnCount = 0;
					bFlag = _bNpcBehavior_Detector(iNpcH);				
					if (bFlag == TRUE) 
					{	SendEventToNearClient_TypeA(iNpcH, DEF_OWNERTYPE_NPC, MSGID_EVENT_MOTION, DEF_OBJECTATTACK, m_pNpcList[iNpcH]->m_sX, m_pNpcList[iNpcH]->m_sY, 1); 
			}	}	}
			break;
		default: 
			TargetSearch(iNpcH, &sTarget, &cTargetType);				
			break;
		}
		break;
	}	
	if ((sTarget != NULL)) 
	{	m_pNpcList[iNpcH]->m_cBehavior          = DEF_BEHAVIOR_ATTACK;
		m_pNpcList[iNpcH]->m_sBehaviorTurnCount = 0;		
		m_pNpcList[iNpcH]->m_iTargetIndex = sTarget;
		m_pNpcList[iNpcH]->m_cTargetType  = cTargetType;
		return;
	}
}

void CGame::UseItemHandler(int iClientH, short sItemIndex, short dX, short dY, short sDestItemID, DWORD dwMsgTime)
{int iMax, iV1, iV2, iV3, iV4, iSEV1, iEffectResult = 0;
 DWORD dwTime, dwGUID;
 short sTemp, sTmpType, sTmpAppr1;
 char cSlateType[20];
 BOOL bDepleteNow = TRUE;	
 int iMapIndex;
 // SNOOPY: Added for suppport of ZEM life information
 char cInfoString[500];

	dwTime = timeGetTime();
	ZeroMemory(cSlateType,sizeof(cSlateType));

	if (m_pClientList[iClientH] == NULL) return;
	if (m_pClientList[iClientH]->m_bIsKilled == TRUE) return;
	if (m_pClientList[iClientH]->m_bIsInitComplete == FALSE) return;
	iMapIndex = m_pClientList[iClientH]->m_cMapIndex;
	if (iMapIndex < 0) return;

	if ((sItemIndex < 0) || (sItemIndex >= DEF_MAXITEMS)) return;
	if (m_pClientList[iClientH]->m_pItemList[sItemIndex] == NULL) return;

	// If item is personal, do not allow anybody else to use it.
	if (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sTouchEffectType == DEF_ITET_UNIQUE_OWNER)
	{	if (   (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sTouchEffectValue1 == m_pClientList[iClientH]->m_sCharIDnum1) 
			&& (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sTouchEffectValue2 == m_pClientList[iClientH]->m_sCharIDnum2) 
			&& (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sTouchEffectValue3 == m_pClientList[iClientH]->m_sCharIDnum3) ) 
		{}else 
		{	ItemDepleteHandler(iClientH, sItemIndex, TRUE); 
			return;	
	}	}
	if (   (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cItemType == DEF_ITEMTYPE_USE_DEPLETE)	// 3
		|| (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cItemType == DEF_ITEMTYPE_USE_PERM)		// 9 
		|| (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cItemType == DEF_ITEMTYPE_ARROW) 
		|| (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cItemType == DEF_ITEMTYPE_EAT) 
		|| (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cItemType == DEF_ITEMTYPE_USE_SKILL) 
		|| (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cItemType == DEF_ITEMTYPE_USE_DEPLETE_DEST))
	{}else return; 	
	if (    (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cItemType == DEF_ITEMTYPE_USE_DEPLETE) 
		 || (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cItemType == DEF_ITEMTYPE_EAT)) 	
	{	// Snoopy: Add Hack detection here...
		if (  (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectType == DEF_ITEMEFFECTTYPE_HP)
			||(m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectType == DEF_ITEMEFFECTTYPE_MP))
		{	// Check potion drinking speed
			if (m_pClientList[iClientH]->m_dwPopoLATS == 0) 
			{	m_pClientList[iClientH]->m_dwPopoLATS  = dwMsgTime;
				m_pClientList[iClientH]->m_iPopoCount  = 0;
				m_pClientList[iClientH]->m_iPopoTotalS = 0;
			}else 
			{	// over 2 seconds delay, reset  // Over 6 potions reset
				if (   ((dwMsgTime - m_pClientList[iClientH]->m_dwPopoLATS) > 2000)
					|| (m_pClientList[iClientH]->m_iPopoCount > 5))
				{	m_pClientList[iClientH]->m_dwPopoLATS  = 0;
				}else
				{	m_pClientList[iClientH]->m_iPopoTotalS += (dwMsgTime - m_pClientList[iClientH]->m_dwPopoLATS);
					m_pClientList[iClientH]->m_iPopoCount  += 1;
					m_pClientList[iClientH]->m_dwPopoLATS = dwMsgTime;
					// Monitoring: Show all popoton gaps...( huge file !)
					if (m_pClientList[iClientH]->m_bMonitorThisChar)
					{	wsprintf(G_cTxt, "Potion drink:  PC(%s) - Drink average delay:%dms (%d Potions). \tIP(%s)"				
							, m_pClientList[iClientH]->m_cCharName
							, (m_pClientList[iClientH]->m_iPopoTotalS / m_pClientList[iClientH]->m_iPopoCount)
							, m_pClientList[iClientH]->m_iPopoCount
							, m_pClientList[iClientH]->m_cIPaddress);
						PutMonitorLogFileList(G_cTxt);
					}
					// Detect fast drinking +- 285ms detect below 240 ms average on 6 checks
					if (   (m_pClientList[iClientH]->m_iPopoCount >2)
						&& ((m_pClientList[iClientH]->m_iPopoTotalS / m_pClientList[iClientH]->m_iPopoCount) < (180 + 10*m_pClientList[iClientH]->m_iPopoCount)))
					{	wsprintf(G_cTxt, "Potion drink:  PC(%s) - Drink average delay: %dms. \tIP(%s)"				
							, m_pClientList[iClientH]->m_cCharName
							, (m_pClientList[iClientH]->m_iPopoTotalS / m_pClientList[iClientH]->m_iPopoCount)
							, m_pClientList[iClientH]->m_cIPaddress);
						PutHackLogFileList(G_cTxt);
						if (m_pClientList[iClientH]->m_bMonitorThisChar) PutMonitorLogFileList(G_cTxt);
						else 
						{	ItemDepleteHandler(iClientH, sItemIndex, TRUE); 
							return; // popo -> no effect !
		}	}	}	}	}
		// Scroll delay Hack detection
		if (   (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sSprite == 6) 
			&& (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sSpriteFrame == 9)
			&& ((dwMsgTime - m_pClientList[iClientH]->m_dwLastDamageTime) < (10*1000)) 			
			&& ((dwMsgTime - m_pClientList[iClientH]->m_dwLastDamageTime) > 1200)) //(max possible ping...			
		{	wsprintf(G_cTxt, "Scroll delay:  PC(%s) - Uses scroll %dms after taking damage. \tIP(%s)"				
				, m_pClientList[iClientH]->m_cCharName
				, dwMsgTime - m_pClientList[iClientH]->m_dwLastDamageTime
				, m_pClientList[iClientH]->m_cIPaddress);
			PutHackLogFileList(G_cTxt);	
			ItemDepleteHandler(iClientH, sItemIndex, TRUE); 
			return;
		}		

		switch (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectType) {
		case DEF_ITEMEFFECTTYPE_WARM:
			if (m_pClientList[iClientH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_ICE ] == 1) 
			{	bRemoveFromDelayEventList(iClientH, DEF_OWNERTYPE_PLAYER, DEF_MAGICTYPE_ICE);
				bRegisterDelayEvent(DEF_DELAYEVENTTYPE_MAGICRELEASE, DEF_MAGICTYPE_ICE, dwTime + (1*1000), 
							                iClientH, DEF_OWNERTYPE_PLAYER, NULL, NULL, NULL, 1, NULL, NULL);	
			}
			m_pClientList[iClientH]->m_dwWarmEffectTime = dwTime;
			break;

		case DEF_ITEMEFFECTTYPE_LOTTERY:
			switch (iDice(1,12)) {
			case 1:		// HP	
				m_pClientList[iClientH]->m_iHP = iGetMaxHP(iClientH, FALSE);
				iEffectResult = 1;
				break;
			case 2:		// MP
				m_pClientList[iClientH]->m_iMP = iGetMaxMP(iClientH); 
				iEffectResult = 2;
				break;
			case 3:		// SP
				m_pClientList[iClientH]->m_iSP = iGetMaxSP(iClientH); 
				iEffectResult = 3;
				break;
			case 4:		// Food
				m_pClientList[iClientH]->m_iHPstock = 500;
				m_pClientList[iClientH]->m_iHungerStatus = 100;
				break;
			case 5:		// recall
				ItemDepleteHandler(iClientH, sItemIndex, TRUE);
				RequestTeleportHandler(iClientH, "1   ");
				break;
			case 6:		// Invisibility
				PlayerMagicHandler(iClientH, m_pClientList[iClientH]->m_sX, m_pClientList[iClientH]->m_sY, 32, TRUE, -1);// -1 allows using with weapon shield equiped 
				break;
			case 7:		// summon WW 
				PlayerMagicHandler(iClientH, m_pClientList[iClientH]->m_sX, m_pClientList[iClientH]->m_sY, 31, TRUE, -15); // Negative value enables to use with weapon shield equiped  	         
				break;
			case 8: 	// Trance 
				PlayerMagicHandler(iClientH, m_pClientList[iClientH]->m_sX, m_pClientList[iClientH]->m_sY, 75, TRUE, -1);// -1 allows using with weapon shield equiped 	    	         
				break;
			case 9: 	// PFM 
				PlayerMagicHandler(iClientH, m_pClientList[iClientH]->m_sX, m_pClientList[iClientH]->m_sY, 33, TRUE, -1);// -1 allows using with weapon shield equiped 	    	         
				break;
			case 10:	// PFA 
				PlayerMagicHandler(iClientH, m_pClientList[iClientH]->m_sX, m_pClientList[iClientH]->m_sY, 24, TRUE, -1);// -1 allows using with weapon shield equiped 	    	         
				break;
			case 11:	// Abaddon Fury, will damage all on map, but attract all mobs as well 
				PlayerMagicHandler(iClientH, m_pClientList[iClientH]->m_sX, m_pClientList[iClientH]->m_sY,  4, TRUE, -1);// -1 allows using with weapon shield equiped
				break;
			case 12:	// TP Bisle
				ItemDepleteHandler(iClientH, sItemIndex, TRUE);
				RequestTeleportHandler(iClientH, "3   ", "bisle", -1, -1);
				break;
			default:
				break;
			}
			break;

		case DEF_ITEMEFFECTTYPE_SLATES:
			if (m_pClientList[iClientH]->m_pItemList[sItemIndex] != NULL) 
			{	// Full Ancient Slate ??
				if (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sIDnum == 867) 
				{	// Slates dont work on Heldenian Map if Heldenian running 				
					if (   (m_bIsHeldenianMode == TRUE) 
						&& (m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_bIsHeldenianMap == TRUE)) 						
					{	ZeroMemory(cInfoString,  sizeof(cInfoString));	
						wsprintf(cInfoString, "Heldenian map, usage fordidden.");
						ShowClientMsg(iClientH, "Anc.Slate", cInfoString ); 
						return;	
					}
					if (m_bIsCrusadeMode == TRUE) 		
					{	ZeroMemory(cInfoString,  sizeof(cInfoString));	
						wsprintf(cInfoString, "Crusade in progress, usage fordidden.");
						ShowClientMsg(iClientH, "Anc.Slate", cInfoString ); 
						return;	
					}
					if (   ( m_bIsAvatarMode == TRUE) 	// The Avatar is running..
						&& (m_pClientList[iClientH]->m_cMapIndex == m_iPLmapIndex)) 	
					{	ZeroMemory(cInfoString,  sizeof(cInfoString));	
						wsprintf(cInfoString, "Avatar in progress, usage fordidden.");
						ShowClientMsg(iClientH, "Anc.Slate", cInfoString ); 
						return;		
					}
					switch (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemSpecEffectValue2){
					case 1: // Invincible slate rouge
						strcpy(cSlateType, "Invincible");
						iEffectResult = 4;
						break;
					case 2: // Bezerk slate jaune
						m_pClientList[iClientH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_BERSERK ] = 20; //+200% Damage!
						SetBerserkFlag(iClientH, DEF_OWNERTYPE_PLAYER, TRUE);
						bRegisterDelayEvent(DEF_DELAYEVENTTYPE_MAGICRELEASE, DEF_MAGICTYPE_BERSERK, dwTime + (1000 * 600),
							iClientH, DEF_OWNERTYPE_PLAYER, NULL, NULL, NULL, 1, NULL, NULL);
						SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_MAGICEFFECTON, DEF_MAGICTYPE_BERSERK, 1, NULL, NULL);
						strcpy(cSlateType, "Berserk");
						break;
					case 3: // Mana slate bleue
						strcpy(cSlateType, "Mana");
						iEffectResult = 5;
						break;
					case 4: // Exp slate verte
						strcpy(cSlateType, "Exp");
						iEffectResult = 6;
						break;
					case 5: // Full crits Slate noire
						strcpy(cSlateType, "Full Crits");
						m_pClientList[iClientH]->m_iSuperAttackLeft = m_pClientList[iClientH]->m_iLevel / 10;
						m_pClientList[iClientH]->m_iHP = iGetMaxHP(iClientH, FALSE);
						m_pClientList[iClientH]->m_iMP = iGetMaxMP(iClientH);
						m_pClientList[iClientH]->m_iSP = iGetMaxSP(iClientH);
						m_pClientList[iClientH]->m_iHungerStatus = 100;
						m_pClientList[iClientH]->m_iHPstock = 500;
						ZeroMemory(cInfoString,  sizeof(cInfoString));	
						wsprintf(cInfoString, "HP, MP and Crits restored.");
						ShowClientMsg(iClientH,  "Slate", cInfoString);	
						iEffectResult = 8;
						break;
					default:	
						strcpy(cSlateType, "Unknown");
						break;
					}
					if (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemSpecEffectValue2 != 5)
					{	SetSlateFlag(iClientH, m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemSpecEffectValue2, TRUE);
						bRegisterDelayEvent(DEF_DELAYEVENTTYPE_ANCIENT_TABLET, m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemSpecEffectValue2, 
								dwTime + (1000 * 600), iClientH, DEF_OWNERTYPE_PLAYER, NULL, NULL, NULL, 1, NULL, NULL);
					}
					if(strlen(cSlateType) > 0)
					//	_bItemLog(DEF_ITEMLOG_USE, iClientH, strlen(cSlateType), m_pClientList[iClientH]->m_pItemList[sItemIndex]);
					wsprintf(G_cTxt, "PC(%s)\tUses an Ancient tablet (type %d).\t%s(%d %d)\tIP(%s)"
						, m_pClientList[iClientH]->m_cCharName
						, cSlateType
						, m_pClientList[iClientH]->m_cMapName
						, m_pClientList[iClientH]->m_sX
						, m_pClientList[iClientH]->m_sY
						, m_pClientList[iClientH]->m_cIPaddress);
					PutItemLogFileList(G_cTxt);
					PutLogFileList(G_cTxt);		
			}	}
			break;
		case DEF_ITEMEFFECTTYPE_HP:
			iMax = iGetMaxHP(iClientH, TRUE); // BloodEffect limite le regen			
			if (   (m_pClientList[iClientH]->m_iHP < iMax)
				&& (m_pClientList[iClientH]->m_iHP > 0)
				&& (m_pMapList[iMapIndex]->m_bHpMpSpPopoEnabled == TRUE)) 				
			{	if (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemSpecEffectValue1 == 0) 
				{	iV1 = m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectValue1;
					iV2 = m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectValue2;
					iV3 = m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectValue3;
				}else 
				{	iV1 = m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemSpecEffectValue1;
					iV2 = m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemSpecEffectValue2;
					iV3 = m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemSpecEffectValue3;
				}
				m_pClientList[iClientH]->m_iHP += (iDice(iV1, iV2) + iV3); 
				if (m_pClientList[iClientH]->m_iHP > iMax) m_pClientList[iClientH]->m_iHP = iMax;
				if (m_pClientList[iClientH]->m_iHP <= 0)   m_pClientList[iClientH]->m_iHP = 1;
				iEffectResult = 1;
			}else if (m_pMapList[iMapIndex]->m_bHpMpSpPopoEnabled != TRUE) 	
			{	iEffectResult = 11;
			}
			break;

		case DEF_ITEMEFFECTTYPE_MP:
			iMax = iGetMaxMP(iClientH);
			if (   (m_pClientList[iClientH]->m_iMP < iMax) 
				&& (m_pMapList[iMapIndex]->m_bHpMpSpPopoEnabled == TRUE)) 
			{	if (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemSpecEffectValue1 == 0) 
				{	iV1 = m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectValue1;
					iV2 = m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectValue2;
					iV3 = m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectValue3;
				}else 
				{	iV1 = m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemSpecEffectValue1;
					iV2 = m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemSpecEffectValue2;
					iV3 = m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemSpecEffectValue3;
				}
				m_pClientList[iClientH]->m_iMP += (iDice(iV1, iV2) + iV3); 
				if (m_pClientList[iClientH]->m_iMP > iMax) 
					m_pClientList[iClientH]->m_iMP = iMax;
				iEffectResult = 2;
			}else if (m_pMapList[iMapIndex]->m_bHpMpSpPopoEnabled != TRUE) 	
			{	iEffectResult = 12;
			}
			break;

		case DEF_ITEMEFFECTTYPE_SP:
			iMax = iGetMaxSP(iClientH);	
			if (   (m_pClientList[iClientH]->m_iSP < iMax)
				&& ((m_bIsAvatarMode == FALSE) || (m_iPLmapIndex == -1) || (m_iAvatarMessenger != iClientH)) // Not for Avatar messenger! 
				&& (m_pMapList[iMapIndex]->m_bHpMpSpPopoEnabled == TRUE)) 					
			{	if (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemSpecEffectValue1 == 0) 
				{	iV1 = m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectValue1;
					iV2 = m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectValue2;
					iV3 = m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectValue3;
				}else 
				{	iV1 = m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemSpecEffectValue1;
					iV2 = m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemSpecEffectValue2;
					iV3 = m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemSpecEffectValue3;
				}
				m_pClientList[iClientH]->m_iSP += (iDice(iV1, iV2) + iV3); 
				if (m_pClientList[iClientH]->m_iSP > iMax) 
					m_pClientList[iClientH]->m_iSP = iMax;
				iEffectResult = 3;
			}else if (m_pMapList[iMapIndex]->m_bHpMpSpPopoEnabled != TRUE) 
			{	iEffectResult = 13;		
			}
			if (m_pClientList[iClientH]->m_bIsPoisoned == TRUE) {
				m_pClientList[iClientH]->m_bIsPoisoned = FALSE;
				SetPoisonFlag(iClientH, DEF_OWNERTYPE_PLAYER, FALSE); 
				// removes poison aura when using a revitalizing potion
				SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_MAGICEFFECTOFF, DEF_MAGICTYPE_POISON, NULL, NULL, NULL);
			}
			break;

		case DEF_ITEMEFFECTTYPE_CRIT:
			iMax = m_pClientList[iClientH]->m_iLevel / 10;
			if (m_pClientList[iClientH]->m_iSuperAttackLeft < iMax) m_pClientList[iClientH]->m_iSuperAttackLeft += 1;
			iEffectResult = 7;
			break;

		case DEF_ITEMEFFECTTYPE_HPSTOCK:
			iV1 = m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectValue1;
			iV2 = m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectValue2;
			iV3 = m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectValue3;
		
			m_pClientList[iClientH]->m_iHPstock += iDice(iV1, iV2) + iV3;
			if (m_pClientList[iClientH]->m_iHPstock < 0)   m_pClientList[iClientH]->m_iHPstock = 0;
			if (m_pClientList[iClientH]->m_iHPstock > 500) m_pClientList[iClientH]->m_iHPstock = 500;

			m_pClientList[iClientH]->m_iHungerStatus += iDice(iV1, iV2) + iV3;
			if (m_pClientList[iClientH]->m_iHungerStatus > 100) m_pClientList[iClientH]->m_iHungerStatus = 100;
			if (m_pClientList[iClientH]->m_iHungerStatus < 0)   m_pClientList[iClientH]->m_iHungerStatus = 0;
			break;

		case DEF_ITEMEFFECTTYPE_STUDYSKILL:
			iV1 = m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectValue1;
			iV2 = m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectValue2;
			iV3 = m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectValue3;
			iV4 = m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectValue4;
			iSEV1 = m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemSpecEffectValue1;			
			if (iV3 == 0) // Train a skill to Stated value
			{	if (iSEV1 == 0) 
				{	TrainSkillResponse(TRUE, iClientH, iV1, iV2);
				}else 
				{	TrainSkillResponse(TRUE, iClientH, iV1, iSEV1);
				}
			}else // Train Skill by XXX points 
			{	if (   (m_pClientList[iClientH]->m_cSkillMastery[iV1] >= iV2)  //1V2 Min skill for trainning more
					&& (m_pClientList[iClientH]->m_cSkillMastery[iV1] <= iV4)) //iV4 Max Skill to train more
				{	TrainSkillResponse(FALSE, iClientH, iV1, iV3);
			}	}
			break;

		case DEF_ITEMEFFECTTYPE_STUDYMAGIC:
			iV1 = m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectValue1;
			if (m_pMagicConfigList[iV1] != NULL) 
			{	RequestStudyMagicHandler(iClientH, m_pMagicConfigList[iV1]->m_cName, bDepleteNow, FALSE);
				if (bDepleteNow == TRUE) 	// SNOOPY: Added Logging here
					_bItemLog(DEF_ITEMLOG_MAGICLEARN,iClientH,m_pMagicConfigList[iV1]->m_cName,NULL);
			}
			break;

		case DEF_ITEMEFFECTTYPE_MAGIC:
			// Using scroll -> you become visible.
			if ( (m_pClientList[iClientH]->m_iStatus & 0x10) != 0 ) 
			{	if (m_pClientList[iClientH]->m_iAdminUserLevel == 0) 
				{	SetInvisibilityFlag(iClientH, DEF_OWNERTYPE_PLAYER, FALSE);				
					bRemoveFromDelayEventList(iClientH, DEF_OWNERTYPE_PLAYER, DEF_MAGICTYPE_INVISIBILITY);
					m_pClientList[ iClientH ]->m_cMagicEffectStatus[ DEF_MAGICTYPE_INVISIBILITY ] = NULL;
			}	}
			switch (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectValue1) {
			case 1:// Magic = Recall 
				ItemDepleteHandler(iClientH, sItemIndex, TRUE);
				RequestTeleportHandler(iClientH, "1   ");
				break;

			case 2: // Magic = Invisibility. 
				PlayerMagicHandler(iClientH, m_pClientList[iClientH]->m_sX, m_pClientList[iClientH]->m_sY, 32, TRUE, m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectValue6);
				break;

			case 3:	// Magic = Detect Invis 
				if (m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_bIsFightZone == FALSE)
					PlayerMagicHandler(iClientH, m_pClientList[iClientH]->m_sX, m_pClientList[iClientH]->m_sY, 34, TRUE, m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectValue6);
				break;

			case 4:	// fixed location teleportation:
				switch (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectValue2) {
				case 1:	// Bleeding Island Ticket
					if (memcmp(m_pClientList[iClientH]->m_cMapName, "bisle", 5) != 0) {
						ItemDepleteHandler(iClientH, sItemIndex, TRUE);
						RequestTeleportHandler(iClientH, "3   ", "bisle", -1, -1);
					}
					break;
// SNOOPY: new possible TP scolls
				case 3: // TP to Temple, depending on religion
					if (m_pClientList[iClientH]->m_cSide == 2) 
					{	ItemDepleteHandler(iClientH, sItemIndex, TRUE);
						RequestTeleportHandler(iClientH, "3   ", "cath_2", -1, -1);
					}
					if (m_pClientList[iClientH]->m_cSide == 1) 
					{	ItemDepleteHandler(iClientH, sItemIndex, TRUE);
						RequestTeleportHandler(iClientH, "3   ", "cath_1", -1, -1);									
					}	
					break;
				case 4: // TP to Equilibrium
					if ((memcmp(m_pClientList[iClientH]->m_cMapName, "lost", 4) != 0) && (m_bMapModeEquilibrium)) {
						ItemDepleteHandler(iClientH, sItemIndex, TRUE);
						RequestTeleportHandler(iClientH, "3   ", "lost", -1, -1);
					}
					break;					
				case 11:	
				case 12:
				case 13:
				case 14:
				case 15:
				case 16:
				case 17:
				case 18:
				case 19:	// Arena tickets
					SYSTEMTIME SysTime;
					GetLocalTime(&SysTime);
					if (   (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sTouchEffectValue1 != SysTime.wMonth) 
						|| (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sTouchEffectValue2 != SysTime.wDay) 
						|| (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sTouchEffectValue3 <= SysTime.wHour) ) 
					{}else 
					{	char cDestMapName[11];
						ZeroMemory(cDestMapName, sizeof(cDestMapName));
						wsprintf(cDestMapName, "fightzone%d", m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectValue2 - 10);
						if (memcmp(m_pClientList[iClientH]->m_cMapName, cDestMapName, 10) != 0) 
						{	ItemDepleteHandler(iClientH, sItemIndex, TRUE);
							RequestTeleportHandler(iClientH, "3   ", cDestMapName, -1, -1);
					}	}
					break;
				}
				break;

			case 5: // summon effects        NB: Heldenians scroll must be defined as DEF_ITEMTYPE_USE_PERM
				if (   (m_bIsHeldenianMode == TRUE)
					&& (m_pMapList[m_pClientList[iClientH]->m_cMapIndex] != 0) 
					&& (m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_bIsHeldenianMap == 1))
				{	ItemDepleteHandler(iClientH, sItemIndex, TRUE);// On Heldenian map summon is not possible
					return; // No "normal" summons at Heldenian events
				}
				if (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectValue6 == -1) // -1 allows using with weapon shield equiped
				PlayerMagicHandler(iClientH, m_pClientList[iClientH]->m_sX, m_pClientList[iClientH]->m_sY, 31, TRUE,
					m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectValue2 * -1);
				else
				PlayerMagicHandler(iClientH, m_pClientList[iClientH]->m_sX, m_pClientList[iClientH]->m_sY, 31, TRUE,
					m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectValue2); 	 
				break;
			case 6:	// Berzerk 
				PlayerMagicHandler(iClientH, m_pClientList[iClientH]->m_sX, m_pClientList[iClientH]->m_sY, 50, TRUE
					, m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectValue6);// -1 allows using with weapon shield equiped 	    	         
				break;
			case 7:	// PFM 
				PlayerMagicHandler(iClientH, m_pClientList[iClientH]->m_sX, m_pClientList[iClientH]->m_sY, 33, TRUE
					, m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectValue6);// -1 allows using with weapon shield equiped 	    	         
				break;
			case 8:	// PFA 
				PlayerMagicHandler(iClientH, m_pClientList[iClientH]->m_sX, m_pClientList[iClientH]->m_sY, 24, TRUE
					, m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectValue6);// -1 allows using with weapon shield equiped 	    	         
				break;
			case 0:// Spell by number	
				PlayerMagicHandler(iClientH
					, m_pClientList[iClientH]->m_sX + m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectValue4
					, m_pClientList[iClientH]->m_sY + m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectValue5
					, m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectValue2, TRUE
					, m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectValue6);// -1 allows using with weapon shield equiped
				break;	
			case 31:// Beholder		( NB: Using the item makes you visible. )		
				if (m_pClientList[iClientH]->m_iBeholderPower == 0) // excludes GMs or inactivated necks (Neck are not active if you're invi)
				{	m_pClientList[iClientH]->m_iBeholderPower = m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectValue2 + 1;   	         
					SendNewInitMapData(iClientH);
				}
				break;			
			default:
				break;
			}
			break;

		case DEF_ITEMEFFECTTYPE_FIRMSTAMINAR:
			if ((m_bIsAvatarMode == TRUE) && (m_iPLmapIndex != -1) && (m_iAvatarMessenger == iClientH))
			{	m_pClientList[iClientH]->m_iTimeLeft_FirmStaminar = 0; // Not for Avatar messenger! 
			}else
			{	m_pClientList[iClientH]->m_iTimeLeft_FirmStaminar += m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectValue1;
				if (m_pClientList[iClientH]->m_iTimeLeft_FirmStaminar > 20*30) m_pClientList[iClientH]->m_iTimeLeft_FirmStaminar = 20*30; 
			}
			break;

		case DEF_ITEMEFFECTTYPE_CHANGEATTR:
			switch (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectValue1) {
			case 1:	// Hair color popo
				m_pClientList[iClientH]->m_cHairColor++;
				if (m_pClientList[iClientH]->m_cHairColor > 15) m_pClientList[iClientH]->m_cHairColor = 0;
				sTemp = (m_pClientList[iClientH]->m_cHairStyle << 8) | (m_pClientList[iClientH]->m_cHairColor << 4) | (m_pClientList[iClientH]->m_cUnderwear);
				m_pClientList[iClientH]->m_sAppr1 = sTemp;
				break;

			case 2: // Hair style popo
				m_pClientList[iClientH]->m_cHairStyle++;
				if (m_pClientList[iClientH]->m_cHairStyle > 7) m_pClientList[iClientH]->m_cHairStyle = 0;
				sTemp = (m_pClientList[iClientH]->m_cHairStyle << 8) | (m_pClientList[iClientH]->m_cHairColor << 4) | (m_pClientList[iClientH]->m_cUnderwear);
				m_pClientList[iClientH]->m_sAppr1 = sTemp;
				break;

			case 3: // Skin color
				m_pClientList[iClientH]->m_cSkin++;
				if (m_pClientList[iClientH]->m_cSkin > 3)
					m_pClientList[iClientH]->m_cSkin = 1;				
				if (m_pClientList[iClientH]->m_cSex == 1)      sTemp = 1;
				else if (m_pClientList[iClientH]->m_cSex == 2) sTemp = 4; 				
				switch (m_pClientList[iClientH]->m_cSkin) {
				case 2:	sTemp += 1; break;
				case 3:	sTemp += 2; break;
				}
				m_pClientList[iClientH]->m_sType  = sTemp;
				break;

			case 4:	// Sex change
				sTemp = m_pClientList[iClientH]->m_sAppr3 & 0xFF0F;
				if (sTemp == 0) 
				{	if (m_pClientList[iClientH]->m_cSex == 1) 
						 m_pClientList[iClientH]->m_cSex = 2;
					else m_pClientList[iClientH]->m_cSex = 1;

					if (m_pClientList[iClientH]->m_cSex == 1) 
					{	sTmpType = 1;
					}else if (m_pClientList[iClientH]->m_cSex == 2) 
					{	sTmpType = 4; 
					}
					switch (m_pClientList[iClientH]->m_cSkin) {
					case 1: break;
					case 2: sTmpType += 1; break;
					case 3: sTmpType += 2; break;
					}
					sTmpAppr1 = (m_pClientList[iClientH]->m_cHairStyle << 8) | (m_pClientList[iClientH]->m_cHairColor << 4) | (m_pClientList[iClientH]->m_cUnderwear);
					m_pClientList[iClientH]->m_sType  = sTmpType;
					m_pClientList[iClientH]->m_sAppr1 = sTmpAppr1; 
				}
				break;
			}
			SendEventToNearClient_TypeA(iClientH, DEF_OWNERTYPE_PLAYER, MSGID_EVENT_MOTION, DEF_OBJECTNULLACTION, NULL, NULL, NULL);
			break;
		}
		//SNOOPY: Request Teleport Handler may send character to another server, 
		//        so the client will be deleted and saved before Deplating the recall scroll
		if (bDepleteNow == TRUE)
			ItemDepleteHandler(iClientH, sItemIndex, TRUE);
		
		switch (iEffectResult) {
		case 1:
			SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_HP, NULL, NULL, NULL, NULL);
			break;
		case 2:
			SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_MP, NULL, NULL, NULL, NULL);
			break;
		case 3:
			SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_SP, NULL, NULL, NULL, NULL);
			break;
		case 4: // Invincible
			SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_SLATE_INVINCIBLE, NULL, NULL, NULL, NULL);
			break;
		case 5: // Mana
			SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_SLATE_MANA, NULL, NULL, NULL, NULL);
			break;
		case 6: // EXP
			SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_SLATE_EXP, NULL, NULL, NULL, NULL);
			break;
		case 7: // Add critical
			SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_SUPERATTACKLEFT, NULL, NULL, NULL, NULL);
			break;
		case 8: // BlackSlate
			SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_SUPERATTACKLEFT, NULL, NULL, NULL, NULL);
			SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_HP, NULL, NULL, NULL, NULL);
			SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_MP, NULL, NULL, NULL, NULL);
			SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_SP, NULL, NULL, NULL, NULL);
			break;
		case 11: // HPup forbidden			
			ZeroMemory(cInfoString,  sizeof(cInfoString));	
			wsprintf(cInfoString, "HP potion usage forbidden.");
			ShowClientMsg(iClientH,  "Special", cInfoString);	
			//SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_IPACCOUNTINFO, NULL, NULL, NULL, cInfoString);
			break;
		case 12: // MPup forbidden			
			ZeroMemory(cInfoString,  sizeof(cInfoString));	
			wsprintf(cInfoString, "MP potion usage forbidden.");
			ShowClientMsg(iClientH,  "Special", cInfoString);	
			//SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_IPACCOUNTINFO, NULL, NULL, NULL, cInfoString);
			break;
		case 13: // SPup forbidden			
			ZeroMemory(cInfoString,  sizeof(cInfoString));	
			wsprintf(cInfoString, "SP potion usage forbidden.");
			ShowClientMsg(iClientH,  "Special", cInfoString);	
			//SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_IPACCOUNTINFO, NULL, NULL, NULL, cInfoString);
			break;
		default:
			break;
		}
	}else if (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cItemType == DEF_ITEMTYPE_USE_DEPLETE_DEST) 
	{	if (_bDepleteDestTypeItemUseEffect(iClientH, dX, dY, sItemIndex, sDestItemID) == TRUE) 
			ItemDepleteHandler(iClientH, sItemIndex, TRUE); 
	}else if (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cItemType == DEF_ITEMTYPE_ARROW) 
	{	m_pClientList[iClientH]->m_cArrowIndex = _iGetArrowItemIndex(iClientH);
	}else if (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cItemType == DEF_ITEMTYPE_USE_PERM) 
	{	switch (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectType) {
		case DEF_ITEMEFFECTTYPE_SHOWLOCATION:
			iV1 = m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectValue1;
			switch (iV1) {
			case 1:	// Map in character bag
				if (strcmp(m_pClientList[iClientH]->m_cMapName, "aresden") == 0)
					SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_SHOWMAP, iV1, 1, NULL, NULL);
				else if (strcmp(m_pClientList[iClientH]->m_cMapName, "elvine") == 0)
					SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_SHOWMAP, iV1, 2, NULL, NULL);
				else if (strcmp(m_pClientList[iClientH]->m_cMapName, "middleland") == 0)
					 SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_SHOWMAP, iV1, 3, NULL, NULL);
				else if (strcmp(m_pClientList[iClientH]->m_cMapName, "default") == 0)
					 SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_SHOWMAP, iV1, 4, NULL, NULL);	
				else if (strcmp(m_pClientList[iClientH]->m_cMapName, "huntzone2") == 0)
					 SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_SHOWMAP, iV1, 5, NULL, NULL);
				else if (strcmp(m_pClientList[iClientH]->m_cMapName, "huntzone1") == 0)
					 SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_SHOWMAP, iV1, 6, NULL, NULL);
				else if (strcmp(m_pClientList[iClientH]->m_cMapName, "huntzone4") == 0)
					 SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_SHOWMAP, iV1, 7, NULL, NULL);
				else if (strcmp(m_pClientList[iClientH]->m_cMapName, "huntzone3") == 0)
					 SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_SHOWMAP, iV1, 8, NULL, NULL);
				else if (strcmp(m_pClientList[iClientH]->m_cMapName, "arefarm") == 0)
					 SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_SHOWMAP, iV1, 9, NULL, NULL);
				else if (strcmp(m_pClientList[iClientH]->m_cMapName, "elvfarm") == 0)
					 SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_SHOWMAP, iV1, 10, NULL, NULL);
				else SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_SHOWMAP, iV1, 0, NULL, NULL);
				break;
			}
			break;		

		case DEF_ITEMEFFECTTYPE_ALTERITEMDROP:// SNOOPY: Added support to show ZEMStone remaining life
			ZeroMemory(cInfoString,  sizeof(cInfoString));	
			wsprintf(cInfoString, "%s, your ZemStone is %d/3."
					, m_pClientList[iClientH]->m_cCharName
					, m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_wCurLifeSpan);
			SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_IPACCOUNTINFO, NULL, NULL, NULL, cInfoString);
			ZeroMemory(cInfoString, sizeof(cInfoString));
			break;

		case DEF_ITEMEFFECTTYPE_EVENT_ITEMDROP:// SNOOPY: Added support to show Token item creation date
			ZeroMemory(cInfoString,  sizeof(cInfoString));	
			wsprintf(cInfoString, "%s, your Token's date is %d/%d, %dh."
					, m_pClientList[iClientH]->m_cCharName
					, m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sTouchEffectValue1
					, m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sTouchEffectValue2
					, m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sTouchEffectValue3);
			SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_IPACCOUNTINFO, NULL, NULL, NULL, cInfoString);
			ZeroMemory(cInfoString, sizeof(cInfoString));
			break;

		case DEF_ITEMEFFECTTYPE_BOMB:
			bRegisterDelayEvent(  DEF_DELAYEVENTTYPE_DAMAGEOBJECT
				, 0 //iEffectType (Spell n°)
				, dwTime + (100*m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectValue1) //dwLastTime
				, iClientH // iTargetH
				, DEF_OWNERTYPE_PLAYER // cTargetType
				, m_pClientList[iClientH]->m_cMapIndex // cMapIndex
				, m_pClientList[iClientH]->m_sX, m_pClientList[iClientH]->m_sY, 0, 0, 0);
			m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sSpriteFrame += 1;
			DropItemHandler(iClientH, sItemIndex, -1, m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cName, TRUE);
			break;

		case DEF_ITEMEFFECTTYPE_MAGIC: // Here for scrolls that be be depleted or not depending conditions
			// Using scroll -> you become visible.
			if ( (m_pClientList[iClientH]->m_iStatus & 0x10) != 0 ) 
			{	if (m_pClientList[iClientH]->m_iAdminUserLevel == 0) 
				{	SetInvisibilityFlag(iClientH, DEF_OWNERTYPE_PLAYER, FALSE);				
					bRemoveFromDelayEventList(iClientH, DEF_OWNERTYPE_PLAYER, DEF_MAGICTYPE_INVISIBILITY);
					m_pClientList[ iClientH ]->m_cMagicEffectStatus[ DEF_MAGICTYPE_INVISIBILITY ] = NULL;
			}	}
			switch (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectValue1) {
			case 1: // Magic = Eternal Recall scrolls
				RequestTeleportHandler(iClientH, "1   ");			
				break;

			case 2: // Magic = Eternal invi scroll Invisibility. 
				PlayerMagicHandler(iClientH, m_pClientList[iClientH]->m_sX, m_pClientList[iClientH]->m_sY, 32, TRUE, m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectValue6);
				break;

			case 3:	// Magic = Eternal Detect Invis scroll
				if (m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_bIsFightZone == FALSE)
					PlayerMagicHandler(iClientH, m_pClientList[iClientH]->m_sX, m_pClientList[iClientH]->m_sY, 34, TRUE, m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectValue6);
				break;

			case 4:	// fixed location teleportation:
				switch (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectValue2) {
				case 1:	// Bleeding Island Ticket
					if (memcmp(m_pClientList[iClientH]->m_cMapName, "bisle", 5) != 0) 
					{	RequestTeleportHandler(iClientH, "3   ", "bisle", -1, -1);
					}
					break;
				case 3: // TP to Temple, depending on religion
					if (m_pClientList[iClientH]->m_cSide == 2) 
					{	RequestTeleportHandler(iClientH, "3   ", "cath_2", -1, -1);
					}
					if (m_pClientList[iClientH]->m_cSide == 1) 
					{	RequestTeleportHandler(iClientH, "3   ", "cath_1", -1, -1);									
					}	
					break;
				case 4: // TP to Equilibrium
					if ((memcmp(m_pClientList[iClientH]->m_cMapName, "lost", 4) != 0) && (m_bMapModeEquilibrium)) 
					{	RequestTeleportHandler(iClientH, "3   ", "lost", -1, -1);
					}
					break;					
				}
				break;

			case 5: // Heldenians scroll must be defined as DEF_ITEMTYPE_USE_PERM
					// Only Helnenian scrolls can be defined as DEF_ITEMTYPE_USE_PERM 
					// Scrolls not belonging to the user are depleted when entering function 
				if (   (m_bIsHeldenianMode == TRUE)
					&& (m_bHeldenianWarInitiated == TRUE)
					&& (m_pMapList[m_pClientList[iClientH]->m_cMapIndex] != 0) 
					&& (m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_bIsHeldenianMap == 1)
					&& (strcmp(m_pClientList[iClientH]->m_cMapName, "GodH") != 0))
				{	memcpy(&dwGUID, &m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemSpecEffectValue1, 4);					
					if (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sTouchEffectType == DEF_ITET_UNIQUE_OWNER)
					{	if (dwGUID == m_dwHeldenianGUID)
						{	// Scrolls from current Heldenian can summon
							if (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectValue6 == -1)// -1 allows using with weapon shield equiped
								PlayerMagicHandler(iClientH, m_pClientList[iClientH]->m_sX, m_pClientList[iClientH]->m_sY, 31, TRUE,
									m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectValue2); 
							else 
								PlayerMagicHandler(iClientH, m_pClientList[iClientH]->m_sX, m_pClientList[iClientH]->m_sY, 31, TRUE,
									m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectValue2 * -1); 
							m_pClientList[iClientH]->m_iWarContribution   += 300;
							if (m_pClientList[iClientH]->m_iWarContribution > DEF_MAXWARCONTRIBUTION)
								m_pClientList[iClientH]->m_iWarContribution = DEF_MAXWARCONTRIBUTION;
							if (m_pClientList[iClientH]->m_iWarContribution >= 256*128)
								SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_CONSTRUCTIONPOINT, m_pClientList[iClientH]->m_iConstructionPoint, (m_pClientList[iClientH]->m_iWarContribution %(256*128)), 1, NULL);
						}
						// But older scrolls will be depleted without effect!
						ItemDepleteHandler(iClientH, sItemIndex, TRUE);	
					}else
					{	// Not personal scrolls can summon and deplete scroll now
						if (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectValue6 == -1)// -1 allows using with weapon shield equiped
						PlayerMagicHandler(iClientH, m_pClientList[iClientH]->m_sX, m_pClientList[iClientH]->m_sY, 31, TRUE,
							m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectValue2); 
						else 
						PlayerMagicHandler(iClientH, m_pClientList[iClientH]->m_sX, m_pClientList[iClientH]->m_sY, 31, TRUE,
							m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectValue2 * -1); 
						ItemDepleteHandler(iClientH, sItemIndex, TRUE);	
						return;
					}
				}else // No permanent scroll outside Special Heldenian summon scrolls
				{	if (m_bIsHeldenianMode == FALSE) ItemDepleteHandler(iClientH, sItemIndex, TRUE);	
					return;	
				}	 
				break;

			case 6:	// Eternal Berzerk 
				PlayerMagicHandler(iClientH, m_pClientList[iClientH]->m_sX, m_pClientList[iClientH]->m_sY, 50, TRUE
					, m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectValue6);// -1 allows using with weapon shield equiped 	    	         
				break;

			case 7:	//Eternal  PFM 
				PlayerMagicHandler(iClientH, m_pClientList[iClientH]->m_sX, m_pClientList[iClientH]->m_sY, 33, TRUE
					, m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectValue6);// -1 allows using with weapon shield equiped 	    	         
				break;

			case 8:	// Eternal PFA 
				PlayerMagicHandler(iClientH, m_pClientList[iClientH]->m_sX, m_pClientList[iClientH]->m_sY, 24, TRUE
					, m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectValue6);// -1 allows using with weapon shield equiped 	    	         
				break;
			case 0:// Eternal Spell by number	
				PlayerMagicHandler(iClientH
					, m_pClientList[iClientH]->m_sX + m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectValue4
					, m_pClientList[iClientH]->m_sY + m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectValue5
					, m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectValue2, TRUE
					, m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectValue6);// -1 allows using with weapon shield equiped
				break;
			case 31:// Eternal Beholder		( NB: Using the item makes you visible. )		
				if (m_pClientList[iClientH]->m_iBeholderPower == 0) // excludes GMs or inactivated necks (Neck are not active if you're invi)
				{	m_pClientList[iClientH]->m_iBeholderPower = m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectValue2 + 1;   	         
					SendNewInitMapData(iClientH);
				}
				break;					
			default:
				break;
			}
			break;
		}
	}else if (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cItemType == DEF_ITEMTYPE_USE_SKILL) 		
	{	if ( (m_pClientList[iClientH]->m_pItemList[sItemIndex] == NULL) || 
			 (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_wCurLifeSpan <= 0) ||
			 (m_pClientList[iClientH]->m_bSkillUsingStatus[ m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sRelatedSkill ] == TRUE) ) 
		{	return;
		}else 
		{	if ( m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_wMaxLifeSpan != 0 ) 
			{	m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_wCurLifeSpan--;
				if (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_wCurLifeSpan <= 0) 
				{	SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_ITEMLIFESPANEND, DEF_EQUIPPOS_NONE, sItemIndex, NULL, NULL);
				}else 
				{	int iSkillUsingTimeID = (int)timeGetTime();					
					bRegisterDelayEvent(DEF_DELAYEVENTTYPE_USEITEM_SKILL, m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sRelatedSkill, 
			                     dwTime + m_pSkillConfigList[ m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sRelatedSkill ]->m_sValue2*1000, 
								 iClientH, DEF_OWNERTYPE_PLAYER, m_pClientList[iClientH]->m_cMapIndex, dX, dY, 
								 m_pClientList[iClientH]->m_cSkillMastery[ m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sRelatedSkill ], iSkillUsingTimeID, NULL);
					m_pClientList[iClientH]->m_bSkillUsingStatus[ m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sRelatedSkill ] = TRUE;
					m_pClientList[iClientH]->m_iSkillUsingTimeID[ m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sRelatedSkill ] = iSkillUsingTimeID; //v1.12
	}	}	}	}
}

void CGame::Effect_ManaDown_Spot(short sAttackerH, char cAttackerType, short sTargetH, char cTargetType, short sV1, short sV2, short sV3, BOOL bExp, int iAttr)
{
 int iPartyID, iDamage;
 char cAttackerSide;
 DWORD dwTime;

 	if (cAttackerType == DEF_OWNERTYPE_PLAYER)
		if (m_pClientList[sAttackerH] == NULL) return;

	if (cAttackerType == DEF_OWNERTYPE_NPC)
		if (m_pNpcList[sAttackerH] == NULL) return;

	if (   (cAttackerType == DEF_OWNERTYPE_PLAYER) 
		&& (m_bIsHeldenianMode == TRUE)				// No spell work before war has begun
		&& (m_bHeldenianWarInitiated == FALSE)
		&& (m_pMapList[m_pClientList[sAttackerH]->m_cMapIndex] != 0) 
		&& (m_pMapList[m_pClientList[sAttackerH]->m_cMapIndex]->m_bIsHeldenianMap == 1)) return; 
	
	dwTime = timeGetTime();
	iDamage = iDice(sV1, sV2) + sV3;
	if (iDamage <= 0) iDamage = 0;

	switch (cAttackerType) {
	case DEF_OWNERTYPE_PLAYER:	
		if ((m_bAdminSecurity == TRUE) && (m_pClientList[sAttackerH]->m_iAdminUserLevel > 0)) return;
		if ((m_bIsCrusadeMode == FALSE) && (m_pClientList[sAttackerH]->m_bIsPlayerCivil == TRUE) && (cTargetType == DEF_OWNERTYPE_PLAYER)) return;
		if (   (m_pMapList[m_pClientList[sAttackerH]->m_cMapIndex]->m_bIsAttackEnabled == FALSE) 
			&& (m_pClientList[sAttackerH]->m_iAdminUserLevel == 0)) return;	
		cAttackerSide = m_pClientList[sAttackerH]->m_cSide;
		iPartyID = m_pClientList[sAttackerH]->m_iPartyID;
		break;

	case DEF_OWNERTYPE_NPC:
		if (m_pMapList[m_pNpcList[sAttackerH]->m_cMapIndex]->m_bIsAttackEnabled == FALSE) return;	
		cAttackerSide = m_pNpcList[sAttackerH]->m_cSide;
		iPartyID = 0;
		break;
	}

	switch (cTargetType) {
	case DEF_OWNERTYPE_PLAYER:
		if (m_pClientList[sTargetH] == NULL) return;
		if (m_pClientList[sTargetH]->m_bIsInitComplete == FALSE) return;
		if (m_pClientList[sTargetH]->m_bIsKilled == TRUE) return;
		if (m_pClientList[sTargetH]->m_bManaSlate) return;
		if (   (cAttackerType == DEF_OWNERTYPE_PLAYER) 
			&& (m_bIsCrusadeMode == FALSE) 
			&& (m_pClientList[sTargetH]->m_iPKCount == 0) 
			&& (m_pClientList[sTargetH]->m_bIsPlayerCivil == TRUE)) return;		
		if ((dwTime - m_pClientList[sTargetH]->m_dwTime) > DEF_RAGPROTECTIONTIME) return;		
		if (   (m_pClientList[sTargetH]->m_iPartyID != NULL) 
			&& (iPartyID == m_pClientList[sTargetH]->m_iPartyID)
			&& (m_pClientList[sTargetH]->m_bIsReflexionVictim == FALSE) ) return;

		if (cAttackerType == DEF_OWNERTYPE_PLAYER)  
		{	if (m_pMapList[m_pClientList[sTargetH]->m_cMapIndex]->iGetAttribute(m_pClientList[sTargetH]->m_sX, m_pClientList[sTargetH]->m_sY, 0x00000005) != 0) return;
		}	
		
		m_pClientList[sTargetH]->m_iMP -= iDamage;
		if (m_pClientList[sTargetH]->m_iMP <= 0) {
			m_pClientList[sTargetH]->m_iMP = 0;
		}
		break;

	case DEF_OWNERTYPE_NPC:
		if (m_pNpcList[sTargetH] == NULL) return;
		if (m_pNpcList[sTargetH]->m_iMana <= 0) return;
		if ((m_bIsCrusadeMode == TRUE) && (cAttackerSide == m_pNpcList[sTargetH]->m_cSide)) return;
		m_pNpcList[sTargetH]->m_iMana -= iDamage;
		if (m_pNpcList[sTargetH]->m_iMana < 0) {
			m_pNpcList[sTargetH]->m_iMana = 0;
		}
		break;
	}
}

void CGame::Effect_Damage_Spot(short sAttackerH, char cAttackerType, short sTargetH, char cTargetType, short sV1, short sV2, short sV3, BOOL bExp, int iAttr, int iSpellSpecial)
{	int iPartyID, iDamage, iSideCondition, iIndex, iRemainLife, iTemp, iExp, iMaxSuperAttack, iRepDamage;
	char cAttackerSide, cDamageMoveDir;
	DWORD dwTime;
	register double dTmp1, dTmp2, dTmp3;
	short sAtkX, sAtkY, sTgtX, sTgtY, dX, dY;
	int iHalfDamage;

	if ((cAttackerType == DEF_OWNERTYPE_PLAYER) && (m_pClientList[sAttackerH] == NULL)) return;
	if ((cAttackerType == DEF_OWNERTYPE_NPC) && (m_pNpcList[sAttackerH] == NULL)) return;
	if (   (cTargetType == DEF_OWNERTYPE_PLAYER) // Reflexion effect 
		&& (m_pClientList[sTargetH] != NULL)
		&& (m_pClientList[sTargetH]->m_cMagicEffectStatus[DEF_MAGICTYPE_REFLEXION] == 3) )
	{	sTargetH = sAttackerH;
		cTargetType = cAttackerType;			
	}
	if (   (cAttackerType == DEF_OWNERTYPE_PLAYER) 
		&& (m_bIsHeldenianMode == TRUE)				// No spell work before war has begun
		&& (m_bHeldenianWarInitiated == FALSE)
		&& (m_pMapList[m_pClientList[sAttackerH]->m_cMapIndex] != 0) 
		&& (m_pMapList[m_pClientList[sAttackerH]->m_cMapIndex]->m_bIsHeldenianMap == 1)) return; 
	
	dwTime = timeGetTime();
	iDamage = iDice(sV1, sV2) + sV3;
	if (iDamage <= 0) iDamage = 0;
				
	switch (cAttackerType) {
	case DEF_OWNERTYPE_PLAYER:	
		if ((m_bAdminSecurity == TRUE) && (m_pClientList[sAttackerH]->m_iAdminUserLevel > 0)) return;
		if (   (m_pMapList[m_pClientList[sAttackerH]->m_cMapIndex]->m_bIsAttackEnabled == FALSE) 
			&& (m_pClientList[sAttackerH]->m_iAdminUserLevel == 0)) return;	
		if (   (m_bIsCrusadeMode == FALSE) && (m_pClientList[sAttackerH]->m_bIsPlayerCivil == TRUE) 
			&& (cTargetType == DEF_OWNERTYPE_PLAYER)) return;

		if (m_pClientList[sAttackerH]->m_cHeroArmourBonus == 2) iDamage += 4;
		switch (m_pClientList[sAttackerH]->m_cKlonessMiscDamageBonus) {
		case 0:	// Nothing special
			break;
		case -1: //Berserk Wand
			if (iSpellSpecial == 0)
				iDamage = iDamage + iDamage/4;
			else
				iDamage = iDamage + iDamage/8;
			break;
		case -2: //Liche Wand
			if (iSpellSpecial == 0)
				iDamage = iDamage + iDamage/8;
			break;
		default: // Kloness wand bonus
			iDamage += m_pClientList[sAttackerH]->m_cKlonessMiscDamageBonus;// Kloness wand fixed effect
			break;
		}
		// Kloness Necklace
		if (m_pClientList[sAttackerH]->m_cKlonessNeckDamageBonus > 0)
		{	if (cTargetType == DEF_OWNERTYPE_PLAYER)
			{	if (m_pClientList[sTargetH] != NULL)
				{	iRepDamage = m_pClientList[sAttackerH]->m_cKlonessNeckDamageBonus - (m_pClientList[sTargetH]->m_iRating / 100);
					if (iRepDamage >5) iRepDamage = 5;
					if (iRepDamage >0) iDamage += iRepDamage;
		}	}	}
		dTmp1 = (double)iDamage;
		if (m_pClientList[sAttackerH]->m_iMag <= 0)
			 dTmp2 = 1.0f;
		else dTmp2 = (double)(m_pClientList[sAttackerH]->m_iMag + m_pClientList[sAttackerH]->m_iAngelicMag);	
		dTmp2 = dTmp2 / 3.3f;
		dTmp3 = dTmp1 + (dTmp1 * (dTmp2 / 100.0f));
		iDamage = (int)(dTmp3 +0.5f);
		iDamage += m_pClientList[sAttackerH]->m_iAddMagicalDamage;
		iHalfDamage = iDamage / 2;
		switch (iAttr) { // Items for damage bonus
		case 1: iDamage += m_pClientList[sAttackerH]->m_iAddDamageEarth; break;
		case 2: iDamage += m_pClientList[sAttackerH]->m_iAddDamageAir;   break;
		case 3: iDamage += m_pClientList[sAttackerH]->m_iAddDamageFire;  break;
		case 4: iDamage += m_pClientList[sAttackerH]->m_iAddDamageWater; break;
		default: break;
		}
		if (iDamage < iHalfDamage) iDamage = iHalfDamage;
		if (iDamage <= 0) iDamage = 0;

		if (m_pMapList[m_pClientList[sAttackerH]->m_cMapIndex]->m_bIsFightZone == TRUE) 
			iDamage += iDamage/3;
		if (   (m_bHeldenianWarInitiated == TRUE)
			&& (bCheckHeldenianMap(sAttackerH, DEF_OWNERTYPE_PLAYER) == TRUE)) 
		{	iDamage += iDamage/3;
		}		
		if ((cTargetType == DEF_OWNERTYPE_PLAYER) && (m_bIsCrusadeMode == TRUE) 
			&& (m_pClientList[sAttackerH]->m_iCrusadeDuty == 1)) // Crusade 
		{	if (m_pClientList[sAttackerH]->m_iLevel <= 80) 
			{	iDamage += (iDamage*7)/10 ;
			}else if (m_pClientList[sAttackerH]->m_iLevel <= 100) 
				{	iDamage += iDamage/2;
				}else iDamage += iDamage/3;
		}	
		cAttackerSide = m_pClientList[sAttackerH]->m_cSide;
		iPartyID = m_pClientList[sAttackerH]->m_iPartyID;
		sAtkX = m_pClientList[sAttackerH]->m_sX;
		sAtkY = m_pClientList[sAttackerH]->m_sY;
		break;

	case DEF_OWNERTYPE_NPC:
		if (m_pMapList[m_pNpcList[sAttackerH]->m_cMapIndex]->m_bIsAttackEnabled == FALSE) return;
		cAttackerSide = m_pNpcList[sAttackerH]->m_cSide;
		sAtkX = m_pNpcList[sAttackerH]->m_sX;
		sAtkY = m_pNpcList[sAttackerH]->m_sY;
		iPartyID = 0;
		break;
	}

	switch (cTargetType) {
	case DEF_OWNERTYPE_PLAYER:
		if (m_pClientList[sTargetH] == NULL) return;
		if (m_pClientList[sTargetH]->m_bIsInitComplete  == FALSE) return;
		if (m_pClientList[sTargetH]->m_bIsKilled		== TRUE)  return;
		if (m_pClientList[sTargetH]->m_bInvincibleSlate == TRUE)  return;		
		if (m_pClientList[sTargetH]->m_bAntiTPLameEK	== TRUE)  return;	
		if (m_pClientList[sTargetH]->m_iAdminUserLevel > 0)		  return;
		if (m_pClientList[sTargetH]->m_cMapIndex < 0)			  return;
		if ((dwTime - m_pClientList[sTargetH]->m_dwTime) > DEF_RAGPROTECTIONTIME) return;
		if (   (cAttackerType == DEF_OWNERTYPE_PLAYER) && (m_bIsCrusadeMode == FALSE)  
			&& (m_pClientList[sTargetH]->m_iPKCount == 0) 
			&& (m_pClientList[sTargetH]->m_bIsPlayerCivil == TRUE)) return;
		// SNOOPY: Only travellers can damage travellers
		if (   (cAttackerType == DEF_OWNERTYPE_PLAYER) 
			&& (m_pClientList[sTargetH]->m_bIsNeutral == TRUE) 
			&& (m_pClientList[sAttackerH]->m_bIsNeutral == FALSE) 
			&& (m_pClientList[sTargetH]->m_iPKCount == 0) ) return;
		// Party
		if (   (m_pClientList[sTargetH]->m_iPartyID != NULL)
			&& (iPartyID == m_pClientList[sTargetH]->m_iPartyID)
			&& (m_pClientList[sTargetH]->m_bIsReflexionVictim == FALSE) ) return;

		// SNOOPY: Implementation of pk-mode
		if ((cAttackerType == DEF_OWNERTYPE_PLAYER) 
			&& (m_bIsCrusadeMode == FALSE) 
			/*&& (m_pClientList[sAttackerH]->m_iPKCount == 0) 
			&& (m_pClientList[sTargetH]->m_iPKCount == 0)*/) {
			switch (m_pMapList[m_pClientList[sTargetH]->m_cMapIndex]->m_iPKmode) {
			case -5: // no EK, but PK possible, crim treated as "normal citizens"
				if (m_pClientList[sTargetH]->m_cSide != m_pClientList[sAttackerH]->m_cSide) return;
				break;
			case -4: // Evil side can be victim but not attack, crim treated as "normal citizens"
				if (m_pClientList[sTargetH]->m_cSide != 4) return;
				break;
			case -3: // No PK or EK allowed, crim treated as "normal citizens"
				return;
				break;
			case -2: // No PK and EK allowed only against Evil side (m_cSide =4), crim treated as "normal citizens"
				if (m_pClientList[sTargetH]->m_cSide + m_pClientList[sAttackerH]->m_cSide <5) return;
				break;
			case -1: // No PK, EK allowed, crim treated as "normal citizens"
				if (m_pClientList[sTargetH]->m_cSide + m_pClientList[sAttackerH]->m_cSide == 2) return;
				if (m_pClientList[sTargetH]->m_cSide + m_pClientList[sAttackerH]->m_cSide == 4) return;
				break;
			case 5: // no EK, but PK possible... 
				if (   (m_pClientList[sTargetH]->m_cSide != m_pClientList[sAttackerH]->m_cSide) 
					&& (m_pClientList[sAttackerH]->m_iPKCount == 0) 
					&& (m_pClientList[sTargetH]->m_iPKCount == 0)) return;
				break;
			case 4: // Evil side can be victim but not attack
				if (   (m_pClientList[sTargetH]->m_cSide != 4) 					
					&& (m_pClientList[sAttackerH]->m_iPKCount == 0) 
					&& (m_pClientList[sTargetH]->m_iPKCount == 0)) return;
				break;
			case 3: // No PK or EK allowed
				if (   (m_pClientList[sAttackerH]->m_iPKCount == 0) 
					&& (m_pClientList[sTargetH]->m_iPKCount == 0)) return;
				break;
			case 2: // No PK and EK allowed only against Evil side (m_cSide =4)
				if (   (m_pClientList[sTargetH]->m_cSide + m_pClientList[sAttackerH]->m_cSide <5)					
					&& (m_pClientList[sAttackerH]->m_iPKCount == 0) 
					&& (m_pClientList[sTargetH]->m_iPKCount == 0))  return;
				break;
			case 1: // No PK, EK allowed				
				if (   (m_pClientList[sAttackerH]->m_iPKCount == 0) 
					&& (m_pClientList[sTargetH]->m_iPKCount == 0))  
				{	if (m_pClientList[sTargetH]->m_cSide + m_pClientList[sAttackerH]->m_cSide == 2) return;
					if (m_pClientList[sTargetH]->m_cSide + m_pClientList[sAttackerH]->m_cSide == 4) return;
				}
				break;
			case 0:  // All EK allowed
				break;
			}
		} 

		if (cAttackerType == DEF_OWNERTYPE_PLAYER)  
		{	if (m_pClientList[sAttackerH]->m_bIsSafeAttackMode == TRUE) 
			{	iSideCondition = iGetPlayerRelationship(sAttackerH, sTargetH);
				switch (iSideCondition) {
				case 0: // Friendly, same guild: No damage.
					return;
					break;
				case 1: // Friendly: Lower damage in arena or no damage
					if (m_pMapList[m_pClientList[sAttackerH]->m_cMapIndex]->m_bIsFightZone == TRUE)
					{	iDamage = iDamage/3;
					}else return; 
					break;
				case 2: // Normal damage
					break;
				}
			}
			if (m_pMapList[m_pClientList[sTargetH]->m_cMapIndex]->iGetAttribute(m_pClientList[sTargetH]->m_sX, m_pClientList[sTargetH]->m_sY, 0x00000005) != 0) return;
		}
		ClearSkillUsingStatus(sTargetH);		
		switch (iAttr) {
		case 1: if (m_pClientList[sTargetH]->m_iAddAbsEarth != 0) {
				dTmp1 = (double)iDamage;
				dTmp2 = (double)m_pClientList[sTargetH]->m_iAddAbsEarth;
				dTmp3 = (dTmp2/100.0f)*dTmp1;
				iDamage = iDamage - (int)(dTmp3);
				if (iDamage < 0) iDamage = 0;
			}
			break;
		case 2: if (m_pClientList[sTargetH]->m_iAddAbsAir != 0) 
			{	dTmp1 = (double)iDamage;
				dTmp2 = (double)m_pClientList[sTargetH]->m_iAddAbsAir;
				dTmp3 = (dTmp2/100.0f)*dTmp1;
				iDamage = iDamage - (int)(dTmp3);
				if (iDamage < 0) iDamage = 0;
			}
			break;
		case 3: if (m_pClientList[sTargetH]->m_iAddAbsFire != 0) 
			{	dTmp1 = (double)iDamage;
				dTmp2 = (double)m_pClientList[sTargetH]->m_iAddAbsFire;
				dTmp3 = (dTmp2/100.0f)*dTmp1;
				iDamage = iDamage - (int)(dTmp3);
				if (iDamage < 0) iDamage = 0;
			}
			break;
		case 4: if (m_pClientList[sTargetH]->m_iAddAbsWater != 0) 
			{	dTmp1 = (double)iDamage;
				dTmp2 = (double)m_pClientList[sTargetH]->m_iAddAbsWater;
				dTmp3 = (dTmp2/100.0f)*dTmp1;
				iDamage = iDamage - (int)(dTmp3);
				if (iDamage < 0) iDamage = 0;
			}
			break;
		default: break;
		}
		iIndex = m_pClientList[sTargetH]->m_iMagicDamageSaveItemIndex;
		if ((iIndex != -1) && (iIndex >= 0) && (iIndex < DEF_MAXITEMS)) 
		{	switch (m_pClientList[sTargetH]->m_pItemList[iIndex]->m_sIDnum) {
			case 335: // Emmy ring 20%
				dTmp1 = (double)iDamage;
				dTmp2 = dTmp1 * 0.2f;
				dTmp3 = dTmp1 - dTmp2;
				iDamage = (int)(dTmp3 +0.5f);
				break;						
			case 337: //  Ruby ring 10%
				dTmp1 = (double)iDamage;
				dTmp2 = dTmp1 * 0.1f;
				dTmp3 = dTmp1 - dTmp2;
				iDamage = (int)(dTmp3 +0.5f);
				break;
			}
			if (iDamage <= 0) iDamage = 0;			
			iRemainLife = m_pClientList[sTargetH]->m_pItemList[iIndex]->m_wCurLifeSpan;			
			if (iRemainLife <= iDamage) 
			{	ItemDepleteHandler(sTargetH, iIndex, TRUE);
			}else 
			{	m_pClientList[sTargetH]->m_pItemList[iIndex]->m_wCurLifeSpan -= iDamage;
			}
		}
		if (m_pClientList[sTargetH]->m_iAddAbsMD != 0) 
		{	dTmp1 = (double)iDamage;
			dTmp2 = (double)m_pClientList[sTargetH]->m_iAddAbsMD;
			dTmp3 = (dTmp2/100.0f)*dTmp1;
			iDamage = iDamage - (int)dTmp3;
		}
		if (cTargetType == DEF_OWNERTYPE_PLAYER) 
		{	iDamage -= (iDice(1, m_pClientList[sTargetH]->m_iVit/10) - 1);
			if (iDamage <= 0) iDamage = 0;
		}
		if (m_pClientList[sTargetH]->m_cMagicEffectStatus[DEF_MAGICTYPE_PROTECT] == 2)
			iDamage = iDamage / 2;
		if ((cAttackerType == DEF_OWNERTYPE_PLAYER) && (m_pClientList[sTargetH]->m_bIsSpecialAbilityEnabled == TRUE)) 
		{	switch (m_pClientList[sTargetH]->m_iSpecialAbilityType) {
			case 51: // Merien invulnerability
			case 52:
				return;		
		}	}	
		if (   (m_pClientList[sTargetH]->m_bIsLuckyEffect > 0) 
			&& ((iDice(1,100) <= m_pClientList[sTargetH]->m_bIsLuckyEffect))
			&& (m_pClientList[sTargetH]->m_iHP <= iDamage)) 
		{	iDamage = m_pClientList[sTargetH]->m_iHP - 1;
		}	
		m_pClientList[sTargetH]->m_iHP -= iDamage;
		if (m_pClientList[sTargetH]->m_iHP <= 0) 
		{	ClientKilledHandler(sTargetH, sAttackerH, cAttackerType, iDamage);	
		}else 
		{	if (iDamage > 0) 
			{	if (m_pClientList[sTargetH]->m_iAddTransMana > 0) 
				{	dTmp1 = (double)m_pClientList[sTargetH]->m_iAddTransMana;
					dTmp2 = (double)iDamage;
					dTmp3 = (dTmp1/100.0f)*dTmp2 +1.0f;
					iTemp = iGetMaxMP(sTargetH);
					m_pClientList[sTargetH]->m_iMP += (int)dTmp3;
					if (m_pClientList[sTargetH]->m_iMP > iTemp) m_pClientList[sTargetH]->m_iMP = iTemp;
				}
				if (m_pClientList[sTargetH]->m_iAddChargeCritical > 0) 
				{	if (iDice(1,100) <= (m_pClientList[sTargetH]->m_iAddChargeCritical)) 
					{	iMaxSuperAttack = (m_pClientList[sTargetH]->m_iLevel / 10);
						if (m_pClientList[sTargetH]->m_iSuperAttackLeft < iMaxSuperAttack) m_pClientList[sTargetH]->m_iSuperAttackLeft++;
						SendNotifyMsg(NULL, sTargetH, DEF_NOTIFY_SUPERATTACKLEFT, NULL, NULL, NULL, NULL);
				}	}				
				m_pClientList[sTargetH]->m_dwLastDamageTime = dwTime;
				SendNotifyMsg(NULL, sTargetH, DEF_NOTIFY_HP, NULL, NULL, NULL, NULL);
				SendEventToNearClient_TypeA(sTargetH, DEF_OWNERTYPE_PLAYER, MSGID_EVENT_MOTION, DEF_OBJECTDAMAGE, iDamage, NULL, NULL);
				if (m_pClientList[sTargetH]->m_bSkillUsingStatus[19] != TRUE) 
				{	m_pMapList[m_pClientList[sTargetH]->m_cMapIndex]->ClearOwner(0, sTargetH, DEF_OWNERTYPE_PLAYER, m_pClientList[sTargetH]->m_sX, m_pClientList[sTargetH]->m_sY);
					m_pMapList[m_pClientList[sTargetH]->m_cMapIndex]->SetOwner(sTargetH, DEF_OWNERTYPE_PLAYER, m_pClientList[sTargetH]->m_sX, m_pClientList[sTargetH]->m_sY);
				}			
				// 1 : Hold-Person 
				// 2+: Paralize, higher values, harder to break...
				// 20: Always breaks Medusa kiss
				if (m_pClientList[sTargetH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_HOLDOBJECT ] == 20) // Medusa Kiss
				{	m_pClientList[sTargetH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_HOLDOBJECT ] = 0;
					SendNotifyMsg(NULL, sTargetH, DEF_NOTIFY_MAGICEFFECTOFF, DEF_MAGICTYPE_HOLDOBJECT, 20, NULL, NULL);	
					bRemoveFromDelayEventList(sTargetH, DEF_OWNERTYPE_PLAYER, DEF_MAGICTYPE_HOLDOBJECT);
				}else if (m_pClientList[sTargetH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_HOLDOBJECT ] == 1) // Hold Person
				{	m_pClientList[sTargetH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_HOLDOBJECT ] = 0;
					SendNotifyMsg(NULL, sTargetH, DEF_NOTIFY_MAGICEFFECTOFF, DEF_MAGICTYPE_HOLDOBJECT, 1, NULL, NULL);	
					bRemoveFromDelayEventList(sTargetH, DEF_OWNERTYPE_PLAYER, DEF_MAGICTYPE_HOLDOBJECT);
				}else if (   (m_pClientList[sTargetH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_HOLDOBJECT ] != 0) // Para/Entangle
					&& (iDice(1, (m_pClientList[sTargetH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_HOLDOBJECT ]) ) == 1))
				{	m_pClientList[sTargetH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_HOLDOBJECT ] = 0;
					SendNotifyMsg(NULL, sTargetH, DEF_NOTIFY_MAGICEFFECTOFF, DEF_MAGICTYPE_HOLDOBJECT, 2, NULL, NULL);	
					bRemoveFromDelayEventList(sTargetH, DEF_OWNERTYPE_PLAYER, DEF_MAGICTYPE_HOLDOBJECT);
		}	}	}
		sTgtX = m_pClientList[sTargetH]->m_sX;
		sTgtY = m_pClientList[sTargetH]->m_sY;
		break;

	case DEF_OWNERTYPE_NPC:
		if (m_pNpcList[sTargetH] == NULL) return;
		if (m_pNpcList[sTargetH]->m_iHP <= 0) return;
		if ((m_bIsCrusadeMode == TRUE) && (cAttackerSide == m_pNpcList[sTargetH]->m_cSide)) return;	
		if (cAttackerType == DEF_OWNERTYPE_PLAYER)  // No damage on own shields
		{	switch (m_pNpcList[sTargetH]->m_sType) {
			case 40: // Shield generator
			case 41: // GMG
				if ((m_pClientList[sAttackerH]->m_cSide == 0) || (m_pNpcList[sTargetH]->m_cSide == m_pClientList[sAttackerH]->m_cSide)) return;
				break;				
			case 95: // Willowisp guéri par sorts qui fly pas
				m_pNpcList[sTargetH]->m_iHP += iDamage;
				if (m_pNpcList[sTargetH]->m_iHP > m_pNpcList[sTargetH]->m_iHitDice*4) m_pNpcList[sTargetH]->m_iHP = m_pNpcList[sTargetH]->m_iHitDice*4;
				return;				
				break;
			case 96: if (iAttr != 2) break; // Air Elemental, Lightning damage regens HP !
			case 97: if (iAttr != 3) break; // Fire Elemental
			case 98: if (iAttr != 1) break; // Earth Elemental
			case 99: if (iAttr != 4) break; // Ice Elemental
				{	m_pNpcList[sTargetH]->m_iHP += iDamage;
					if (m_pNpcList[sTargetH]->m_iHP > m_pNpcList[sTargetH]->m_iHitDice*4) m_pNpcList[sTargetH]->m_iHP = m_pNpcList[sTargetH]->m_iHitDice*4;
					return;
				}
				break;
		}	}
		if (m_pNpcList[sTargetH]->m_iAbsDamage > 0) 
		{	dTmp1 = (double)iDamage;
			dTmp2 = (double)(m_pNpcList[sTargetH]->m_iAbsDamage)/100.0f;
			dTmp3 = dTmp1 * dTmp2;
			dTmp2 = dTmp1 - dTmp3;
			iDamage = (int)dTmp2;
			if (iDamage < 0) iDamage = 1;
		}
		if (m_pNpcList[sTargetH]->m_cMagicEffectStatus[DEF_MAGICTYPE_PROTECT] == 2)
			iDamage = iDamage / 2;	

		sTgtX = m_pNpcList[sTargetH]->m_sX;
		sTgtY = m_pNpcList[sTargetH]->m_sY;
		switch (m_pNpcList[sTargetH]->m_cActionLimit) {
		case 2: // merchant
		case 6: // Moving talking npc
			return;
		case 4: // EnergyBall is the onlymob moved 
			if (iDice(1,4) != 2) return;
			iDamage = 0;
			cDamageMoveDir = iDice(1,8); // Area spells will push energyBall in random direction.	
			dX = m_pNpcList[sTargetH]->m_sX + _tmp_cTmpDirX[cDamageMoveDir];
			dY = m_pNpcList[sTargetH]->m_sY + _tmp_cTmpDirY[cDamageMoveDir];
			if (m_pMapList[m_pNpcList[sTargetH]->m_cMapIndex]->bGetMoveable(dX, dY, NULL) == FALSE) 
			{	cDamageMoveDir = iDice(1,8);
				dX = m_pNpcList[sTargetH]->m_sX + _tmp_cTmpDirX[cDamageMoveDir];
				dY = m_pNpcList[sTargetH]->m_sY + _tmp_cTmpDirY[cDamageMoveDir];			
				if (m_pMapList[m_pNpcList[sTargetH]->m_cMapIndex]->bGetMoveable(dX, dY, NULL) == FALSE) return;
			}						
			m_pMapList[m_pNpcList[sTargetH]->m_cMapIndex]->ClearOwner(5, sTargetH, DEF_OWNERTYPE_NPC, m_pNpcList[sTargetH]->m_sX, m_pNpcList[sTargetH]->m_sY);
			m_pMapList[m_pNpcList[sTargetH]->m_cMapIndex]->SetOwner(sTargetH, DEF_OWNERTYPE_NPC, dX, dY);
			m_pNpcList[sTargetH]->m_sX   = dX;
			m_pNpcList[sTargetH]->m_sY   = dY;
			m_pNpcList[sTargetH]->m_cDir = cDamageMoveDir;					
			SendEventToNearClient_TypeA(sTargetH, DEF_OWNERTYPE_NPC, MSGID_EVENT_MOTION, DEF_OBJECTMOVE, NULL, NULL, NULL);
			if (bCheckEnergySphereDestination(sTargetH, sAttackerH, cAttackerType) == TRUE) 
			{	if (cAttackerType == DEF_OWNERTYPE_PLAYER) 
				{	iExp = (m_pNpcList[sTargetH]->m_iExp/3);
					// SNOOPY: Now Adding weapon bonus XP (20%) added after party bonus
					if ((m_pClientList[sAttackerH]->m_iAddExp != NULL) && ( m_iXPBonusType < 2))  
					{	dTmp1 = (double)m_pClientList[sAttackerH]->m_iAddExp;
						dTmp2 = (double)iExp;
						dTmp3 = (dTmp1/100.0f)*dTmp2;
						iExp += (int)dTmp3;
					}
					GetExp(sAttackerH, iExp);
				}
				NpcKilledHandler(sTargetH, DEF_OWNERTYPE_NPC, sTargetH, 0);
			}
			return;
		}
	
		m_pNpcList[sTargetH]->m_iHP -= iDamage;
		if (m_pNpcList[sTargetH]->m_iHP <= 0) 
		{	NpcKilledHandler(sAttackerH, cAttackerType, sTargetH, iDamage);
		}else 
		{	SendEventToNearClient_TypeA(sTargetH, DEF_OWNERTYPE_NPC, MSGID_EVENT_MOTION, DEF_OBJECTDAMAGE, iDamage, NULL, NULL);
			switch (cAttackerType) {
			case DEF_OWNERTYPE_NPC:
				if (   (m_pNpcList[sTargetH]->m_cSide	== m_pNpcList[sAttackerH]->m_cSide) 
					&& (m_pNpcList[sTargetH]->m_sType	== m_pNpcList[sAttackerH]->m_sType)) return;
				if (   (iDice(1,10) == 2) // 1/10 counterAttack: reduced chances to attract npc by non-flying spell
					&& (m_pNpcList[sTargetH]->m_cActionLimit < 2)   
					&& (  (m_pNpcList[sTargetH]->m_cTargetType  != DEF_OWNERTYPE_NPC)
						||(m_pNpcList[sTargetH]->m_iTargetIndex != sAttackerH)))
				{	m_pNpcList[sTargetH]->m_cBehavior			= DEF_BEHAVIOR_ATTACK;
					m_pNpcList[sTargetH]->m_sBehaviorTurnCount	= 0;		
					m_pNpcList[sTargetH]->m_iTargetIndex		= sAttackerH;
					m_pNpcList[sTargetH]->m_cTargetType			= DEF_OWNERTYPE_NPC;
					m_pNpcList[sTargetH]->m_dwTime				= dwTime;
				}
				break;
			case DEF_OWNERTYPE_PLAYER: // Guards, cats, rabbits will not attack on such spell damage ?
				if (m_pNpcList[sTargetH]->m_cSide == m_pClientList[sAttackerH]->m_cSide) break;
				if (   (iDice(1,6) == 2) // 1/6 counterAttack: reduced chances to attract npc by non-flying spell
					&& (m_pNpcList[sTargetH]->m_cActionLimit < 2)   
					&& (  (m_pNpcList[sTargetH]->m_cTargetType  != DEF_OWNERTYPE_PLAYER)
						||(m_pNpcList[sTargetH]->m_iTargetIndex != sAttackerH)))
				{	m_pNpcList[sTargetH]->m_cBehavior			= DEF_BEHAVIOR_ATTACK;
					m_pNpcList[sTargetH]->m_sBehaviorTurnCount	= 0;		
					m_pNpcList[sTargetH]->m_iTargetIndex		= sAttackerH;
					m_pNpcList[sTargetH]->m_cTargetType			= DEF_OWNERTYPE_PLAYER;
					m_pNpcList[sTargetH]->m_dwTime				= dwTime;
				}
				// SNOOPY: Add XP for ennemy summons 
				if (   (m_pNpcList[sTargetH]->m_iNoDieRemainExp > 0) 
					&& (m_pClientList[sAttackerH] != NULL)  // Snoopy: Added normal XP for killing ennemy summons
					&& (iDice(1,3) == 2)
					&& ((m_pNpcList[sTargetH]->m_bIsSummoned != TRUE) || ((m_pClientList[sAttackerH]->m_cSide != m_pNpcList[sTargetH]->m_cSide))) ) 
				{	if (m_pNpcList[sTargetH]->m_iNoDieRemainExp > iDamage) 
					{	iExp = iDamage;
						if (m_pClientList[sAttackerH]->m_iLevel > 100 ) 
						{	switch (m_pNpcList[sTargetH]->m_sType) {
							case 55:
							case 56: iExp = 0; break;
							default: break;
						}	}
						if ((m_bIsCrusadeMode == TRUE) && (iExp > 10)) iExp = 10;						
						// Adding weapon bonus XP (20%) added after party bonus
						if ((m_pClientList[sAttackerH]->m_iAddExp != NULL) && ( m_iXPBonusType < 2))  
						{	dTmp1 = (double)m_pClientList[sAttackerH]->m_iAddExp;
							dTmp2 = (double)iExp;
							dTmp3 = (dTmp1/100.0f)*dTmp2;
							iExp += (int)dTmp3;
						}											
						if (bExp == TRUE) 
							 GetExp(sAttackerH, iExp, TRUE);
						else GetExp(sAttackerH, (iExp/2), TRUE);
						m_pNpcList[sTargetH]->m_iNoDieRemainExp -= iDamage;
					}else 
					{	iExp = m_pNpcList[sTargetH]->m_iNoDieRemainExp;
						if (m_pClientList[sAttackerH]->m_iLevel > 100 ) 
						{	switch (m_pNpcList[sTargetH]->m_sType) {
							case 55:
							case 56: iExp = 0; break;
							default: break;
						}	}	
						if ((m_bIsCrusadeMode == TRUE) && (iExp > 10)) iExp = 10;
						// Adding weapon bonus XP (20%) added after party bonus
						if ((m_pClientList[sAttackerH]->m_iAddExp != NULL) && ( m_iXPBonusType < 2))  
						{	dTmp1 = (double)m_pClientList[sAttackerH]->m_iAddExp;
							dTmp2 = (double)iExp;
							dTmp3 = (dTmp1/100.0f)*dTmp2;
							iExp += (int)dTmp3;
						}						
						if (bExp == TRUE) 
							 GetExp(sAttackerH, iExp, TRUE);
						else GetExp(sAttackerH, (iExp/2), TRUE);
						m_pNpcList[sTargetH]->m_iNoDieRemainExp = 0;				
				}	}
				break;
			} // End switch (cAttackerType) {
			if (   (m_pNpcList[sTargetH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_HOLDOBJECT ] != 0)
				&& (iDice(1, (m_pNpcList[sTargetH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_HOLDOBJECT ])) == 1)) // reduced AntiPara for non Flying spells
			{	m_pNpcList[sTargetH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_HOLDOBJECT ] = NULL;
				bRemoveFromDelayEventList(sTargetH, DEF_OWNERTYPE_NPC, DEF_MAGICTYPE_HOLDOBJECT);
		}	}
		break;
	} // End of switch (cTargetType) {
}

void CGame::Effect_Damage_Spot_DamageMove(short sAttackerH, char cAttackerType, short sTargetH, char cTargetType, short sAtkX, short sAtkY, short sV1, short sV2, short sV3, BOOL bExp, int iAttr, int iSpellSpecial)
{	int iPartyID, iDamage, iSideCondition, iIndex, iRemainLife, iTemp, iExp, iMaxSuperAttack, iRepDamage;
	char cAttackerSide, cDamageMoveDir;	
	DWORD dwTime; //, wWeaponType;
	register double dTmp1, dTmp2, dTmp3;
	short sTgtX, sTgtY, dX, dY;
	int iMoveDamage, iMagCaster, iHalfDamage;

	if ((cAttackerType == DEF_OWNERTYPE_PLAYER) && (m_pClientList[sAttackerH] == NULL)) return;
	if ((cAttackerType == DEF_OWNERTYPE_NPC) && (m_pNpcList[sAttackerH] == NULL)) return;
	if (   (cTargetType == DEF_OWNERTYPE_PLAYER) // Reflexion effect 
		&& (m_pClientList[sTargetH] != NULL)
		&& (m_pClientList[sTargetH]->m_cMagicEffectStatus[DEF_MAGICTYPE_REFLEXION] == 3) )
	{	sTargetH = sAttackerH;
		cTargetType = cAttackerType;			
	}
	
	if (   (cAttackerType == DEF_OWNERTYPE_PLAYER) 
		&& (m_bIsHeldenianMode == TRUE)				// No Damage spell work before war has begun
		&& (m_bHeldenianWarInitiated == FALSE)
		&& (m_pMapList[m_pClientList[sAttackerH]->m_cMapIndex] != 0) 
		&& (m_pMapList[m_pClientList[sAttackerH]->m_cMapIndex]->m_bIsHeldenianMap == 1)) return; 
	
	dwTime = timeGetTime();
	iDamage = iDice(sV1, sV2) + sV3;
	if (iDamage <= 0) iDamage = 0;
	sTgtX = 0;
	sTgtY = 0;

	iPartyID = 0;
	switch (cAttackerType) {
	case DEF_OWNERTYPE_PLAYER:
		if ((m_bAdminSecurity == TRUE) && (m_pClientList[sAttackerH]->m_iAdminUserLevel > 0)) return;
		if ((m_pMapList[ m_pClientList[sAttackerH]->m_cMapIndex ]->m_bIsAttackEnabled == FALSE) 
			&& (m_pClientList[sAttackerH]->m_iAdminUserLevel == 0)) return;
		if (   (m_bIsCrusadeMode == FALSE) && (m_pClientList[sAttackerH]->m_bIsPlayerCivil == TRUE) 
			&& (cTargetType == DEF_OWNERTYPE_PLAYER)) return;

		if (m_pClientList[sAttackerH]->m_cHeroArmourBonus == 2) iDamage += 4;		
		switch (m_pClientList[sAttackerH]->m_cKlonessMiscDamageBonus) {
		case 0:	// Nothing special
			break;
		case -1: //Berserk Wand
			if (iSpellSpecial == 0)
				iDamage = iDamage + iDamage/4;
			else
				iDamage = iDamage + iDamage/8;
			break;
		case -2: //Liche Wand
			if (iSpellSpecial == 0)
				iDamage = iDamage + iDamage/8;
			break;
		default: // Kloness wand bonus
			iDamage += m_pClientList[sAttackerH]->m_cKlonessMiscDamageBonus;// Kloness wand fixed effect
			break;
		}
		// Kloness Necklace
		if (m_pClientList[sAttackerH]->m_cKlonessNeckDamageBonus > 0)
		{	if (cTargetType == DEF_OWNERTYPE_PLAYER)
			{	if (m_pClientList[sTargetH] != NULL)
				{	iRepDamage = m_pClientList[sAttackerH]->m_cKlonessNeckDamageBonus - (m_pClientList[sTargetH]->m_iRating / 100);
					if (iRepDamage >5) iRepDamage = 5;
					if (iRepDamage >0) iDamage += iRepDamage;
		}	}	}
		dTmp1 = (double)iDamage;
		if (m_pClientList[sAttackerH]->m_iMag <= 0)
			 dTmp2 = 1.0f;			
		else dTmp2 = (double)(m_pClientList[sAttackerH]->m_iMag + m_pClientList[sAttackerH]->m_iAngelicMag);	
		dTmp2 = dTmp2 / 3.3f;
		dTmp3 = dTmp1 + (dTmp1 * (dTmp2 / 100.0f));
		iDamage = (int)(dTmp3 +0.5f);
		iDamage += m_pClientList[sAttackerH]->m_iAddMagicalDamage;
		iHalfDamage = iDamage / 2;
		switch (iAttr) { // Items for damage bonus
		case 1: iDamage += m_pClientList[sAttackerH]->m_iAddDamageEarth; break;
		case 2: iDamage += m_pClientList[sAttackerH]->m_iAddDamageAir;   break;
		case 3: iDamage += m_pClientList[sAttackerH]->m_iAddDamageFire;  break;
		case 4: iDamage += m_pClientList[sAttackerH]->m_iAddDamageWater; break;
		default: break;
		}
		if (iDamage < iHalfDamage) iDamage = iHalfDamage;
		if (iDamage <= 0) iDamage = 0;

		if (m_pMapList[m_pClientList[sAttackerH]->m_cMapIndex]->m_bIsFightZone == TRUE) 
			iDamage += iDamage/3;
		if (   (m_bHeldenianWarInitiated == TRUE)
			&& (bCheckHeldenianMap(sAttackerH, DEF_OWNERTYPE_PLAYER) == TRUE)) 
		{	iDamage += iDamage/3;
		}			
		if ((cTargetType == DEF_OWNERTYPE_PLAYER) && (m_bIsCrusadeMode == TRUE) 
			&& (m_pClientList[sAttackerH]->m_iCrusadeDuty == 1)) // Crusade
		{	if (m_pClientList[sAttackerH]->m_iLevel <= 80)
			{	iDamage += (iDamage*7)/10 ;
			}else if (m_pClientList[sAttackerH]->m_iLevel <= 100)
				{	iDamage += iDamage/2;
				}else iDamage += iDamage/3;
		}
		cAttackerSide = m_pClientList[sAttackerH]->m_cSide;		
		iPartyID = m_pClientList[sAttackerH]->m_iPartyID;
		iMagCaster = m_pClientList[sAttackerH]->m_iMag + m_pClientList[sAttackerH]->m_iAngelicMag;
		break;

	case DEF_OWNERTYPE_NPC:
		if (m_pMapList[ m_pNpcList[sAttackerH]->m_cMapIndex ]->m_bIsAttackEnabled == FALSE) return;
		cAttackerSide = m_pNpcList[sAttackerH]->m_cSide;
		iPartyID = 0;
		iMagCaster = m_pNpcList[sAttackerH]->m_iHitDice;
		break;
	}

	switch (cTargetType) {
	case DEF_OWNERTYPE_PLAYER:
		if (m_pClientList[sTargetH] == NULL) return;
		if (m_pClientList[sTargetH]->m_bIsInitComplete	== FALSE) return;
		if (m_pClientList[sTargetH]->m_bIsKilled		== TRUE)  return;
		if (m_pClientList[sTargetH]->m_bInvincibleSlate == TRUE)  return;	
		if (m_pClientList[sTargetH]->m_bAntiTPLameEK	== TRUE)  return;		
		if (m_pClientList[sTargetH]->m_iAdminUserLevel > 0)		  return;
		if (m_pClientList[sTargetH]->m_cMapIndex < 0)			  return;	
		if ((dwTime - m_pClientList[sTargetH]->m_dwTime) > DEF_RAGPROTECTIONTIME) return;
		if (   (cAttackerType == DEF_OWNERTYPE_PLAYER) && (m_bIsCrusadeMode == FALSE) 
			&& (m_pClientList[sTargetH]->m_iPKCount == 0) 
			&& (m_pClientList[sTargetH]->m_bIsPlayerCivil == TRUE)) return;
		if (m_pClientList[sTargetH]->m_cMapIndex < 0) return;
		// SNOOPY: Only travellers can damage travellers
		if (   (cAttackerType == DEF_OWNERTYPE_PLAYER)
			&& (m_pClientList[sTargetH]->m_bIsNeutral == TRUE) 
			&& (m_pClientList[sAttackerH]->m_bIsNeutral == FALSE) 
			&& (m_pClientList[sTargetH]->m_iPKCount == 0) ) return;
		// Party	
		if (   (m_pClientList[sTargetH]->m_iPartyID != NULL) 
			&& (iPartyID == m_pClientList[sTargetH]->m_iPartyID)
			&& (m_pClientList[sTargetH]->m_bIsReflexionVictim == FALSE) ) return;
		
		// SNOOPY: Implementation of pk-mode
		if ((cAttackerType == DEF_OWNERTYPE_PLAYER) 
			&& (m_bIsCrusadeMode == FALSE) 
			/*&& (m_pClientList[sAttackerH]->m_iPKCount == 0) 
			&& (m_pClientList[sTargetH]->m_iPKCount == 0)*/) {
			switch (m_pMapList[m_pClientList[sTargetH]->m_cMapIndex]->m_iPKmode) {
			case -5: // no EK, but PK possible, crim treated as "normal citizens"
				if (m_pClientList[sTargetH]->m_cSide != m_pClientList[sAttackerH]->m_cSide) return;
				break;
			case -4: // Evil side can be victim but not attack, crim treated as "normal citizens"
				if (m_pClientList[sTargetH]->m_cSide != 4) return;
				break;
			case -3: // No PK or EK allowed, crim treated as "normal citizens"
				return;
				break;
			case -2: // No PK and EK allowed only against Evil side (m_cSide =4), crim treated as "normal citizens"
				if (m_pClientList[sTargetH]->m_cSide + m_pClientList[sAttackerH]->m_cSide <5) return;
				break;
			case -1: // No PK, EK allowed, crim treated as "normal citizens"
				if (m_pClientList[sTargetH]->m_cSide + m_pClientList[sAttackerH]->m_cSide == 2) return;
				if (m_pClientList[sTargetH]->m_cSide + m_pClientList[sAttackerH]->m_cSide == 4) return;
				break;
			case 5: // no EK, but PK possible... 
				if (   (m_pClientList[sTargetH]->m_cSide != m_pClientList[sAttackerH]->m_cSide) 
					&& (m_pClientList[sAttackerH]->m_iPKCount == 0) 
					&& (m_pClientList[sTargetH]->m_iPKCount == 0)) return;
				break;
			case 4: // Evil side can be victim but not attack
				if (   (m_pClientList[sTargetH]->m_cSide != 4) 					
					&& (m_pClientList[sAttackerH]->m_iPKCount == 0) 
					&& (m_pClientList[sTargetH]->m_iPKCount == 0)) return;
				break;
			case 3: // No PK or EK allowed
				if (   (m_pClientList[sAttackerH]->m_iPKCount == 0) 
					&& (m_pClientList[sTargetH]->m_iPKCount == 0)) return;
				break;
			case 2: // No PK and EK allowed only against Evil side (m_cSide =4)
				if (   (m_pClientList[sTargetH]->m_cSide + m_pClientList[sAttackerH]->m_cSide <5)					
					&& (m_pClientList[sAttackerH]->m_iPKCount == 0) 
					&& (m_pClientList[sTargetH]->m_iPKCount == 0))  return;
				break;
			case 1: // No PK, EK allowed				
				if (   (m_pClientList[sAttackerH]->m_iPKCount == 0) 
					&& (m_pClientList[sTargetH]->m_iPKCount == 0))  
				{	if (m_pClientList[sTargetH]->m_cSide + m_pClientList[sAttackerH]->m_cSide == 2) return;
					if (m_pClientList[sTargetH]->m_cSide + m_pClientList[sAttackerH]->m_cSide == 4) return;
				}
				break;
			case 0:  // All EK allowed
				break;
			}
		} 
		if (cAttackerType == DEF_OWNERTYPE_PLAYER)  			
		{	if (m_pClientList[sAttackerH]->m_bIsSafeAttackMode == TRUE) 
			{	iSideCondition = iGetPlayerRelationship(sAttackerH, sTargetH);
				switch (iSideCondition) {
				case 0: // Friendly, same guild: No damage.
					return;
					break;
				case 1: // Friendly: Lower damage in arena or no damage					
					if (m_pMapList[m_pClientList[sAttackerH]->m_cMapIndex]->m_bIsFightZone == TRUE)
					{	iDamage = iDamage/4;
					}else return; 
					break;
				case 2: // Normal damage
					break;				
			}	}
			if (m_pMapList[m_pClientList[sTargetH]->m_cMapIndex]->iGetAttribute(m_pClientList[sTargetH]->m_sX, m_pClientList[sTargetH]->m_sY, 0x00000005) != 0) return;
		}		
		ClearSkillUsingStatus(sTargetH);

		switch (iAttr) {
		case 1: if (m_pClientList[sTargetH]->m_iAddAbsEarth != 0) 
			{	dTmp1 = (double)iDamage;
				dTmp2 = (double)m_pClientList[sTargetH]->m_iAddAbsEarth;
				dTmp3 = (dTmp2/100.0f)*dTmp1;
				iDamage = iDamage - (int)(dTmp3);
				if (iDamage < 0) iDamage = 0;
			}
			break;
		case 2: if (m_pClientList[sTargetH]->m_iAddAbsAir != 0) 
			{	dTmp1 = (double)iDamage;
				dTmp2 = (double)m_pClientList[sTargetH]->m_iAddAbsAir;
				dTmp3 = (dTmp2/100.0f)*dTmp1;
				iDamage = iDamage - (int)(dTmp3);
				if (iDamage < 0) iDamage = 0;
			}
			break;
		case 3: if (m_pClientList[sTargetH]->m_iAddAbsFire != 0) 
			{	dTmp1 = (double)iDamage;
				dTmp2 = (double)m_pClientList[sTargetH]->m_iAddAbsFire;
				dTmp3 = (dTmp2/100.0f)*dTmp1;
				iDamage = iDamage - (int)(dTmp3);
				if (iDamage < 0) iDamage = 0;
			}
			break;
		case 4:	if (m_pClientList[sTargetH]->m_iAddAbsWater != 0) 
			{	dTmp1 = (double)iDamage;
				dTmp2 = (double)m_pClientList[sTargetH]->m_iAddAbsWater;
				dTmp3 = (dTmp2/100.0f)*dTmp1;
				iDamage = iDamage - (int)(dTmp3);
				if (iDamage < 0) iDamage = 0;
			}
			break;
		default: break;
		}		
		iIndex = m_pClientList[sTargetH]->m_iMagicDamageSaveItemIndex;
		if ((iIndex != -1) && (iIndex >= 0) && (iIndex < DEF_MAXITEMS)) 
		{	switch (m_pClientList[sTargetH]->m_pItemList[iIndex]->m_sIDnum) {
			case 335: // Emmy ring 20%
				dTmp1 = (double)iDamage;
				dTmp2 = dTmp1 * 0.2f;
				dTmp3 = dTmp1 - dTmp2;
				iDamage = (int)(dTmp3 +0.5f);
				break;						
			case 337: //  Ruby ring 10%
				dTmp1 = (double)iDamage;
				dTmp2 = dTmp1 * 0.1f;
				dTmp3 = dTmp1 - dTmp2;
				iDamage = (int)(dTmp3 +0.5f);
				break;
			}
			if (iDamage <= 0) iDamage = 0;			
			iRemainLife = m_pClientList[sTargetH]->m_pItemList[iIndex]->m_wCurLifeSpan;			
			if (iRemainLife <= iDamage) 
			{	ItemDepleteHandler(sTargetH, iIndex, TRUE);
			}else 
			{	m_pClientList[sTargetH]->m_pItemList[iIndex]->m_wCurLifeSpan -= iDamage;
		}	}
		if (m_pClientList[sTargetH]->m_iAddAbsMD != 0) 
		{	dTmp1 = (double)iDamage;
			dTmp2 = (double)m_pClientList[sTargetH]->m_iAddAbsMD;
			dTmp3 = (dTmp2/100.0f)*dTmp1;
			iDamage = iDamage - (int)dTmp3;
		}
		if (cTargetType == DEF_OWNERTYPE_PLAYER) 
		{	iDamage -= (iDice(1, m_pClientList[sTargetH]->m_iVit/10) - 1);
			if (iDamage <= 0) iDamage = 0;
		}
		if (m_pClientList[sTargetH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_PROTECT ] == 2)
			iDamage = iDamage / 2;	
		if ((cAttackerType == DEF_OWNERTYPE_PLAYER) && (m_pClientList[sTargetH]->m_bIsSpecialAbilityEnabled == TRUE)) 
		{	switch (m_pClientList[sTargetH]->m_iSpecialAbilityType) {
			case 51: // Merien invulnerability
			case 52:
				return;
		}	}
		if (   (m_pClientList[sTargetH]->m_bIsLuckyEffect > 0) 
			&& ((iDice(1,100) <= m_pClientList[sTargetH]->m_bIsLuckyEffect))
			&& (m_pClientList[sTargetH]->m_iHP <= iDamage)) 
		{	iDamage = m_pClientList[sTargetH]->m_iHP - 1;
		}
		m_pClientList[sTargetH]->m_iHP -= iDamage;
		if (m_pClientList[sTargetH]->m_iHP <= 0) 
		{	ClientKilledHandler(sTargetH, sAttackerH, cAttackerType, iDamage);	
		}else 
		{	if (iDamage > 0) 
			{	if (m_pClientList[sTargetH]->m_iAddTransMana > 0) 
				{	dTmp1 = (double)m_pClientList[sTargetH]->m_iAddTransMana;
					dTmp2 = (double)iDamage;
					dTmp3 = (dTmp1/100.0f)*dTmp2 +1.0f;
					iTemp = iGetMaxMP(sTargetH);
					m_pClientList[sTargetH]->m_iMP += (int)dTmp3;
					if (m_pClientList[sTargetH]->m_iMP > iTemp) m_pClientList[sTargetH]->m_iMP = iTemp;
				}
				if (m_pClientList[sTargetH]->m_iAddChargeCritical > 0)
				{	if (iDice(1,100) <= (m_pClientList[sTargetH]->m_iAddChargeCritical)) 
					{	iMaxSuperAttack = (m_pClientList[sTargetH]->m_iLevel / 10);
						if (m_pClientList[sTargetH]->m_iSuperAttackLeft < iMaxSuperAttack) m_pClientList[sTargetH]->m_iSuperAttackLeft++;
						SendNotifyMsg(NULL, sTargetH, DEF_NOTIFY_SUPERATTACKLEFT, NULL, NULL, NULL, NULL);
				}	}
				if ((cAttackerType == DEF_OWNERTYPE_PLAYER) && (m_pMapList[m_pClientList[sAttackerH]->m_cMapIndex]->m_bIsFightZone == TRUE)) 
					 iMoveDamage = 80;
				else iMoveDamage = 50;
				if (iDamage >= iMoveDamage) 	//		char cDamageMoveDir;
				{	sTgtX = m_pClientList[sTargetH]->m_sX;
					sTgtY = m_pClientList[sTargetH]->m_sY;
					if (sTgtX == sAtkX) 
					{	if (sTgtY > sAtkY) cDamageMoveDir = 5;
						else if (sTgtY < sAtkY) cDamageMoveDir = 1;
					}else if (sTgtX > sAtkX) 
					{	if (sTgtY == sAtkY)     cDamageMoveDir = 3;
						else if (sTgtY > sAtkY) cDamageMoveDir = 4;
						else if (sTgtY < sAtkY) cDamageMoveDir = 2;
					}else if (sTgtX < sAtkX) 
					{	if (sTgtY == sAtkY)     cDamageMoveDir = 7;
						else if (sTgtY > sAtkY) cDamageMoveDir = 6;
						else if (sTgtY < sAtkY) cDamageMoveDir = 8;							
					}
					if ((sTgtX == sAtkX) && (sTgtY == sAtkY)) cDamageMoveDir = iDice(1,8);	
					m_pClientList[sTargetH]->m_dwLastDamageTime = dwTime;
					SendNotifyMsg(NULL, sTargetH, DEF_NOTIFY_HP, NULL, NULL, NULL, NULL);
					m_pClientList[sTargetH]->m_iLastDamage = iDamage;
					m_pClientList[sTargetH]->m_dwLastDamageMoveTime = dwTime;
					m_pClientList[sTargetH]->m_dwDamageMoveCounter ++;
					SendNotifyMsg(NULL, sTargetH, DEF_NOTIFY_DAMAGEMOVE, cDamageMoveDir, iDamage, NULL, NULL);
				}else 
				{	m_pClientList[sTargetH]->m_dwLastDamageTime = dwTime;
					SendNotifyMsg(NULL, sTargetH, DEF_NOTIFY_HP, NULL, NULL, NULL, NULL);
					SendEventToNearClient_TypeA(sTargetH, DEF_OWNERTYPE_PLAYER, MSGID_EVENT_MOTION, DEF_OBJECTDAMAGE, iDamage, NULL, NULL);
				}
				if (m_pClientList[sTargetH]->m_bSkillUsingStatus[19] != TRUE) 
				{	m_pMapList[m_pClientList[sTargetH]->m_cMapIndex]->ClearOwner(0, sTargetH, DEF_OWNERTYPE_PLAYER, m_pClientList[sTargetH]->m_sX, m_pClientList[sTargetH]->m_sY);
					m_pMapList[m_pClientList[sTargetH]->m_cMapIndex]->SetOwner(sTargetH, DEF_OWNERTYPE_PLAYER, m_pClientList[sTargetH]->m_sX, m_pClientList[sTargetH]->m_sY);
				}	
				// 1 : Hold-Person 
				// 2+: Paralize, higher values, harder to break...	
				// 20: Always breaks Medusa kiss
				if (m_pClientList[sTargetH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_HOLDOBJECT ] == 20) // Always unpara if Medusa Kiss
				{	SendNotifyMsg(NULL, sTargetH, DEF_NOTIFY_MAGICEFFECTOFF, DEF_MAGICTYPE_HOLDOBJECT, 20, NULL, NULL);							
					m_pClientList[sTargetH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_HOLDOBJECT ] = NULL;
					bRemoveFromDelayEventList(sTargetH, DEF_OWNERTYPE_PLAYER, DEF_MAGICTYPE_HOLDOBJECT);
				}else if (m_pClientList[sTargetH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_HOLDOBJECT ] == 1) // Always unpara if HoldPerson
				{	SendNotifyMsg(NULL, sTargetH, DEF_NOTIFY_MAGICEFFECTOFF, DEF_MAGICTYPE_HOLDOBJECT, 1, NULL, NULL);							
					m_pClientList[sTargetH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_HOLDOBJECT ] = NULL;
					bRemoveFromDelayEventList(sTargetH, DEF_OWNERTYPE_PLAYER, DEF_MAGICTYPE_HOLDOBJECT);
				}else if (m_pClientList[sTargetH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_HOLDOBJECT ] != 0) // Para entangle
				{	SendNotifyMsg(NULL, sTargetH, DEF_NOTIFY_MAGICEFFECTOFF, DEF_MAGICTYPE_HOLDOBJECT, 2, NULL, NULL);							
					m_pClientList[sTargetH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_HOLDOBJECT ] = NULL;
					bRemoveFromDelayEventList(sTargetH, DEF_OWNERTYPE_PLAYER, DEF_MAGICTYPE_HOLDOBJECT);				
		}	}	}
		break;

	case DEF_OWNERTYPE_NPC:
		if (m_pNpcList[sTargetH] == NULL) return;
		if (m_pNpcList[sTargetH]->m_iHP <= 0) return;
		if ((m_bIsCrusadeMode == TRUE) && (cAttackerSide == m_pNpcList[sTargetH]->m_cSide)) return;		
		if (cAttackerType == DEF_OWNERTYPE_PLAYER)  // No damage on own shields
		{	switch (m_pNpcList[sTargetH]->m_sType) {
			case 40: // Shield generator
			case 41: // GMG
				if ((m_pClientList[sAttackerH]->m_cSide == 0) || (m_pNpcList[sTargetH]->m_cSide == m_pClientList[sAttackerH]->m_cSide)) return;
				break;
			case 96: if (iAttr != 2) break; // Air Elemental, Lightning damage regens HP !
			case 97: if (iAttr != 3) break; // Fire Elemental
			case 98: if (iAttr != 1) break; // Earth Elemental
			case 99: if (iAttr != 4) break; // Ice Elemental
				{	m_pNpcList[sTargetH]->m_iHP += iDamage;
					if (m_pNpcList[sTargetH]->m_iHP > m_pNpcList[sTargetH]->m_iHitDice*4) m_pNpcList[sTargetH]->m_iHP = m_pNpcList[sTargetH]->m_iHitDice*4;
					return;
				}
				break;
		}	}
		if (m_pNpcList[sTargetH]->m_iAbsDamage > 0) 
		{	dTmp1 = (double)iDamage;
			dTmp2 = (double)(m_pNpcList[sTargetH]->m_iAbsDamage)/100.0f;
			dTmp3 = dTmp1 * dTmp2;
			dTmp2 = dTmp1 - dTmp3;
			iDamage = (int)dTmp2;
			if (iDamage < 0) iDamage = 1;
		}
		if (m_pNpcList[sTargetH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_PROTECT ] == 2)
			iDamage = iDamage / 2;	
		
		switch (m_pNpcList[sTargetH]->m_cActionLimit) {
		case 2: // merchant
		case 6: // Moving talking npc
			return;
		case 4:	
			sTgtX = m_pNpcList[sTargetH]->m_sX;
			sTgtY = m_pNpcList[sTargetH]->m_sY;
			iDamage = 0;
			if (sTgtX == sAtkX) 
			{	if (sTgtY == sAtkY) return;
				else if (sTgtY > sAtkY) cDamageMoveDir = 5;
				else if (sTgtY < sAtkY) cDamageMoveDir = 1;
			}else if (sTgtX > sAtkX) 
			{	if (sTgtY == sAtkY)     cDamageMoveDir = 3;
				else if (sTgtY > sAtkY) cDamageMoveDir = 4;
				else if (sTgtY < sAtkY) cDamageMoveDir = 2;
			}else if (sTgtX < sAtkX) 
			{	if (sTgtY == sAtkY)     cDamageMoveDir = 7;
				else if (sTgtY > sAtkY) cDamageMoveDir = 6;
				else if (sTgtY < sAtkY) cDamageMoveDir = 8;							
			}			
			dX = m_pNpcList[sTargetH]->m_sX + _tmp_cTmpDirX[cDamageMoveDir];
			dY = m_pNpcList[sTargetH]->m_sY + _tmp_cTmpDirY[cDamageMoveDir];
			if (m_pMapList[m_pNpcList[sTargetH]->m_cMapIndex]->bGetMoveable(dX, dY, NULL) == FALSE) 
			{	cDamageMoveDir = iDice(1,8);
				dX = m_pNpcList[sTargetH]->m_sX + _tmp_cTmpDirX[cDamageMoveDir];
				dY = m_pNpcList[sTargetH]->m_sY + _tmp_cTmpDirY[cDamageMoveDir];			
				if (m_pMapList[m_pNpcList[sTargetH]->m_cMapIndex]->bGetMoveable(dX, dY, NULL) == FALSE) return;
			}						
			m_pMapList[m_pNpcList[sTargetH]->m_cMapIndex]->ClearOwner(5, sTargetH, DEF_OWNERTYPE_NPC, m_pNpcList[sTargetH]->m_sX, m_pNpcList[sTargetH]->m_sY);
			m_pMapList[m_pNpcList[sTargetH]->m_cMapIndex]->SetOwner(sTargetH, DEF_OWNERTYPE_NPC, dX, dY);
			m_pNpcList[sTargetH]->m_sX   = dX;
			m_pNpcList[sTargetH]->m_sY   = dY;
			m_pNpcList[sTargetH]->m_cDir = cDamageMoveDir;					
			SendEventToNearClient_TypeA(sTargetH, DEF_OWNERTYPE_NPC, MSGID_EVENT_MOTION, DEF_OBJECTMOVE, NULL, NULL, NULL);
			dX = m_pNpcList[sTargetH]->m_sX + _tmp_cTmpDirX[cDamageMoveDir];
			dY = m_pNpcList[sTargetH]->m_sY + _tmp_cTmpDirY[cDamageMoveDir];					
			if (m_pMapList[m_pNpcList[sTargetH]->m_cMapIndex]->bGetMoveable(dX, dY, NULL) == FALSE) 
			{	cDamageMoveDir = iDice(1,8);
				dX = m_pNpcList[sTargetH]->m_sX + _tmp_cTmpDirX[cDamageMoveDir];
				dY = m_pNpcList[sTargetH]->m_sY + _tmp_cTmpDirY[cDamageMoveDir];						
				if (m_pMapList[m_pNpcList[sTargetH]->m_cMapIndex]->bGetMoveable(dX, dY, NULL) == FALSE) return;
			}						
			m_pMapList[m_pNpcList[sTargetH]->m_cMapIndex]->ClearOwner(5, sTargetH, DEF_OWNERTYPE_NPC, m_pNpcList[sTargetH]->m_sX, m_pNpcList[sTargetH]->m_sY);
			m_pMapList[m_pNpcList[sTargetH]->m_cMapIndex]->SetOwner(sTargetH, DEF_OWNERTYPE_NPC, dX, dY);
			m_pNpcList[sTargetH]->m_sX   = dX;
			m_pNpcList[sTargetH]->m_sY   = dY;
			m_pNpcList[sTargetH]->m_cDir = cDamageMoveDir;
			SendEventToNearClient_TypeA(sTargetH, DEF_OWNERTYPE_NPC, MSGID_EVENT_MOTION, DEF_OBJECTMOVE, NULL, NULL, NULL);
			if (bCheckEnergySphereDestination(sTargetH, sAttackerH, cAttackerType) == TRUE) 
			{	if (cAttackerType == DEF_OWNERTYPE_PLAYER) 
				{	iExp = (m_pNpcList[sTargetH]->m_iExp/3);
					// SNOOPY: Now Adding weapon bonus XP (20%) added after party bonus
					if ((m_pClientList[sAttackerH]->m_iAddExp != NULL) && ( m_iXPBonusType < 2))  
					{	dTmp1 = (double)m_pClientList[sAttackerH]->m_iAddExp;
						dTmp2 = (double)iExp;
						dTmp3 = (dTmp1/100.0f)*dTmp2;
						iExp += (int)dTmp3;
					}
					GetExp(sAttackerH, iExp);
				}
				NpcKilledHandler(sTargetH, DEF_OWNERTYPE_NPC, sTargetH, 0);
			}
			return;
		case 0:	// Snoopy: Fly npcs ...
		case 1: // Never runner mobs
//IMPORTANT; A flying mob can be touched 2 or more times by the same spell !
			if ( (m_pNpcList[sTargetH]->m_iHP > iDamage)  
				&& (iDamage+iDice(1,85) >= 25*(6+ m_pNpcList[sTargetH]->m_cSize)) 
				&& (m_pNpcList[sTargetH]->m_iHitDice <= iMagCaster) )
			{	sTgtX = m_pNpcList[sTargetH]->m_sX;
				sTgtY = m_pNpcList[sTargetH]->m_sY;
				if (sTgtX == sAtkX) 
				{	if (sTgtY > sAtkY) cDamageMoveDir = 5;
					else if (sTgtY < sAtkY) cDamageMoveDir = 1;
				}else if (sTgtX > sAtkX) 
				{	if (sTgtY == sAtkY)     cDamageMoveDir = 3;
					else if (sTgtY > sAtkY) cDamageMoveDir = 4;
					else if (sTgtY < sAtkY) cDamageMoveDir = 2;
				}else if (sTgtX < sAtkX) 
				{	if (sTgtY == sAtkY)     cDamageMoveDir = 7;
					else if (sTgtY > sAtkY) cDamageMoveDir = 6;
					else if (sTgtY < sAtkY) cDamageMoveDir = 8;							
				}			
				if ((sTgtX == sAtkX) && (sTgtY == sAtkY)) cDamageMoveDir = iDice(1,8);	 
				dX = m_pNpcList[sTargetH]->m_sX + _tmp_cTmpDirX[cDamageMoveDir];
				dY = m_pNpcList[sTargetH]->m_sY + _tmp_cTmpDirY[cDamageMoveDir];
				if (m_pMapList[m_pNpcList[sTargetH]->m_cMapIndex]->bGetMoveable(dX, dY, NULL) == FALSE) 
				{	cDamageMoveDir = iDice(1,8);
					dX = m_pNpcList[sTargetH]->m_sX + _tmp_cTmpDirX[cDamageMoveDir];
					dY = m_pNpcList[sTargetH]->m_sY + _tmp_cTmpDirY[cDamageMoveDir];			
					if (m_pMapList[m_pNpcList[sTargetH]->m_cMapIndex]->bGetMoveable(dX, dY, NULL) == FALSE) break;
				}						
				m_pMapList[m_pNpcList[sTargetH]->m_cMapIndex]->ClearOwner(5, sTargetH, DEF_OWNERTYPE_NPC, m_pNpcList[sTargetH]->m_sX, m_pNpcList[sTargetH]->m_sY);
				m_pMapList[m_pNpcList[sTargetH]->m_cMapIndex]->SetOwner(sTargetH, DEF_OWNERTYPE_NPC, dX, dY);
				m_pNpcList[sTargetH]->m_sX   = dX;
				m_pNpcList[sTargetH]->m_sY   = dY;			
				m_pNpcList[sTargetH]->m_dwTime = dwTime + m_pNpcList[sTargetH]->m_dwActionTime; // npc stun for a while
				//m_pNpcList[sTargetH]->m_cDir = cDamageMoveDir;			
				// Remove the npc and create it again to new place
				SendEventToNearClient_TypeA(sTargetH, DEF_OWNERTYPE_NPC, MSGID_EVENT_LOG, DEF_MSGTYPE_REJECT, NULL, NULL, NULL);
				SendEventToNearClient_TypeA(sTargetH, DEF_OWNERTYPE_NPC, MSGID_EVENT_LOG, DEF_MSGTYPE_CONFIRM, NULL, NULL, NULL);
			}
			break;
		}

		m_pNpcList[sTargetH]->m_iHP -= iDamage;
		if (m_pNpcList[sTargetH]->m_iHP < 0) 
		{	NpcKilledHandler(sAttackerH, cAttackerType, sTargetH, iDamage);
		}else 
		{	SendEventToNearClient_TypeA(sTargetH, DEF_OWNERTYPE_NPC, MSGID_EVENT_MOTION, DEF_OBJECTDAMAGE, iDamage, NULL, NULL);
			switch (cAttackerType) {
			case DEF_OWNERTYPE_NPC:
				if (   (m_pNpcList[sTargetH]->m_cSide	== m_pNpcList[sAttackerH]->m_cSide) 
					&& (m_pNpcList[sTargetH]->m_sType	== m_pNpcList[sAttackerH]->m_sType)) return;
				if (   (iDice(1,5) == 2) // 1/5 counterAttack: reduced chances to attract npc by non-flying spell
					&& (m_pNpcList[sTargetH]->m_cActionLimit < 2)   					
					&& (  (m_pNpcList[sTargetH]->m_cTargetType  != DEF_OWNERTYPE_NPC)
						||(m_pNpcList[sTargetH]->m_iTargetIndex != sAttackerH)))
				{	m_pNpcList[sTargetH]->m_cBehavior			= DEF_BEHAVIOR_ATTACK;
					m_pNpcList[sTargetH]->m_sBehaviorTurnCount	= 0;		
					m_pNpcList[sTargetH]->m_iTargetIndex		= sAttackerH;
					m_pNpcList[sTargetH]->m_cTargetType			= DEF_OWNERTYPE_NPC;
					m_pNpcList[sTargetH]->m_dwTime				= dwTime;
				}
				break;
			case DEF_OWNERTYPE_PLAYER: // Guards, cats, rabbits will not attack on such spell damage ?
				if (m_pNpcList[sTargetH]->m_cSide == m_pClientList[sAttackerH]->m_cSide) break;
				if (   (iDice(1,3) == 2) // 1/3 counterAttack: reduced chances to attract npc by non-flying spell
					&& (m_pNpcList[sTargetH]->m_cActionLimit < 2)   
					&& (  (m_pNpcList[sTargetH]->m_cTargetType  != DEF_OWNERTYPE_PLAYER)
						||(m_pNpcList[sTargetH]->m_iTargetIndex != sAttackerH)))
				{	m_pNpcList[sTargetH]->m_cBehavior			= DEF_BEHAVIOR_ATTACK;
					m_pNpcList[sTargetH]->m_sBehaviorTurnCount	= 0;		
					m_pNpcList[sTargetH]->m_iTargetIndex		= sAttackerH;
					m_pNpcList[sTargetH]->m_cTargetType			= DEF_OWNERTYPE_PLAYER;
					m_pNpcList[sTargetH]->m_dwTime				= dwTime;
				}
				// SNOOPY: Add XP for ennemy summons 
				if (   (m_pNpcList[sTargetH]->m_iNoDieRemainExp > 0) 
					&& (m_pClientList[sAttackerH] != NULL)  // Snoopy: Added normal XP for killing ennemy summons
					&& (iDice(1,3) == 2)
					&& ((m_pNpcList[sTargetH]->m_bIsSummoned != TRUE) || ((m_pClientList[sAttackerH]->m_cSide != m_pNpcList[sTargetH]->m_cSide))) ) 
				{	if (m_pNpcList[sTargetH]->m_iNoDieRemainExp > iDamage) 
					{	iExp = iDamage;
						if (m_pClientList[sAttackerH]->m_iLevel > 100 ) 
						{	switch (m_pNpcList[sTargetH]->m_sType) {
							case 55:
							case 56: iExp = 0; break;
							default: break;
						}	}
						if ((m_bIsCrusadeMode == TRUE) && (iExp > 10)) iExp = 10;						
						// Adding weapon bonus XP (20%) added after party bonus
						if ((m_pClientList[sAttackerH]->m_iAddExp != NULL) && ( m_iXPBonusType < 2))  
						{	dTmp1 = (double)m_pClientList[sAttackerH]->m_iAddExp;
							dTmp2 = (double)iExp;
							dTmp3 = (dTmp1/100.0f)*dTmp2;
							iExp += (int)dTmp3;
						}											
						if (bExp == TRUE) 
							 GetExp(sAttackerH, iExp, TRUE);
						else GetExp(sAttackerH, (iExp/2), TRUE);
						m_pNpcList[sTargetH]->m_iNoDieRemainExp -= iDamage;
					}else 
					{	iExp = m_pNpcList[sTargetH]->m_iNoDieRemainExp;
						if (m_pClientList[sAttackerH]->m_iLevel > 100 ) 
						{	switch (m_pNpcList[sTargetH]->m_sType) {
							case 55:
							case 56: iExp = 0; break;
							default: break;
						}	}	
						if ((m_bIsCrusadeMode == TRUE) && (iExp > 10)) iExp = 10;
						// Adding weapon bonus XP (20%) added after party bonus
						if ((m_pClientList[sAttackerH]->m_iAddExp != NULL) && ( m_iXPBonusType < 2))  
						{	dTmp1 = (double)m_pClientList[sAttackerH]->m_iAddExp;
							dTmp2 = (double)iExp;
							dTmp3 = (dTmp1/100.0f)*dTmp2;
							iExp += (int)dTmp3;
						}						
						if (bExp == TRUE) 
							 GetExp(sAttackerH, iExp, TRUE);
						else GetExp(sAttackerH, (iExp/2), TRUE);
						m_pNpcList[sTargetH]->m_iNoDieRemainExp = 0;				
				}	}
				break;
			} // End switch (cAttackerType)
			if (   (m_pNpcList[sTargetH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_HOLDOBJECT ] != 0)
				&& (iDice(1, (m_pNpcList[sTargetH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_HOLDOBJECT ])) == 1)) 
			{	m_pNpcList[sTargetH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_HOLDOBJECT ] = NULL;
				bRemoveFromDelayEventList(sTargetH, DEF_OWNERTYPE_NPC, DEF_MAGICTYPE_HOLDOBJECT);
		}	}
		break;
	}
}
//Snoopy: This kind of spell offers no MA possibility at all.
void CGame::Effect_Damage_Explosion(short sAttackerH, char cAttackerType, short sTargetH, char cTargetType, short sAtkX, short sAtkY, short sV1, short sV2, short sV3, BOOL bExp, int iAttr)
{	int iDamage, iSideCondition, iExp;
	char cAttackerSide, cDamageMoveDir;	
	DWORD dwTime; //, wWeaponType;
	register double dTmp1, dTmp2, dTmp3;
	short sTgtX, sTgtY, dX, dY;

	if ((cAttackerType == DEF_OWNERTYPE_PLAYER) && (m_pClientList[sAttackerH] == NULL)) return;
	if ((cAttackerType == DEF_OWNERTYPE_NPC) && (m_pNpcList[sAttackerH] == NULL)) return;
	if (   (cAttackerType == DEF_OWNERTYPE_PLAYER) 
		&& (m_bIsHeldenianMode == TRUE)				// No spell work before war has begun
		&& (m_bHeldenianWarInitiated == FALSE)
		&& (m_pMapList[m_pClientList[sAttackerH]->m_cMapIndex] != 0) 
		&& (m_pMapList[m_pClientList[sAttackerH]->m_cMapIndex]->m_bIsHeldenianMap == 1)) return; 

	dwTime = timeGetTime();
	iDamage = iDice(sV1, sV2) + sV3;
	if (iDamage <= 0) iDamage = 0;
	sTgtX = 0;
	sTgtY = 0;

	switch (cAttackerType) {
	case DEF_OWNERTYPE_PLAYER:
		if ((m_bAdminSecurity == TRUE) && (m_pClientList[sAttackerH]->m_iAdminUserLevel > 0)) return;
		if (   (m_bIsCrusadeMode == FALSE) && (m_pClientList[sAttackerH]->m_bIsPlayerCivil == TRUE) 
			&& (cTargetType == DEF_OWNERTYPE_PLAYER)) return;
		if ((m_pMapList[ m_pClientList[sAttackerH]->m_cMapIndex ]->m_bIsAttackEnabled == FALSE) 
			&& (m_pClientList[sAttackerH]->m_iAdminUserLevel == 0)) return;
		cAttackerSide = m_pClientList[sAttackerH]->m_cSide;	
		break;
	case DEF_OWNERTYPE_NPC:
		if (m_pMapList[ m_pNpcList[sAttackerH]->m_cMapIndex ]->m_bIsAttackEnabled == FALSE) return;
		cAttackerSide = m_pNpcList[sAttackerH]->m_cSide;
		break;
	}

	switch (cTargetType) {
	case DEF_OWNERTYPE_PLAYER:
		if (m_pClientList[sTargetH] == NULL) return;
		if (m_pClientList[sTargetH]->m_bIsInitComplete	== FALSE) return;
		if (m_pClientList[sTargetH]->m_bIsKilled		== TRUE)  return;
		if (m_pClientList[sTargetH]->m_bInvincibleSlate == TRUE)  return;		
		if (m_pClientList[sTargetH]->m_bAntiTPLameEK	== TRUE)  return;	
		if (m_pClientList[sTargetH]->m_iAdminUserLevel > 0)		  return;
		if (m_pClientList[sTargetH]->m_cMapIndex < 0)			  return;
		if ((dwTime - m_pClientList[sTargetH]->m_dwTime) > DEF_RAGPROTECTIONTIME) return;
		if (   (cAttackerType == DEF_OWNERTYPE_PLAYER) && (m_bIsCrusadeMode == FALSE) 
			&& (m_pClientList[sTargetH]->m_iPKCount == 0) 
			&& (m_pClientList[sTargetH]->m_bIsPlayerCivil == TRUE)) return;
		if (m_pClientList[sTargetH]->m_cMapIndex < 0) return;
		// SNOOPY: Only travellers can damage travellers
		if (   (cAttackerType == DEF_OWNERTYPE_PLAYER)
			&& (m_pClientList[sTargetH]->m_bIsNeutral == TRUE) 
			&& (m_pClientList[sAttackerH]->m_bIsNeutral == FALSE) 
			&& (m_pClientList[sTargetH]->m_iPKCount == 0) ) return;
		
		// SNOOPY: Implementation of pk-mode
		if ((cAttackerType == DEF_OWNERTYPE_PLAYER) 
			&& (m_bIsCrusadeMode == FALSE) 
			/*&& (m_pClientList[sAttackerH]->m_iPKCount == 0) 
			&& (m_pClientList[sTargetH]->m_iPKCount == 0)*/) {
			switch (m_pMapList[m_pClientList[sTargetH]->m_cMapIndex]->m_iPKmode) {
			case -5: // no EK, but PK possible, crim treated as "normal citizens"
				if (m_pClientList[sTargetH]->m_cSide != m_pClientList[sAttackerH]->m_cSide) return;
				break;
			case -4: // Evil side can be victim but not attack, crim treated as "normal citizens"
				if (m_pClientList[sTargetH]->m_cSide != 4) return;
				break;
			case -3: // No PK or EK allowed, crim treated as "normal citizens"
				return;
				break;
			case -2: // No PK and EK allowed only against Evil side (m_cSide =4), crim treated as "normal citizens"
				if (m_pClientList[sTargetH]->m_cSide + m_pClientList[sAttackerH]->m_cSide <5) return;
				break;
			case -1: // No PK, EK allowed, crim treated as "normal citizens"
				if (m_pClientList[sTargetH]->m_cSide + m_pClientList[sAttackerH]->m_cSide == 2) return;
				if (m_pClientList[sTargetH]->m_cSide + m_pClientList[sAttackerH]->m_cSide == 4) return;
				break;
			case 5: // no EK, but PK possible... 
				if (   (m_pClientList[sTargetH]->m_cSide != m_pClientList[sAttackerH]->m_cSide) 
					&& (m_pClientList[sAttackerH]->m_iPKCount == 0) 
					&& (m_pClientList[sTargetH]->m_iPKCount == 0)) return;
				break;
			case 4: // Evil side can be victim but not attack
				if (   (m_pClientList[sTargetH]->m_cSide != 4) 					
					&& (m_pClientList[sAttackerH]->m_iPKCount == 0) 
					&& (m_pClientList[sTargetH]->m_iPKCount == 0)) return;
				break;
			case 3: // No PK or EK allowed
				if (   (m_pClientList[sAttackerH]->m_iPKCount == 0) 
					&& (m_pClientList[sTargetH]->m_iPKCount == 0)) return;
				break;
			case 2: // No PK and EK allowed only against Evil side (m_cSide =4)
				if (   (m_pClientList[sTargetH]->m_cSide + m_pClientList[sAttackerH]->m_cSide <5)					
					&& (m_pClientList[sAttackerH]->m_iPKCount == 0) 
					&& (m_pClientList[sTargetH]->m_iPKCount == 0))  return;
				break;
			case 1: // No PK, EK allowed				
				if (   (m_pClientList[sAttackerH]->m_iPKCount == 0) 
					&& (m_pClientList[sTargetH]->m_iPKCount == 0))  
				{	if (m_pClientList[sTargetH]->m_cSide + m_pClientList[sAttackerH]->m_cSide == 2) return;
					if (m_pClientList[sTargetH]->m_cSide + m_pClientList[sAttackerH]->m_cSide == 4) return;
				}
				break;
			case 0:  // All EK allowed
				break;
			}
		} 
		if (cAttackerType == DEF_OWNERTYPE_PLAYER)  			
		{	if (m_pClientList[sAttackerH]->m_bIsSafeAttackMode == TRUE) 
			{	iSideCondition = iGetPlayerRelationship(sAttackerH, sTargetH);
				switch (iSideCondition) {
				case 0: // Friendly, same guild: No damage.
					return;
					break;
				case 1: // Friendly: Normal damage in arena or no damage
					if (m_pMapList[m_pClientList[sAttackerH]->m_cMapIndex]->m_bIsFightZone == TRUE)
					{	//iDamage = iDamage/2;
					}else return; 
					break;
				case 2: // Normal damage
					break;				
			}	}
			if (m_pMapList[m_pClientList[sTargetH]->m_cMapIndex]->iGetAttribute(m_pClientList[sTargetH]->m_sX, m_pClientList[sTargetH]->m_sY, 0x00000005) != 0) return;
		}		
		ClearSkillUsingStatus(sTargetH);

		if (   (m_pClientList[sTargetH]->m_bIsLuckyEffect > 0) 
			&& ((iDice(1,100) <= m_pClientList[sTargetH]->m_bIsLuckyEffect))
			&& (m_pClientList[sTargetH]->m_iHP <= iDamage)) 
		{	iDamage = m_pClientList[sTargetH]->m_iHP - 1;
		}
		m_pClientList[sTargetH]->m_iHP -= iDamage;
		if (m_pClientList[sTargetH]->m_iHP <= 0) 
		{	ClientKilledHandler(sTargetH, sAttackerH, cAttackerType, iDamage);	
		}else 
		{	if (iDamage > 0) 
			{	sTgtX = m_pClientList[sTargetH]->m_sX;
				sTgtY = m_pClientList[sTargetH]->m_sY;
				if (sTgtX == sAtkX) 
				{	if (sTgtY > sAtkY) cDamageMoveDir = 5;
					else if (sTgtY < sAtkY) cDamageMoveDir = 1;
				}else if (sTgtX > sAtkX) 
				{	if (sTgtY == sAtkY)     cDamageMoveDir = 3;
					else if (sTgtY > sAtkY) cDamageMoveDir = 4;
					else if (sTgtY < sAtkY) cDamageMoveDir = 2;
				}else if (sTgtX < sAtkX) 
				{	if (sTgtY == sAtkY)     cDamageMoveDir = 7;
					else if (sTgtY > sAtkY) cDamageMoveDir = 6;
					else if (sTgtY < sAtkY) cDamageMoveDir = 8;							
				}
				if ((sTgtX == sAtkX) && (sTgtY == sAtkY)) cDamageMoveDir = iDice(1,8);
				m_pClientList[sTargetH]->m_dwLastDamageTime = dwTime;	
				SendNotifyMsg(NULL, sTargetH, DEF_NOTIFY_HP, NULL, NULL, NULL, NULL);
				m_pClientList[sTargetH]->m_iLastDamage = iDamage;
				m_pClientList[sTargetH]->m_dwLastDamageMoveTime = dwTime;
				m_pClientList[sTargetH]->m_dwDamageMoveCounter ++;
				SendNotifyMsg(NULL, sTargetH, DEF_NOTIFY_DAMAGEMOVE, cDamageMoveDir, iDamage, NULL, NULL);

				if (m_pClientList[sTargetH]->m_bSkillUsingStatus[19] != TRUE) 
				{	m_pMapList[m_pClientList[sTargetH]->m_cMapIndex]->ClearOwner(0, sTargetH, DEF_OWNERTYPE_PLAYER, m_pClientList[sTargetH]->m_sX, m_pClientList[sTargetH]->m_sY);
					m_pMapList[m_pClientList[sTargetH]->m_cMapIndex]->SetOwner(sTargetH, DEF_OWNERTYPE_PLAYER, m_pClientList[sTargetH]->m_sX, m_pClientList[sTargetH]->m_sY);
				}	
				// 1 : Hold-Person 
				// 2+: Paralize, higher values, harder to break...		
				// 20: Always breaks Medusa kiss
				// Explosion always unPara
				if (m_pClientList[sTargetH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_HOLDOBJECT ] == 20) // Medusa kiss
				{	SendNotifyMsg(NULL, sTargetH, DEF_NOTIFY_MAGICEFFECTOFF, DEF_MAGICTYPE_HOLDOBJECT, 20, NULL, NULL);
					m_pClientList[sTargetH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_HOLDOBJECT ] = NULL;
					bRemoveFromDelayEventList(sTargetH, DEF_OWNERTYPE_PLAYER, DEF_MAGICTYPE_HOLDOBJECT);
				}else if (m_pClientList[sTargetH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_HOLDOBJECT ] == 1) // Hold person
				{	SendNotifyMsg(NULL, sTargetH, DEF_NOTIFY_MAGICEFFECTOFF, DEF_MAGICTYPE_HOLDOBJECT, 1, NULL, NULL);
					m_pClientList[sTargetH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_HOLDOBJECT ] = NULL;
					bRemoveFromDelayEventList(sTargetH, DEF_OWNERTYPE_PLAYER, DEF_MAGICTYPE_HOLDOBJECT); // Para entangle
				}else if (m_pClientList[sTargetH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_HOLDOBJECT ] != 0) 
				{	SendNotifyMsg(NULL, sTargetH, DEF_NOTIFY_MAGICEFFECTOFF, DEF_MAGICTYPE_HOLDOBJECT, 2, NULL, NULL);
					m_pClientList[sTargetH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_HOLDOBJECT ] = NULL;
					bRemoveFromDelayEventList(sTargetH, DEF_OWNERTYPE_PLAYER, DEF_MAGICTYPE_HOLDOBJECT);
		}	}	}
		break;

	case DEF_OWNERTYPE_NPC:
		if (m_pNpcList[sTargetH] == NULL) return;
		if (m_pNpcList[sTargetH]->m_iHP <= 0) return;
		if ((m_bIsCrusadeMode == TRUE) && (cAttackerSide == m_pNpcList[sTargetH]->m_cSide)) return;		
		if (cAttackerType == DEF_OWNERTYPE_PLAYER)  // No damage on own shields
		{	switch (m_pNpcList[sTargetH]->m_sType) {
			case 40: // Shield generator
			case 41: // GMG
				if ((m_pClientList[sAttackerH]->m_cSide == 0) || (m_pNpcList[sTargetH]->m_cSide == m_pClientList[sAttackerH]->m_cSide)) return;
				break;
			/*case 96: if (iAttr != 2) break; // Air Elemental, Lightning damage regens HP !
			case 97: if (iAttr != 3) break; // Fire Elemental
			case 98: if (iAttr != 1) break; // Earth Elemental
			case 99: if (iAttr != 4) break; // Ice Elemental
				{	iDamage *=2;
				}
				break;*/
			}
		}		
		switch (m_pNpcList[sTargetH]->m_cActionLimit) {
		case 2: // merchant
		case 6: // Moving talking npc
			return;
		case 4:	
			sTgtX = m_pNpcList[sTargetH]->m_sX;
			sTgtY = m_pNpcList[sTargetH]->m_sY;
			iDamage = 0;
			if (sTgtX == sAtkX) 
			{	if (sTgtY == sAtkY) return;
				else if (sTgtY > sAtkY) cDamageMoveDir = 5;
				else if (sTgtY < sAtkY) cDamageMoveDir = 1;
			}else if (sTgtX > sAtkX) 
			{	if (sTgtY == sAtkY)     cDamageMoveDir = 3;
				else if (sTgtY > sAtkY) cDamageMoveDir = 4;
				else if (sTgtY < sAtkY) cDamageMoveDir = 2;
			}else if (sTgtX < sAtkX) 
			{	if (sTgtY == sAtkY)     cDamageMoveDir = 7;
				else if (sTgtY > sAtkY) cDamageMoveDir = 6;
				else if (sTgtY < sAtkY) cDamageMoveDir = 8;							
			}			
			dX = m_pNpcList[sTargetH]->m_sX + _tmp_cTmpDirX[cDamageMoveDir];
			dY = m_pNpcList[sTargetH]->m_sY + _tmp_cTmpDirY[cDamageMoveDir];					
			if (m_pMapList[m_pNpcList[sTargetH]->m_cMapIndex]->bGetMoveable(dX, dY, NULL) == FALSE) 
			{	cDamageMoveDir = iDice(1,8);
				dX = m_pNpcList[sTargetH]->m_sX + _tmp_cTmpDirX[cDamageMoveDir];
				dY = m_pNpcList[sTargetH]->m_sY + _tmp_cTmpDirY[cDamageMoveDir];						
				if (m_pMapList[m_pNpcList[sTargetH]->m_cMapIndex]->bGetMoveable(dX, dY, NULL) == FALSE) return;
			}						
			m_pMapList[m_pNpcList[sTargetH]->m_cMapIndex]->ClearOwner(5, sTargetH, DEF_OWNERTYPE_NPC, m_pNpcList[sTargetH]->m_sX, m_pNpcList[sTargetH]->m_sY);
			m_pMapList[m_pNpcList[sTargetH]->m_cMapIndex]->SetOwner(sTargetH, DEF_OWNERTYPE_NPC, dX, dY);
			m_pNpcList[sTargetH]->m_sX   = dX;
			m_pNpcList[sTargetH]->m_sY   = dY;
			m_pNpcList[sTargetH]->m_cDir = cDamageMoveDir;
			SendEventToNearClient_TypeA(sTargetH, DEF_OWNERTYPE_NPC, MSGID_EVENT_MOTION, DEF_OBJECTMOVE, NULL, NULL, NULL);
			if (bCheckEnergySphereDestination(sTargetH, sAttackerH, cAttackerType) == TRUE) 
			{	if (cAttackerType == DEF_OWNERTYPE_PLAYER) 
				{	iExp = (m_pNpcList[sTargetH]->m_iExp/3);
					// SNOOPY: Now Adding weapon bonus XP (20%) added after party bonus
					if ((m_pClientList[sAttackerH]->m_iAddExp != NULL) && ( m_iXPBonusType < 2))  
					{	dTmp1 = (double)m_pClientList[sAttackerH]->m_iAddExp;
						dTmp2 = (double)iExp;
						dTmp3 = (dTmp1/100.0f)*dTmp2;
						iExp += (int)dTmp3;
					}
					GetExp(sAttackerH, iExp);
				}
				NpcKilledHandler(sTargetH, DEF_OWNERTYPE_NPC, sTargetH, 0);
			}
			return;
		case 0:	// Snoopy: Fly npcs ...
		case 1:	// never runner mobs
		//IMPORTANT; A flying npc can be touched 2 or more times by the same spell !
			if (TRUE) // Always Fly target!
			{	sTgtX = m_pNpcList[sTargetH]->m_sX;
				sTgtY = m_pNpcList[sTargetH]->m_sY;
				if (sTgtX == sAtkX) 
				{	if (sTgtY > sAtkY) cDamageMoveDir = 5;
					else if (sTgtY < sAtkY) cDamageMoveDir = 1;
				}else if (sTgtX > sAtkX) 
				{	if (sTgtY == sAtkY)     cDamageMoveDir = 3;
					else if (sTgtY > sAtkY) cDamageMoveDir = 4;
					else if (sTgtY < sAtkY) cDamageMoveDir = 2;
				}else if (sTgtX < sAtkX) 
				{	if (sTgtY == sAtkY)     cDamageMoveDir = 7;
					else if (sTgtY > sAtkY) cDamageMoveDir = 6;
					else if (sTgtY < sAtkY) cDamageMoveDir = 8;							
				}			
				if ((sTgtX == sAtkX) && (sTgtY == sAtkY)) cDamageMoveDir = iDice(1,8);	 
				dX = m_pNpcList[sTargetH]->m_sX + _tmp_cTmpDirX[cDamageMoveDir];
				dY = m_pNpcList[sTargetH]->m_sY + _tmp_cTmpDirY[cDamageMoveDir];
				if (m_pMapList[m_pNpcList[sTargetH]->m_cMapIndex]->bGetMoveable(dX, dY, NULL) == FALSE) 
				{	cDamageMoveDir = iDice(1,8);
					dX = m_pNpcList[sTargetH]->m_sX + _tmp_cTmpDirX[cDamageMoveDir];
					dY = m_pNpcList[sTargetH]->m_sY + _tmp_cTmpDirY[cDamageMoveDir];			
					if (m_pMapList[m_pNpcList[sTargetH]->m_cMapIndex]->bGetMoveable(dX, dY, NULL) == FALSE) break;
				}						
				m_pMapList[m_pNpcList[sTargetH]->m_cMapIndex]->ClearOwner(5, sTargetH, DEF_OWNERTYPE_NPC, m_pNpcList[sTargetH]->m_sX, m_pNpcList[sTargetH]->m_sY);
				m_pMapList[m_pNpcList[sTargetH]->m_cMapIndex]->SetOwner(sTargetH, DEF_OWNERTYPE_NPC, dX, dY);
				m_pNpcList[sTargetH]->m_sX   = dX;
				m_pNpcList[sTargetH]->m_sY   = dY;			
				m_pNpcList[sTargetH]->m_dwTime = dwTime + m_pNpcList[sTargetH]->m_dwActionTime; // npc stun for a while
				// Remove the npc and create it again to new place
				SendEventToNearClient_TypeA(sTargetH, DEF_OWNERTYPE_NPC, MSGID_EVENT_LOG, DEF_MSGTYPE_REJECT, NULL, NULL, NULL);
				SendEventToNearClient_TypeA(sTargetH, DEF_OWNERTYPE_NPC, MSGID_EVENT_LOG, DEF_MSGTYPE_CONFIRM, NULL, NULL, NULL);
			}
			break;
		}	
		m_pNpcList[sTargetH]->m_iHP -= iDamage;
		if (m_pNpcList[sTargetH]->m_iHP < 0) 
		{	NpcKilledHandler(sAttackerH, cAttackerType, sTargetH, iDamage);
		}else // Explosion always unpara
		{	if (m_pNpcList[sTargetH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_HOLDOBJECT ] != 0)
			{	m_pNpcList[sTargetH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_HOLDOBJECT ] = NULL;
				bRemoveFromDelayEventList(sTargetH, DEF_OWNERTYPE_NPC, DEF_MAGICTYPE_HOLDOBJECT);
			}			
			SendEventToNearClient_TypeA(sTargetH, DEF_OWNERTYPE_NPC, MSGID_EVENT_MOTION, DEF_OBJECTDAMAGE, iDamage, NULL, NULL);
		}
		break;
	}
}

void CGame::Effect_HpUp_Spot(short sAttackerH, char cAttackerType, short sTargetH, char cTargetType, short sV1, short sV2, short sV3)
{
 int iHP, iMaxHP;
 	if (cAttackerType == DEF_OWNERTYPE_PLAYER)
		if (m_pClientList[sAttackerH] == NULL) return;
	iHP = iDice(sV1, sV2) + sV3;
	switch (cTargetType) {
	case DEF_OWNERTYPE_PLAYER:
		if (m_pClientList[sTargetH] == NULL) return;
		if (m_pClientList[sTargetH]->m_bIsKilled == TRUE) return;
		if (m_pClientList[sTargetH]->m_iHP <= 0 ) return;
		iMaxHP = iGetMaxHP(sTargetH, TRUE); // BloodEffect limite le regen 	
		if (   (m_pClientList[sTargetH]->m_iHP < iMaxHP) 
			&& (m_pClientList[sTargetH]->m_iHP > 0))
		{	m_pClientList[sTargetH]->m_iHP += iHP;
			if (m_pClientList[sTargetH]->m_iHP > iMaxHP) m_pClientList[sTargetH]->m_iHP = iMaxHP;
			if (m_pClientList[sTargetH]->m_iHP <= 0)     m_pClientList[sTargetH]->m_iHP = 1;
			SendNotifyMsg(NULL, sTargetH, DEF_NOTIFY_HP, NULL, NULL, NULL, NULL);
		}
		break;

	case DEF_OWNERTYPE_NPC:
		if (m_pNpcList[sTargetH] == NULL) return;
		if (m_pNpcList[sTargetH]->m_iHP <= 0) return;
		if (m_pNpcList[sTargetH]->m_bIsKilled == TRUE) return;
		iMaxHP = m_pNpcList[sTargetH]->m_iHitDice*4;
		if (m_pNpcList[sTargetH]->m_iHP < iMaxHP) 
		{	m_pNpcList[sTargetH]->m_iHP += iHP;
			if (m_pNpcList[sTargetH]->m_iHP > iMaxHP) m_pNpcList[sTargetH]->m_iHP = iMaxHP;
			if (m_pNpcList[sTargetH]->m_iHP <= 0)     m_pNpcList[sTargetH]->m_iHP = 1;
		}
		break;
	}
}

void CGame::Effect_SpDown_Spot(short sAttackerH, char cAttackerType, short sTargetH, char cTargetType, short sV1, short sV2, short sV3)
{	int iSP, iMaxSP;
	DWORD dwTime = timeGetTime();
	if (cAttackerType == DEF_OWNERTYPE_PLAYER)
		if (m_pClientList[sAttackerH] == NULL) return;
	iSP = iDice(sV1, sV2) + sV3;	
	switch (cTargetType) {
	case DEF_OWNERTYPE_PLAYER:
		if (m_pClientList[sTargetH] == NULL) return;
		if (m_pClientList[sTargetH]->m_bIsKilled		== TRUE) return;
		// Is the user having an invincibility slate
		if (m_pClientList[sTargetH]->m_bInvincibleSlate == TRUE) return;
		if (m_pClientList[sTargetH]->m_bAntiTPLameEK	== TRUE) return;
		if (   (cAttackerType == DEF_OWNERTYPE_PLAYER) 
			&& (m_bIsHeldenianMode == TRUE)				// No spell work before war has begun
			&& (m_bHeldenianWarInitiated == FALSE)
			&& (m_pMapList[m_pClientList[sAttackerH]->m_cMapIndex] != 0) 
			&& (m_pMapList[m_pClientList[sAttackerH]->m_cMapIndex]->m_bIsHeldenianMap == 1)) return; 
		iMaxSP = iGetMaxSP(sTargetH);
		if (m_pClientList[sTargetH]->m_iSP > 0) 
		{	if (m_pClientList[sTargetH]->m_iTimeLeft_FirmStaminar == 0) 
			{	m_pClientList[sTargetH]->m_iSP -= iSP;
				if (m_pClientList[sTargetH]->m_iSP < 0) m_pClientList[sTargetH]->m_iSP = 0;
				SendNotifyMsg(NULL, sTargetH, DEF_NOTIFY_SP, NULL, NULL, NULL, NULL);			
		}	}
		break;
	case DEF_OWNERTYPE_NPC:
		break;
	}
}

void CGame::Effect_SpUp_Spot(short sAttackerH, char cAttackerType, short sTargetH, char cTargetType, short sV1, short sV2, short sV3)
{	int iSP, iMaxSP;
	DWORD dwTime = timeGetTime();
	if (cAttackerType == DEF_OWNERTYPE_PLAYER)
	if (m_pClientList[sAttackerH] == NULL) return;
	iSP = iDice(sV1, sV2) + sV3;	
	switch (cTargetType) {
	case DEF_OWNERTYPE_PLAYER:
		if (m_pClientList[sTargetH] == NULL) return;
		if (m_pClientList[sTargetH]->m_bIsKilled == TRUE) return;	
		iMaxSP = iGetMaxSP(sTargetH);
		if (m_pClientList[sTargetH]->m_iSP < iMaxSP) 
		{	m_pClientList[sTargetH]->m_iSP += iSP;			
			if (m_pClientList[sTargetH]->m_iSP > iMaxSP) 
				m_pClientList[sTargetH]->m_iSP = iMaxSP;
			SendNotifyMsg(NULL, sTargetH, DEF_NOTIFY_SP, NULL, NULL, NULL, NULL);
		}
		break;
	case DEF_OWNERTYPE_NPC:
		break;
	}
}

/*********************************************************************************************************************
**  int BOOL CGame::bCheckResistingMagicSuccess(char cAttackerDir, short sTargetH, char cTargetType, int iHitRatio) **
**  description			:: calculates if a player resists magic														**
**  last updated		:: November 20, 2004; 8:42 PM; Hypnotoad													**
**	return value		:: BOOL																						**
**  commentary			::	-	hero armor for target mages adds 50 magic resistance								**
**							-	10000 or more it ratio will deduct 10000 hit ratio									**
**							-	invincible tablet is 100% magic resistance											**
**********************************************************************************************************************/
BOOL CGame::bCheckResistingMagicSuccess(char cAttackerDir, short sTargetH, char cTargetType, int iHitRatio)
{
 double dTmp1, dTmp2, dTmp3;
 int    iTargetMagicResistRatio, iDestHitRatio, iResult;
 char   cTargetDir, cProtect;								 

	switch (cTargetType) {
	case DEF_OWNERTYPE_PLAYER:
		if (m_pClientList[sTargetH] == NULL) return FALSE;
		if (m_pMapList[m_pClientList[sTargetH]->m_cMapIndex]->m_bIsAttackEnabled == FALSE) return FALSE;
		if (m_pClientList[sTargetH]->m_iAdminUserLevel > 0)		 return TRUE;
		if (m_pClientList[sTargetH]->m_bInvincibleSlate == TRUE) return TRUE;
		if (m_pClientList[sTargetH]->m_bAntiTPLameEK	== TRUE) return TRUE;
		cTargetDir = m_pClientList[sTargetH]->m_cDir;
		iTargetMagicResistRatio = m_pClientList[sTargetH]->m_cSkillMastery[3] + m_pClientList[sTargetH]->m_iAddMR;
		if ((m_pClientList[sTargetH]->m_iMag + m_pClientList[sTargetH]->m_iAngelicMag) > 50) 
			iTargetMagicResistRatio += ((m_pClientList[sTargetH]->m_iMag + m_pClientList[sTargetH]->m_iAngelicMag) - 50);
		iTargetMagicResistRatio += m_pClientList[sTargetH]->m_iAddResistMagic;
		cProtect = m_pClientList[sTargetH]->m_cMagicEffectStatus[DEF_MAGICTYPE_PROTECT]; 
		if ((m_pClientList[sTargetH]->m_iSetEffect >= 4) && (m_pClientList[sTargetH]->m_iSetEffect < 10)) 
		{	iTargetMagicResistRatio += 100;
			if (cProtect != 5) cProtect = 2;
		}
		break;

	case DEF_OWNERTYPE_NPC:
		if (m_pNpcList[sTargetH] == NULL) return FALSE;
		cTargetDir = m_pNpcList[sTargetH]->m_cDir;
		iTargetMagicResistRatio = m_pNpcList[sTargetH]->m_cResistMagic;
		cProtect = m_pNpcList[sTargetH]->m_cMagicEffectStatus[DEF_MAGICTYPE_PROTECT]; 
		break;
	}

	if (cProtect == 5) return TRUE;
	if ((iHitRatio < 1000) && (cProtect == 2)) return TRUE;
	if (iHitRatio == -1) return FALSE;

	if (iHitRatio >= 10000) iHitRatio -= 10000;
	if (iTargetMagicResistRatio < 1) iTargetMagicResistRatio = 1;
	/*if ((cAttackerDir != 0) && (m_pClientList[sTargetH] != NULL) && (m_pClientList[sTargetH]->m_cHeroArmourBonus == 2)) 
	{	iHitRatio += 50;
	}*/
	dTmp1 = (double)(iHitRatio);
	dTmp2 = (double)(iTargetMagicResistRatio); 
	dTmp3 = (dTmp1 / dTmp2)*50.0f;
	iDestHitRatio = (int)(dTmp3); 
	
	if (iDestHitRatio < DEF_MINIMUMHITRATIO) iDestHitRatio = DEF_MINIMUMHITRATIO;
	if (iDestHitRatio > DEF_MAXIMUMHITRATIO) iDestHitRatio = DEF_MAXIMUMHITRATIO;
	if (iDestHitRatio >= 100) return FALSE;
	
	iResult = iDice(1, 100);
	if (iResult <= iDestHitRatio) return FALSE;

	if (cTargetType == DEF_OWNERTYPE_PLAYER)
		CalculateSSN_SkillIndex(sTargetH, 3, 1);
	return TRUE;
}

BOOL CGame::bCheckResistingTremorSuccess(short sTargetH, char cTargetType)
{	int  iStability;
	switch (cTargetType) {
	case DEF_OWNERTYPE_PLAYER:
		if (m_pClientList[sTargetH] == NULL) return FALSE;
		if (m_pClientList[sTargetH]->m_iAdminUserLevel > 0) return TRUE;
		// Max load is lvl150*500 + str250*500 = 200 000 (=>2000)
		iStability = 1300 - (m_pClientList[sTargetH]->m_iCurWeightLoad/100); 
		iStability += m_pClientList[sTargetH]->m_iAddAbsEarth;			
		if (iStability > 90)  iStability = 90;
		if (iStability < 10)  iStability = 10;
		if (iDice(1, 100) < iStability) return TRUE;
		else return FALSE;
		break;

	case DEF_OWNERTYPE_NPC:
		return FALSE;
		break;
	}
	return FALSE;
}

BOOL CGame::bCheckResistingIceSuccess(char cAttackerDir, short sTargetH, char cTargetType, int iHitRatio)
{   int    iTargetIceResistRatio, iResult;
	switch (cTargetType) {
	case DEF_OWNERTYPE_PLAYER:
		if (m_pClientList[sTargetH] == NULL) return FALSE;
		if (m_pClientList[sTargetH]->m_iAdminUserLevel > 0) return TRUE;
		iTargetIceResistRatio = m_pClientList[sTargetH]->m_iAddAbsWater*2; // Abs Ice may prevent spell freeze
		if (m_pClientList[sTargetH]->m_dwWarmEffectTime == NULL) 
		{}else if ((timeGetTime() - m_pClientList[sTargetH]->m_dwWarmEffectTime) < 1000*30) return TRUE;
		break;

	case DEF_OWNERTYPE_NPC:
		if (m_pNpcList[sTargetH] == NULL) return FALSE;
		iTargetIceResistRatio = m_pNpcList[sTargetH]->m_cResistMagic/2;
		break;
	}	
	if (iTargetIceResistRatio < 10) iTargetIceResistRatio = 10;	
	iResult = iDice(1, 100 + iHitRatio);
	if (iResult <= iTargetIceResistRatio) return TRUE;
	return FALSE;
}

BOOL CGame::bSetItemToBankItem(int iClientH, class CItem * pItem)
{
 register int i, iRet;
 DWORD * dwp;
 WORD  * wp;
 char  * cp;
 short * sp;
 char cData[100];
	
	if (m_pClientList[iClientH] == NULL) return FALSE;
	if (pItem == NULL) return FALSE;
	if (m_pClientList[iClientH]->m_bIsInsideWarehouse == FALSE) return FALSE;

	for (i = 0; i < DEF_MAXBANKITEMS; i++)
	if (m_pClientList[iClientH]->m_pItemInBankList[i] == NULL) {
		
		m_pClientList[iClientH]->m_pItemInBankList[i] = pItem;
		
		dwp  = (DWORD *)(cData + DEF_INDEX4_MSGID);
		*dwp = MSGID_NOTIFY;
		wp   = (WORD *)(cData + DEF_INDEX2_MSGTYPE);
		*wp  = DEF_NOTIFY_ITEMTOBANK;
				
		cp = (char *)(cData + DEF_INDEX2_MSGTYPE + 2);

		*cp = i;
		cp++;

		*cp = 1; // amount
		cp++;

		memcpy(cp, pItem->m_cName, 20);
		cp += 20;

		dwp  = (DWORD *)cp;
		*dwp = pItem->m_dwCount;
		cp += 4;

		*cp = pItem->m_cItemType;
		cp++;

		*cp = pItem->m_cEquipPos;
		cp++;

		*cp = (char)0; 
		cp++;

		sp  = (short *)cp;
		*sp = pItem->m_sLevelLimit;
		cp += 2;
	
		*cp = pItem->m_cGenderLimit;
		cp++;
		
		wp = (WORD *)cp;
		*wp = pItem->m_wCurLifeSpan;
		cp += 2;

		wp = (WORD *)cp;
		*wp = pItem->m_wWeight;
		cp += 2;

		sp  = (short *)cp;
		*sp = pItem->m_sSprite;
		cp += 2;

		sp  = (short *)cp;
		*sp = pItem->m_sSpriteFrame;
		cp += 2;

		*cp = pItem->m_cItemColor;
		cp++;

		sp = (short *)cp;
		*sp = pItem->m_sItemEffectValue2;
		cp += 2;

		// v1.42
		dwp = (DWORD *)cp;
		*dwp = pItem->m_dwAttribute;
		cp += 4;

		//SNOOPY: Completion/Purity fix ?
		sp = (short *)cp;
		*cp = pItem->m_sItemSpecEffectValue2;
		cp += 2;


		// iRet = m_pClientList[iClientH]->m_pXSock->iSendMsg(cData, 55);
		iRet = m_pClientList[iClientH]->m_pXSock->iSendMsg(cData, 57);
		switch (iRet) {
		case DEF_XSOCKEVENT_QUENEFULL:
		case DEF_XSOCKEVENT_SOCKETERROR:
		case DEF_XSOCKEVENT_CRITICALERROR:
		case DEF_XSOCKEVENT_SOCKETCLOSED:
			// DeleteClient(iClientH, TRUE, TRUE);
			return TRUE; 
			// v1.41 FALSE
		}

		return TRUE;
	}
	return FALSE;
}
// Checks if total skills are over the maximum when increasing a stated skill
BOOL CGame::bCheckTotalSkillMasteryPoints(int iClientH, int iSkill)
{	if (m_pClientList[iClientH]->m_iAdminUserLevel > 0) return FALSE; // Not reduced, GM
	register int i;
	int iRemainPoint, iTotalPoints, iWeaponIndex, iDownSkillSSN, iDownPoint;
	short sDownSkillIndex;
	if (m_pClientList[iClientH] == NULL) return FALSE;
	iTotalPoints = 0;
	for (i = 0; i <	DEF_MAXSKILLTYPE; i++) 
		iTotalPoints += m_pClientList[iClientH]->m_cSkillMastery[i];

	iRemainPoint = iTotalPoints - m_sCharSkillLimit;
	if (iRemainPoint > 0) 
	{	while (iRemainPoint > 0) 			
		{	sDownSkillIndex = -1; 
			if (   (m_pClientList[iClientH]->m_iDownSkillIndex != -1)  
				&& (m_pClientList[iClientH]->m_cSkillMastery[m_pClientList[iClientH]->m_iDownSkillIndex] > 0) )
			{	sDownSkillIndex = m_pClientList[iClientH]->m_iDownSkillIndex;
			}else 
			{	iDownSkillSSN = 99999999;
				for (i = 0; i < DEF_MAXSKILLTYPE; i++)
				{	if (   (m_pClientList[iClientH]->m_cSkillMastery[i] >= 21) && (i != iSkill) 
						&& (m_pClientList[iClientH]->m_iSkillSSN[i] <= iDownSkillSSN)) 
					{	iDownSkillSSN = m_pClientList[iClientH]->m_iSkillSSN[i];
						m_pClientList[iClientH]->m_iDownSkillIndex = i; // Snoopy: impose a downskill index !
						sDownSkillIndex = i; // returns the skill further from next up, over 20...
					}
				}
			}			
			if (sDownSkillIndex != -1) 				
			{	if (m_pClientList[iClientH]->m_cSkillMastery[sDownSkillIndex] <= 20) // v1.4
				 	 iDownPoint = m_pClientList[iClientH]->m_cSkillMastery[sDownSkillIndex];
				else iDownPoint = 1;
				m_pClientList[iClientH]->m_cSkillMastery[sDownSkillIndex] -= iDownPoint; // v1.4
				m_pClientList[iClientH]->m_iSkillSSN[sDownSkillIndex] = m_iSkillSSNpoint[m_pClientList[iClientH]->m_cSkillMastery[sDownSkillIndex]+1] - 1;
				iRemainPoint -= iDownPoint; // v1.4				
				if (m_pClientList[iClientH]->m_sItemEquipmentStatus[ DEF_EQUIPPOS_TWOHAND ] != -1) 
				{	iWeaponIndex = m_pClientList[iClientH]->m_sItemEquipmentStatus[ DEF_EQUIPPOS_TWOHAND ];
					if (m_pClientList[iClientH]->m_pItemList[iWeaponIndex]->m_sRelatedSkill == sDownSkillIndex) 
					{	m_pClientList[iClientH]->m_iHitRatio -= iDownPoint; // v1.4
						if (m_pClientList[iClientH]->m_iHitRatio < 0) m_pClientList[iClientH]->m_iHitRatio = 0;
					}
				}
				if (m_pClientList[iClientH]->m_sItemEquipmentStatus[ DEF_EQUIPPOS_RHAND ] != -1) {
					iWeaponIndex = m_pClientList[iClientH]->m_sItemEquipmentStatus[ DEF_EQUIPPOS_RHAND ];
					if (m_pClientList[iClientH]->m_pItemList[iWeaponIndex]->m_sRelatedSkill == sDownSkillIndex) 
					{	m_pClientList[iClientH]->m_iHitRatio -= iDownPoint; // v1.4
						if (m_pClientList[iClientH]->m_iHitRatio < 0) m_pClientList[iClientH]->m_iHitRatio = 0;
					}
				}
				SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_SKILL, sDownSkillIndex, m_pClientList[iClientH]->m_cSkillMastery[sDownSkillIndex], NULL, NULL);
			}else 
			{	wsprintf(G_cTxt, "Packet Editing:    PC(%s) - Has more than allowed skill points (%d).(Unable to reduce skill total) \tIP(%s)"
					, m_pClientList[iClientH]->m_cCharName
					, iRemainPoint + m_sCharSkillLimit
					, m_pClientList[iClientH]->m_cIPaddress);
				PutHackLogFileList(G_cTxt);
				//DeleteClient(iClientH, TRUE, TRUE); // if we delete client here, will crash calling functions			
				return FALSE; // Unable to find the proper skill to reduce...
			}
		}
		return TRUE; // Reduced...
	}
	return FALSE; // Not reduced, because under maximum..
}


void CGame::OnKeyDown(WPARAM wParam, LPARAM lParam)
{
	switch (wParam) {
	case VK_F1:
		m_bF1pressed = TRUE;	
		ZeroMemory(m_cBugText, sizeof(m_cBugText)); // RAZ the red warning
		m_iBugWarning = 0;
		break;
	case VK_F4:
		m_bF4pressed = TRUE;
		break;
	case VK_F5:
		m_bF5pressed = TRUE;
		break;
	case VK_F12:
		m_bF12pressed = TRUE;
		break;
	}
}

void CGame::OnKeyUp(WPARAM wParam, LPARAM lParam)
{ int i; 
	#define VK_1 0x31
	#define VK_2 0x32
	#define VK_3 0x33
	#define VK_4 0x34
	#define VK_5 0x35
	switch (wParam) {
	case VK_F2:		
		if (bShowActivity == TRUE) bShowActivity = FALSE;
		else bShowActivity = TRUE;
		break;	
	case VK_F1:  m_bF1pressed = FALSE; break;
	case VK_F4:  m_bF4pressed = FALSE; break;
	case VK_F5:  m_bF5pressed = FALSE; break;
	case VK_F12: m_bF12pressed = FALSE;	break;	
	case VK_F6:	if (m_bF1pressed == TRUE) 
				{	PutLogList("(!) Send server shutdown announcement1...");
					for (i = 1; i < DEF_MAXCLIENTS; i++)
					if ((m_pClientList[i] != NULL) && (m_pClientList[i]->m_bIsInitComplete == TRUE)) 
					{	SendNotifyMsg(NULL, i, DEF_NOTIFY_SERVERSHUTDOWN, 1, NULL, NULL, NULL);
					}
				}break;
	case VK_F7:	if (m_bF1pressed == TRUE) 
				{	PutLogList("(!) Send server shutdown announcement2...");
					for (i = 1; i < DEF_MAXCLIENTS; i++)
					if ((m_pClientList[i] != NULL) && (m_pClientList[i]->m_bIsInitComplete == TRUE))
					{	SendNotifyMsg(NULL, i, DEF_NOTIFY_SERVERSHUTDOWN, 2, NULL, NULL, NULL);
					}
				}break;	
	case VK_F9:	if ((m_bF1pressed == TRUE))
				{	PutLogList("(!!!) Resume Crusade Mode...");
					LocalStartCrusadeMode(NULL);
				}break;
	case VK_F11:if ((m_bF1pressed == TRUE)) 
				{	PutLogList("(!!!) ManualEndCrusadeMode: side 0");
					ManualEndCrusadeMode(0);
				}break;
	case VK_1:	if ((m_bF1pressed == TRUE)) GlobalUpdateConfigs(1);	break;
	case VK_2:	if ((m_bF1pressed == TRUE)) GlobalUpdateConfigs(2);	break;
	case VK_3:	if ((m_bF1pressed == TRUE))	GlobalUpdateConfigs(3);	break;
	case VK_4:	if ((m_bF1pressed == TRUE))	GlobalUpdateConfigs(4);	break;
	case VK_5:	if ((m_bF1pressed == TRUE)) GlobalUpdateConfigs(5);	break;
	/*#define VK_A 0x41 // a key 
	case VK_A:if ((m_bF1pressed == TRUE)) {	GlobalStartApocalypseMode(0);}break;*/		
/*	#define VK_H 0x49 // H key 
	case VK_H:if ((m_bF1pressed == TRUE)) {	GlobalStartHeldenianMode();}break;*/
	case VK_HOME: if ((m_bF1pressed == TRUE)) GlobalStartCrusadeMode();
				  else  OnStartGameSignal();  
		break;
	case VK_INSERT:	_GrandMagicLaunchMsgSend(1, 1);	MeteorStrikeMsgHandler(1); break;
	case VK_DELETE:	_GrandMagicLaunchMsgSend(1, 2);	MeteorStrikeMsgHandler(2); break;
	}
}
/*********************************************************************************************************************
**  BOOL CGame::bRegisterDelayEvent(int iDelayType, int iEffectType, DWORD dwLastTime, int iTargetH,				**
**									   char cTargetType, char cMapIndex, int dX, int dY, int iV1, int iV2, int iV3) **
**  description			:: initiates the delayed event process														**
**  last updated		:: November 20, 2004; 9:30 PM; Hypnotoad													**
**	return value		:: BOOL																						**
**********************************************************************************************************************/
BOOL CGame::bRegisterDelayEvent(int iDelayType, int iEffectType, DWORD dwLastTime, int iTargetH, char cTargetType, char cMapIndex, int dX, int dY, int iV1, int iV2, int iV3)
{	register int i;
	for (i = 0; i < DEF_MAXDELAYEVENTS; i++) 
	if (m_pDelayEventList[i] == NULL) 
	{	m_pDelayEventList[i] = new class CDelayEvent;
		m_pDelayEventList[i]->m_iDelayType	= iDelayType;
		m_pDelayEventList[i]->m_iEffectType = iEffectType;
		m_pDelayEventList[i]->m_cMapIndex	= cMapIndex;
		m_pDelayEventList[i]->m_dX			= dX;
		m_pDelayEventList[i]->m_dY			= dY;
		m_pDelayEventList[i]->m_iTargetH    = iTargetH;
		m_pDelayEventList[i]->m_cTargetType = cTargetType;
		m_pDelayEventList[i]->m_iV1         = iV1;
		m_pDelayEventList[i]->m_iV2         = iV2;
		m_pDelayEventList[i]->m_iV3         = iV3; 
		m_pDelayEventList[i]->m_dwTriggerTime = dwLastTime;
		return TRUE;
	}
	return FALSE;
}

void CGame::DelayEventProcessor()
{
 register int i, iSkillNum, iResult;
 DWORD dwTime = timeGetTime();
 int iTemp;
 int i4;

	for (i = 0; i < DEF_MAXDELAYEVENTS; i++) 
	if ((m_pDelayEventList[i] != NULL) && (m_pDelayEventList[i]->m_dwTriggerTime < dwTime)) {

		switch (m_pDelayEventList[i]->m_iDelayType) {

		case DEF_DELAYEVENTTYPE_DELETECLIENT: // Add delayed DeleteClient in case off detected LogOutHack...			
			if (m_pClientList[m_pDelayEventList[i]->m_iTargetH]->m_cDelayedDeco == 1) // 1 prevents DeleteClient to happen before time
			{	m_pClientList[m_pDelayEventList[i]->m_iTargetH]->m_cDelayedDeco = 2;  // 2 allows DeleteCleint
				DeleteClient(m_pDelayEventList[i]->m_iTargetH, TRUE, TRUE);			
			}
			break;

		case DEF_DELAYEVENTTYPE_STORMBLADE: // Add delayed effect for mini-storms
			StormBlade(m_pDelayEventList[i]->m_iTargetH, m_pDelayEventList[i]->m_cMapIndex, m_pDelayEventList[i]->m_dX, m_pDelayEventList[i]->m_dY);
			break;

		case DEF_DELAYEVENTTYPE_ANCIENT_TABLET:
			if (m_pDelayEventList[i]->m_cTargetType == DEF_OWNERTYPE_PLAYER)
			{	if (m_pClientList[m_pDelayEventList[i]->m_iTargetH]->m_bInvincibleSlate) {
					iTemp = 1;
				}
				else if (m_pClientList[m_pDelayEventList[i]->m_iTargetH]->m_bManaSlate) {
					iTemp = 3;
				}
				else if (m_pClientList[m_pDelayEventList[i]->m_iTargetH]->m_bXpSlate) {
					iTemp = 4;
				}
				SendNotifyMsg(NULL, m_pDelayEventList[i]->m_iTargetH, DEF_NOTIFY_SLATE_STATUS, iTemp, NULL, NULL, NULL);
				SetSlateFlag(m_pDelayEventList[i]->m_iTargetH, iTemp, FALSE);
			}
			break;
		case DEF_DELAYEVENTTYPE_RESTART_SERVER:
			if (m_iTotalClients > 0)
			{	PutLogList("(!) CONFIGS RELOADING NEXT TIME...");
				_iForcePlayerDisconect(15);				
				DWORD dwTime = timeGetTime();	
				bRegisterDelayEvent(DEF_DELAYEVENTTYPE_RESTART_SERVER, 0, dwTime + 2000 ,0, 0, NULL, NULL, NULL, 0, NULL, NULL);
			}else
			{	PutLogList("(!) CONFIGS RELOADING NOW...");
				bInit();
			}
			break;

		case DEF_DELAYEVENTTYPE_CALCMETEORSTRIKEEFFECT:
			CalcMeteorStrikeEffectHandler(m_pDelayEventList[i]->m_cMapIndex);
			break;

		case DEF_DELAYEVENTTYPE_DOMETEORSTRIKEDAMAGE:
			DoMeteorStrikeDamageHandler(m_pDelayEventList[i]->m_cMapIndex);
			break;
		
		case DEF_DELAYEVENTTYPE_METEORSTRIKE:
			MeteorStrikeHandler(m_pDelayEventList[i]->m_cMapIndex);
			break;
		
		case DEF_DELAYEVENTTYPE_USEITEM_SKILL:
			switch (m_pDelayEventList[i]->m_cTargetType) {
			case DEF_OWNERTYPE_PLAYER:
				iSkillNum = m_pDelayEventList[i]->m_iEffectType;				
				if ( m_pClientList[m_pDelayEventList[i]->m_iTargetH] == NULL ) break;
				if ( m_pClientList[m_pDelayEventList[i]->m_iTargetH]->m_bSkillUsingStatus[iSkillNum] == FALSE ) break;
				if ( m_pClientList[m_pDelayEventList[i]->m_iTargetH]->m_iSkillUsingTimeID[iSkillNum] != m_pDelayEventList[i]->m_iV2) break;
				m_pClientList[m_pDelayEventList[i]->m_iTargetH]->m_bSkillUsingStatus[iSkillNum] = FALSE;
				m_pClientList[m_pDelayEventList[i]->m_iTargetH]->m_iSkillUsingTimeID[iSkillNum] = NULL;
				iResult = iCalculateUseSkillItemEffect(m_pDelayEventList[i]->m_iTargetH, m_pDelayEventList[i]->m_cTargetType,
				 	                                   m_pDelayEventList[i]->m_iV1, iSkillNum, m_pDelayEventList[i]->m_cMapIndex, m_pDelayEventList[i]->m_dX, m_pDelayEventList[i]->m_dY);

				SendNotifyMsg(NULL, m_pDelayEventList[i]->m_iTargetH, DEF_NOTIFY_SKILLUSINGEND, iResult, NULL, NULL, NULL);
				break;
			}
			break;
		
		case DEF_DELAYEVENTTYPE_TAMING_SKILL:
			switch (m_pDelayEventList[i]->m_cTargetType) {
			case DEF_OWNERTYPE_PLAYER:				
				if ( m_pClientList[m_pDelayEventList[i]->m_iTargetH] == NULL ) break;
				// If not the right Taming usage exit
				if ( m_pClientList[m_pDelayEventList[i]->m_iTargetH]->m_bSkillUsingStatus[22] == FALSE ) break;
				if ( m_pClientList[m_pDelayEventList[i]->m_iTargetH]->m_iSkillUsingTimeID[22] != m_pDelayEventList[i]->m_iV2) break;
				_TamingHandler(m_pDelayEventList[i]->m_iTargetH
					, 22
					, m_pDelayEventList[i]->m_cMapIndex
					, m_pDelayEventList[i]->m_dX
					, m_pDelayEventList[i]->m_dY);
				m_pClientList[m_pDelayEventList[i]->m_iTargetH]->m_bSkillUsingStatus[22] = FALSE;
				m_pClientList[m_pDelayEventList[i]->m_iTargetH]->m_iSkillUsingTimeID[22] = NULL;
				break;
			}
			break;
		case DEF_DELAYEVENTTYPE_DAMAGEOBJECT:
			if (m_pClientList[m_pDelayEventList[i]->m_iTargetH] == NULL) break; 
			//	Same as DEF_MAGICTYPE_EXPLOSION: // 52, Sends back pc or mobs away from caster with some damage.					
			int   ix, iy;
			short sOwnerH;
			char  cOwnerType;
			// Fly from targeted point with double/mulptiple strike/fly...
			for (iy = m_pDelayEventList[i]->m_dY; iy >= m_pDelayEventList[i]->m_dY - 4; iy--)// up left
			for (ix = m_pDelayEventList[i]->m_dX; ix >= m_pDelayEventList[i]->m_dX - 4; ix--) 
			{	m_pMapList[m_pDelayEventList[i]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, ix, iy);
				Effect_Damage_Explosion(m_pDelayEventList[i]->m_iTargetH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pDelayEventList[i]->m_dX, m_pDelayEventList[i]->m_dY, 8, 8, 36, FALSE, 0);
			}
			for (iy = m_pDelayEventList[i]->m_dY+1; iy <= m_pDelayEventList[i]->m_dY + 4; iy++)// down left
			for (ix = m_pDelayEventList[i]->m_dX;   ix >= m_pDelayEventList[i]->m_dX - 4; ix--) 
			{	m_pMapList[m_pDelayEventList[i]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, ix, iy);
				Effect_Damage_Explosion(m_pDelayEventList[i]->m_iTargetH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pDelayEventList[i]->m_dX, m_pDelayEventList[i]->m_dY, 8, 8, 6, FALSE, 0);
			}
			for (iy = m_pDelayEventList[i]->m_dY;   iy >= m_pDelayEventList[i]->m_dY - 4; iy--)
			for (ix = m_pDelayEventList[i]->m_dX+1; ix <= m_pDelayEventList[i]->m_dX + 4; ix++) // up right
			{	m_pMapList[m_pDelayEventList[i]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, ix, iy);
				Effect_Damage_Explosion(m_pDelayEventList[i]->m_iTargetH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pDelayEventList[i]->m_dX, m_pDelayEventList[i]->m_dY, 8, 8, 36, FALSE, 0);
			}
			for (iy = m_pDelayEventList[i]->m_dY+1; iy <= m_pDelayEventList[i]->m_dY + 4; iy++) // down right
			for (ix = m_pDelayEventList[i]->m_dX+1; ix <= m_pDelayEventList[i]->m_dX + 4; ix++) 
			{	m_pMapList[m_pDelayEventList[i]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, ix, iy);
				Effect_Damage_Explosion(m_pDelayEventList[i]->m_iTargetH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pDelayEventList[i]->m_dX, m_pDelayEventList[i]->m_dY, 8, 8, 36, FALSE, 0);
			}	
			//Show effects
			SendEventToNearClient_TypeB(MSGID_EVENT_COMMON, DEF_COMMONTYPE_MAGIC, m_pDelayEventList[i]->m_cMapIndex
				, m_pDelayEventList[i]->m_dX, m_pDelayEventList[i]->m_dY
				, m_pDelayEventList[i]->m_dX, m_pDelayEventList[i]->m_dY
				, 161, m_pClientList[m_pDelayEventList[i]->m_iTargetH]->m_sType);	
			for (iy = m_pDelayEventList[i]->m_dY-4; iy <= m_pDelayEventList[i]->m_dY+4; iy++)
			for (ix = m_pDelayEventList[i]->m_dX-4; ix <= m_pDelayEventList[i]->m_dX+4; ix++)
			{	m_pMapList[m_pDelayEventList[i]->m_cMapIndex]->GetDeadOwner(&sOwnerH, &cOwnerType, ix, iy);					
				if ((cOwnerType == DEF_OWNERTYPE_PLAYER) && (m_pClientList[sOwnerH] != NULL) && (m_pClientList[sOwnerH]->m_iHP > 0)) 
				{	if (bCheckResistingMagicSuccess(0, sOwnerH, cOwnerType, 400) == FALSE)
					Effect_Damage_Spot(m_pDelayEventList[i]->m_iTargetH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, 8, 8, 36, FALSE, 1);
				}// Dead owner will fly without MR possibility
				if (iDice(1,7)==4) // Add fires
					iAddDynamicObjectList(m_pDelayEventList[i]->m_iTargetH, DEF_OWNERTYPE_PLAYER_INDIRECT, DEF_DYNAMICOBJECT_FIRE3, m_pDelayEventList[i]->m_cMapIndex, ix, iy, (iDice(1,7)+3)*1000, 8);
			} 
			//remove item
			CItem *pItem;
			short sRemainItemSprite, sRemainItemSpriteFrame;
			char cRemainItemColor;	
			BOOL bDeletedItem;
			bDeletedItem = FALSE;			
			do 	// Delete all items on current tile
			{	pItem = m_pMapList[m_pDelayEventList[i]->m_cMapIndex]->pGetItem(m_pDelayEventList[i]->m_dX, m_pDelayEventList[i]->m_dY
					, &sRemainItemSprite, &sRemainItemSpriteFrame, &cRemainItemColor); // v1.4
				if (pItem != NULL) 
				{	bDeletedItem = TRUE;
					delete pItem;	
				}
			} while(pItem != NULL);
			if (bDeletedItem == TRUE) // If 2 Bombs at same place, 1st one erases 2nd one. sending 2nd disparition would crash client.
			{	SendEventToNearClient_TypeB(MSGID_EVENT_COMMON, DEF_COMMONTYPE_SETITEM
					, m_pDelayEventList[i]->m_cMapIndex
					, m_pDelayEventList[i]->m_dX, m_pDelayEventList[i]->m_dY
					, sRemainItemSprite, sRemainItemSpriteFrame, cRemainItemColor);
			}	
			break;
		
		case DEF_DELAYEVENTTYPE_KILL_ABADDON:
			NpcKilledHandler(m_pDelayEventList[i]->m_iTargetH, DEF_OWNERTYPE_NPC, m_pDelayEventList[i]->m_iTargetH, 0);
			break;

		case DEF_DELAYEVENTTYPE_END_APOCALYPSE:
			GlobalEndApocalypseMode(0);	
			break;

		case DEF_DELAYEVENTTYPE_MAGICRELEASE: 
			// Removes the aura after time
			switch (m_pDelayEventList[i]->m_cTargetType) {
			case DEF_OWNERTYPE_PLAYER:
				if (m_pClientList[ m_pDelayEventList[i]->m_iTargetH ] == NULL) break;
				// Para must send 1 or 2 only to the client
				if (m_pDelayEventList[i]->m_iEffectType == DEF_MAGICTYPE_HOLDOBJECT)
				{	switch(m_pDelayEventList[i]->m_iV1){
					case 1: // Hold Person
						SendNotifyMsg(NULL, m_pDelayEventList[i]->m_iTargetH, DEF_NOTIFY_MAGICEFFECTOFF, DEF_MAGICTYPE_HOLDOBJECT, 1, NULL, NULL);				
						break;	
					case 20: // Medusa kiss
						SendNotifyMsg(NULL, m_pDelayEventList[i]->m_iTargetH, DEF_NOTIFY_MAGICEFFECTOFF, DEF_MAGICTYPE_HOLDOBJECT, 20, NULL, NULL);
						break;
					default: // Para 
						SendNotifyMsg(NULL, m_pDelayEventList[i]->m_iTargetH, DEF_NOTIFY_MAGICEFFECTOFF, DEF_MAGICTYPE_HOLDOBJECT, 2, NULL, NULL);				
						break;
					}
					m_pClientList[ m_pDelayEventList[i]->m_iTargetH ]->m_cMagicEffectStatus[ m_pDelayEventList[i]->m_iEffectType ] = NULL;	
					break;				
				}
				SendNotifyMsg(NULL, m_pDelayEventList[i]->m_iTargetH, DEF_NOTIFY_MAGICEFFECTOFF, m_pDelayEventList[i]->m_iEffectType
					, m_pClientList[ m_pDelayEventList[i]->m_iTargetH ]->m_cMagicEffectStatus[ m_pDelayEventList[i]->m_iEffectType ], NULL, NULL);
				
				m_pClientList[ m_pDelayEventList[i]->m_iTargetH ]->m_cMagicEffectStatus[ m_pDelayEventList[i]->m_iEffectType ] = NULL;

				// Berserk 
				if (m_pDelayEventList[i]->m_iEffectType == DEF_MAGICTYPE_BERSERK)
				{	SetBerserkFlag(m_pDelayEventList[i]->m_iTargetH, DEF_OWNERTYPE_PLAYER, FALSE); break; 				
				// Invisibility
				}else if (m_pDelayEventList[i]->m_iEffectType == DEF_MAGICTYPE_INVISIBILITY)
				{	SetInvisibilityFlag(m_pDelayEventList[i]->m_iTargetH, DEF_OWNERTYPE_PLAYER, FALSE); break; 
				// Protection Magic
				}else if (m_pDelayEventList[i]->m_iEffectType == DEF_MAGICTYPE_PROTECT) 
				{	switch(m_pDelayEventList[i]->m_iV1){
					case 1: SetProtectionFromArrowFlag(m_pDelayEventList[i]->m_iTargetH, DEF_OWNERTYPE_PLAYER, FALSE); break;						    
					case 2:
					case 5: SetMagicProtectionFlag(m_pDelayEventList[i]->m_iTargetH, DEF_OWNERTYPE_PLAYER, FALSE); break;						   
					case 3:
					case 4: m_pClientList[ m_pDelayEventList[i]->m_iTargetH ]->m_cMagicEffectStatus[DEF_MAGICTYPE_DEFENCESHIELD_VALUE] = 0;
						    SetDefenseShieldFlag(m_pDelayEventList[i]->m_iTargetH, DEF_OWNERTYPE_PLAYER, FALSE); break;						   
					} 
					break;					
				// Ice Frozen 
				}else if (m_pDelayEventList[i]->m_iEffectType == DEF_MAGICTYPE_ICE)
				{	SetIceFlag(m_pDelayEventList[i]->m_iTargetH, DEF_OWNERTYPE_PLAYER, FALSE); break;				
				// Inbitition casting 
				}else if (m_pDelayEventList[i]->m_iEffectType == DEF_MAGICTYPE_INHIBITION)
				{	m_pClientList[m_pDelayEventList[i]->m_iTargetH]->m_bInhibition = FALSE; break; 
				// Finish METAMORPHOSIS 
				}else if (m_pDelayEventList[i]->m_iEffectType == DEF_MAGICTYPE_METAMORPHOSIS)
				{	SetMetamorphosisFlag(m_pDelayEventList[i]->m_iTargetH, DEF_OWNERTYPE_PLAYER, FALSE); break; 
				// Confusion
				}else if (m_pDelayEventList[i]->m_iEffectType == DEF_MAGICTYPE_CONFUSE)
				{	switch(m_pDelayEventList[i]->m_iV1){
					// SNOOPY: added Confusion, send back good info about players arround
					case 2: SetConfusionFlag(m_pDelayEventList[i]->m_iTargetH, DEF_OWNERTYPE_PLAYER, FALSE); break;
					case 3: SetIllusionFlag(m_pDelayEventList[i]->m_iTargetH, DEF_OWNERTYPE_PLAYER, FALSE); break;
					case 4: SetIllusionMovementFlag(m_pDelayEventList[i]->m_iTargetH, DEF_OWNERTYPE_PLAYER, FALSE); break;
					} 
					break;				 				
				// polymorph 
				}else if (m_pDelayEventList[i]->m_iEffectType == DEF_MAGICTYPE_POLYMORPH) 
				{	m_pClientList[m_pDelayEventList[i]->m_iTargetH]->m_sType = m_pClientList[m_pDelayEventList[i]->m_iTargetH]->m_sOriginalType;
					for ( i4 = 0; i4 < DEF_MAXITEMS; i4++) // Unequip armors if sex no longer allows it
					{	if (   (m_pClientList[m_pDelayEventList[i]->m_iTargetH]->m_pItemList[i4] != NULL)										
							&& (m_pClientList[m_pDelayEventList[i]->m_iTargetH]->m_bIsItemEquipped[i4]) )	
						{	if (bEquipItemHandler(m_pDelayEventList[i]->m_iTargetH, i4, TRUE) == FALSE) 	
							{ 	// if an item was removed compute Total item effect
								CalcTotalItemEffect(m_pDelayEventList[i]->m_iTargetH, i4, false);
					}	}	}
					SendEventToNearClient_TypeA(m_pDelayEventList[i]->m_iTargetH, DEF_OWNERTYPE_PLAYER, MSGID_EVENT_MOTION, DEF_OBJECTNULLACTION, NULL, NULL, NULL);
					break;				 
				// Finish Reflexion Aura
				}else if (m_pDelayEventList[i]->m_iEffectType == DEF_MAGICTYPE_REFLEXION)
				{	SetReflexionFlag(m_pDelayEventList[i]->m_iTargetH, DEF_OWNERTYPE_PLAYER, FALSE); break;
				} 
				break;			
		
			case DEF_OWNERTYPE_NPC:
				if (m_pNpcList[ m_pDelayEventList[i]->m_iTargetH ] == NULL) break;				
				m_pNpcList[ m_pDelayEventList[i]->m_iTargetH ]->m_cMagicEffectStatus[ m_pDelayEventList[i]->m_iEffectType ] = NULL;	
				// Ice 
				if (m_pDelayEventList[i]->m_iEffectType == DEF_MAGICTYPE_ICE)
				{	SetIceFlag(m_pDelayEventList[i]->m_iTargetH, DEF_OWNERTYPE_NPC, FALSE); break;					 
				// Protection Magic
				}else if (m_pDelayEventList[i]->m_iEffectType == DEF_MAGICTYPE_PROTECT) 
				{	switch(m_pDelayEventList[i]->m_iV1){
						case 1:
							SetProtectionFromArrowFlag(m_pDelayEventList[i]->m_iTargetH, DEF_OWNERTYPE_NPC, FALSE);
							break;
						case 2:
						case 5:
							SetMagicProtectionFlag(m_pDelayEventList[i]->m_iTargetH, DEF_OWNERTYPE_NPC, FALSE);
							break;
						case 3:
						case 4:
							m_pNpcList[ m_pDelayEventList[i]->m_iTargetH ]->m_cMagicEffectStatus[DEF_MAGICTYPE_DEFENCESHIELD_VALUE] = 0;
							SetDefenseShieldFlag(m_pDelayEventList[i]->m_iTargetH, DEF_OWNERTYPE_NPC, FALSE);
							break;
					}	
					break;				
				// Invisibility 				 
				}else if (m_pDelayEventList[i]->m_iEffectType == DEF_MAGICTYPE_INVISIBILITY)
				{	SetInvisibilityFlag(m_pDelayEventList[i]->m_iTargetH, DEF_OWNERTYPE_NPC, FALSE); break;
				// Berserk 
				}else if (m_pDelayEventList[i]->m_iEffectType == DEF_MAGICTYPE_BERSERK)
				{	SetBerserkFlag(m_pDelayEventList[i]->m_iTargetH, DEF_OWNERTYPE_NPC, FALSE); break;
				// polymorph 
				}else if (m_pDelayEventList[i]->m_iEffectType == DEF_MAGICTYPE_POLYMORPH) 
				{	m_pNpcList[m_pDelayEventList[i]->m_iTargetH]->m_sType = m_pNpcList[m_pDelayEventList[i]->m_iTargetH]->m_sOriginalType;
					SendEventToNearClient_TypeA(m_pDelayEventList[i]->m_iTargetH, DEF_OWNERTYPE_NPC, MSGID_EVENT_MOTION, DEF_OBJECTNULLACTION, NULL, NULL, NULL);
					break;
				// Illusion
				}else if (m_pDelayEventList[i]->m_iEffectType == DEF_MAGICTYPE_CONFUSE)
				{	SetIllusionFlag(m_pDelayEventList[i]->m_iTargetH, DEF_OWNERTYPE_NPC, FALSE); break;
				}
				break; // Defanlt case
			}
			break;
		}		
		delete m_pDelayEventList[i];
		m_pDelayEventList[i] = NULL;
	}
}
BOOL CGame::bRemoveFromDelayEventList(int iH, char cType, int iEffectType)
{ register int i;
	for (i = 0; i < DEF_MAXDELAYEVENTS; i++) 	
	if (m_pDelayEventList[i] != NULL) 
	{	if (iEffectType == NULL) 	// Effect 
		{	if ( (m_pDelayEventList[i]->m_iTargetH == iH) && (m_pDelayEventList[i]->m_cTargetType == cType) ) 
			{	delete m_pDelayEventList[i];
				m_pDelayEventList[i] = NULL;
			}
		}else 
		{	if (   (m_pDelayEventList[i]->m_iTargetH == iH) && (m_pDelayEventList[i]->m_cTargetType == cType) 
				&& (m_pDelayEventList[i]->m_iEffectType == iEffectType) ) 
			{	delete m_pDelayEventList[i];
				m_pDelayEventList[i] = NULL;
	}	}	}	
	return TRUE;
}

void CGame::SendObjectMotionRejectMsg(int iClientH)
{	if (m_pClientList[iClientH] == NULL) return; // add by snoopy
	char  * cp, cData[30];
 DWORD * dwp;
 WORD  * wp;
 short * sp;
 int     iRet;
	m_pClientList[iClientH]->m_bIsMoveBlocked = TRUE; // v2.171
	dwp  = (DWORD *)(cData + DEF_INDEX4_MSGID);
 	*dwp = MSGID_RESPONSE_MOTION;
	wp   = (WORD *)(cData + DEF_INDEX2_MSGTYPE);
	*wp  = DEF_OBJECTMOTION_REJECT;	
	cp   = (char *)(cData + DEF_INDEX2_MSGTYPE + 2); 
	sp  = (short *)cp;
	*sp = m_pClientList[iClientH]->m_sX; 
	cp += 2;
	sp  = (short *)cp;
	*sp = m_pClientList[iClientH]->m_sY; 
	cp += 2;	
	iRet = m_pClientList[iClientH]->m_pXSock->iSendMsg(cData, 10);
	switch (iRet) {
	case DEF_XSOCKEVENT_QUENEFULL:
	case DEF_XSOCKEVENT_SOCKETERROR:
	case DEF_XSOCKEVENT_CRITICALERROR:
	case DEF_XSOCKEVENT_SOCKETCLOSED:
		DeleteClient(iClientH, TRUE, TRUE);
		return;
	}
	return;
}

int CGame::_iGetTotalClients()
{
 register int i, iTotal;

	iTotal = 0;
	for (i = 1; i < DEF_MAXCLIENTS; i++) 
	if (m_pClientList[i] != NULL) iTotal++;

	return iTotal;
}

void CGame::DynamicObjectEffectProcessor()
{
 register int i, ix, iy, iIndex;
 short sOwnerH, iDamage, sType, sAttacker;
 char  cOwnerType, cAttackerOwnerType;
 DWORD dwTime = timeGetTime();
 DWORD dwRegisterTime;

	for (i = 0; i < DEF_MAXDYNAMICOBJECTS; i++) 
	if (m_pDynamicObjectList[i] != NULL) 	// Added attacker responsability...	
	{	cAttackerOwnerType = m_pDynamicObjectList[i]->m_cOwnerType;
		if (cAttackerOwnerType == DEF_OWNERTYPE_PLAYER_INDIRECT)
		{	sAttacker = m_pDynamicObjectList[i]->m_sOwner;
			if (m_pClientList[sAttacker] == NULL) 
			{	sAttacker = 0;
				cAttackerOwnerType = NULL;
			}else if (strcmp(m_pClientList[sAttacker]->m_cCharName, m_pDynamicObjectList[i]->cOwnerName)!=0)
			{	sAttacker = 0;
				cAttackerOwnerType = NULL;
		}	}
		switch (m_pDynamicObjectList[i]->m_sType) {
		case DEF_DYNAMICOBJECT_PCLOUD_BEGIN:
			for (ix = m_pDynamicObjectList[i]->m_sX -1; ix <= m_pDynamicObjectList[i]->m_sX+1; ix++)
			for (iy = m_pDynamicObjectList[i]->m_sY -1; iy <= m_pDynamicObjectList[i]->m_sY+1; iy++) 				
			{	m_pMapList[m_pDynamicObjectList[i]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, ix, iy);
				if (sOwnerH != NULL) 				
				{	switch (cOwnerType) {	// Poison Damage
					case DEF_OWNERTYPE_PLAYER:
						if (m_pClientList[sOwnerH] == NULL) continue;
						if (m_pClientList[sOwnerH]->m_bIsKilled == TRUE) continue;	
						if (m_pClientList[sOwnerH]->m_bAntiTPLameEK == TRUE)  continue;						// 
						//if (m_pDynamicObjectList[i]->m_iV1 < 20)
						//	 iDamage = iDice(1,6);
						//else iDamage = iDice(1,8);
						// Snoopy: Increazed a bit ..because rain/snow will reduce it.
						if (m_pDynamicObjectList[i]->m_iV1 <= 20) // Was 20 or 40 in spells definition ....
							 iDamage = iDice(2,4); // 1..8 >> 2..8
						else iDamage = iDice(2,5); // 1..8 >> 2..10	
						// SNOOPY: Whether Bouns
						iDamage += iGetWhetherMagicBonusEffect(46, m_pMapList[m_pDynamicObjectList[i]->m_cMapIndex]->m_cWhetherStatus);
						if (iDamage < 1 ) iDamage = 1;
						// No damage on Travelers or GMS
						if (   (m_pClientList[sOwnerH]->m_iAdminUserLevel == 0)
							&& (m_pClientList[sOwnerH]->m_bIsNeutral == FALSE))
						m_pClientList[sOwnerH]->m_iHP -= iDamage;
						
						if (m_pClientList[sOwnerH]->m_iHP <= 0) 
						{	ClientKilledHandler(sOwnerH, sAttacker, cAttackerOwnerType, iDamage);	
	  					}else 
						{	if (iDamage > 0) 
							{	m_pClientList[sOwnerH]->m_dwLastDamageTime = dwTime;
								SendNotifyMsg(NULL, sOwnerH, DEF_NOTIFY_HP, NULL, NULL, NULL, NULL);
								// Poison hardlly unPara, but removes Medusa kiss
								if (m_pClientList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_HOLDOBJECT ] == 20)     // Medusa kiss
								{	SendNotifyMsg(NULL, sOwnerH, DEF_NOTIFY_MAGICEFFECTOFF, DEF_MAGICTYPE_HOLDOBJECT, 20, NULL, NULL);
									m_pClientList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_HOLDOBJECT ] = NULL;
									bRemoveFromDelayEventList(sOwnerH, DEF_OWNERTYPE_PLAYER, DEF_MAGICTYPE_HOLDOBJECT);
								}else if (m_pClientList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_HOLDOBJECT ] == 1) // Hold person
								{	SendNotifyMsg(NULL, sOwnerH, DEF_NOTIFY_MAGICEFFECTOFF, DEF_MAGICTYPE_HOLDOBJECT, 1, NULL, NULL);
									m_pClientList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_HOLDOBJECT ] = NULL;
									bRemoveFromDelayEventList(sOwnerH, DEF_OWNERTYPE_PLAYER, DEF_MAGICTYPE_HOLDOBJECT);
								}else if (   (m_pClientList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_HOLDOBJECT ] != 0) // PAra entangle
									&& (iDice(1, (m_pClientList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_HOLDOBJECT ]*4) ) == 1))
								{	SendNotifyMsg(NULL, sOwnerH, DEF_NOTIFY_MAGICEFFECTOFF, DEF_MAGICTYPE_HOLDOBJECT, 2, NULL, NULL);
									m_pClientList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_HOLDOBJECT ] = NULL;
									bRemoveFromDelayEventList(sOwnerH, DEF_OWNERTYPE_PLAYER, DEF_MAGICTYPE_HOLDOBJECT);
						 	}	}
							if (   (bCheckResistingMagicSuccess(0, sOwnerH, DEF_OWNERTYPE_PLAYER, 100) == FALSE) 
								&& (m_pClientList[sOwnerH]->m_bIsPoisoned == FALSE) ) 
							{	m_pClientList[sOwnerH]->m_bIsPoisoned  = TRUE;
								m_pClientList[sOwnerH]->m_iPoisonLevel = m_pDynamicObjectList[i]->m_iV1;
								m_pClientList[sOwnerH]->m_dwPoisonTime = dwTime;
								SetPoisonFlag(sOwnerH, cOwnerType, TRUE);// poison aura appears from dynamic objects
								SendNotifyMsg(NULL, sOwnerH, DEF_NOTIFY_MAGICEFFECTON, DEF_MAGICTYPE_POISON, m_pClientList[sOwnerH]->m_iPoisonLevel, NULL, NULL);
						}	}
						break;

					case DEF_OWNERTYPE_NPC:
						if (m_pNpcList[sOwnerH] == NULL) continue;
						if (m_pDynamicObjectList[i]->m_iV1 < 20)
							 iDamage = iDice(2,4);
						else iDamage = iDice(2,5);	
						// SNOOPY: Whether Bouns
						iDamage += iGetWhetherMagicBonusEffect(46, m_pMapList[m_pDynamicObjectList[i]->m_cMapIndex]->m_cWhetherStatus);
						if (iDamage < 1 ) iDamage = 1;				
						// HP
						switch (m_pNpcList[sOwnerH]->m_cActionLimit) {
						case 2: // merchants
						case 3: // Dummy
						case 4: // energy sphere
						case 5: // Crusade structures
						case 6: // moving merchants
						case 8: // Heldenian gate.
						default:
							iDamage = 0;
						case 0: // normal monster
						case 1: // never runner monster
							m_pNpcList[sOwnerH]->m_iHP -= iDamage;
							// SNOOPY: Poison cloud can poison npc
							if ((bCheckResistingMagicSuccess(0, sOwnerH, DEF_OWNERTYPE_NPC, 100) == FALSE)
								&& (bCheckResistingPoisonSuccess(sOwnerH, DEF_OWNERTYPE_NPC) == FALSE) )			
							{	if (m_pNpcList[sOwnerH]->m_iPoisonLevel < m_pDynamicObjectList[i]->m_iV1) 
									m_pNpcList[sOwnerH]->m_iPoisonLevel = m_pDynamicObjectList[i]->m_iV1; 
								SetPoisonFlag(sOwnerH, cOwnerType, TRUE);// poison aura appears from dynamic objects
							}
							if (m_pNpcList[sOwnerH]->m_iHP <= 0) 
							{	NpcKilledHandler(sAttacker, cAttackerOwnerType, sOwnerH, 0); 	
							}else 
							{	if (iDice(1,3) == 2) m_pNpcList[sOwnerH]->m_dwTime = dwTime;
								// Damage hardlly removes para
								if (   (m_pNpcList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_HOLDOBJECT ] != 0)
									&& (iDice(1, (m_pNpcList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_HOLDOBJECT ]*4)) == 1)) 
								{	m_pNpcList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_HOLDOBJECT ] = NULL;
									bRemoveFromDelayEventList(sOwnerH, DEF_OWNERTYPE_NPC, DEF_MAGICTYPE_HOLDOBJECT);
								}		
					 			SendEventToNearClient_TypeA(sOwnerH, DEF_OWNERTYPE_NPC, MSGID_EVENT_MOTION, DEF_OBJECTDAMAGE, iDamage, 0, NULL);
							}
							break;
						}
						break;
			}	}	}
			break;
						
		case DEF_DYNAMICOBJECT_ICESTORM:
			for (ix = m_pDynamicObjectList[i]->m_sX -2; ix <= m_pDynamicObjectList[i]->m_sX+2; ix++)
			for (iy = m_pDynamicObjectList[i]->m_sY -2; iy <= m_pDynamicObjectList[i]->m_sY+2; iy++) 
			{	m_pMapList[m_pDynamicObjectList[i]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, ix, iy);
				if (sOwnerH != NULL) 
				{	switch (cOwnerType) {
					case DEF_OWNERTYPE_PLAYER:
						if (m_pClientList[sOwnerH] == NULL) continue;
						if (m_pClientList[sOwnerH]->m_bIsKilled == TRUE) continue;
						if (m_pClientList[sOwnerH]->m_bAntiTPLameEK == TRUE)  continue;						
						//iDamage = iDice(3,3) + 5;// Increased damages a bit
						iDamage = iDice(3,4) + 5;
						// iGetWhetherMagicBonusEffect
						// SNOOPY: Whether Bouns
						iDamage += iGetWhetherMagicBonusEffect(55, m_pMapList[m_pDynamicObjectList[i]->m_cMapIndex]->m_cWhetherStatus);
						if (iDamage < 1 ) iDamage=1;						
						// No damage on Travelers or GMS
						if (   (m_pClientList[sOwnerH]->m_iAdminUserLevel == 0)
							&& (m_pClientList[sOwnerH]->m_bIsNeutral == FALSE))
						m_pClientList[sOwnerH]->m_iHP -= iDamage;						
						if (m_pClientList[sOwnerH]->m_iHP <= 0) 
						{	ClientKilledHandler(sOwnerH, sAttacker, cAttackerOwnerType, iDamage);
	  					}else 
						{	if (iDamage > 0) 
							{	m_pClientList[sOwnerH]->m_dwLastDamageTime = dwTime;
								SendNotifyMsg(NULL, sOwnerH, DEF_NOTIFY_HP, NULL, NULL, NULL, NULL);
								// Only removes Hold Person & Medusa kiss, but not Para (2+)
								if (m_pClientList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_HOLDOBJECT ] == 20) // Medusa kiss
								{	SendNotifyMsg(NULL, sOwnerH, DEF_NOTIFY_MAGICEFFECTOFF, DEF_MAGICTYPE_HOLDOBJECT , 20, NULL, NULL);
									m_pClientList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_HOLDOBJECT ] = NULL;
									bRemoveFromDelayEventList(sOwnerH, DEF_OWNERTYPE_PLAYER, DEF_MAGICTYPE_HOLDOBJECT);
						 		}else if (m_pClientList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_HOLDOBJECT ] == 1)      // Hold person
								{	SendNotifyMsg(NULL, sOwnerH, DEF_NOTIFY_MAGICEFFECTOFF, DEF_MAGICTYPE_HOLDOBJECT , 1, NULL, NULL);
									m_pClientList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_HOLDOBJECT ] = NULL;
									bRemoveFromDelayEventList(sOwnerH, DEF_OWNERTYPE_PLAYER, DEF_MAGICTYPE_HOLDOBJECT); 
						 	}	}
							if (   (bCheckResistingIceSuccess(0, sOwnerH, DEF_OWNERTYPE_PLAYER, m_pDynamicObjectList[i]->m_iV1) == FALSE) 
								&& (m_pClientList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_ICE ] == 0) ) 								
							{	m_pClientList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_ICE ] = 1;
								SetIceFlag(sOwnerH, cOwnerType, TRUE);
								bRegisterDelayEvent(DEF_DELAYEVENTTYPE_MAGICRELEASE, DEF_MAGICTYPE_ICE, dwTime + (20*1000), 
									                sOwnerH, cOwnerType, NULL, NULL, NULL, 1, NULL, NULL);
								SendNotifyMsg(NULL, sOwnerH, DEF_NOTIFY_MAGICEFFECTON, DEF_MAGICTYPE_ICE, 1, NULL, NULL);
						}	}
						break;

					case DEF_OWNERTYPE_NPC:
						if (m_pNpcList[sOwnerH] == NULL) continue;						
						iDamage = iDice(3,4) + 5;
						// SNOOPY: Whether Bouns
						iDamage += iGetWhetherMagicBonusEffect(55, m_pMapList[m_pDynamicObjectList[i]->m_cMapIndex]->m_cWhetherStatus);
						if (iDamage < 1 ) iDamage = 1;					
						switch (m_pNpcList[sOwnerH]->m_cActionLimit) {
						case 2: // merchants
						case 3: // Dummy
						case 4: // energy sphere
						case 6: // moving merchants
						default:
							iDamage = 0;
							break;
						case 5: // Crusade structures
						case 8: // Heldenian gate.
							iDamage = iDamage/2;
						case 0: // normal monster
						case 1: // never runner monster
							m_pNpcList[sOwnerH]->m_iHP -= iDamage;
							if (m_pNpcList[sOwnerH]->m_iHP <= 0) 
							{	NpcKilledHandler(sAttacker, cAttackerOwnerType, sOwnerH, 0); 
							}else // Damage removes hold only
							{	if (iDice(1,3) == 2) m_pNpcList[sOwnerH]->m_dwTime = dwTime;
								if (m_pNpcList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_HOLDOBJECT ] == 1) 
								{	m_pNpcList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_HOLDOBJECT ] = NULL;
								}						
					 			SendEventToNearClient_TypeA(sOwnerH, DEF_OWNERTYPE_NPC, MSGID_EVENT_MOTION, DEF_OBJECTDAMAGE, iDamage, 0, NULL);
								if (  (bCheckResistingIceSuccess(0, sOwnerH, DEF_OWNERTYPE_NPC, m_pDynamicObjectList[i]->m_iV1) == FALSE) 
									&& (m_pNpcList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_ICE ] == 0) ) 
								{	m_pNpcList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_ICE ] = 1;
									SetIceFlag(sOwnerH, cOwnerType, TRUE);
									bRegisterDelayEvent(DEF_DELAYEVENTTYPE_MAGICRELEASE, DEF_MAGICTYPE_ICE, dwTime + (20*1000), 
										sOwnerH, cOwnerType, NULL, NULL, NULL, 1, NULL, NULL);
							}	}
							break;
						}
					   	break;
				}	}
				// Damage on dead owner: Pretendcorpse
				m_pMapList[m_pDynamicObjectList[i]->m_cMapIndex]->GetDeadOwner(&sOwnerH, &cOwnerType, ix, iy);
				if (   (cOwnerType == DEF_OWNERTYPE_PLAYER) && (m_pClientList[sOwnerH] != NULL) 
					&& (m_pClientList[sOwnerH]->m_iHP > 0) ) 
				{	iDamage = iDice(6,4) + 10; // Increased serioully. iDamage = iDice(3,2);
					m_pClientList[sOwnerH]->m_iHP -= iDamage;						
					if (m_pClientList[sOwnerH]->m_iHP <= 0) 
					{	ClientKilledHandler(sOwnerH, sAttacker, cAttackerOwnerType, iDamage);
	  				}else 
					{	if (iDamage > 0) 
						{	m_pClientList[sOwnerH]->m_dwLastDamageTime = dwTime;
							SendNotifyMsg(NULL, sOwnerH, DEF_NOTIFY_HP, NULL, NULL, NULL, NULL);
				}	}	}
				// Reduce duration of Fire Object around
				m_pMapList[m_pDynamicObjectList[i]->m_cMapIndex]->bGetDynamicObject(ix, iy, &sType, &dwRegisterTime, &iIndex);
				if (((sType == DEF_DYNAMICOBJECT_FIRE) || (sType == DEF_DYNAMICOBJECT_FIRE3)) && (m_pDynamicObjectList[iIndex] != NULL)) 
					m_pDynamicObjectList[iIndex]->m_dwLastTime = m_pDynamicObjectList[iIndex]->m_dwLastTime - (m_pDynamicObjectList[iIndex]->m_dwLastTime/10);
			}
			break;
		
		case DEF_DYNAMICOBJECT_FIRE3: // FireBow's fire
		case DEF_DYNAMICOBJECT_FIRE2: // Crusade buildings burning.
		case DEF_DYNAMICOBJECT_FIRE:	// Fire-Wall		
			if (m_pDynamicObjectList[i]->m_iCount == 1) 
			{	CheckFireBluring(m_pDynamicObjectList[i]->m_cMapIndex, m_pDynamicObjectList[i]->m_sX, m_pDynamicObjectList[i]->m_sY);
			}
			m_pDynamicObjectList[i]->m_iCount++;
			if (m_pDynamicObjectList[i]->m_iCount > 10) m_pDynamicObjectList[i]->m_iCount = 10; 
			for (ix = m_pDynamicObjectList[i]->m_sX -1; ix <= m_pDynamicObjectList[i]->m_sX+1; ix++)
			for (iy = m_pDynamicObjectList[i]->m_sY -1; iy <= m_pDynamicObjectList[i]->m_sY+1; iy++) 				
			{	m_pMapList[m_pDynamicObjectList[i]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, ix, iy);
				if (sOwnerH != NULL) 
				{	// Fire Damage
					switch (cOwnerType) {					
					case DEF_OWNERTYPE_PLAYER:
						if (m_pClientList[sOwnerH] == NULL) continue;
						if (m_pClientList[sOwnerH]->m_bIsKilled == TRUE) continue;	
						if (m_pClientList[sOwnerH]->m_bAntiTPLameEK == TRUE)  continue;						
						//iDamage = iDice(1,6);	// Snoopy: Increazed a bit ..because rain/snow will reduce it.	.
						iDamage = iDice(2,4);			
						// SNOOPY: Whether Bouns
						iDamage += iGetWhetherMagicBonusEffect(40, m_pMapList[m_pDynamicObjectList[i]->m_cMapIndex]->m_cWhetherStatus);
						if (iDamage < 1 ) iDamage=1;
						// No damage on Travelers or GMS
						if (   (m_pClientList[sOwnerH]->m_iAdminUserLevel == 0)
							&& (m_pClientList[sOwnerH]->m_bIsNeutral == FALSE))
						m_pClientList[sOwnerH]->m_iHP -= iDamage;				
						if (m_pClientList[sOwnerH]->m_iHP <= 0) 
						{	ClientKilledHandler(sOwnerH, sAttacker, cAttackerOwnerType, iDamage);
	  					}else 
						{	if (iDamage > 0) 
							{	m_pClientList[sOwnerH]->m_dwLastDamageTime = dwTime;
								SendNotifyMsg(NULL, sOwnerH, DEF_NOTIFY_HP, NULL, NULL, NULL, NULL);
								// Fire good to unPara	 removes Medusa kiss
								if (m_pClientList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_HOLDOBJECT ] == 20) // Medusa kiss
								{	SendNotifyMsg(NULL, sOwnerH, DEF_NOTIFY_MAGICEFFECTOFF, DEF_MAGICTYPE_HOLDOBJECT, 20, NULL, NULL);
									m_pClientList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_HOLDOBJECT ] = NULL;
									bRemoveFromDelayEventList(sOwnerH, DEF_OWNERTYPE_PLAYER, DEF_MAGICTYPE_HOLDOBJECT);
								}else if (m_pClientList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_HOLDOBJECT ] == 1) // hold person
								{	SendNotifyMsg(NULL, sOwnerH, DEF_NOTIFY_MAGICEFFECTOFF, DEF_MAGICTYPE_HOLDOBJECT, 1, NULL, NULL);
									m_pClientList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_HOLDOBJECT ] = NULL;
									bRemoveFromDelayEventList(sOwnerH, DEF_OWNERTYPE_PLAYER, DEF_MAGICTYPE_HOLDOBJECT);  
								}else if (   (m_pClientList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_HOLDOBJECT ] != 0) // para Entangle 
									&& (iDice(1, (m_pClientList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_HOLDOBJECT ])) <= 2))
								{	SendNotifyMsg(NULL, sOwnerH, DEF_NOTIFY_MAGICEFFECTOFF, DEF_MAGICTYPE_HOLDOBJECT, 2, NULL, NULL);
									m_pClientList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_HOLDOBJECT ] = NULL;
									bRemoveFromDelayEventList(sOwnerH, DEF_OWNERTYPE_PLAYER, DEF_MAGICTYPE_HOLDOBJECT);
						}	}	}
						break;

					case DEF_OWNERTYPE_NPC:
						if (m_pNpcList[sOwnerH] == NULL) continue;						
						iDamage = iDice(2,4);	
						// SNOOPY: Whether Bouns
						iDamage += iGetWhetherMagicBonusEffect(40, m_pMapList[m_pDynamicObjectList[i]->m_cMapIndex]->m_cWhetherStatus);
						if (iDamage < 1 ) iDamage=1;												
						switch (m_pNpcList[sOwnerH]->m_cActionLimit) {
						case 2: // merchants
						case 4: // energy sphere
						case 6: // moving merchants
							iDamage = 0;
							break;
						case 3: // Dummy				More damage
						case 5: // Crusade structures	More damage
						case 8: // Heldenian gate.		More damage
							m_pNpcList[sOwnerH]->m_iHP -= iDamage;
						case 0: // normal monster
						case 1: // never runner monster
						default:
							// For self Fires, add HP instead of damaging (Fire Elemental)
							if ((cAttackerOwnerType == DEF_OWNERTYPE_NPC) && (sOwnerH == sAttacker))
							{	m_pNpcList[sOwnerH]->m_iHP += iDamage;							
								if (m_pNpcList[sOwnerH]->m_iHP > m_pNpcList[sOwnerH]->m_iHitDice*4) m_pNpcList[sOwnerH]->m_iHP = m_pNpcList[sOwnerH]->m_iHitDice*4;
							}else m_pNpcList[sOwnerH]->m_iHP -= iDamage;
							if (m_pNpcList[sOwnerH]->m_iHP <= 0) 
							{	NpcKilledHandler(sAttacker, cAttackerOwnerType, sOwnerH, 0); 
							}else // Damage removes para
							{	if (iDice(1,3) == 2) m_pNpcList[sOwnerH]->m_dwTime = dwTime;				
								// Fire good at unPara
								if (   (m_pNpcList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_HOLDOBJECT ] != 0)
									&& (iDice(1, (m_pNpcList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_HOLDOBJECT ]*2)) == 1)) 
								{	m_pNpcList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_HOLDOBJECT ] = NULL;
								}						
					 			SendEventToNearClient_TypeA(sOwnerH, DEF_OWNERTYPE_NPC, MSGID_EVENT_MOTION, DEF_OBJECTDAMAGE, iDamage, 0, NULL);
							}
							break;
						}
					   	break;
					}
				} //Pretend Corpse
				m_pMapList[m_pDynamicObjectList[i]->m_cMapIndex]->GetDeadOwner(&sOwnerH, &cOwnerType, ix, iy);
				if (    (cOwnerType == DEF_OWNERTYPE_PLAYER) && (m_pClientList[sOwnerH] != NULL) 
			 	     && (m_pClientList[sOwnerH]->m_iHP > 0) ) 
				{	iDamage = iDice(1,6);
					m_pClientList[sOwnerH]->m_iHP -= iDamage;						
					if (m_pClientList[sOwnerH]->m_iHP <= 0) 
					{	ClientKilledHandler(sOwnerH, sAttacker, cAttackerOwnerType, iDamage);
	  				}else 
					{	if (iDamage > 0) 
						{	m_pClientList[sOwnerH]->m_dwLastDamageTime = dwTime;
							SendNotifyMsg(NULL, sOwnerH, DEF_NOTIFY_HP, NULL, NULL, NULL, NULL);
				}	}	}
				// Reduce duration of Ice Object nearby
				m_pMapList[m_pDynamicObjectList[i]->m_cMapIndex]->bGetDynamicObject(ix, iy, &sType, &dwRegisterTime, &iIndex);
				if ((sType == DEF_DYNAMICOBJECT_ICESTORM) && (m_pDynamicObjectList[iIndex] != NULL)) 
					m_pDynamicObjectList[iIndex]->m_dwLastTime = m_pDynamicObjectList[iIndex]->m_dwLastTime - (m_pDynamicObjectList[iIndex]->m_dwLastTime/10);
			}
			break;	
	}	}
}

char _tmp_cCorpseX[] = {  0,  1, 1, 1, 0, -1, -1, -1, 0, 0, 0, 0};
char _tmp_cCorpseY[] = { -1, -1, 0, 1, 1,  1,  0, -1, 0, 0, 0};
void CGame::ClearSkillUsingStatus(int iClientH)
{register int i;
 short tX, fX, tY, fY;
	if (m_pClientList[iClientH] == NULL) return;
	if (m_pClientList[iClientH]->m_bSkillUsingStatus[19] == TRUE) // Pretend corpse
	{	tX = m_pClientList[iClientH]->m_sX;
		tY = m_pClientList[iClientH]->m_sY;
		if (m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->bGetMoveable(tX, tY, NULL) == FALSE) 
		{	fX = m_pClientList[iClientH]->m_sX + _tmp_cCorpseX[m_pClientList[iClientH]->m_cDir];
			fY = m_pClientList[iClientH]->m_sY + _tmp_cCorpseY[m_pClientList[iClientH]->m_cDir];
			if (m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->bGetMoveable(fX, fY, NULL) == FALSE) 
			{	m_pClientList[iClientH]->m_cDir = iDice(1,8);
				fX = m_pClientList[iClientH]->m_sX + _tmp_cCorpseX[m_pClientList[iClientH]->m_cDir];
				fY = m_pClientList[iClientH]->m_sY + _tmp_cCorpseY[m_pClientList[iClientH]->m_cDir];
				if (m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->bGetMoveable(fX , fY, NULL) == FALSE) 
				{	return;
			}	} 
			m_pClientList[iClientH]->m_iLastDamage = 0;
			m_pClientList[iClientH]->m_dwLastDamageMoveTime = timeGetTime();
			m_pClientList[iClientH]->m_dwDamageMoveCounter ++;
			SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_DAMAGEMOVE, m_pClientList[iClientH]->m_cDir, NULL, NULL, NULL);
		}
	}
	// SNOOPY: Taming
	if (m_pClientList[iClientH]->m_bSkillUsingStatus[22] == TRUE) 
	{	SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_SKILLUSINGEND, NULL, NULL, NULL, NULL);
		bRemoveFromDelayEventList(iClientH, DEF_OWNERTYPE_PLAYER, DEF_DELAYEVENTTYPE_TAMING_SKILL);
	}	
	for (i = 0; i < DEF_MAXSKILLTYPE; i++) 
	{	m_pClientList[iClientH]->m_bSkillUsingStatus[i] = FALSE;
		m_pClientList[iClientH]->m_iSkillUsingTimeID[i] = NULL;
	}	
	if (m_pClientList[iClientH]->m_iAllocatedFish != NULL) 
	{	if (m_pFish[m_pClientList[iClientH]->m_iAllocatedFish] != NULL) 
			m_pFish[m_pClientList[iClientH]->m_iAllocatedFish]->m_sEngagingCount--;
		m_pClientList[iClientH]->m_iAllocatedFish = NULL;
		SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_FISHCANCELED, NULL, NULL, NULL, NULL);
	}
}

int CGame::iCalculateUseSkillItemEffect(int iOwnerH, char cOwnerType, char cOwnerSkill, int iSkillNum, char cMapIndex, int dX, int dY)
{
 class CItem * pItem;
 char  cItemName[21];
 short lX, lY;
 int   iResult, iFish;

	switch (cOwnerType) {
	case DEF_OWNERTYPE_PLAYER:
		if (m_pClientList[iOwnerH] == NULL) return 0;
		if (m_pClientList[iOwnerH]->m_cMapIndex != cMapIndex) return 0;
		lX = m_pClientList[iOwnerH]->m_sX;
		lY = m_pClientList[iOwnerH]->m_sY;
		break;

	case DEF_OWNERTYPE_NPC:
		if (m_pNpcList[iOwnerH] == NULL) return 0;
		if (m_pNpcList[iOwnerH]->m_cMapIndex != cMapIndex) return 0;
		lX = m_pNpcList[iOwnerH]->m_sX;
		lY = m_pNpcList[iOwnerH]->m_sY;
		break;
	}

	if (cOwnerSkill == 0) return 0;
		iResult = iDice(1, 105);
	if (cOwnerSkill <= iResult)	return 0; 
	if (m_pMapList[cMapIndex]->bGetIsWater(dX, dY) == FALSE) return 0;

	if (cOwnerType == DEF_OWNERTYPE_PLAYER)
		CalculateSSN_SkillIndex(iOwnerH, iSkillNum, 1);

	switch (m_pSkillConfigList[iSkillNum]->m_sType) {
	case DEF_SKILLEFFECTTYPE_GET: 
		ZeroMemory(cItemName, sizeof(cItemName));
		switch (m_pSkillConfigList[iSkillNum]->m_sValue1) {
		case 1:
			wsprintf(cItemName, "Meat");
			break;
		case 2:
	//if (m_pMapList[cMapIndex]->bGetIsWater(dX, dY) == FALSE) return 0; 			
			if (cOwnerType == DEF_OWNERTYPE_PLAYER) 
			{	iFish = iCheckFish(iOwnerH, cMapIndex, dX, dY);
		   		if (iFish == NULL) wsprintf(cItemName, "Fish");
			}else wsprintf(cItemName, "Fish");
			break;
		}
		if (strlen(cItemName) != 0) 
		{	if (memcmp(cItemName, "Fish", 6) == 0) {
				SendNotifyMsg(NULL, iOwnerH, DEF_NOTIFY_FISHSUCCESS, NULL, NULL, NULL, NULL);
				m_pClientList[iOwnerH]->m_iExpStock += iDice(1,2);
			}			
			pItem = new class CItem;
			if (pItem == NULL) return 0;
			if (_bInitItemAttr(pItem, cItemName) == TRUE) 
			{	m_pMapList[cMapIndex]->bSetItem(lX, lY, pItem);
				SendEventToNearClient_TypeB(MSGID_EVENT_COMMON, DEF_COMMONTYPE_ITEMDROP, cMapIndex,
					lX, lY, pItem->m_sSprite, pItem->m_sSpriteFrame, pItem->m_cItemColor); 
		}	}
		break;
	}
	return 1;
}

void CGame::UseSkillHandler(int iClientH, int iV1, int iV2, int iV3)
{char  cOwnerType;
 short sAttackerWeapon, sOwnerH;
 int   iResult, iPlayerSkillLevel;
	char cTemp[256];
	if (m_pClientList[iClientH] == NULL) return;
	if (m_pClientList[iClientH]->m_bIsInitComplete == FALSE) return;

	if ((iV1 < 0) || (iV1 >= DEF_MAXSKILLTYPE)) return;
	if (m_pSkillConfigList[iV1]	== NULL) return;
	if (m_pClientList[iClientH]->m_bSkillUsingStatus[iV1] == TRUE) return;

	/*	if (iV1 != 19) {
		m_pClientList[iClientH]->m_iAbuseCount++;
		if ((m_pClientList[iClientH]->m_iAbuseCount % 30) == 0) {
			wsprintf(G_cTxt, "(!) Ã‡Ã˜Ã…Â· Â¿Ã«Ã€Ã‡Ã€Ãš(%s) Skill(%d) Tries(%d)",m_pClientList[iClientH]->m_cCharName, 
				                                                       iV1, m_pClientList[iClientH]->m_iAbuseCount);
			PutLogFileList(G_cTxt);
		}
	}	*/
	iPlayerSkillLevel = m_pClientList[iClientH]->m_cSkillMastery[iV1];
	iResult = iDice(1, 100);
	// SNOOPY revamped for Taming
	switch (m_pSkillConfigList[iV1]->m_sType) {
	case DEF_SKILLEFFECTTYPE_PRETEND: //type 2
		if (iResult > iPlayerSkillLevel) {
			SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_SKILLUSINGEND, NULL, NULL, NULL, NULL);
			return;
		}
		switch (m_pSkillConfigList[iV1]->m_sValue1) {
		case 1: // Pretend corpse
			if (m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_bIsFightZone == TRUE) 
			{	SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_SKILLUSINGEND, NULL, NULL, NULL, NULL);
				return;
			}
			m_pMapList[ m_pClientList[iClientH]->m_cMapIndex ]->GetDeadOwner(&sOwnerH, &cOwnerType, m_pClientList[iClientH]->m_sX, m_pClientList[iClientH]->m_sY);
			if (sOwnerH != NULL) {
				SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_SKILLUSINGEND, NULL, NULL, NULL, NULL);
				return;
			}
			// check if somebody is just aside
			iResult = 0;
			if (m_pClientList[iClientH]->m_iAdminUserLevel <= 0) {
				m_pMapList[ m_pClientList[iClientH]->m_cMapIndex ]->GetOwner(&sOwnerH, &cOwnerType, m_pClientList[iClientH]->m_sX, m_pClientList[iClientH]->m_sY-1);
				iResult += sOwnerH;
				m_pMapList[ m_pClientList[iClientH]->m_cMapIndex ]->GetOwner(&sOwnerH, &cOwnerType, m_pClientList[iClientH]->m_sX, m_pClientList[iClientH]->m_sY+1);
				iResult += sOwnerH;
				m_pMapList[ m_pClientList[iClientH]->m_cMapIndex ]->GetOwner(&sOwnerH, &cOwnerType, m_pClientList[iClientH]->m_sX-1, m_pClientList[iClientH]->m_sY);
				iResult += sOwnerH;
				m_pMapList[ m_pClientList[iClientH]->m_cMapIndex ]->GetOwner(&sOwnerH, &cOwnerType, m_pClientList[iClientH]->m_sX+1, m_pClientList[iClientH]->m_sY);
				iResult += sOwnerH;
				m_pMapList[ m_pClientList[iClientH]->m_cMapIndex ]->GetOwner(&sOwnerH, &cOwnerType, m_pClientList[iClientH]->m_sX-1, m_pClientList[iClientH]->m_sY-1);
				iResult += sOwnerH;
				m_pMapList[ m_pClientList[iClientH]->m_cMapIndex ]->GetOwner(&sOwnerH, &cOwnerType, m_pClientList[iClientH]->m_sX+1, m_pClientList[iClientH]->m_sY-1);
				iResult += sOwnerH;
				m_pMapList[ m_pClientList[iClientH]->m_cMapIndex ]->GetOwner(&sOwnerH, &cOwnerType, m_pClientList[iClientH]->m_sX-1, m_pClientList[iClientH]->m_sY+1);
				iResult += sOwnerH;
				m_pMapList[ m_pClientList[iClientH]->m_cMapIndex ]->GetOwner(&sOwnerH, &cOwnerType, m_pClientList[iClientH]->m_sX+1, m_pClientList[iClientH]->m_sY+1);
				iResult += sOwnerH;
			}
			if (iResult != 0) {
				SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_SKILLUSINGEND, NULL, NULL, NULL, NULL);
				return;
			}
			CalculateSSN_SkillIndex(iClientH, iV1, 1);
			sAttackerWeapon = 1;
			SendEventToNearClient_TypeA(iClientH, DEF_OWNERTYPE_PLAYER, MSGID_EVENT_MOTION, DEF_OBJECTDYING, 0, sAttackerWeapon, NULL);
			m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->ClearOwner(14, iClientH, DEF_OWNERTYPE_PLAYER, m_pClientList[iClientH]->m_sX, m_pClientList[iClientH]->m_sY);
			m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->SetDeadOwner(iClientH, DEF_OWNERTYPE_PLAYER, m_pClientList[iClientH]->m_sX, m_pClientList[iClientH]->m_sY);
			m_pClientList[iClientH]->m_bSkillUsingStatus[iV1] = TRUE;			
			break;
		}
		break;
	case DEF_SKILLEFFECTTYPE_TAMING: // SNOOPY: Implemented this.
		if (   ((m_pClientList[iClientH]->m_iStatus & 0x00000010) == 0)      // Invi character can not tame !
			&& (m_pClientList[iClientH]->m_bSkillUsingStatus[19] == FALSE)) // PretendCorpse character canot Tame
		{	m_pClientList[iClientH]->m_bSkillUsingStatus[iV1] = TRUE;
			m_pClientList[iClientH]->m_iSkillUsingTimeID[iV1] = (int)timeGetTime();
			// Register delay to perform Taming
			bRegisterDelayEvent(DEF_DELAYEVENTTYPE_TAMING_SKILL // int iDelayType
						, 22 // int iEffectType
						, timeGetTime() + m_pSkillConfigList[22]->m_sValue2*100 // nbe of 1/10th seconds in Skill.cfg
						, iClientH // int iTargetH
						, DEF_OWNERTYPE_PLAYER // char cTargetType
						, m_pClientList[iClientH]->m_cMapIndex // char cMapIndex
						, m_pClientList[iClientH]->m_sX // int X
						, m_pClientList[iClientH]->m_sY // int Y
						, (int )m_pClientList[iClientH]->m_bSkillUsingStatus[iV1] // int iV1
						, m_pClientList[iClientH]->m_iSkillUsingTimeID[iV1] // int iV2
						, NULL); // int iV3
	ZeroMemory(cTemp, sizeof(cTemp));
	wsprintf(cTemp, "Taming in progress...");	
ChatMsgHandlerGSM(0, 0, m_pClientList[iClientH]->m_cCharName, cTemp, (DWORD) sizeof(cTemp));		
		}else SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_SKILLUSINGEND, NULL, NULL, NULL, NULL);
		break;
	}
}

void CGame::ReqSellItemHandler(int iClientH, char cItemID, char cSellToWhom, int iNum, char * pItemName)
{char cItemCategory,cItemName[21];
 short sRemainLife;
 int   iPrice;
 double d1, d2, d3;
 BOOL   bNeutral;
 DWORD  dwSWEType, dwSWEValue, dwAddPrice1, dwAddPrice2, dwMul1, dwMul2;
 CItem * m_pGold;
	if (m_pClientList[iClientH] == NULL) return;
	if (m_pClientList[iClientH]->m_bIsInitComplete == FALSE) return;
	if ((cItemID < 0) || (cItemID >= 50)) return;
	if (m_pClientList[iClientH]->m_pItemList[cItemID] == NULL) return;
	if (iNum <= 0) return;
	if (m_pClientList[iClientH]->m_pItemList[cItemID]->m_dwCount < iNum) return;
	iCalcTotalWeight(iClientH);
	m_pGold = new class CItem;
	ZeroMemory(cItemName, sizeof(cItemName));
	wsprintf(cItemName, "Gold");
	_bInitItemAttr(m_pGold, cItemName);
	bNeutral = FALSE;
	if (memcmp(m_pClientList[iClientH]->m_cLocation, "NONE", 4) == 0) bNeutral = TRUE;
	switch (cSellToWhom) {
	case 15: 		// BS
	case 24:        // Shop
		cItemCategory = m_pClientList[iClientH]->m_pItemList[cItemID]->m_cCategory;
		if ( (cItemCategory > 20) && (cItemCategory < 51) ) 
		{	iPrice = (m_pClientList[iClientH]->m_pItemList[cItemID]->m_wPrice / 2)*iNum;
			sRemainLife = m_pClientList[iClientH]->m_pItemList[cItemID]->m_wCurLifeSpan;
			// 1/2 price for travellers
			if (bNeutral == TRUE) iPrice = iPrice/2;
			if (iPrice <= 0)    iPrice = 1;
			if (iPrice > 1000000) iPrice = 1000000;
			if (m_pClientList[iClientH]->m_iCurWeightLoad + iGetItemWeight(m_pGold, iPrice) > (DWORD)_iCalcMaxLoad(iClientH)) 
			{	SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_CANNOTSELLITEM, cItemID, 4, NULL, m_pClientList[iClientH]->m_pItemList[cItemID]->m_cName);
			}else SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_SELLITEMPRICE, cItemID, sRemainLife, iPrice, m_pClientList[iClientH]->m_pItemList[cItemID]->m_cName, iNum);
		}else if ( (cItemCategory > 0) && (cItemCategory < 21) ) 
		{	// Weapons armors those items can have best value for stats...
			sRemainLife = m_pClientList[iClientH]->m_pItemList[cItemID]->m_wCurLifeSpan;
			if (sRemainLife == 0) 
			{	SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_CANNOTSELLITEM, cItemID, 2, NULL, m_pClientList[iClientH]->m_pItemList[cItemID]->m_cName);
			}else 
			{	d1 = (double)sRemainLife;
				if (m_pClientList[iClientH]->m_pItemList[cItemID]->m_wMaxLifeSpan != 0)
					d2 = (double)m_pClientList[iClientH]->m_pItemList[cItemID]->m_wMaxLifeSpan;
				else d2 = 1.0f;
				d3 = (d1 / d2) * 0.5f;
				d2 = (double)m_pClientList[iClientH]->m_pItemList[cItemID]->m_wPrice; 
				d3 = d3 * d2; 
				iPrice = (int)d3;
				iPrice = iPrice*iNum;
				dwAddPrice1 = 0;
				dwAddPrice2 = 0;
				if ((m_pClientList[iClientH]->m_pItemList[cItemID]->m_dwAttribute & 0x00F00000) != NULL) 
				{	dwSWEType  = (m_pClientList[iClientH]->m_pItemList[cItemID]->m_dwAttribute & 0x00F00000) >> 20;  
					dwSWEValue = (m_pClientList[iClientH]->m_pItemList[cItemID]->m_dwAttribute & 0x000F0000) >> 16;
					switch (dwSWEType) {
					case 1: dwMul1 = 4; break;  // Critical
					case 2: dwMul1 = 6; break;  // Poisonous
					case 3: dwMul1 = 15; break; // Rite
					case 4: dwMul1 = 10; break; // Wizard's
					case 5: dwMul1 = 3; break;  // Agile
					case 6: dwMul1 = 2; break;  // Light
					case 7: dwMul1 = 5; break;  // Sharp
					case 8: dwMul1 = 2; break;  // Strong
					case 9: dwMul1 = 20; break; // Ancient
					default: dwMul1 = 1; break;
					}
					d1 = (double)iPrice*dwMul1;
					switch (dwSWEValue) {
					case 1: d2 = 10.0f; break;
					case 2: d2 = 20.0f; break;
					case 3: d2 = 30.0f; break;
					case 4: d2 = 35.0f; break;
					case 5: d2 = 40.0f; break;
					case 6: d2 = 50.0f; break;
					case 7: d2 = 100.0f; break;
					case 8: d2 = 200.0f; break;
					case 9: d2 = 300.0f; break;
					case 10: d2 = 400.0f; break;
					case 11: d2 = 500.0f; break;
					case 12: d2 = 700.0f; break;
					case 13: d2 = 900.0f; break;
					default: d2 = 0.0f; break;
					}
					d3 = d1*(d2/100.0f);
					dwAddPrice1 = (int)(d1 + d3);
				}
				if ((m_pClientList[iClientH]->m_pItemList[cItemID]->m_dwAttribute & 0x0000F000) != NULL) 
				{	dwSWEType  = (m_pClientList[iClientH]->m_pItemList[cItemID]->m_dwAttribute & 0x0000F000) >> 12;  
					dwSWEValue = (m_pClientList[iClientH]->m_pItemList[cItemID]->m_dwAttribute & 0x00000F00) >> 8;
					switch (dwSWEType) {
					case 1: 
					case 12: dwMul2 = 2; break;
					case 2:
					case 3:
					case 4:
					case 5:
					case 6:
					case 7: dwMul2 = 4; break;
					case 8:
					case 9:
					case 10:
					case 11: dwMul2 = 6; break;
					}
					d1 = (double)iPrice*dwMul2;
					switch (dwSWEValue) {
					case 1: d2 = 10.0f; break;
					case 2: d2 = 20.0f; break;
					case 3: d2 = 30.0f; break;
					case 4: d2 = 35.0f; break;
					case 5: d2 = 40.0f; break;
					case 6: d2 = 50.0f; break;
					case 7: d2 = 100.0f; break;
					case 8: d2 = 200.0f; break;
					case 9: d2 = 300.0f; break;
					case 10: d2 = 400.0f; break;
					case 11: d2 = 500.0f; break;
					case 12: d2 = 700.0f; break;
					case 13: d2 = 900.0f; break;
					default: d2 = 0.0f; break;
					}
					d3 = d1*(d2/100.0f);
					dwAddPrice2 = (int)(d1 + d3);
				}
				iPrice = iPrice + (dwAddPrice1 - (dwAddPrice1/3)) + (dwAddPrice2 - (dwAddPrice2/3));
				if (bNeutral == TRUE) iPrice = iPrice/2;
				if (iPrice <= 0)    iPrice = 1;
				if (iPrice > 1000000) iPrice = 1000000;
				if (m_pClientList[iClientH]->m_iCurWeightLoad + iGetItemWeight(m_pGold, iPrice) > (DWORD)_iCalcMaxLoad(iClientH)) 
				{	SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_CANNOTSELLITEM, cItemID, 4, NULL, m_pClientList[iClientH]->m_pItemList[cItemID]->m_cName);
				}else SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_SELLITEMPRICE, cItemID, sRemainLife, iPrice, m_pClientList[iClientH]->m_pItemList[cItemID]->m_cName, iNum);
			}
		}else SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_CANNOTSELLITEM, cItemID, 1, NULL, m_pClientList[iClientH]->m_pItemList[cItemID]->m_cName);
		break;
	default:
		break;
	}
	if (m_pGold != NULL) delete m_pGold;
}

void CGame::ReqSellItemConfirmHandler(int iClientH, char cItemID, int iNum, char * pString)
{class CItem * pItemGold;
 short sRemainLife;
 int   iPrice;
 double d1, d2, d3;
 char   * cp, cItemName[21], cData[120], cItemCategory;
 DWORD  * dwp, dwMul1, dwMul2, dwSWEType, dwSWEValue, dwAddPrice1, dwAddPrice2;
 WORD   * wp;
 int    iEraseReq, iRet;
 short * sp;
 BOOL   bNeutral;

	if (m_pClientList[iClientH] == NULL) return;
	if (m_pClientList[iClientH]->m_bIsInitComplete == FALSE) return;
	if ((cItemID < 0) || (cItemID >= 50)) return;
	if (m_pClientList[iClientH]->m_pItemList[cItemID] == NULL) return;
	if (iNum <= 0) return;
	if (m_pClientList[iClientH]->m_pItemList[cItemID]->m_dwCount < iNum) return;
	if (m_pClientList[iClientH]->m_pIsProcessingAllowed == FALSE) return;

	iCalcTotalWeight(iClientH);
	cItemCategory = m_pClientList[iClientH]->m_pItemList[cItemID]->m_cCategory;
	bNeutral = FALSE;
	if (memcmp(m_pClientList[iClientH]->m_cLocation, "NONE", 4) == 0) bNeutral = TRUE;
  	if ( (cItemCategory > 0) && (cItemCategory < 21) ) 
	{	sRemainLife = m_pClientList[iClientH]->m_pItemList[cItemID]->m_wCurLifeSpan;		
		if (sRemainLife <= 0) 
		{	return;
		}else 
		{	d1 = (double)sRemainLife;
			if (m_pClientList[iClientH]->m_pItemList[cItemID]->m_wMaxLifeSpan != 0)
				d2 = (double)m_pClientList[iClientH]->m_pItemList[cItemID]->m_wMaxLifeSpan;
			else d2 = 1.0f;
			d3 = (d1 / d2) * 0.5f;
			d2 = (double)m_pClientList[iClientH]->m_pItemList[cItemID]->m_wPrice; 
			d3 = d3 * d2; 			
			iPrice = (short)d3;
			iPrice = iPrice*iNum;
			dwAddPrice1 = 0;
			dwAddPrice2 = 0;
			if ((m_pClientList[iClientH]->m_pItemList[cItemID]->m_dwAttribute & 0x00F00000) != NULL) 
			{	dwSWEType  = (m_pClientList[iClientH]->m_pItemList[cItemID]->m_dwAttribute & 0x00F00000) >> 20;  
				dwSWEValue = (m_pClientList[iClientH]->m_pItemList[cItemID]->m_dwAttribute & 0x000F0000) >> 16;
				switch (dwSWEType) {
				case 1: dwMul1 = 4; break;  // Critical
				case 2: dwMul1 = 6; break;  // Poisonous
				case 3: dwMul1 = 15; break; // Rite
				case 4: dwMul1 = 10; break; // Wizard's
				case 5: dwMul1 = 3; break;  // Agile
				case 6: dwMul1 = 2; break;  // Light
				case 7: dwMul1 = 5; break;  // Sharp
				case 8: dwMul1 = 2; break;  // Strong
				case 9: dwMul1 = 20; break; // Ancient
				default: dwMul1 = 1; break;
				}
				d1 = (double)iPrice*dwMul1;
				switch (dwSWEValue) {
				case 1: d2 = 10.0f; break;
				case 2: d2 = 20.0f; break;
				case 3: d2 = 30.0f; break;
				case 4: d2 = 35.0f; break;
				case 5: d2 = 40.0f; break;
				case 6: d2 = 50.0f; break;
				case 7: d2 = 100.0f; break;
				case 8: d2 = 200.0f; break;
				case 9: d2 = 300.0f; break;
				case 10: d2 = 400.0f; break;
				case 11: d2 = 500.0f; break;
				case 12: d2 = 700.0f; break;
				case 13: d2 = 900.0f; break;
				default: d2 = 0.0f; break;
				}
				d3 = d1*(d2/100.0f);
				dwAddPrice1 = (int)(d1 + d3);
			}
			if ((m_pClientList[iClientH]->m_pItemList[cItemID]->m_dwAttribute & 0x0000F000) != NULL) 
			{	dwSWEType  = (m_pClientList[iClientH]->m_pItemList[cItemID]->m_dwAttribute & 0x0000F000) >> 12;  
				dwSWEValue = (m_pClientList[iClientH]->m_pItemList[cItemID]->m_dwAttribute & 0x00000F00) >> 8;				
				switch (dwSWEType) {
				case 1: 
				case 12: dwMul2 = 2; break;					
				case 2:
				case 3:
				case 4:
				case 5:
				case 6:
				case 7: dwMul2 = 4; break;					
				case 8:
				case 9:
				case 10:
				case 11: dwMul2 = 6; break;
				}					
				d1 = (double)iPrice*dwMul2;
				switch (dwSWEValue) {
				case 1: d2 = 10.0f; break;
				case 2: d2 = 20.0f; break;
				case 3: d2 = 30.0f; break;
				case 4: d2 = 35.0f; break;
				case 5: d2 = 40.0f; break;
				case 6: d2 = 50.0f; break;
				case 7: d2 = 100.0f; break;
				case 8: d2 = 200.0f; break;
				case 9: d2 = 300.0f; break;
				case 10: d2 = 400.0f; break;
				case 11: d2 = 500.0f; break;
				case 12: d2 = 700.0f; break;
				case 13: d2 = 900.0f; break;
				default: d2 = 0.0f; break;
				}
				d3 = d1*(d2/100.0f);
				dwAddPrice2 = (int)(d1 + d3);
			}
			iPrice = iPrice + (dwAddPrice1 - (dwAddPrice1/3)) + (dwAddPrice2 - (dwAddPrice2/3));
			if (bNeutral == TRUE) iPrice = iPrice/2;
			if (iPrice <= 0) iPrice = 1;
			if (iPrice > 1000000) iPrice = 1000000;
			SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_ITEMSOLD, cItemID, NULL, NULL, NULL);
			_bItemLog(DEF_ITEMLOG_SELL, iClientH, (int) -1, m_pClientList[iClientH]->m_pItemList[cItemID]) ;
			if ((m_pClientList[iClientH]->m_pItemList[cItemID]->m_cItemType == DEF_ITEMTYPE_CONSUME) ||
				(m_pClientList[iClientH]->m_pItemList[cItemID]->m_cItemType == DEF_ITEMTYPE_ARROW)) 
			{	SetItemCount(iClientH, cItemID, m_pClientList[iClientH]->m_pItemList[cItemID]->m_dwCount - iNum);
			}	
			else // Last TRUE to prevent logging twice: Sell then Deplete
				ItemDepleteHandler(iClientH, cItemID, FALSE, TRUE); 
		}
	}else if ( (cItemCategory > 20) && (cItemCategory < 51) ) 
	{	iPrice = m_pClientList[iClientH]->m_pItemList[cItemID]->m_wPrice/2; 
		iPrice = iPrice*iNum;
		if (bNeutral == TRUE) iPrice = iPrice/2;
		if (iPrice <= 0) iPrice = 1;
		if (iPrice > 1000000) iPrice = 1000000; 
		SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_ITEMSOLD, cItemID, NULL, NULL, NULL);
		_bItemLog(DEF_ITEMLOG_SELL, iClientH, (int) -1, m_pClientList[iClientH]->m_pItemList[cItemID]);
		if ((m_pClientList[iClientH]->m_pItemList[cItemID]->m_cItemType == DEF_ITEMTYPE_CONSUME) ||
			(m_pClientList[iClientH]->m_pItemList[cItemID]->m_cItemType == DEF_ITEMTYPE_ARROW)) 
		{	SetItemCount(iClientH, cItemID, m_pClientList[iClientH]->m_pItemList[cItemID]->m_dwCount - iNum);
		}else // Last TRUE to prevent logging twice: Sell then Deplete
			ItemDepleteHandler(iClientH, cItemID, FALSE, TRUE);
	}else return; 
	if (iPrice <= 0) return;
	pItemGold = new class CItem;
	ZeroMemory(cItemName, sizeof(cItemName));
	wsprintf(cItemName, "Gold");
	_bInitItemAttr(pItemGold, cItemName);	
	pItemGold->m_dwCount = iPrice;	
	if (_bAddClientItemList(iClientH, pItemGold, &iEraseReq) == TRUE) 
	{	dwp  = (DWORD *)(cData + DEF_INDEX4_MSGID);
		*dwp = MSGID_NOTIFY;
		wp   = (WORD *)(cData + DEF_INDEX2_MSGTYPE);
		*wp  = DEF_NOTIFY_ITEMOBTAINED;		
		cp = (char *)(cData + DEF_INDEX2_MSGTYPE + 2);		
		*cp = 1;
		cp++;		
		memcpy(cp, pItemGold->m_cName, 20);
		cp += 20;		
		dwp  = (DWORD *)cp;
		*dwp = pItemGold->m_dwCount;
		cp += 4;		
		*cp = pItemGold->m_cItemType;
		cp++;		
		*cp = pItemGold->m_cEquipPos;
		cp++;		
		*cp = (char)0;
		cp++;		
		sp  = (short *)cp;
		*sp = pItemGold->m_sLevelLimit;
		cp += 2;		
		*cp = pItemGold->m_cGenderLimit;
		cp++;		
		wp = (WORD *)cp;
		*wp = pItemGold->m_wCurLifeSpan;
		cp += 2;		
		wp = (WORD *)cp;
		*wp = pItemGold->m_wWeight;
		cp += 2;		
		sp  = (short *)cp;
		*sp = pItemGold->m_sSprite;
		cp += 2;		
		sp  = (short *)cp;
		*sp = pItemGold->m_sSpriteFrame;
		cp += 2;
		*cp = pItemGold->m_cItemColor;
		cp++;
		*cp = (char)pItemGold->m_sItemSpecEffectValue2; // v1.41 
		cp++;		
		dwp = (DWORD *)cp;
		*dwp = pItemGold->m_dwAttribute;
		cp += 4;
		if (iEraseReq == 1)	delete pItemGold;
		iRet = m_pClientList[iClientH]->m_pXSock->iSendMsg(cData, 53);
		iCalcTotalWeight(iClientH);
		switch (iRet) {
		case DEF_XSOCKEVENT_QUENEFULL:
		case DEF_XSOCKEVENT_SOCKETERROR:
		case DEF_XSOCKEVENT_CRITICALERROR:
		case DEF_XSOCKEVENT_SOCKETCLOSED:
			DeleteClient(iClientH, TRUE, TRUE);
			break;
		}
	}else 
	{	m_pMapList[ m_pClientList[iClientH]->m_cMapIndex ]->bSetItem(m_pClientList[iClientH]->m_sX, 
			m_pClientList[iClientH]->m_sY, pItemGold);		
		SendEventToNearClient_TypeB(MSGID_EVENT_COMMON, DEF_COMMONTYPE_ITEMDROP, m_pClientList[iClientH]->m_cMapIndex,
			m_pClientList[iClientH]->m_sX, m_pClientList[iClientH]->m_sY,  
			pItemGold->m_sSprite, pItemGold->m_sSpriteFrame, pItemGold->m_cItemColor);
		iCalcTotalWeight(iClientH);
		dwp  = (DWORD *)(cData + DEF_INDEX4_MSGID);
		*dwp = MSGID_NOTIFY;
		wp   = (WORD *)(cData + DEF_INDEX2_MSGTYPE);
		*wp  = DEF_NOTIFY_CANNOTCARRYMOREITEM;		
		iRet = m_pClientList[iClientH]->m_pXSock->iSendMsg(cData, 6);
		switch (iRet) {
		case DEF_XSOCKEVENT_QUENEFULL:
		case DEF_XSOCKEVENT_SOCKETERROR:
		case DEF_XSOCKEVENT_CRITICALERROR:
		case DEF_XSOCKEVENT_SOCKETCLOSED:
			DeleteClient(iClientH, TRUE, TRUE);
			return;
		}
	}
}

void CGame::ReqRepairItemHandler(int iClientH, char cItemID, char cRepairWhom, char * pString)
{char cItemCategory;
 short sRemainLife, sPrice;
 double d1, d2, d3;
	if (m_pClientList[iClientH] == NULL) return;
	if (m_pClientList[iClientH]->m_bIsInitComplete == FALSE) return;
	if ((cItemID < 0) || (cItemID >= 50)) return;
	if (m_pClientList[iClientH]->m_pItemList[cItemID] == NULL) return;

	cItemCategory = m_pClientList[iClientH]->m_pItemList[cItemID]->m_cCategory;
	switch (cItemCategory) {
	default: // Cannot repair
		SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_CANNOTREPAIRITEM, cItemID, 1, NULL, m_pClientList[iClientH]->m_pItemList[cItemID]->m_cName);
		break;
	case 1:  // Weapons
	case 2:  // Unused
	case 3:  // Bows
	//case 4:// Single arrow
	case 5:  // Shields
	case 6:  // Armor.
	case 7:  // Unused
	case 8:	 // Wands
	case 9:  // Armor, not dyable
	case 10: // Armor, dyable
		if (cRepairWhom != 24) // 24 = BS ????
		{	SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_CANNOTREPAIRITEM, cItemID, 2, NULL, m_pClientList[iClientH]->m_pItemList[cItemID]->m_cName);
			return;
		}
		goto LABEL_REPAIR;
		break;
	case 11: // Clothes
	case 12: // Cape Boots
	case 13: // Clothes, Cape boot not dyeable
	case 15: // SantaSuit
	case 43: // Fishing rod
	case 46: // Rings Necks
		if (cRepairWhom != 15) 	// Shop ?
		{	SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_CANNOTREPAIRITEM, cItemID, 2, NULL, m_pClientList[iClientH]->m_pItemList[cItemID]->m_cName);
			return;
		}
LABEL_REPAIR:;
		sRemainLife = m_pClientList[iClientH]->m_pItemList[cItemID]->m_wCurLifeSpan;
		if (sRemainLife == 0) 
		{	sPrice = m_pClientList[iClientH]->m_pItemList[cItemID]->m_wPrice / 2;
		}else 
		{	d1 = (double)sRemainLife;
			if (m_pClientList[iClientH]->m_pItemList[cItemID]->m_wMaxLifeSpan != 0)
				d2 = (double)m_pClientList[iClientH]->m_pItemList[cItemID]->m_wMaxLifeSpan;
			else d2 = 1.0f;
			d3 = (d1 / d2) * 0.5f;
			d2 = (double)m_pClientList[iClientH]->m_pItemList[cItemID]->m_wPrice; 
			d3 = d3 * d2;			
			sPrice = (m_pClientList[iClientH]->m_pItemList[cItemID]->m_wPrice / 2) - (short)d3;
		}
		SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_REPAIRITEMPRICE, cItemID, sRemainLife, sPrice, m_pClientList[iClientH]->m_pItemList[cItemID]->m_cName);
		break;
	}
}

void CGame::ReqRepairItemCofirmHandler(int iClientH, char cItemID, char * pString)
{ short    sRemainLife, sPrice;
 char   * cp, cItemCategory, cData[120];
 double   d1, d2, d3;
 DWORD  * dwp, dwGoldCount;
 WORD   * wp;
 int      iRet, iGoldWeight;

	if (m_pClientList[iClientH] == NULL) return;
	if (m_pClientList[iClientH]->m_bIsInitComplete == FALSE) return;
	if ((cItemID < 0) || (cItemID >= 50)) return;
	if (m_pClientList[iClientH]->m_pItemList[cItemID] == NULL) return;
	if (m_pClientList[iClientH]->m_pIsProcessingAllowed == FALSE) return;
	cItemCategory = m_pClientList[iClientH]->m_pItemList[cItemID]->m_cCategory;
	switch (cItemCategory) {
	default: // Cannot repair
		SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_CANNOTREPAIRITEM, cItemID, 1, NULL, m_pClientList[iClientH]->m_pItemList[cItemID]->m_cName);
		break;
	case 1:  // Weapons
	case 2:  // ..Unused
	case 3:  // Bows
	//case 4:// Single arrow
	case 5:  // Shields
	case 6:  // Armor.
	case 7:  // ..Unused
	case 8:	 // Wands
	case 9:  // Armor, not dyable
	case 10: // Armor, dyable
	case 11: // Clothes
	case 12: // Cape Boots
	case 13: // Clothes, Cape, Boots, not dyeable
	case 15: // SantaSuit
	case 43: // Fishing rod
	case 46: // Rings Necks
		sRemainLife = m_pClientList[iClientH]->m_pItemList[cItemID]->m_wCurLifeSpan;
		if (sRemainLife == 0) 
		{	sPrice = m_pClientList[iClientH]->m_pItemList[cItemID]->m_wPrice / 2;
		}else 
		{	d1 = (double)abs(sRemainLife);
			if (m_pClientList[iClientH]->m_pItemList[cItemID]->m_wMaxLifeSpan != 0)
				d2 = (double)abs(m_pClientList[iClientH]->m_pItemList[cItemID]->m_wMaxLifeSpan);
			else d2 = 1.0f;
			d3 = (d1 / d2) * 0.5f;
			d2 = (double)m_pClientList[iClientH]->m_pItemList[cItemID]->m_wPrice;
			d3 = d3 * d2;			
			sPrice = (m_pClientList[iClientH]->m_pItemList[cItemID]->m_wPrice / 2) - (short)d3;
		}		
		dwGoldCount = dwGetItemCount(iClientH, "Gold");		
		if ( dwGoldCount < (DWORD)sPrice ) 
		{	dwp  = (DWORD *)(cData + DEF_INDEX4_MSGID);
			*dwp = MSGID_NOTIFY;
			wp   = (WORD *)(cData + DEF_INDEX2_MSGTYPE);
			*wp  = DEF_NOTIFY_NOTENOUGHGOLD;
			cp   = (char *)(cData + DEF_INDEX2_MSGTYPE + 2);
			*cp  = cItemID;
			cp++;			
			iRet = m_pClientList[iClientH]->m_pXSock->iSendMsg(cData, 7);
			switch (iRet) {
			case DEF_XSOCKEVENT_QUENEFULL:
			case DEF_XSOCKEVENT_SOCKETERROR:
			case DEF_XSOCKEVENT_CRITICALERROR:
			case DEF_XSOCKEVENT_SOCKETCLOSED:
				DeleteClient(iClientH, TRUE, TRUE);
				return;
			}
			return;
		}else // !BUG POINT .
		{	m_pClientList[iClientH]->m_pItemList[cItemID]->m_wCurLifeSpan = m_pClientList[iClientH]->m_pItemList[cItemID]->m_wMaxLifeSpan;
		 	SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_ITEMREPAIRED, cItemID, m_pClientList[iClientH]->m_pItemList[cItemID]->m_wCurLifeSpan, NULL, NULL);
			iGoldWeight = SetItemCount(iClientH, "Gold", dwGoldCount - sPrice );			
			iCalcTotalWeight(iClientH);
			m_stCityStatus[m_pClientList[iClientH]->m_cSide].iFunds += sPrice;
		}
		break;
	}
}

int CGame::iCalcTotalWeight(int iClientH)
{register int i, iWeight;
 short sItemIndex;	
	if (m_pClientList[iClientH] == NULL) return 0;	
	m_pClientList[iClientH]->m_iAlterItemDropIndex = -1;	// .
	for (sItemIndex = 0; sItemIndex < DEF_MAXITEMS; sItemIndex++)
	if  (m_pClientList[iClientH]->m_pItemList[sItemIndex] != NULL) 
	{	switch (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectType) {
		case DEF_ITEMEFFECTTYPE_ALTERITEMDROP:
			if (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_wCurLifeSpan > 0) 
			{	m_pClientList[iClientH]->m_iAlterItemDropIndex = sItemIndex;
			}
			break;
		case DEF_ITEMEFFECTTYPE_EVENT_ITEMDROP:
			m_pClientList[iClientH]->m_iEventItemDropIndex = sItemIndex;
			break;
	}	}
	iWeight = 0;
	for (i = 0; i < DEF_MAXITEMS; i++)
	if (m_pClientList[iClientH]->m_pItemList[i] != NULL) 
	{	iWeight += iGetItemWeight(m_pClientList[iClientH]->m_pItemList[i], m_pClientList[iClientH]->m_pItemList[i]->m_dwCount);
	}
	m_pClientList[iClientH]->m_iCurWeightLoad = iWeight;
	return iWeight;	
}

void CGame::CheckAndNotifyGServersConnection(int iClientH)
{ // by Snoopy to allow knowlegde of servers currentlly up
	if (m_pClientList[iClientH] == NULL) return;	
	char   * cp, cName[11], cBuff[256], * p_ErrorMsg;
	ZeroMemory(cName, sizeof(cName));
	ZeroMemory(cBuff, sizeof(cBuff));
	WORD * wp;
	cp = (char *)cBuff;
	*cp = GSM_REQUEST_FINDCHARACTER;
	cp++;
	wp = (WORD *)cp;
	*wp = m_wServerID_GSS;
	cp += 2;
	wp = (WORD *)cp;
	*wp = iClientH;
	cp += 2;
	memcpy(cp, cName, 10); // Empty 
	cp += 10;
	memcpy(cp, m_pClientList[iClientH]->m_cCharName, 10);
	cp += 10;
	bStockMsgToGateServer(cBuff, 25);
	// Current server	
	if (m_pClientList[iClientH]->m_iAdminUserLevel < m_iAdminLevelGoto)// not a GM
	{	wsprintf(G_cTxt, "The server %s is running.", m_cServerName);
	}else // valid GM
	{	wsprintf(G_cTxt, "The server %s is running. Players(%d/%d). "
			, m_cServerName
			, m_iTotalClients
			, m_iMaxClients);
		if (m_iBugWarning != 0) // send the red error msg to GM
		{	p_ErrorMsg = lstrcat(G_cTxt, m_cBugText);
		}
	}
	SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_IPACCOUNTINFO, NULL, NULL, NULL, G_cTxt);
}

void CGame::CheckAndNotifyPlayerConnection(int iClientH, char * pMsg, DWORD dwSize)
{char   seps[] = "= \t\n";
 char   * token, * cp, cName[11], cBuff[256], cPlayerLocation[120];
 class  CStrTok * pStrTok;
 register int i;
 WORD * wp;
	if (m_pClientList[iClientH] == NULL) return;
	if (dwSize <= 0) return;
	ZeroMemory(cPlayerLocation,sizeof(cPlayerLocation));
	ZeroMemory(cName, sizeof(cName));
	ZeroMemory(cBuff, sizeof(cBuff));
	memcpy(cBuff, pMsg, dwSize);
	pStrTok = new class CStrTok(cBuff, seps);
	token = pStrTok->pGet();
	token = pStrTok->pGet();
	if (token == NULL) {
		delete pStrTok;
		return;
	}
	if (strlen(token) > 10) 
		 memcpy(cName, token, 10);	
	else memcpy(cName, token, strlen(token));

	for (i = 1; i < DEF_MAXCLIENTS; i++) 
	if ((m_pClientList[i] != NULL) && (memcmp(cName, m_pClientList[i]->m_cCharName, 10) == 0)) 
	{	if(m_pClientList[iClientH]->m_iAdminUserLevel >= m_iAdminLevelGoto) // GM's get more info
		{	cp = (char *)cPlayerLocation;
			memcpy(cp,m_pClientList[i]->m_cMapName,10);
			cp += 10;
			wp = (WORD *)cp;
			*wp = m_pClientList[i]->m_sX;
			cp += 2;
			wp = (WORD *)cp;
			*wp = m_pClientList[i]->m_sY;
			cp += 2;
			wsprintf(G_cTxt, "GM Order(%-10s): /fi %s", m_pClientList[iClientH]->m_cCharName, cName);
			bSendMsgToLS(MSGID_GAMEMASTERLOG, iClientH, FALSE, G_cTxt);
		}
		SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_PLAYERONGAME, NULL, NULL, NULL, m_pClientList[i]->m_cCharName,NULL,NULL,NULL,NULL,NULL,NULL,cPlayerLocation);
		delete pStrTok;
		return;
	}
	// Client is not connected to current server, so ask other servers
	ZeroMemory(cBuff, sizeof(cBuff));
	cp = (char *)cBuff;
	*cp = GSM_REQUEST_FINDCHARACTER;
	cp++;
	wp = (WORD *)cp;
	*wp = m_wServerID_GSS;
	cp += 2;
	wp = (WORD *)cp;
	*wp = iClientH;
	cp += 2;
	memcpy(cp, cName, 10);
	cp += 10;
	memcpy(cp, m_pClientList[iClientH]->m_cCharName, 10);
	cp += 10;
	bStockMsgToGateServer(cBuff, 25);
	delete pStrTok;
}

void CGame::ToggleWhisperPlayer(int iClientH, char * pMsg, DWORD dwMsgSize)
{
 char   seps[] = "= \t\n";
 char   * token, cName[11], cBuff[256];
 class  CStrTok * pStrTok;
 register int i;
 char *cp;
 WORD *wp;

	if (m_pClientList[iClientH] == NULL) return;
	if (dwMsgSize <= 0) return;

	ZeroMemory(cName, sizeof(cName));
	ZeroMemory(cBuff, sizeof(cBuff));
	memcpy(cBuff, pMsg, dwMsgSize);

	pStrTok = new class CStrTok(cBuff, seps);
	token = pStrTok->pGet();
	token = pStrTok->pGet();
   	
	if (token == NULL) 
	{	m_pClientList[iClientH]->m_iWhisperPlayerIndex = -1;
		ZeroMemory(m_pClientList[iClientH]->m_cWhisperPlayerName, sizeof(m_pClientList[iClientH]->m_cWhisperPlayerName));
		m_pClientList[iClientH]->m_bIsCheckingWhisperPlayer = FALSE;
		SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_WHISPERMODEOFF, NULL, NULL, NULL, cName);
	}else 
	{	if (strlen(token) > 10)	
			 memcpy(cName, token, 10);
		else memcpy(cName, token, strlen(token));
		
		m_pClientList[iClientH]->m_iWhisperPlayerIndex = -1;

		for (i = 1; i < DEF_MAXCLIENTS; i++) 
			if ((m_pClientList[i] != NULL) && (memcmp(m_pClientList[i]->m_cCharName, cName, 10) == 0)) {
				if (i == iClientH) 
				{	delete pStrTok;
					return;
				}
				m_pClientList[iClientH]->m_iWhisperPlayerIndex = i;
				ZeroMemory(m_pClientList[iClientH]->m_cWhisperPlayerName, sizeof(m_pClientList[iClientH]->m_cWhisperPlayerName));
				strcpy(m_pClientList[iClientH]->m_cWhisperPlayerName, cName);
		   		break;
			}

		if (m_pClientList[iClientH]->m_iWhisperPlayerIndex == -1) 
		{	ZeroMemory(cBuff, sizeof(cBuff));
			cp = (char *)cBuff;
			*cp = GSM_REQUEST_FINDCHARACTER;
			cp++;
			wp = (WORD *)cp;
			*wp = m_wServerID_GSS;
			cp += 2;
			wp = (WORD *)cp;
			*wp = iClientH;
			cp += 2;
			memcpy(cp, cName, 10);
			cp += 10;
			memcpy(cp, m_pClientList[iClientH]->m_cCharName, 10);
			cp += 10;
			bStockMsgToGateServer(cBuff, 25);
			ZeroMemory(m_pClientList[iClientH]->m_cWhisperPlayerName, sizeof(m_pClientList[iClientH]->m_cWhisperPlayerName));
			strcpy(m_pClientList[iClientH]->m_cWhisperPlayerName, cName);
			m_pClientList[iClientH]->m_bIsCheckingWhisperPlayer = TRUE;
		}else
		{	SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_WHISPERMODEON, NULL, NULL, NULL, m_pClientList[iClientH]->m_cWhisperPlayerName);
		}
	} 
	delete pStrTok;
}


void CGame::SetPlayerProfile(int iClientH, char * pMsg, DWORD dwMsgSize)
{
 char cTemp[256];
 register int i;
	if (m_pClientList[iClientH] == NULL) return;
	if ((dwMsgSize - 7) <= 0) return;

	ZeroMemory(cTemp, sizeof(cTemp));
	memcpy(cTemp, (pMsg + 7), dwMsgSize - 7);	
	for (i = 0; i < 256; i++)
		if (cTemp[i] == ' ') cTemp[i] = '_';
	cTemp[255] = NULL;

	ZeroMemory(m_pClientList[iClientH]->m_cProfile, sizeof(m_pClientList[iClientH]->m_cProfile));
	strcpy(m_pClientList[iClientH]->m_cProfile, cTemp);
}

void CGame::GetPlayerProfile(int iClientH, char * pMsg, DWORD dwMsgSize)
{	char   seps[] = "= \t\n";
	char   * token, cName[11], cBuff[256], cBuff2[500];
	class  CStrTok * pStrTok;
	register int i;
	if (m_pClientList[iClientH] == NULL) return;
	if ((dwMsgSize)	<= 0) return;
	ZeroMemory(cName, sizeof(cName));
	ZeroMemory(cBuff, sizeof(cBuff));
	memcpy(cBuff, pMsg, dwMsgSize);
	pStrTok = new class CStrTok(cBuff, seps);
	token = pStrTok->pGet();
	token = pStrTok->pGet();
  	
	if (token != NULL) 
	{	if (strlen(token) > 10) 
			 memcpy(cName, token, 10);
		else memcpy(cName, token, strlen(token));		
		for (i = 1; i < DEF_MAXCLIENTS; i++) 
		if ((m_pClientList[i] != NULL) && (memcmp(m_pClientList[i]->m_cCharName, cName, 10) == 0)) 
		{	ZeroMemory(cBuff2, sizeof(cBuff2));
			wsprintf(cBuff2, "%s Profile: %s", cName, m_pClientList[i]->m_cProfile);
			SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_PLAYERPROFILE, NULL, NULL, NULL, cBuff2);
			delete pStrTok;
			return;
		}
		// ZeroMemory(cBuff2, sizeof(cBuff2)); // Disable /pf if not on same serveur ?????
		// wsprintf(cBuff2, "%s Profile: %s", cName, "");
		// SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_PLAYERPROFILE, NULL, NULL, NULL, cBuff2);
		SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_PLAYERNOTONGAME, NULL, NULL, NULL, cName);
	}
	delete pStrTok;
	return;
}

void CGame::CalcTotalItemEffect(int iClientH, int iEquipItemID, BOOL bNotify)
{
 register short sItemIndex;
 int  i, /*iArrowIndex, */ iPrevSAType, iTemp, iLastSetEffect;
 int iShieldHPrec, iShieldSPrec, iShieldMPrec, iRepDamage;
 int iTotalAngelicstatas;
 iShieldHPrec = iShieldSPrec = iShieldMPrec = 0;
 char cEquipPos;
 char cInfoString[500];
 double dV1, dV2, dV3;
 DWORD  dwSWEType, dwSWEValue;
 short  sTemp;
   	if (m_pClientList[iClientH] == NULL) return;
// Snoopy: Added DefRatio for Monks if no heavy equipment
 BOOL bHasMonkDefenseRation = TRUE;
 BOOL bHasDruidAllowedItems = TRUE;
 BOOL bHasBarbarianAllowedItems = TRUE;
 BOOL bHasKnightAllowedItems = TRUE;
	if (   (m_pClientList[iClientH]->m_sItemEquipmentStatus[DEF_EQUIPPOS_RHAND]   != -1) 
		&& (m_pClientList[iClientH]->m_sItemEquipmentStatus[DEF_EQUIPPOS_TWOHAND] != -1) ) 
	{	if (m_pClientList[iClientH]->m_pItemList[ m_pClientList[iClientH]->m_sItemEquipmentStatus[DEF_EQUIPPOS_RHAND] ] != NULL) 
		{	m_pClientList[iClientH]->m_bIsItemEquipped[m_pClientList[iClientH]->m_sItemEquipmentStatus[DEF_EQUIPPOS_RHAND]] = FALSE;
			m_pClientList[iClientH]->m_sItemEquipmentStatus[DEF_EQUIPPOS_RHAND] = -1;
	}	}
	iTotalAngelicstatas = m_pClientList[iClientH]->m_iAngelicStr + (16 * m_pClientList[iClientH]->m_iAngelicInt)
		+ (256 * m_pClientList[iClientH]->m_iAngelicDex) + (16*256 * m_pClientList[iClientH]->m_iAngelicMag);
	m_pClientList[iClientH]->m_iAngelicStr			= 0; // By Snoopy81
	m_pClientList[iClientH]->m_iAngelicInt			= 0; // By Snoopy81
	m_pClientList[iClientH]->m_iAngelicDex			= 0; // By Snoopy81
	m_pClientList[iClientH]->m_iAngelicMag			= 0; // By Snoopy81

	iLastSetEffect = m_pClientList[iClientH]->m_iSetEffect;
	m_pClientList[iClientH]->m_iSetEffect			= 0; // By Snoopy81 
	
	SetAngelFlag(iClientH, DEF_OWNERTYPE_PLAYER, 0, 0);

	m_pClientList[iClientH]->m_cAttackDiceThrow_SM = 0;
	m_pClientList[iClientH]->m_cAttackDiceRange_SM = 0;
	m_pClientList[iClientH]->m_cAttackBonus_SM     = 0;  
	m_pClientList[iClientH]->m_cAttackDiceThrow_L  = 0;
	m_pClientList[iClientH]->m_cAttackDiceRange_L  = 0;
	m_pClientList[iClientH]->m_cAttackBonus_L      = 0;
	m_pClientList[iClientH]->m_iHitRatio  = 0;
	m_pClientList[iClientH]->m_iHitRatio3 = 0; // for MG attack
	m_pClientList[iClientH]->m_iDefenseRatio = m_pClientList[iClientH]->m_iDex * 2; // Angelic bonus at end of function
	m_pClientList[iClientH]->m_iDefenseRatio2 = m_pClientList[iClientH]->m_iDex;
	m_pClientList[iClientH]->m_iDefenseRatio3 = 0; // No bonus here
	m_pClientList[iClientH]->m_iDamageAbsorption_Shield = 0;
	
	for (i = 0; i < DEF_MAXITEMEQUIPPOS; i++)
	m_pClientList[iClientH]->m_iDamageAbsorption_Armor[i]  = 0;

	m_pClientList[iClientH]->m_iManaSaveRatio  = 0;
	m_pClientList[iClientH]->m_iAddResistMagic = 0;
	m_pClientList[iClientH]->m_iAddPhysicalDamage = 0;
	m_pClientList[iClientH]->m_iAddMagicalDamage  = 0;
	m_pClientList[iClientH]->m_bIsLuckyEffect  = 0;
	m_pClientList[iClientH]->m_iMagicDamageSaveItemIndex = -1;
	m_pClientList[iClientH]->m_iSideEffect_MaxHPdown = 0;
	m_pClientList[iClientH]->m_iAddAbsAir   = 0;
	m_pClientList[iClientH]->m_iAddAbsEarth = 0;
	m_pClientList[iClientH]->m_iAddAbsFire  = 0;
	m_pClientList[iClientH]->m_iAddAbsWater = 0;
	m_pClientList[iClientH]->m_iAddDamageEarth	= 0; 
	m_pClientList[iClientH]->m_iAddDamageAir	= 0; 
	m_pClientList[iClientH]->m_iAddDamageFire	= 0;
	m_pClientList[iClientH]->m_iAddDamageWater	= 0;

	m_pClientList[iClientH]->m_iCustomItemValue_Attack  = 0;
	m_pClientList[iClientH]->m_iCustomItemValue_Defense = 0;

	m_pClientList[iClientH]->m_iMinAP_SM = 0;
	m_pClientList[iClientH]->m_iMinAP_L  = 0;
	m_pClientList[iClientH]->m_iMaxAP_SM = 0;
	m_pClientList[iClientH]->m_iMaxAP_L  = 0;

	m_pClientList[iClientH]->m_iSpecialWeaponEffectType  = 0;	// for enchanted weapons
	m_pClientList[iClientH]->m_iSpecialWeaponEffectValue = 0;	// 
	m_pClientList[iClientH]->m_iSpecialWeaponEffectSpell = -1;

	m_pClientList[iClientH]->m_iAddHP = m_pClientList[iClientH]->m_iAddSP    = m_pClientList[iClientH]->m_iAddMP    = 0; 
	m_pClientList[iClientH]->m_iAddAR = m_pClientList[iClientH]->m_iAddPR    = m_pClientList[iClientH]->m_iAddDR    = 0;
	m_pClientList[iClientH]->m_iAddMR = m_pClientList[iClientH]->m_iAddAbsPD = m_pClientList[iClientH]->m_iAddAbsMD = 0;
	m_pClientList[iClientH]->m_iAddCD = m_pClientList[iClientH]->m_iAddExp   = m_pClientList[iClientH]->m_iAddGold  = 0;	
	
	iPrevSAType = m_pClientList[iClientH]->m_iSpecialAbilityType;

	m_pClientList[iClientH]->m_iSpecialAbilityType     = 0;
	m_pClientList[iClientH]->m_iSpecialAbilityLastSec  = 0;
	m_pClientList[iClientH]->m_iSpecialAbilityEquipPos = 0;

	m_pClientList[iClientH]->m_iAddTransMana = 0;
	m_pClientList[iClientH]->m_iAddChargeCritical = 0;

	// re introduced by SNOOPY
	m_pClientList[iClientH]->m_iHitRatio_ItemEffect_SM = 0;
	m_pClientList[iClientH]->m_iHitRatio_ItemEffect_L  = 0;
	m_pClientList[iClientH]->m_iMagicHitRatio_ItemEffect = 0;
	
	m_pClientList[iClientH]->m_iAlterItemDropIndex		= -1;
	m_pClientList[iClientH]->m_iEventItemDropIndex		= -1;
	m_pClientList[iClientH]->m_cKlonessMiscDamageBonus	= 0;
	m_pClientList[iClientH]->m_cKlonessNeckDamageBonus	= 0;

	for (sItemIndex = 0; sItemIndex < DEF_MAXITEMS; sItemIndex++)
	if  (m_pClientList[iClientH]->m_pItemList[sItemIndex] != NULL) 
	{	switch (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectType) {
		case DEF_ITEMEFFECTTYPE_ALTERITEMDROP:
			if (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_wCurLifeSpan > 0) 
			{	m_pClientList[iClientH]->m_iAlterItemDropIndex = sItemIndex;
			}
			break;
		case DEF_ITEMEFFECTTYPE_EVENT_ITEMDROP:
			m_pClientList[iClientH]->m_iEventItemDropIndex = sItemIndex;
			break;
	}	}
	// Hidden bonus to hit per weapon reintroduced by SNOOPY
	for (sItemIndex = 0; sItemIndex < DEF_MAXITEMS; sItemIndex++)
	if  ((m_pClientList[iClientH]->m_pItemList[sItemIndex] != NULL) && 
		(m_pClientList[iClientH]->m_bIsItemEquipped[sItemIndex] == TRUE)) 	
	{	switch (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectType) {			
		case DEF_ITEMEFFECTTYPE_ATTACK_DEFENSE:
		case DEF_ITEMEFFECTTYPE_ATTACK_MANASAVE:
		case DEF_ITEMEFFECTTYPE_ATTACK_MAXHPDOWN:
		case DEF_ITEMEFFECTTYPE_ATTACK:		
		case DEF_ITEMEFFECTTYPE_ATTACK_ARROW:
		case DEF_ITEMEFFECTTYPE_DEFENSE:
			m_pClientList[iClientH]->m_iHitRatio_ItemEffect_SM += m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sSpecialEffectValue1;
			m_pClientList[iClientH]->m_iHitRatio_ItemEffect_L  += m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sSpecialEffectValue2;
			break;	
		// Use same (L) value for both SM & L
		case DEF_ITEMEFFECTTYPE_ATTACK_SPECABLTY:
		case DEF_ITEMEFFECTTYPE_DEFENSE_SPECABLTY:
			m_pClientList[iClientH]->m_iHitRatio_ItemEffect_SM += m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sSpecialEffectValue2;
			m_pClientList[iClientH]->m_iHitRatio_ItemEffect_L  += m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sSpecialEffectValue2;
			break;
	}	}

	for (sItemIndex = 0; sItemIndex < DEF_MAXITEMS; sItemIndex++)
	if  (   (m_pClientList[iClientH]->m_pItemList[sItemIndex] != NULL) 
		 && (m_pClientList[iClientH]->m_bIsItemEquipped[sItemIndex] == TRUE)) 
	{	switch(m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sIDnum) {
		case 259:// WandMShield: MS15 Effect
			m_pClientList[iClientH]->m_iManaSaveRatio += 15;
			if (m_pClientList[iClientH]->m_iManaSaveRatio > 80) m_pClientList[iClientH]->m_iManaSaveRatio = 80;
			switch (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sTouchEffectValue1 %16){
			case 0:
				m_pClientList[iClientH]->m_iAddDamageEarth	-= 5; 
				m_pClientList[iClientH]->m_iAddDamageAir	+= 5; 
				break;
			case 1:
				m_pClientList[iClientH]->m_iAddDamageEarth	+= 5; 
				m_pClientList[iClientH]->m_iAddDamageAir	-= 5; 
				break;
			case 2:
				m_pClientList[iClientH]->m_iAddDamageFire	+= 5;
				m_pClientList[iClientH]->m_iAddDamageWater	-= 5;
				break;
			case 3:
				m_pClientList[iClientH]->m_iAddDamageFire	-= 5;
				m_pClientList[iClientH]->m_iAddDamageWater	+= 5;
				break;
			case 4:
				m_pClientList[iClientH]->m_iAddDamageEarth	-= 10; 
				m_pClientList[iClientH]->m_iAddDamageAir	+= 10; 
				//m_pClientList[iClientH]->m_iAddDamageFire	  -= 3;
				m_pClientList[iClientH]->m_iAddDamageWater	-= 4;
				break;
			case 5:
				m_pClientList[iClientH]->m_iAddDamageEarth	+= 10; 
				m_pClientList[iClientH]->m_iAddDamageAir	-= 10; 
				m_pClientList[iClientH]->m_iAddDamageFire	-= 4;
				//m_pClientList[iClientH]->m_iAddDamageWater	-= 2;
				break;
			case 6:
				m_pClientList[iClientH]->m_iAddDamageEarth	-= 4; 
				//m_pClientList[iClientH]->m_iAddDamageAir	-= 2; 
				m_pClientList[iClientH]->m_iAddDamageFire	+= 10;
				m_pClientList[iClientH]->m_iAddDamageWater	-= 10;
				break;
			case 7:
				//m_pClientList[iClientH]->m_iAddDamageEarth	-= 2; 
				m_pClientList[iClientH]->m_iAddDamageAir	-= 4; 
				m_pClientList[iClientH]->m_iAddDamageFire	-= 10;
				m_pClientList[iClientH]->m_iAddDamageWater	+= 10;
				break;
			default:
				break;
			}
			break;
		case 646: // NecklaceOfBeholder
			if ((m_pClientList[iClientH]->m_iStatus & 0x00000010) == 0) // Work only if not invi
			{	if (m_pClientList[iClientH]->m_iBeholderPower == 0)	    // Excludes GMs or Already Beholder Potion effect
				{	m_pClientList[iClientH]->m_iBeholderPower = 1;
					SendNewInitMapData(iClientH);					
			}	}
			break;
		case 707: // DarkMageRobeM
		case 708: // DarkMageRobeW 
			m_pClientList[iClientH]->m_iAddMP += 33;
			break;			
		case 709: //DarkKnightBlade: variable damage, base damage is as Anc GiS.
			m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectValue1 = m_pItemConfigList[709]->m_sItemEffectValue1;
			m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectValue2 = m_pItemConfigList[709]->m_sItemEffectValue2;
			m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectValue3 = m_pItemConfigList[709]->m_sItemEffectValue3;
			m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectValue4 = m_pItemConfigList[709]->m_sItemEffectValue4;
			m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectValue5 = m_pItemConfigList[709]->m_sItemEffectValue5;
			m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectValue6 = m_pItemConfigList[709]->m_sItemEffectValue6;
			if ((m_pClientList[iClientH]->m_iStr + m_pClientList[iClientH]->m_iAngelicStr) > 220) // Up to Vampire damage
			{	m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectValue1 +=1; // + dice
				m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectValue4 +=1;
				m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectValue3 -=2; // minor bonus
				m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectValue6 -=1;
			}else if ((m_pClientList[iClientH]->m_iStr + m_pClientList[iClientH]->m_iAngelicStr) > 181) // Up to Shadow damage (not the PA!)
			{	m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectValue2 +=2;
				m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectValue5 +=2;
			}else if ((m_pClientList[iClientH]->m_iStr + m_pClientList[iClientH]->m_iAngelicStr) < 156) // Back to Anc Flam
			{	m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectValue3 -=3;
				m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectValue6 -=3;
				if ((m_pClientList[iClientH]->m_iStr + m_pClientList[iClientH]->m_iAngelicStr) < 130) // Back to Anc GS
				{	m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectValue2 -=1;
					m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectValue5 -=1;			
			}	}	
// ATTENTION: Equiping an Angel Pendant AFTER the blade would not increase weapon catégory.
			break;
		case 845: //StormBlade
			m_pClientList[iClientH]->m_iAddAbsAir   += 50;
			break;
		case 849: //Kloness Blade
		case 850: //Kloness Axe
		case 851: //Kloness Esterk
		case 863: //Kloness MS20
		case 864: //Kloness MS28
			if (m_pClientList[iClientH]->m_iRating > 99) 
			{	iRepDamage = m_pClientList[iClientH]->m_iRating/100;
				if (iRepDamage > 5) iRepDamage = 5;
				m_pClientList[iClientH]->m_cKlonessMiscDamageBonus = iRepDamage;
			}
			m_pClientList[iClientH]->m_iSpecialWeaponEffectType = 3; // mimics righteous weapons
			break;
		case 859: //NecklaceOfKloness
			if (m_pClientList[iClientH]->m_iRating > 99) 
			{	iRepDamage = m_pClientList[iClientH]->m_iRating/100;
				if (iRepDamage > 10) iRepDamage = 10;
				m_pClientList[iClientH]->m_cKlonessNeckDamageBonus	= iRepDamage;
			}
			break;
		case 861:
		case 862: // Berserk Wands
			m_pClientList[iClientH]->m_cKlonessMiscDamageBonus = -1; // For added spell damage
			break;
		case 873: // FireBow
			m_pClientList[iClientH]->m_iAddAbsFire  += 50;
			break;
		case 936: // StormBow
			m_pClientList[iClientH]->m_iAddAbsWater += 50;
			break;
		case 982: // Added here MS40 Effect for BloodWandMS40
			m_pClientList[iClientH]->m_iManaSaveRatio += 40;
			if (m_pClientList[iClientH]->m_iManaSaveRatio > 80) m_pClientList[iClientH]->m_iManaSaveRatio = 80;
			break;
		case 984: // Added here MS10 Effect for LichMS10
			m_pClientList[iClientH]->m_iManaSaveRatio += 10;
			if (m_pClientList[iClientH]->m_iManaSaveRatio > 80) m_pClientList[iClientH]->m_iManaSaveRatio = 80;
			m_pClientList[iClientH]->m_cKlonessMiscDamageBonus = -2; // For added spell damage
			break;	
		//case 618: // DarkElfBow
		case 991: // DrowBlade
		case 992: // DrowHelmM
		case 993: // DrowChainM
		case 994: // DrowChainW
		case 995: // DrowBoots
			m_pClientList[iClientH]->m_iSetEffect += 1;
			break;
		case 997: // LicheRobeW
			m_pClientList[iClientH]->m_iAddMP += 20;		// 20% MPrec
			m_pClientList[iClientH]->m_iAddAbsWater += 32;	// 32% IceMA
			break;
		}

		cEquipPos = m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cEquipPos;
		switch (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectType) {
		case DEF_ITEMEFFECTTYPE_MAGICDAMAGESAVE:
			m_pClientList[iClientH]->m_iMagicDamageSaveItemIndex = sItemIndex;
			break;		
		case DEF_ITEMEFFECTTYPE_ATTACK_DEFENSE:
		case DEF_ITEMEFFECTTYPE_ATTACK_MANASAVE:
		case DEF_ITEMEFFECTTYPE_ATTACK_MAXHPDOWN:
		case DEF_ITEMEFFECTTYPE_ATTACK:			
		case DEF_ITEMEFFECTTYPE_ATTACK_SPECABLTY:
			m_pClientList[iClientH]->m_cAttackDiceThrow_SM = m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectValue1;
			m_pClientList[iClientH]->m_cAttackDiceRange_SM = m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectValue2;
			m_pClientList[iClientH]->m_cAttackBonus_SM     = m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectValue3;
			m_pClientList[iClientH]->m_cAttackDiceThrow_L  = m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectValue4;
			m_pClientList[iClientH]->m_cAttackDiceRange_L  = m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectValue5;
			m_pClientList[iClientH]->m_cAttackBonus_L      = m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectValue6;
			// Xelima Upgraded weapons
			iTemp = (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_dwAttribute & 0xF0000000) >> 28;
			m_pClientList[iClientH]->m_cAttackBonus_SM += iTemp;
			m_pClientList[iClientH]->m_cAttackBonus_L += iTemp;
			// Notice: +1 on Magic damage as well
			m_pClientList[iClientH]->m_iAddMagicalDamage  += iTemp;
						
			// Add skill to HitRatio
			m_pClientList[iClientH]->m_iHitRatio += m_pClientList[iClientH]->m_cSkillMastery[ m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sRelatedSkill ]; 
			m_pClientList[iClientH]->m_sUsingWeaponSkill = m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sRelatedSkill;
			
			// v1.41 Custom-Made <==> Manuf items
			if ((m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_dwAttribute & 0x00000001) != NULL) 
			{	m_pClientList[iClientH]->m_iCustomItemValue_Attack += (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemSpecEffectValue2 /2);
				if (m_pClientList[iClientH]->m_iCustomItemValue_Attack > 100)
					m_pClientList[iClientH]->m_iCustomItemValue_Attack = 100;
				if (m_pClientList[iClientH]->m_iCustomItemValue_Attack < -100)
					m_pClientList[iClientH]->m_iCustomItemValue_Attack = -100;

				if (m_pClientList[iClientH]->m_iCustomItemValue_Attack > 0) 
				{	// Completion >100%
					dV2 = (double)m_pClientList[iClientH]->m_iCustomItemValue_Attack;
					dV1 = (dV2/100.0f)*(5.0f);
					m_pClientList[iClientH]->m_iMinAP_SM = m_pClientList[iClientH]->m_cAttackDiceThrow_SM + 
														   m_pClientList[iClientH]->m_cAttackBonus_SM + (int)dV1;					
					m_pClientList[iClientH]->m_iMinAP_L  = m_pClientList[iClientH]->m_cAttackDiceThrow_L + 
														   m_pClientList[iClientH]->m_cAttackBonus_L + (int)dV1;
					if (m_pClientList[iClientH]->m_iMinAP_SM < 1) m_pClientList[iClientH]->m_iMinAP_SM = 1;
					if (m_pClientList[iClientH]->m_iMinAP_L < 1)  m_pClientList[iClientH]->m_iMinAP_L = 1;
					if (m_pClientList[iClientH]->m_iMinAP_SM > (m_pClientList[iClientH]->m_cAttackDiceThrow_SM * m_pClientList[iClientH]->m_cAttackDiceRange_SM + m_pClientList[iClientH]->m_cAttackBonus_SM)) 
						m_pClientList[iClientH]->m_iMinAP_SM = (m_pClientList[iClientH]->m_cAttackDiceThrow_SM * m_pClientList[iClientH]->m_cAttackDiceRange_SM + m_pClientList[iClientH]->m_cAttackBonus_SM);
					if (m_pClientList[iClientH]->m_iMinAP_L > (m_pClientList[iClientH]->m_cAttackDiceThrow_L * m_pClientList[iClientH]->m_cAttackDiceRange_L + m_pClientList[iClientH]->m_cAttackBonus_L)) 
						m_pClientList[iClientH]->m_iMinAP_L = (m_pClientList[iClientH]->m_cAttackDiceThrow_L * m_pClientList[iClientH]->m_cAttackDiceRange_L + m_pClientList[iClientH]->m_cAttackBonus_L);
				}else if (m_pClientList[iClientH]->m_iCustomItemValue_Attack < 0) 
				{	// Completion <100%
					dV2 = (double)m_pClientList[iClientH]->m_iCustomItemValue_Attack;
					dV1 = (dV2/100.0f)*(5.0f);
					m_pClientList[iClientH]->m_iMaxAP_SM = m_pClientList[iClientH]->m_cAttackDiceThrow_SM * m_pClientList[iClientH]->m_cAttackDiceRange_SM 
														   + m_pClientList[iClientH]->m_cAttackBonus_SM + (int)dV1;
					m_pClientList[iClientH]->m_iMaxAP_L  = m_pClientList[iClientH]->m_cAttackDiceThrow_L * m_pClientList[iClientH]->m_cAttackDiceRange_L 
														   + m_pClientList[iClientH]->m_cAttackBonus_L + (int)dV1;
					if (m_pClientList[iClientH]->m_iMaxAP_SM < 1) m_pClientList[iClientH]->m_iMaxAP_SM = 1;
					if (m_pClientList[iClientH]->m_iMaxAP_L < 1)  m_pClientList[iClientH]->m_iMaxAP_L = 1;
					if (m_pClientList[iClientH]->m_iMaxAP_SM < (m_pClientList[iClientH]->m_cAttackDiceThrow_SM * m_pClientList[iClientH]->m_cAttackDiceRange_SM + m_pClientList[iClientH]->m_cAttackBonus_SM)) 
						m_pClientList[iClientH]->m_iMaxAP_SM = (m_pClientList[iClientH]->m_cAttackDiceThrow_SM * m_pClientList[iClientH]->m_cAttackDiceRange_SM + m_pClientList[iClientH]->m_cAttackBonus_SM);
					if (m_pClientList[iClientH]->m_iMaxAP_L < (m_pClientList[iClientH]->m_cAttackDiceThrow_L * m_pClientList[iClientH]->m_cAttackDiceRange_L + m_pClientList[iClientH]->m_cAttackBonus_L)) 
						m_pClientList[iClientH]->m_iMaxAP_L = (m_pClientList[iClientH]->m_cAttackDiceThrow_L * m_pClientList[iClientH]->m_cAttackDiceRange_L + m_pClientList[iClientH]->m_cAttackBonus_L);
				}
			}
			// Enchanted weapons
			if ((m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_dwAttribute & 0x00F00000) != NULL) 
			{	dwSWEType  = (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_dwAttribute & 0x00F00000) >> 20;  
				dwSWEValue = (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_dwAttribute & 0x000F0000) >> 16;
				switch (dwSWEType) {
				case 2:  // Poison			-> Increase effect of 1st item, or replace a different effect
					bHasKnightAllowedItems =  FALSE;
				case 1:  // Crit +			-> Increase effect of 1st item, or replace a different effect
				case 10: // CP (as wand)	-> Increase effect of 1st item, or replace a different effect
					if (m_pClientList[iClientH]->m_iSpecialWeaponEffectType == dwSWEType)
					{	m_pClientList[iClientH]->m_iSpecialWeaponEffectValue += dwSWEValue;
					}else 
					{	m_pClientList[iClientH]->m_iSpecialWeaponEffectType  = dwSWEType;
						m_pClientList[iClientH]->m_iSpecialWeaponEffectValue = dwSWEValue;	
					}
					break;
				case 7:  // Sharp
					m_pClientList[iClientH]->m_cAttackDiceRange_SM++;
					m_pClientList[iClientH]->m_cAttackDiceRange_L++;
					break;
				case 9:  // Ancient
					m_pClientList[iClientH]->m_cAttackDiceRange_SM += 2;
					m_pClientList[iClientH]->m_cAttackDiceRange_L  += 2;
					break;
				case 11: // ManaConv 
					m_pClientList[iClientH]->m_iAddTransMana += dwSWEValue;	// SNOOPY changed to 20 as for Crit increase
					if (m_pClientList[iClientH]->m_iAddTransMana > 20) m_pClientList[iClientH]->m_iAddTransMana = 20;
					break;
				case 12: // Crit Increase 
					m_pClientList[iClientH]->m_iAddChargeCritical += dwSWEValue;
					if (m_pClientList[iClientH]->m_iAddChargeCritical > 20) m_pClientList[iClientH]->m_iAddChargeCritical = 20;
					break;
				case 4:  // Magic-using weapons
					if (m_pClientList[iClientH]->m_iSpecialWeaponEffectSpell == -1)
					{	switch (dwSWEValue) {
						case 1: //Magic Missile 
							m_pClientList[iClientH]->m_iSpecialWeaponEffectSpell = 0;
							break;
						case 2: // EB
							m_pClientList[iClientH]->m_iSpecialWeaponEffectSpell = 10;
							break;
						case 3: // FireBall
							m_pClientList[iClientH]->m_iSpecialWeaponEffectSpell = 20;
							break;
						case 4: // FireStrike
							m_pClientList[iClientH]->m_iSpecialWeaponEffectSpell = 30;
							break;
						case 5: // TripleEB
							m_pClientList[iClientH]->m_iSpecialWeaponEffectSpell = 47;
							break;
						case 6: // Chill Wind
							m_pClientList[iClientH]->m_iSpecialWeaponEffectSpell = 45;
							break;
						case 7: // IceStrike	
							m_pClientList[iClientH]->m_iSpecialWeaponEffectSpell = 57;
							break;			
						case 8: // ES
							m_pClientList[iClientH]->m_iSpecialWeaponEffectSpell = 60;
							break;		
						case 9: // Armor-Break
							m_pClientList[iClientH]->m_iSpecialWeaponEffectSpell = 66;
							break;
						case 10: // EWStrike
							m_pClientList[iClientH]->m_iSpecialWeaponEffectSpell = 64;
							break;
						case 11: // Mass-Chill-Wind
							m_pClientList[iClientH]->m_iSpecialWeaponEffectSpell = 63;
							break;
						case 12: // Mass FireStrike
							m_pClientList[iClientH]->m_iSpecialWeaponEffectSpell = 61;
							break;
						case 13: // Lightning-Strike
							m_pClientList[iClientH]->m_iSpecialWeaponEffectSpell = 74;
							break;
						case 14: // Mass-Ice-Strike
							m_pClientList[iClientH]->m_iSpecialWeaponEffectSpell = 72;
							break;
						case 15: // MS
							m_pClientList[iClientH]->m_iSpecialWeaponEffectSpell = 81;
							break;
					}	}	
					break;
				default: // All others
					m_pClientList[iClientH]->m_iSpecialWeaponEffectType  = dwSWEType;
					m_pClientList[iClientH]->m_iSpecialWeaponEffectValue = dwSWEValue;	
					break;
				}	}

			// Enchanted weapon, compute stats
			if ((m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_dwAttribute & 0x0000F000) != NULL) 
			{	dwSWEType  = (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_dwAttribute & 0x0000F000) >> 12;  
				dwSWEValue = (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_dwAttribute & 0x00000F00) >> 8;				
				switch (dwSWEType) {
				case 0:  break;
				case 1:  m_pClientList[iClientH]->m_iAddPR += (int)dwSWEValue*7; break;
				case 2:  m_pClientList[iClientH]->m_iAddAR += (int)dwSWEValue*7; break; // armes HitProba
				case 3:  m_pClientList[iClientH]->m_iAddDR += (int)dwSWEValue*7; break;
				case 4:  m_pClientList[iClientH]->m_iAddHP += (int)dwSWEValue*7; break;
				case 5:  m_pClientList[iClientH]->m_iAddSP += (int)dwSWEValue*7; break;
				case 6:  m_pClientList[iClientH]->m_iAddMP += (int)dwSWEValue*7; break;
				case 7:  m_pClientList[iClientH]->m_iAddMR += (int)dwSWEValue*7; break;
				case 8:  m_pClientList[iClientH]->m_iDamageAbsorption_Armor[cEquipPos] += (int)dwSWEValue*3; break;

				case 9:  m_pClientList[iClientH]->m_iAddAbsMD += (int)dwSWEValue*3;
					if (m_pClientList[iClientH]->m_iAddAbsMD > 80) m_pClientList[iClientH]->m_iAddAbsMD = 80; 
					break;
				case 10: m_pClientList[iClientH]->m_iAddCD    += (int)dwSWEValue; break;
				case 11: m_pClientList[iClientH]->m_iAddExp   += (int)dwSWEValue*10; break;
				case 12: m_pClientList[iClientH]->m_iAddGold  += (int)dwSWEValue*10; break;			
			}	}

			// Those Attack items where treated as a bundle above, see here special cases
			switch (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectType) {
			case DEF_ITEMEFFECTTYPE_ATTACK: // More combo for Flamberge
				if (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cApprValue == 12) 
				{	m_pClientList[iClientH]->m_iAddCD +=5;
				}
				break;

			case DEF_ITEMEFFECTTYPE_ATTACK_MAXHPDOWN:
				m_pClientList[iClientH]->m_iSideEffect_MaxHPdown = m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sSpecialEffect;
				// Xelima Upgraded weapons
				iTemp = (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_dwAttribute & 0xF0000000) >> 28;
				m_pClientList[iClientH]->m_iSideEffect_MaxHPdown -= iTemp;
				if (m_pClientList[iClientH]->m_iSideEffect_MaxHPdown < 2) m_pClientList[iClientH]->m_iSideEffect_MaxHPdown = 2;
				break;

			case DEF_ITEMEFFECTTYPE_ATTACK_MANASAVE:
				// SNOOPY: For wands, ignore m_sItemEffectValue4/5/6 for damage{
				m_pClientList[iClientH]->m_cAttackDiceThrow_L  = m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectValue1;
				m_pClientList[iClientH]->m_cAttackDiceRange_L  = m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectValue2;
				m_pClientList[iClientH]->m_cAttackBonus_L      = m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectValue3;
				// Compute Mana save, max=80%
				m_pClientList[iClientH]->m_iManaSaveRatio    += m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectValue4;
				if (m_pClientList[iClientH]->m_iManaSaveRatio > 80) m_pClientList[iClientH]->m_iManaSaveRatio = 80;
				//Snoopy: Reintroduced defence for staves
				m_pClientList[iClientH]->m_iDefenseRatio += m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sSpecialEffect;				
				m_pClientList[iClientH]->m_iDefenseRatio2 += m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sSpecialEffect;					
				m_pClientList[iClientH]->m_iDefenseRatio3 += m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sSpecialEffect;
				//Snoopy: Added Magic ToHit Bonus for some wands.
				m_pClientList[iClientH]->m_iMagicHitRatio_ItemEffect += m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectValue6;	
				break;

			case DEF_ITEMEFFECTTYPE_ATTACK_DEFENSE: // PA for some weapons
				m_pClientList[iClientH]->m_iDamageAbsorption_Armor[DEF_EQUIPPOS_BODY] += m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sSpecialEffect;
				break;

			case DEF_ITEMEFFECTTYPE_ATTACK_SPECABLTY:
				// TYpe of special weapon, Duration of the effect
				m_pClientList[iClientH]->m_iSpecialAbilityType    = m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sSpecialEffect;
				m_pClientList[iClientH]->m_iSpecialAbilityLastSec = m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sSpecialEffectValue1; 
				m_pClientList[iClientH]->m_iSpecialAbilityEquipPos = (int)cEquipPos;
				// SNOOPY: put this here for Xelima / IceElemental Bows
				m_pClientList[iClientH]->m_cArrowIndex = _iGetArrowItemIndex(iClientH);	

				if ((m_pClientList[iClientH]->m_iSpecialAbilityType == 3) // No Medusa blade
					&& (m_pClientList[iClientH]->m_iPriestDruidID == 5))  // for Knights
				{	bHasKnightAllowedItems = FALSE;
				}
				if ((bNotify == TRUE) && (iEquipItemID == (int)sItemIndex))
					SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_SPECIALABILITYSTATUS, 2, m_pClientList[iClientH]->m_iSpecialAbilityType, m_pClientList[iClientH]->m_iSpecialAbilityTime, NULL);
				break;
			}
			break;

		case DEF_ITEMEFFECTTYPE_ADDEFFECT: //(type14)
			switch (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectValue1) {			
			case 1:	// MR
				m_pClientList[iClientH]->m_iAddResistMagic += m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectValue2;
				// Merien Upgraded items
				iTemp = (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_dwAttribute & 0xF0000000) >> 28;
				m_pClientList[iClientH]->m_iAddResistMagic += (iTemp*10);				
				break;

			case 2:	// MS
				m_pClientList[iClientH]->m_iManaSaveRatio += m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectValue2;
				// Merien Upgraded items
				iTemp = (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_dwAttribute & 0xF0000000) >> 28;
				m_pClientList[iClientH]->m_iManaSaveRatio += iTemp;								
				// MS max = 80%
				if (m_pClientList[iClientH]->m_iManaSaveRatio > 80) m_pClientList[iClientH]->m_iManaSaveRatio = 80;
				break;

			case 3:	// Adds physical damage 
				m_pClientList[iClientH]->m_iAddPhysicalDamage += m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectValue2;
				// Merien Upgraded items
				iTemp = (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_dwAttribute & 0xF0000000) >> 28;
				m_pClientList[iClientH]->m_iAddPhysicalDamage += iTemp;					
				break;

			case 4:	// Rings Defence Ratio 
				m_pClientList[iClientH]->m_iDefenseRatio += m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectValue2;
				//SNOOPY
				m_pClientList[iClientH]->m_iDefenseRatio2 += m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectValue2;
				m_pClientList[iClientH]->m_iDefenseRatio3 += m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectValue2;
				// Merien Upgraded items
				iTemp = (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_dwAttribute & 0xF0000000) >> 28;
				m_pClientList[iClientH]->m_iDefenseRatio += (iTemp*5);					
				m_pClientList[iClientH]->m_iDefenseRatio2 += (iTemp*5);				
				m_pClientList[iClientH]->m_iDefenseRatio3 += (iTemp*5);								
				break;

			case 5:	// Lucky Gold Ring
				// SNOOPY: changed to use m_sItemEffectValue2 as Lucky % value
				//         and cumulative betxeen items
				if (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectValue2 > 0)
					 m_pClientList[iClientH]->m_bIsLuckyEffect += m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectValue2;
				else m_pClientList[iClientH]->m_bIsLuckyEffect += 10;
				// Merien Upgraded items
				iTemp = (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_dwAttribute & 0xF0000000) >> 28;
				m_pClientList[iClientH]->m_bIsLuckyEffect += (iTemp*10);
				break;

			case 6:	// Add Magic Damage. 
				m_pClientList[iClientH]->m_iAddMagicalDamage += m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectValue2;
				iTemp = (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_dwAttribute & 0xF0000000) >> 28;
				m_pClientList[iClientH]->m_iAddMagicalDamage += iTemp;					
				break;

			case 7: // Lightning protection
				m_pClientList[iClientH]->m_iAddAbsAir		+= m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectValue2;
				m_pClientList[iClientH]->m_iAddDamageAir	+= m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectValue3; 
				iTemp = (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_dwAttribute & 0xF0000000) >> 28;
				if (m_pClientList[iClientH]->m_iAddAbsAir >=0)		m_pClientList[iClientH]->m_iAddAbsAir		+= (iTemp*5);						
				else												m_pClientList[iClientH]->m_iAddAbsAir		-= (iTemp*5);
				if (m_pClientList[iClientH]->m_iAddDamageAir >=0)	m_pClientList[iClientH]->m_iAddDamageAir	+= (iTemp);						
				else												m_pClientList[iClientH]->m_iAddDamageAir	-= (iTemp);	
				m_pClientList[iClientH]->m_iAddAbsEarth		+= m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectValue6;
				m_pClientList[iClientH]->m_iAddDamageEarth	-= m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectValue3; 
				break;
			case 8: // Earth Protection
				m_pClientList[iClientH]->m_iAddAbsEarth		+= m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectValue2;
				m_pClientList[iClientH]->m_iAddDamageEarth	+= m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectValue3; 
				iTemp = (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_dwAttribute & 0xF0000000) >> 28;					
				if (m_pClientList[iClientH]->m_iAddAbsEarth >=0)	m_pClientList[iClientH]->m_iAddAbsEarth		+= (iTemp*5);						
				else												m_pClientList[iClientH]->m_iAddAbsEarth		-= (iTemp*5);				
				if (m_pClientList[iClientH]->m_iAddDamageEarth >=0) m_pClientList[iClientH]->m_iAddDamageEarth	+= (iTemp);						
				else												m_pClientList[iClientH]->m_iAddDamageEarth	-= (iTemp);	
				m_pClientList[iClientH]->m_iAddAbsAir		+= m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectValue6;
				m_pClientList[iClientH]->m_iAddDamageAir	-= m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectValue3; 
				break;
			case 9: // Fire Protection
				m_pClientList[iClientH]->m_iAddAbsFire		+= m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectValue2;
				m_pClientList[iClientH]->m_iAddDamageFire	+= m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectValue3;
				iTemp = (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_dwAttribute & 0xF0000000) >> 28;
				if (m_pClientList[iClientH]->m_iAddAbsFire >=0)		m_pClientList[iClientH]->m_iAddAbsFire		+= (iTemp*5);						
				else												m_pClientList[iClientH]->m_iAddAbsFire		-= (iTemp*5);
				if (m_pClientList[iClientH]->m_iAddDamageFire >=0)	m_pClientList[iClientH]->m_iAddDamageFire	+= (iTemp);						
				else												m_pClientList[iClientH]->m_iAddDamageFire	-= (iTemp);	
				m_pClientList[iClientH]->m_iAddAbsWater		+= m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectValue6;
				m_pClientList[iClientH]->m_iAddDamageWater	-= m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectValue3;
				break;
			case 10: // Ice Protection
				m_pClientList[iClientH]->m_iAddAbsWater		+= m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectValue2;
				m_pClientList[iClientH]->m_iAddDamageWater	+= m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectValue3;
				iTemp = (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_dwAttribute & 0xF0000000) >> 28;
				if (m_pClientList[iClientH]->m_iAddAbsWater >=0)	m_pClientList[iClientH]->m_iAddAbsWater		+= (iTemp*5);						
				else												m_pClientList[iClientH]->m_iAddAbsWater		-= (iTemp*5);		
				if (m_pClientList[iClientH]->m_iAddDamageWater >=0) m_pClientList[iClientH]->m_iAddDamageWater	+= (iTemp);						
				else												m_pClientList[iClientH]->m_iAddDamageWater	-= (iTemp);	
				m_pClientList[iClientH]->m_iAddAbsFire		+= m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectValue6;
				m_pClientList[iClientH]->m_iAddDamageFire	-= m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectValue3;	
				break;

			case 11: // Poison protection
				m_pClientList[iClientH]->m_iAddPR += m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectValue2;
				iTemp = (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_dwAttribute & 0xF0000000) >> 28;
				m_pClientList[iClientH]->m_iAddPR += (iTemp*10);				
				break;

			case 12: // Adds To Hit Bonus
				m_pClientList[iClientH]->m_iHitRatio += m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectValue2;
				m_pClientList[iClientH]->m_iHitRatio3 += m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectValue2;
				iTemp = (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_dwAttribute & 0xF0000000) >> 28;
				m_pClientList[iClientH]->m_iHitRatio += (iTemp*5);	
				m_pClientList[iClientH]->m_iHitRatio3 += (iTemp*5);	
				break;

			case 13: // Magin Ruby		Characters Hp recovery rate(% applied) added by the purity formula.
				m_pClientList[iClientH]->m_iAddHP += (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemSpecEffectValue2 /5);
				break;

			case 14: // Magin Diamond	Attack probability(physical&magic) added by the purity formula.
				m_pClientList[iClientH]->m_iAddAR += (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemSpecEffectValue2 /5);
				break;

			case 15: // Magin Emerald	Magical damage decreased(% applied) by the purity formula.	
				m_pClientList[iClientH]->m_iAddAbsMD += (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemSpecEffectValue2 /10);
				if (m_pClientList[iClientH]->m_iAddAbsMD > 80) m_pClientList[iClientH]->m_iAddAbsMD = 80; 
				break;

			case 30: // Magin Sapphire	Phisical damage decreased(% applied) by the purity formula.	
				iTemp = (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemSpecEffectValue2 /10);
				m_pClientList[iClientH]->m_iDamageAbsorption_Armor[DEF_EQUIPPOS_HEAD]  += iTemp;
				m_pClientList[iClientH]->m_iDamageAbsorption_Armor[DEF_EQUIPPOS_BODY]  += iTemp;	
				m_pClientList[iClientH]->m_iDamageAbsorption_Armor[DEF_EQUIPPOS_ARMS]  += iTemp;
				m_pClientList[iClientH]->m_iDamageAbsorption_Armor[DEF_EQUIPPOS_PANTS] += iTemp;
				break;	
/*Functions rates confirm.
Magic Diamond: Completion rate / 5 = Functions rate. ? Maximum 20. (not%)
Magic Ruby: Completion rate / 5 = Functions rate.(%) ? Maximum 20%.
Magic Emerald: Completion rate / 10 = Functions rate.(%) ? Maximum 10%.
Magic Sapphire: Completion rate / 10 = Functions rate.(%) ? Maximum 10%.*/

// ******* Angel Code - Begin ******* //			
			case 16: // Angel STR//AngelicPandent(STR)
				iTemp = (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_dwAttribute & 0xF0000000) >> 28;
				m_pClientList[iClientH]->m_iAngelicStr = iTemp;
				SetAngelFlag(iClientH, DEF_OWNERTYPE_PLAYER, 1, iTemp);
				//SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_SETTING_SUCCESS, NULL, NULL, NULL, NULL);
				break;
			case 17: // Angel DEX //AngelicPandent(DEX)
				iTemp = (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_dwAttribute & 0xF0000000) >> 28;
				m_pClientList[iClientH]->m_iAngelicDex = iTemp;
				SetAngelFlag(iClientH, DEF_OWNERTYPE_PLAYER, 2, iTemp);
				//SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_SETTING_SUCCESS, NULL, NULL, NULL, NULL);
				break;
			case 18: // Angel INT//AngelicPandent(INT)
				iTemp = (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_dwAttribute & 0xF0000000) >> 28;
				m_pClientList[iClientH]->m_iAngelicInt = iTemp;
				SetAngelFlag(iClientH, DEF_OWNERTYPE_PLAYER, 3, iTemp);
				//SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_SETTING_SUCCESS, NULL, NULL, NULL, NULL);
				break;
			case 19: // Angel MAG//AngelicPandent(MAG)
				iTemp = (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_dwAttribute & 0xF0000000) >> 28;
				m_pClientList[iClientH]->m_iAngelicMag = iTemp;
				SetAngelFlag(iClientH, DEF_OWNERTYPE_PLAYER, 4, iTemp);
				//SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_SETTING_SUCCESS, NULL, NULL, NULL, NULL);
				break;
		
			}
			if (cEquipPos == DEF_EQUIPPOS_BACK)
			{	// Snoopy Special effect capes/ mantles still have small DefRatio & PA
				m_pClientList[iClientH]->m_iDefenseRatio += 3;	// Standard DR
				m_pClientList[iClientH]->m_iDefenseRatio2 += 3; // DR for PvP
				m_pClientList[iClientH]->m_iDefenseRatio3 += 3; // DR during METAMORPHOSIS Effect
				m_pClientList[iClientH]->m_iDamageAbsorption_Armor[DEF_EQUIPPOS_BACK] += 1;
				// Merien Upgraded diverse (capes?)
				iTemp = (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_dwAttribute & 0xF0000000) >> 28;
				if (iTemp !=0)
				{	m_pClientList[iClientH]->m_iDefenseRatio += (iTemp*5);
					m_pClientList[iClientH]->m_iDefenseRatio2 += (iTemp*5);
					m_pClientList[iClientH]->m_iDefenseRatio3 += (iTemp*5);
					m_pClientList[iClientH]->m_iDamageAbsorption_Armor[DEF_EQUIPPOS_BACK]  += iTemp;
			}	}
			break;
			
		case DEF_ITEMEFFECTTYPE_ATTACK_ARROW:
			if (   (m_pClientList[iClientH]->m_cArrowIndex != -1) 
				&& (m_pClientList[iClientH]->m_pItemList[m_pClientList[iClientH]->m_cArrowIndex] == NULL) ) 			
			{	m_pClientList[iClientH]->m_cArrowIndex = _iGetArrowItemIndex(iClientH);	// ArrowIndex
			}else if (m_pClientList[iClientH]->m_cArrowIndex == -1) 
				m_pClientList[iClientH]->m_cArrowIndex = _iGetArrowItemIndex(iClientH);
			
			if (m_pClientList[iClientH]->m_cArrowIndex == -1) 
			{	m_pClientList[iClientH]->m_cAttackDiceThrow_SM = 0;
				m_pClientList[iClientH]->m_cAttackDiceRange_SM = 0;
				m_pClientList[iClientH]->m_cAttackBonus_SM     = 0;
				m_pClientList[iClientH]->m_cAttackDiceThrow_L  = 0;
				m_pClientList[iClientH]->m_cAttackDiceRange_L  = 0;
				m_pClientList[iClientH]->m_cAttackBonus_L      = 0;
			}else //iArrowIndex = m_pClientList[iClientH]->m_cArrowIndex; 				
			{	m_pClientList[iClientH]->m_cAttackDiceThrow_SM = m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectValue1;
				m_pClientList[iClientH]->m_cAttackDiceRange_SM = m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectValue2;
				m_pClientList[iClientH]->m_cAttackBonus_SM     = m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectValue3;
				m_pClientList[iClientH]->m_cAttackDiceThrow_L  = m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectValue4;
				m_pClientList[iClientH]->m_cAttackDiceRange_L  = m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectValue5;
				m_pClientList[iClientH]->m_cAttackBonus_L      = m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectValue6;
			}
			// Xelima Upgraded bows
			iTemp = (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_dwAttribute & 0xF0000000) >> 28;
			m_pClientList[iClientH]->m_cAttackBonus_SM += iTemp;
			m_pClientList[iClientH]->m_cAttackBonus_L += iTemp;
			
			// Standard HitRatio uses Skill 
			m_pClientList[iClientH]->m_iHitRatio += m_pClientList[iClientH]->m_cSkillMastery[ m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sRelatedSkill ]; 
			// iHitRatio3 discards skill
			// SNOOPY: Added support for enchanted bows. (1st stat)
			if ((m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_dwAttribute & 0x00F00000) != NULL) 
			{	dwSWEType  = (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_dwAttribute & 0x00F00000) >> 20;  
				dwSWEValue = (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_dwAttribute & 0x000F0000) >> 16;
				switch (dwSWEType) {
				case 2:  // Poison			-> Increase effect of 1st item, or replace a different effect					
					bHasKnightAllowedItems =  FALSE;
				case 1:  // Crit +			-> Increase effect of 1st item, or replace a different effect
				case 10: // CP (as wand)	-> Increase effect of 1st item, or replace a different effect
					if (m_pClientList[iClientH]->m_iSpecialWeaponEffectType == dwSWEType)
					{	m_pClientList[iClientH]->m_iSpecialWeaponEffectValue += dwSWEValue;
					}else 
					{	m_pClientList[iClientH]->m_iSpecialWeaponEffectType  = dwSWEType;
						m_pClientList[iClientH]->m_iSpecialWeaponEffectValue = dwSWEValue;	
					}
					break;
				case 7:  // Sharp
					m_pClientList[iClientH]->m_cAttackDiceRange_SM++;
					m_pClientList[iClientH]->m_cAttackDiceRange_L++;
					break;
				case 9:  // Ancient
					m_pClientList[iClientH]->m_cAttackDiceRange_SM += 2;
					m_pClientList[iClientH]->m_cAttackDiceRange_L  += 2;
					break;
				case 11: // ManaConv 
					m_pClientList[iClientH]->m_iAddTransMana += dwSWEValue;	// SNOOPY changed to 20 as for Crit increase
					if (m_pClientList[iClientH]->m_iAddTransMana > 20) m_pClientList[iClientH]->m_iAddTransMana = 20;
					break;
				case 12: // Crit Increase 
					m_pClientList[iClientH]->m_iAddChargeCritical += dwSWEValue;
					if (m_pClientList[iClientH]->m_iAddChargeCritical > 20) m_pClientList[iClientH]->m_iAddChargeCritical = 20;
					break;
				case 4:  // Magic-using weapons, don't overide a main weapon
					if (m_pClientList[iClientH]->m_iSpecialWeaponEffectSpell == -1)
					{	switch (dwSWEValue) {
						case 1: //Magic Missile 
							m_pClientList[iClientH]->m_iSpecialWeaponEffectSpell = 0;
							break;
						case 2: // EB
							m_pClientList[iClientH]->m_iSpecialWeaponEffectSpell = 10;
							break;
						case 3: // FireBall
							m_pClientList[iClientH]->m_iSpecialWeaponEffectSpell = 20;
							break;
						case 4: // FireStrike
							m_pClientList[iClientH]->m_iSpecialWeaponEffectSpell = 30;
							break;
						case 5: // TripleEB
							m_pClientList[iClientH]->m_iSpecialWeaponEffectSpell = 47;
							break;
						case 6: // Chill Wind
							m_pClientList[iClientH]->m_iSpecialWeaponEffectSpell = 45;
							break;
						case 7: // IceStrike	
							m_pClientList[iClientH]->m_iSpecialWeaponEffectSpell = 57;
							break;			
						case 8: // ES
							m_pClientList[iClientH]->m_iSpecialWeaponEffectSpell = 60;
							break;		
						case 9: // Armor-Break
							m_pClientList[iClientH]->m_iSpecialWeaponEffectSpell = 66;
							break;
						case 10: // EWStrike
							m_pClientList[iClientH]->m_iSpecialWeaponEffectSpell = 64;
							break;
						case 11: // Mass-Chill-Wind
							m_pClientList[iClientH]->m_iSpecialWeaponEffectSpell = 63;
							break;
						case 12: // Mass FireStrike
							m_pClientList[iClientH]->m_iSpecialWeaponEffectSpell = 61;
							break;
						case 13: // Lightning-Strike
							m_pClientList[iClientH]->m_iSpecialWeaponEffectSpell = 74;
							break;
						case 14: // Mass-Ice-Strike
							m_pClientList[iClientH]->m_iSpecialWeaponEffectSpell = 72;
							break;
						case 15: // MS
							m_pClientList[iClientH]->m_iSpecialWeaponEffectSpell = 81;
							break;
					}	}					
					break;
				default: // All others
					m_pClientList[iClientH]->m_iSpecialWeaponEffectType  = (int)dwSWEType;
					m_pClientList[iClientH]->m_iSpecialWeaponEffectValue = (int)dwSWEValue;	
					break;
				}
			}

			// SNOOPY: Added support for enchanted bows. (2nd stat)
			if ((m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_dwAttribute & 0x0000F000) != NULL) 
			{	dwSWEType  = (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_dwAttribute & 0x0000F000) >> 12;  
				dwSWEValue = (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_dwAttribute & 0x00000F00) >> 8;				
				switch (dwSWEType) {
				case 0:  break;
				case 1:  m_pClientList[iClientH]->m_iAddPR += (int)dwSWEValue*7; break;
				case 2:  m_pClientList[iClientH]->m_iAddAR += (int)dwSWEValue*7; break; // adds Hit Proba
				case 3:  m_pClientList[iClientH]->m_iAddDR += (int)dwSWEValue*7; break;
				case 4:  m_pClientList[iClientH]->m_iAddHP += (int)dwSWEValue*7; break;
				case 5:  m_pClientList[iClientH]->m_iAddSP += (int)dwSWEValue*7; break;
				case 6:  m_pClientList[iClientH]->m_iAddMP += (int)dwSWEValue*7; break; 
				case 7:  m_pClientList[iClientH]->m_iAddMR += (int)dwSWEValue*7; break;
				case 8:  m_pClientList[iClientH]->m_iDamageAbsorption_Armor[cEquipPos] += (int)dwSWEValue*3; break;
				case 9:  m_pClientList[iClientH]->m_iAddAbsMD += (int)dwSWEValue*3; 
					if (m_pClientList[iClientH]->m_iAddAbsMD > 80) m_pClientList[iClientH]->m_iAddAbsMD = 80;
					break;
				case 10: m_pClientList[iClientH]->m_iAddCD    += (int)dwSWEValue; break;
				case 11: m_pClientList[iClientH]->m_iAddExp   += (int)dwSWEValue*10; break;
				case 12: m_pClientList[iClientH]->m_iAddGold  += (int)dwSWEValue*10; break;
				}
			}
			break;
			
		case DEF_ITEMEFFECTTYPE_DEFENSE: // Notice that MainGauche is here as well .....			
		case DEF_ITEMEFFECTTYPE_DEFENSE_SPECABLTY:
			// SNOOPY: 2 values for Defence ratio fot PvP mode HIGH
			m_pClientList[iClientH]->m_iDefenseRatio += m_pClientList[iClientH]->m_pItemList[ sItemIndex ]->m_sItemEffectValue1;
			m_pClientList[iClientH]->m_iDefenseRatio2 += m_pClientList[iClientH]->m_pItemList[ sItemIndex ]->m_sItemEffectValue1;
			//iDefenseRatio3 not affected by Head/arm/Leg/plate armor pieces

			// Merien Upgraded armors, add DefRatio for all defence items
			iTemp = (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_dwAttribute & 0xF0000000) >> 28;
			m_pClientList[iClientH]->m_iDefenseRatio += (iTemp*5);
			m_pClientList[iClientH]->m_iDefenseRatio2 += (iTemp*5);

			// Manufs armors 
			if ((m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_dwAttribute & 0x00000001) != NULL) 
			{	m_pClientList[iClientH]->m_iCustomItemValue_Defense += m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemSpecEffectValue2;
				dV2 = (double)m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemSpecEffectValue2;
				dV3 = (double)m_pClientList[iClientH]->m_pItemList[ sItemIndex ]->m_sItemEffectValue1;
				dV1 = (double)(dV2 / 100.0f)*dV3;					
				dV1 = dV1 / 2.0f;
				m_pClientList[iClientH]->m_iDefenseRatio += (int)dV1;
				if (m_pClientList[iClientH]->m_iDefenseRatio <= 0) m_pClientList[iClientH]->m_iDefenseRatio = 1;
				// SNOOPY
				m_pClientList[iClientH]->m_iDefenseRatio2 += (int)dV1;
				if (m_pClientList[iClientH]->m_iDefenseRatio2 <= 0) m_pClientList[iClientH]->m_iDefenseRatio2 = 1;
			}

			if ((m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_dwAttribute & 0x00F00000) != NULL) 
			{	dwSWEType  = (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_dwAttribute & 0x00F00000) >> 20;  
				dwSWEValue = (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_dwAttribute & 0x000F0000) >> 16;
				switch (dwSWEType) {
				case 1:  // Crit +			-> May increase effect of 1st item or give effect if no other effect present
				case 2:  // Poison			-> May Increase effect of 1st item or give effect if no other effect present
				case 10: // CP (as wand)	-> May Increase effect of 1st item or give effect if no other effect present				
					if (m_pClientList[iClientH]->m_iSpecialWeaponEffectType == dwSWEType)
					{	m_pClientList[iClientH]->m_iSpecialWeaponEffectValue += dwSWEValue;
					}else  
						if (m_pClientList[iClientH]->m_iSpecialWeaponEffectType == 0)
						{	m_pClientList[iClientH]->m_iSpecialWeaponEffectType  = dwSWEType;
							m_pClientList[iClientH]->m_iSpecialWeaponEffectValue = dwSWEValue;	
						}
					break;
				case 3: // Rite -> Give effect if no other effect present	
					if (m_pClientList[iClientH]->m_iSpecialWeaponEffectType == 0)
					{	m_pClientList[iClientH]->m_iSpecialWeaponEffectType  = dwSWEType;
						m_pClientList[iClientH]->m_iSpecialWeaponEffectValue = dwSWEValue;	
					} 
					break;
				case 7: // Sharp MG have effect in iCalculatteAttackEffect function
				case 9: // Ancient MG have effect in iCalculatteAttackEffect function
					break;				
				case 11: // ManaConv  Total max 20
					m_pClientList[iClientH]->m_iAddTransMana += dwSWEValue;	// SNOOPY changed to 20 as for Crit increase
					if (m_pClientList[iClientH]->m_iAddTransMana > 20) m_pClientList[iClientH]->m_iAddTransMana = 20;
					break;
				case 12: // Crit Increase Total max 20
					m_pClientList[iClientH]->m_iAddChargeCritical += dwSWEValue;
					if (m_pClientList[iClientH]->m_iAddChargeCritical > 20) m_pClientList[iClientH]->m_iAddChargeCritical = 20;
					break;
				case 4: // ???
					break;
				default:
					break;
				}
			}
			// stated armors/shields
			if ((m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_dwAttribute & 0x0000F000) != NULL) 
			{	dwSWEType  = (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_dwAttribute & 0x0000F000) >> 12;  
				dwSWEValue = (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_dwAttribute & 0x00000F00) >> 8;				
				// HP or Rep+ will have effect on Armor or MainGauche !
				switch (dwSWEType) {
				case 0:  break;
				case 1:  m_pClientList[iClientH]->m_iAddPR += (int)dwSWEValue*7; break;
				case 2:  m_pClientList[iClientH]->m_iAddAR += (int)dwSWEValue*7; break; // Armes Hit Proba
				case 3:  m_pClientList[iClientH]->m_iAddDR += (int)dwSWEValue*7; break;
				case 4:  // HPrec
					if (cEquipPos == DEF_EQUIPPOS_LHAND) 
						iShieldHPrec += (int)dwSWEValue*7; 
					else m_pClientList[iClientH]->m_iAddHP += (int)dwSWEValue*7; 					
					break;
				case 5:  // SPrec
					if (cEquipPos == DEF_EQUIPPOS_LHAND) 
						iShieldSPrec += (int)dwSWEValue*7; 
					else m_pClientList[iClientH]->m_iAddSP += (int)dwSWEValue*7; 
					break;
				case 6:   // MPrec
					if (cEquipPos == DEF_EQUIPPOS_LHAND) 
						iShieldMPrec += (int)dwSWEValue*7; 
					else m_pClientList[iClientH]->m_iAddMP += (int)dwSWEValue*7; 
					break; 
				case 7:  m_pClientList[iClientH]->m_iAddMR += (int)dwSWEValue*7; break;
				case 8: // PA
					if (cEquipPos == DEF_EQUIPPOS_LHAND) 
						 m_pClientList[iClientH]->m_iDamageAbsorption_Shield += (int)dwSWEValue*3; 
					else m_pClientList[iClientH]->m_iDamageAbsorption_Armor[cEquipPos] += (int)dwSWEValue*3;
					break;
				case 9:  m_pClientList[iClientH]->m_iAddAbsMD += (int)dwSWEValue*3; break;
				case 10: m_pClientList[iClientH]->m_iAddCD    += (int)dwSWEValue; break;
				case 11: m_pClientList[iClientH]->m_iAddExp   += (int)dwSWEValue*10; break;
				case 12: m_pClientList[iClientH]->m_iAddGold  += (int)dwSWEValue*10; break;
				}
				switch (dwSWEType) {
				case 9: if (m_pClientList[iClientH]->m_iAddAbsMD > 80) m_pClientList[iClientH]->m_iAddAbsMD = 80; break; // ¸¶¹ý ´ë¹ÌÁö Èí¼ö ÃÖ´ë 80%
				}
			}
			switch ( cEquipPos ) { // Sub-cases of DEF_ITEMEFFECTTYPE_DEFENSE
			case DEF_EQUIPPOS_LHAND:
				if (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectValue2 != 0)
				{	m_pClientList[iClientH]->m_iDamageAbsorption_Shield	= m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectValue2;
				}else // Snoopy individual PA setting for shields...
				{	m_pClientList[iClientH]->m_iDamageAbsorption_Shield	= (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectValue1) - (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectValue1)/3;
				}
				// Merien Upgraded shield +1 PA
				iTemp = (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_dwAttribute & 0xF0000000) >> 28;
				m_pClientList[iClientH]->m_iDamageAbsorption_Shield += iTemp;				
				// SNOOPY: No extra def ratio for Monk is Weapon equiped
				bHasMonkDefenseRation = FALSE;
				bHasBarbarianAllowedItems = FALSE;
				if (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cApprValue >3) 
					bHasDruidAllowedItems = FALSE; // Only wood Targe Leather shields for druids
				break;
			case DEF_EQUIPPOS_TWOHAND:
				bHasDruidAllowedItems = FALSE; //useless with standard items
			case DEF_EQUIPPOS_RHAND:
				bHasMonkDefenseRation = FALSE; //useless with standard items
				break;
			case DEF_EQUIPPOS_HEAD:	// PA on Head, no DR bonus for Monks
				m_pClientList[iClientH]->m_iDamageAbsorption_Armor[DEF_EQUIPPOS_HEAD] += (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectValue2);
				// Merien Upgraded helmet +1 PA
				iTemp = (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_dwAttribute & 0xF0000000) >> 28;
				m_pClientList[iClientH]->m_iDamageAbsorption_Armor[DEF_EQUIPPOS_HEAD]  += iTemp;				
				bHasMonkDefenseRation = FALSE;		
				if (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cApprValue !=7) 
					bHasDruidAllowedItems = FALSE; // Only hood for druids
				break;
			case DEF_EQUIPPOS_BODY:
				m_pClientList[iClientH]->m_iDamageAbsorption_Armor[DEF_EQUIPPOS_BODY] += (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectValue2);
				// Merien Upgraded armor +1 PA
				iTemp = (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_dwAttribute & 0xF0000000) >> 28;
				m_pClientList[iClientH]->m_iDamageAbsorption_Armor[DEF_EQUIPPOS_BODY]  += iTemp;				
				switch ( m_pClientList[iClientH]->m_cSex ) {
				case 1: // Male  1:Leather, 5:Tunic
					switch(m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cApprValue){
					case 1:  // Leather
						m_pClientList[iClientH]->m_iDamageAbsorption_Armor[DEF_EQUIPPOS_RELEASEALL] 
							= m_pClientList[iClientH]->m_iDamageAbsorption_Armor[DEF_EQUIPPOS_BODY]/2;
						bHasKnightAllowedItems = FALSE;					
						break;
					case 5:  // Tunic
						m_pClientList[iClientH]->m_iDamageAbsorption_Armor[DEF_EQUIPPOS_RELEASEALL] 
							= m_pClientList[iClientH]->m_iDamageAbsorption_Armor[DEF_EQUIPPOS_BODY]/2;
						break;
					case 2:  // Chain
					case 3:  // Scale
						bHasMonkDefenseRation = FALSE;
						bHasDruidAllowedItems = FALSE; 	
						bHasKnightAllowedItems = FALSE;
						break;
					case 6: //  Robe(M)
					case 10: // eHeroRobe(M)
					case 11: // aHeroRobe(M) // Some all places PA with robes
						m_pClientList[iClientH]->m_iDamageAbsorption_Armor[DEF_EQUIPPOS_RELEASEALL] 
							= m_pClientList[iClientH]->m_iDamageAbsorption_Armor[DEF_EQUIPPOS_BODY]/2;
						bHasKnightAllowedItems = FALSE;	
						break;
					case 4: // Plate
					default:	// plate +				
						bHasMonkDefenseRation = FALSE;
						bHasDruidAllowedItems = FALSE; 						
						bHasBarbarianAllowedItems = FALSE;
						break;		
					}
					break;
				case 2: // Women 1,2:Bodice, 3:Leather
					switch(m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cApprValue){
					case 1:  // Bodice
					case 2:  // Bodice
						m_pClientList[iClientH]->m_iDamageAbsorption_Armor[DEF_EQUIPPOS_RELEASEALL] 
							= m_pClientList[iClientH]->m_iDamageAbsorption_Armor[DEF_EQUIPPOS_BODY]/2;
						break;
					case 3:  // Leather
						m_pClientList[iClientH]->m_iDamageAbsorption_Armor[DEF_EQUIPPOS_RELEASEALL] 
							= m_pClientList[iClientH]->m_iDamageAbsorption_Armor[DEF_EQUIPPOS_BODY]/2;
						bHasKnightAllowedItems = FALSE;
						break;
					case 4:  // Chain
					case 5:  // Scale
						bHasMonkDefenseRation = FALSE;
						bHasDruidAllowedItems = FALSE; 
						bHasKnightAllowedItems = FALSE;	
						break;
					case 7: //  Robe(M)
					case 11: // eHeroRobe(M)
					case 12: // aHeroRobe(M) // Some all places PA with robes
						m_pClientList[iClientH]->m_iDamageAbsorption_Armor[DEF_EQUIPPOS_RELEASEALL] 
							= m_pClientList[iClientH]->m_iDamageAbsorption_Armor[DEF_EQUIPPOS_BODY]/2;
						bHasKnightAllowedItems = FALSE;	
						break;
					case 6: // Plate
					default:					
						bHasMonkDefenseRation = FALSE;
						bHasDruidAllowedItems = FALSE; 						
						bHasBarbarianAllowedItems = FALSE;
						break;		
					}
					break;
				}	
				break;
			case DEF_EQUIPPOS_ARMS:
				m_pClientList[iClientH]->m_iDamageAbsorption_Armor[DEF_EQUIPPOS_ARMS] += (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectValue2);
				// Merien Upgraded hauberks +1 PA
				iTemp = (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_dwAttribute & 0xF0000000) >> 28;
				m_pClientList[iClientH]->m_iDamageAbsorption_Armor[DEF_EQUIPPOS_ARMS]  += iTemp;				
				switch ( m_pClientList[iClientH]->m_cSex ) {
				case 1: // Male  1:Chemise 2:Hauberk
					if (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cApprValue >1) 
					{ 	bHasMonkDefenseRation = FALSE;
						bHasDruidAllowedItems = FALSE; 	
					}else // PA for clothes vs hammers
					{	m_pClientList[iClientH]->m_iDamageAbsorption_Armor[DEF_EQUIPPOS_RELEASEALL] 
							= m_pClientList[iClientH]->m_iDamageAbsorption_Armor[DEF_EQUIPPOS_ARMS]/2;
					}
					break;
				case 2: // Women 1,2:Chemise Shirt, 3:Hauberk
					if (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cApprValue >2)  
					{ 	bHasMonkDefenseRation = FALSE;
						bHasDruidAllowedItems = FALSE; 	
					}else // PA for clothes vs hammers
					{	m_pClientList[iClientH]->m_iDamageAbsorption_Armor[DEF_EQUIPPOS_RELEASEALL] 
							= m_pClientList[iClientH]->m_iDamageAbsorption_Armor[DEF_EQUIPPOS_ARMS]/2;
					}
					break;	
				}
				break;
			case DEF_EQUIPPOS_PANTS:
				m_pClientList[iClientH]->m_iDamageAbsorption_Armor[DEF_EQUIPPOS_PANTS] += (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectValue2);
				// Merien Upgraded leggings +1 PA
				iTemp = (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_dwAttribute & 0xF0000000) >> 28;
				m_pClientList[iClientH]->m_iDamageAbsorption_Armor[DEF_EQUIPPOS_PANTS]  += iTemp;				
				switch ( m_pClientList[iClientH]->m_cSex ) {
				case 1: // Male  1,2:Trousers, 3:Hoses
					switch (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cApprValue) {
					case 1: // Trousers
					case 2: // KneeTrousers	
						break;
					case 3: //hoses	
						bHasKnightAllowedItems = FALSE;	
						bHasMonkDefenseRation = FALSE;
						bHasDruidAllowedItems = FALSE;
						break;
					case 4: // Leggings
						bHasBarbarianAllowedItems = FALSE;
						bHasMonkDefenseRation = FALSE;
						bHasDruidAllowedItems = FALSE; 
						break;
					default: // hero / darkKnight
						bHasBarbarianAllowedItems = FALSE;
						bHasMonkDefenseRation = FALSE;
						bHasDruidAllowedItems = FALSE;
						break;
					}
					break;
				case 2: // Women 1:Skirt, 2,3:Trousers, 4:Hoses
					switch (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cApprValue) {
					case 1: // Skirt
					case 2: // Trousers	
					case 3: // KneeTrousers	
						break;					
					case 4: //hoses
						bHasKnightAllowedItems = FALSE;	
						bHasMonkDefenseRation = FALSE;
						bHasDruidAllowedItems = FALSE;	
						break;
					case 5: // Leggings
						bHasBarbarianAllowedItems = FALSE;
						bHasMonkDefenseRation = FALSE;
						bHasDruidAllowedItems = FALSE;
						break;
					default: // hero / darkKnight
						bHasBarbarianAllowedItems = FALSE;
						bHasMonkDefenseRation = FALSE;
						bHasDruidAllowedItems = FALSE;
						break;
					}
					break;				
				}
				break;
			case DEF_EQUIPPOS_FOOT: // Boots, Shoes
				m_pClientList[iClientH]->m_iDamageAbsorption_Armor[DEF_EQUIPPOS_FOOT] += (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectValue2);
				// Merien Upgraded boots +1 PA
				iTemp = (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_dwAttribute & 0xF0000000) >> 28;
				m_pClientList[iClientH]->m_iDamageAbsorption_Armor[DEF_EQUIPPOS_FOOT]  += iTemp;				
				// Motemorphosed char is still affected by original boots
				m_pClientList[iClientH]->m_iDefenseRatio3 += m_pClientList[iClientH]->m_pItemList[ sItemIndex ]->m_sItemEffectValue1;
				break;
			case DEF_EQUIPPOS_BACK: // Cape
				// Motemorphosed char is still affected by original cape
				m_pClientList[iClientH]->m_iDefenseRatio3 += m_pClientList[iClientH]->m_pItemList[ sItemIndex ]->m_sItemEffectValue1;

			default:
				// SNOOPY: Kept this here so we can use Damage absorbtion for something else (ie: Cape)
				m_pClientList[iClientH]->m_iDamageAbsorption_Armor[cEquipPos] += (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectValue2);
				// Merien Upgraded diverse (capes?)
				iTemp = (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_dwAttribute & 0xF0000000) >> 28;
				m_pClientList[iClientH]->m_iDamageAbsorption_Armor[cEquipPos]  += iTemp;				
				break;
			}

			switch (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectType) {
			case DEF_ITEMEFFECTTYPE_DEFENSE_SPECABLTY:
				m_pClientList[iClientH]->m_iSpecialAbilityType = m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sSpecialEffect;
				m_pClientList[iClientH]->m_iSpecialAbilityLastSec = m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sSpecialEffectValue1; 
				m_pClientList[iClientH]->m_iSpecialAbilityEquipPos = (int)cEquipPos;
				if ((bNotify == TRUE) && (iEquipItemID == (int)sItemIndex))
					SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_SPECIALABILITYSTATUS, 2, m_pClientList[iClientH]->m_iSpecialAbilityType, m_pClientList[iClientH]->m_iSpecialAbilityTime, NULL);
				break;
			}
			break;
		}
	}

	//v1.432
	if ((iPrevSAType != 0) && (m_pClientList[iClientH]->m_iSpecialAbilityType == 0) && (bNotify == TRUE)) 
	{	SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_SPECIALABILITYSTATUS, 4, NULL, NULL, NULL);
		if (m_pClientList[iClientH]->m_bIsSpecialAbilityEnabled == TRUE) 
		{	m_pClientList[iClientH]->m_bIsSpecialAbilityEnabled = FALSE;
			m_pClientList[iClientH]->m_iSpecialAbilityTime = DEF_SPECABLTYTIMESEC;
			sTemp = m_pClientList[iClientH]->m_sAppr4;
			sTemp = sTemp & 0xFF0F;
			m_pClientList[iClientH]->m_sAppr4 = sTemp;
			SendEventToNearClient_TypeA(iClientH, DEF_OWNERTYPE_PLAYER, MSGID_EVENT_MOTION, DEF_OBJECTNULLACTION, NULL, NULL, NULL);
	}	}	
	if (   (iPrevSAType != 0) && (m_pClientList[iClientH]->m_iSpecialAbilityType != 0) 
		&& (iPrevSAType != m_pClientList[iClientH]->m_iSpecialAbilityType) && (bNotify == TRUE)) 
	{	if (m_pClientList[iClientH]->m_bIsSpecialAbilityEnabled == TRUE) 
		{	SendNotifyMsg(NULL, i, DEF_NOTIFY_SPECIALABILITYSTATUS, 3, NULL, NULL, NULL); // 20min
			m_pClientList[iClientH]->m_bIsSpecialAbilityEnabled = FALSE;
			m_pClientList[iClientH]->m_iSpecialAbilityTime = DEF_SPECABLTYTIMESEC;
			sTemp = m_pClientList[iClientH]->m_sAppr4;
			sTemp = sTemp & 0xFF0F;
			m_pClientList[iClientH]->m_sAppr4 = sTemp;
			SendEventToNearClient_TypeA(iClientH, DEF_OWNERTYPE_PLAYER, MSGID_EVENT_MOTION, DEF_OBJECTNULLACTION, NULL, NULL, NULL);
	}	}

	switch (m_pClientList[iClientH]->m_iPriestDruidID) {
	case 2: // Druids
		if ((bHasDruidAllowedItems == FALSE) && (m_pClientList[iClientH]->m_bSpecialFeatureAllowed == TRUE))
		{	m_pClientList[iClientH]->m_bSpecialFeatureAllowed = FALSE;
			bCheckMagicInt(iClientH);		
			// Say to client he lost druid powers.	
			
			ZeroMemory(cInfoString, sizeof(cInfoString));
			wsprintf(cInfoString, "By equiping a forbidden item, you lost Druid abilities.");
			ShowClientMsg(iClientH, "Druid",  cInfoString);				
			// Logging the lost Druid
			wsprintf(G_cTxt, "PC(%s)\tUsing forbiden item. Druid abilities lost.\t%s(%d %d)\tIP(%s)"
				, m_pClientList[iClientH]->m_cCharName
				, m_pClientList[iClientH]->m_cMapName
				, m_pClientList[iClientH]->m_sX
				, m_pClientList[iClientH]->m_sY
				, m_pClientList[iClientH]->m_cIPaddress);
			PutItemLogFileList(G_cTxt);
			PutLogFileList(G_cTxt);

		}else
		{	m_pClientList[iClientH]->m_bSpecialFeatureAllowed = TRUE;
		}
		break;
	case 3: // Monks
		if ((bHasMonkDefenseRation == FALSE) && (m_pClientList[iClientH]->m_bSpecialFeatureAllowed == TRUE))
		{	m_pClientList[iClientH]->m_bSpecialFeatureAllowed = FALSE;
			// Say to client he lost Monk bonus	
			char cInfoString[300];
			ZeroMemory(cInfoString, sizeof(cInfoString));
			wsprintf(cInfoString, "By wearing a cumbersome item, you lost Monk special advantages.");
			ShowClientMsg(iClientH, "Monk",  cInfoString);	
		}else
		{	m_pClientList[iClientH]->m_iDefenseRatio  += m_pClientList[iClientH]->m_cSkillMastery[5]/2;
	 		m_pClientList[iClientH]->m_iDefenseRatio2 += m_pClientList[iClientH]->m_cSkillMastery[5]/2;	 
			m_pClientList[iClientH]->m_bSpecialFeatureAllowed = TRUE;
		}
		break;
	case 5: //Knights
		if ((bHasKnightAllowedItems == FALSE) && (m_pClientList[iClientH]->m_bSpecialFeatureAllowed == TRUE)) 
		{	m_pClientList[iClientH]->m_bSpecialFeatureAllowed = FALSE;
			// Say to client he lost Chevalier bonus	
			 char cInfoString[300];
			 ZeroMemory(cInfoString, sizeof(cInfoString));
			 wsprintf(cInfoString, "By using  degrading weaponry, you lost Knight special abilities.");
			 ShowClientMsg(iClientH, "Knight",  cInfoString);		
		}else
		{	// PA (+10) rajouté ds iCalculateAttackEffect(..)
			m_pClientList[iClientH]->m_bSpecialFeatureAllowed = TRUE;			
		}
		break;
	case 6:  // Barbarian
		if ((bHasBarbarianAllowedItems == FALSE) && (m_pClientList[iClientH]->m_bSpecialFeatureAllowed == TRUE))
		{	m_pClientList[iClientH]->m_bSpecialFeatureAllowed = FALSE;
			// Say to client he lost barbarian bonus	
			 char cInfoString[300];
			 ZeroMemory(cInfoString, sizeof(cInfoString));
			 wsprintf(cInfoString, "By wearing a cumbersome armor, you lost Barbarian special abilities.");
			 ShowClientMsg(iClientH, "Barbarian",  cInfoString);	
		}else
		{	m_pClientList[iClientH]->m_bSpecialFeatureAllowed = TRUE;			
			m_pClientList[iClientH]->m_cAttackDiceThrow_L  += 1;
		}
		break;
	case 1 : // Priests
	default: // others
		break;
	}
	// Snoopy! Limitation of HPrec, MPrec SPrec.100% max not counting shield			
	if (m_pClientList[iClientH]->m_iAddHP > 100 ) m_pClientList[iClientH]->m_iAddHP = 100;
	if (m_pClientList[iClientH]->m_iAddSP > 100 ) m_pClientList[iClientH]->m_iAddSP = 100;
	if (m_pClientList[iClientH]->m_iAddMP > 100 ) m_pClientList[iClientH]->m_iAddMP = 100;
	m_pClientList[iClientH]->m_iAddHP += iShieldHPrec;					
	m_pClientList[iClientH]->m_iAddSP += iShieldSPrec;
	m_pClientList[iClientH]->m_iAddMP += iShieldMPrec;
	m_pClientList[iClientH]->m_cHeroArmourBonus = _cCheckHeroItemEquipped(iClientH);

	// Snoopy: Bonus for Angels	
	m_pClientList[iClientH]->m_iDefenseRatio += m_pClientList[iClientH]->m_iAngelicDex * 2;
	m_pClientList[iClientH]->m_iDefenseRatio2 += m_pClientList[iClientH]->m_iAngelicDex;

	// Snoopy: Test PvP mode moins favorable aux bourinos low dext.
	if ((m_pClientList[iClientH]->m_iDex + m_pClientList[iClientH]->m_iAngelicDex) > 101)
		m_pClientList[iClientH]->m_iDefenseRatio2 += (((m_pClientList[iClientH]->m_iDex + m_pClientList[iClientH]->m_iAngelicDex)-100)/4);
	if ((m_pClientList[iClientH]->m_iDex + m_pClientList[iClientH]->m_iAngelicDex) > 201)
		m_pClientList[iClientH]->m_iDefenseRatio2 += (((m_pClientList[iClientH]->m_iDex + m_pClientList[iClientH]->m_iAngelicDex)-200)/4);

	if (m_pClientList[iClientH]->m_iHP > iGetMaxHP(iClientH)) m_pClientList[iClientH]->m_iHP = iGetMaxHP(iClientH, FALSE);
	if (m_pClientList[iClientH]->m_iMP > iGetMaxMP(iClientH)) m_pClientList[iClientH]->m_iMP = iGetMaxMP(iClientH);
	if (m_pClientList[iClientH]->m_iSP > iGetMaxSP(iClientH)) m_pClientList[iClientH]->m_iSP = iGetMaxSP(iClientH);

	// Set effects
	if (iLastSetEffect != m_pClientList[iClientH]->m_iSetEffect) // changed
	{	if (iLastSetEffect == 4)// no more set effect
		{	ZeroMemory(cInfoString, sizeof(cInfoString));
			wsprintf(cInfoString, "No more wearing a full Dark-Elf set, you lost Drow's magic resistance!");
			ShowClientMsg(iClientH, "Drow",  cInfoString);
		}else if (m_pClientList[iClientH]->m_iSetEffect	== 4) //New set effect
		{	ZeroMemory(cInfoString, sizeof(cInfoString));
			wsprintf(cInfoString, "By using a full Dark-Elf set, you gain Drow's magic resistance!");
			ShowClientMsg(iClientH, "Drow",  cInfoString);
	}	}

	// Maximum value for  PA, here instead of iCalculateAttackEffect
	if (m_pClientList[iClientH]->m_iDamageAbsorption_Armor[DEF_EQUIPPOS_BODY]  > 60)	// Torse,  max 60
		m_pClientList[iClientH]->m_iDamageAbsorption_Armor[DEF_EQUIPPOS_BODY]  = 60;
	if (m_pClientList[iClientH]->m_iDamageAbsorption_Armor[DEF_EQUIPPOS_HEAD]  > 60)	// Tête    max 60
		m_pClientList[iClientH]->m_iDamageAbsorption_Armor[DEF_EQUIPPOS_HEAD]  = 60;
	if (m_pClientList[iClientH]->m_iDamageAbsorption_Armor[DEF_EQUIPPOS_ARMS]  > 60)	// Membres max 60
		m_pClientList[iClientH]->m_iDamageAbsorption_Armor[DEF_EQUIPPOS_ARMS]  = 60;
	if (m_pClientList[iClientH]->m_iDamageAbsorption_Armor[DEF_EQUIPPOS_PANTS] > 60)	// Membres max 60 
		m_pClientList[iClientH]->m_iDamageAbsorption_Armor[DEF_EQUIPPOS_PANTS] = 60;
	if (m_pClientList[iClientH]->m_iDamageAbsorption_Armor[DEF_EQUIPPOS_FOOT]  > 60)	// Pieds   max 60 
		m_pClientList[iClientH]->m_iDamageAbsorption_Armor[DEF_EQUIPPOS_FOOT]  = 60;
	if (m_pClientList[iClientH]->m_iDamageAbsorption_Armor[DEF_EQUIPPOS_BACK]  > 60)	// Dos     max 60
		m_pClientList[iClientH]->m_iDamageAbsorption_Armor[DEF_EQUIPPOS_BACK]  = 60;
	if (m_pClientList[iClientH]->m_iDamageAbsorption_Shield > 60)						// Shield  max 60
		m_pClientList[iClientH]->m_iDamageAbsorption_Shield = 60;

	// Ne dire aux clients que si ca a changé.
	if (iTotalAngelicstatas != (m_pClientList[iClientH]->m_iAngelicStr + (16 * m_pClientList[iClientH]->m_iAngelicInt)
		+ (256 * m_pClientList[iClientH]->m_iAngelicDex) + (16*256 * m_pClientList[iClientH]->m_iAngelicMag)))
	{	SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_SETTING_SUCCESS, NULL, NULL, NULL, NULL);
	}

	
}

int CGame::_iGetPlayerNumberOnSpot(short dX, short dY, char cMapIndex, char cRange)
{
 register int ix, iy, iSum = 0;
 short sOwnerH;
 char  cOwnerType;

	for (ix = dX - cRange; ix <= dX + cRange; ix++)
	for (iy = dY - cRange; iy <= dY + cRange; iy++) {
		m_pMapList[cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, ix, iy);
		if ((sOwnerH != NULL) && (cOwnerType == DEF_OWNERTYPE_PLAYER))
			iSum++;
	}
	return iSum;
}

void CGame::RequestAdminUserMode(int iClientH, char * pData)
{	if (m_pClientList[iClientH] == NULL) return;
	// Should be useless but who knows !
	wsprintf(G_cTxt, "Unknown message:   PC(%s) - Sent a MSGID_ADMINUSER message. \tIP(%s)"
		, m_pClientList[iClientH]->m_cCharName
		, m_pClientList[iClientH]->m_cIPaddress);
	PutHackLogFileList(G_cTxt); 
}

BOOL CGame::bAnalyzeCriminalAction(int iClientH, short dX, short dY, BOOL bIsCheck)
{
 int   iNamingValue, tX, tY;
 short sOwnerH;
 char  cOwnerType, cName[11], cNpcName[21];
 char  cNpcWaypoint[11];

	if (m_pClientList[iClientH] == NULL) return FALSE;
	if (m_pClientList[iClientH]->m_bIsInitComplete == FALSE) return FALSE;
	if (m_bIsCrusadeMode == TRUE) return FALSE;

	m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, dX, dY);

	if ((cOwnerType == DEF_OWNERTYPE_PLAYER) && (m_pClientList[sOwnerH] != NULL)) {
		if (_bGetIsPlayerHostile(iClientH, sOwnerH) != TRUE) {
			if (bIsCheck == TRUE) return TRUE;

			ZeroMemory(cNpcName, sizeof(cNpcName));
			if ((strcmp(m_pClientList[iClientH]->m_cMapName, "aresden") == 0) && (!m_bMapModeEquilibrium))
				strcpy(cNpcName, "Guard-Aresden");			
			else if ((strcmp(m_pClientList[iClientH]->m_cMapName, "elvine") == 0) && (!m_bMapModeEquilibrium)) 
				strcpy(cNpcName, "Guard-Elvine");
			else  if ((strcmp(m_pClientList[iClientH]->m_cMapName, "lost") == 0) && (m_bMapModeEquilibrium)) 
				strcpy(cNpcName, "Guard-Equi");
			else if ((strcmp(m_pClientList[iClientH]->m_cMapName, "default") == 0) && (!m_bMapModeEquilibrium)) 
				strcpy(cNpcName, "Guard-Neutral");
			iNamingValue = m_pMapList[ m_pClientList[iClientH]->m_cMapIndex ]->iGetEmptyNamingValue();
			if (iNamingValue == -1) {

			}
			else {
				ZeroMemory(cNpcWaypoint, sizeof(cNpcWaypoint));
				ZeroMemory(cName, sizeof(cName));
			   	wsprintf(cName, "XX%d", iNamingValue);
				cName[0] = '_';
				cName[1] = m_pClientList[iClientH]->m_cMapIndex+65;
				
				tX = (int)m_pClientList[iClientH]->m_sX;
				tY = (int)m_pClientList[iClientH]->m_sY;
				if (bCreateNewNpc(cNpcName, cName, m_pMapList[ m_pClientList[iClientH]->m_cMapIndex ]->m_cName, 0, 0, DEF_MOVETYPE_RANDOM, 
					              &tX, &tY, cNpcWaypoint, NULL, NULL, -1, FALSE, TRUE) == FALSE) 
				{	m_pMapList[ m_pClientList[iClientH]->m_cMapIndex ]->SetNamingValueEmpty(iNamingValue);
				}else 
				{	bSetNpcAttackMode(cName, iClientH, DEF_OWNERTYPE_PLAYER, TRUE);
				}
			}
		}
	}
	return FALSE;
}

BOOL CGame::_bGetIsPlayerHostile(int iClientH, int sOwnerH)
{
	if (m_pClientList[iClientH] == NULL) return FALSE;
	if (m_pClientList[sOwnerH]  == NULL) return FALSE;

	if (iClientH == sOwnerH) return TRUE;
	if (m_pClientList[iClientH]->m_cSide == 0) {
		if (m_pClientList[sOwnerH]->m_iPKCount != 0) 
			 return TRUE;
		else return FALSE;
	}
	else {
		if (m_pClientList[iClientH]->m_cSide != m_pClientList[sOwnerH]->m_cSide) {
			if (m_pClientList[sOwnerH]->m_cSide == 0) {
				if (m_pClientList[sOwnerH]->m_iPKCount != 0) 
				 	 return TRUE;
				else return FALSE;
			}
			else return TRUE;
		}
		else {
			if (m_pClientList[sOwnerH]->m_iPKCount != 0) 
			 	 return TRUE;
			else return FALSE;
		}
	}
	return FALSE;
}

void CGame::bSetNpcAttackMode(char * cName, int iTargetH, char cTargetType, BOOL bIsPermAttack)
{
 register int i, iIndex;	
	for (i = 1; i < DEF_MAXNPCS; i++)
	if ((m_pNpcList[i] != NULL) && (memcmp(m_pNpcList[i]->m_cName, cName, 5) == 0) ) {
		iIndex = i;
		goto NEXT_STEP_SNAM1;
	}
	return;

NEXT_STEP_SNAM1:;
	switch (cTargetType) {
	case DEF_OWNERTYPE_PLAYER:
		if (m_pClientList[iTargetH] == NULL) return;
		break;

	case DEF_OWNERTYPE_NPC:
		if (m_pNpcList[iTargetH] == NULL) return;
		break;
	}
	m_pNpcList[iIndex]->m_cBehavior          = DEF_BEHAVIOR_ATTACK;
	m_pNpcList[iIndex]->m_sBehaviorTurnCount = 0;		
	m_pNpcList[iIndex]->m_iTargetIndex = iTargetH;
	m_pNpcList[iIndex]->m_cTargetType  = cTargetType;
	m_pNpcList[iIndex]->m_bIsPermAttackMode = bIsPermAttack;
}


void CGame::PoisonEffect(int iClientH, int iV1)
{   int iPoisonLevel, iDamage, iPrevHP, iProb;
	if (m_pClientList[iClientH] == NULL)     return;
	if (m_pClientList[iClientH]->m_bIsKilled == TRUE) return;
	if (m_pClientList[iClientH]->m_bIsInitComplete == FALSE) return;

	iPoisonLevel = m_pClientList[iClientH]->m_iPoisonLevel;
	iDamage = iDice(1, iPoisonLevel);	
	iPrevHP = m_pClientList[iClientH]->m_iHP;
	m_pClientList[iClientH]->m_iHP -= iDamage;
	if (m_pClientList[iClientH]->m_iHP <= 0) m_pClientList[iClientH]->m_iHP = 1;

	if (iPrevHP != m_pClientList[iClientH]->m_iHP)
	{	m_pClientList[iClientH]->m_dwLastDamageTime = timeGetTime();
		SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_HP, NULL, NULL, NULL, NULL);
	}
	iProb = m_pClientList[iClientH]->m_cSkillMastery[23] -10 + m_pClientList[iClientH]->m_iAddPR;
	if (iProb <= 10) iProb = 10;
	if (iDice(1,100) <= iProb) {
		m_pClientList[iClientH]->m_bIsPoisoned = FALSE;
		SetPoisonFlag(iClientH, DEF_OWNERTYPE_PLAYER, FALSE); // remove poison aura after effect complete
		SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_MAGICEFFECTOFF, DEF_MAGICTYPE_POISON, NULL, NULL, NULL);
	}
}
BOOL CGame::bCheckResistingPoisonSuccess(short sOwnerH, char cOwnerType)
{	int iResist, iResult;
	
	switch (cOwnerType) {
	case DEF_OWNERTYPE_PLAYER:
		if (m_pClientList[sOwnerH] == NULL) return FALSE;
		if ((m_pClientList[sOwnerH]->m_iPriestDruidID == 3 ) && (m_pClientList[sOwnerH]->m_iLevel >119))
		{ return TRUE; } // Monks 120+ Poison invulnerables
		if ( (m_pClientList[sOwnerH]->m_iPriestDruidID == 2 ) 
			&& (m_pClientList[sOwnerH]->m_bSpecialFeatureAllowed)
			&& (m_pClientList[sOwnerH]->m_iLevel >119))
		{ return TRUE; } // Druids 120+ Poison invulnerables
		iResist = m_pClientList[sOwnerH]->m_cSkillMastery[23] +m_pClientList[sOwnerH]->m_iAddPR;
		break;

	case DEF_OWNERTYPE_NPC:
		if (m_pNpcList[sOwnerH] == NULL) return FALSE;
		iResist = m_pNpcList[sOwnerH]->m_cPoisonResistance;
		break;
	}

	iResult = iDice(1, 100);
  	if (iResult >= iResist)  
	{	return FALSE;
	}
	if (cOwnerType == DEF_OWNERTYPE_PLAYER)
		CalculateSSN_SkillIndex(sOwnerH, 23, 1);

	return TRUE;
}

BOOL CGame::bCheckBadWord(char * pString)
{
 char * cp;
	cp = pString;
	while (*cp != NULL) {		
		cp++;
	}
	return FALSE;
}

void CGame::CheckDayOrNightMode()
{
 SYSTEMTIME SysTime;	
 char cPrevMode;
 int  i;
	// SNOOPY: ARF ! was = , and not == !
	if (m_bManualTime == TRUE) return;	// 
	cPrevMode = m_cDayOrNight; 
	GetLocalTime(&SysTime);
	if (SysTime.wMinute >= DEF_NIGHTTIME) 
	{	m_cDayOrNight = (char) 2; // Night
	}else
	{	m_cDayOrNight = (char) 1; // Day
	}
	if (cPrevMode != m_cDayOrNight) {
		// See that on server's window
		wsprintf(G_cTxt, "(!) Switching Day/Night: %d", m_cDayOrNight);
		PutLogList(G_cTxt);
		//  
		for (i = 1; i < DEF_MAXCLIENTS; i++) 
		if ((m_pClientList[i] != NULL) && (m_pClientList[i]->m_bIsInitComplete == TRUE)) {
			if ((m_pClientList[i]->m_cMapIndex >= 0) && 
				(m_pMapList[m_pClientList[i]->m_cMapIndex] != NULL) &&
				(m_pMapList[m_pClientList[i]->m_cMapIndex]->m_bIsFixedDayMode == FALSE))
				SendNotifyMsg(NULL, i, DEF_NOTIFY_TIMECHANGE, m_cDayOrNight, NULL, NULL, NULL);	
		}
	}
}


void CGame::ShutUpPlayer(int iClientH, char * pMsg, DWORD dwMsgSize)
{	char   seps[] = "= \t\n";
	char   * token, cName[11], cBuff[256];
	class  CStrTok * pStrTok;
	register int i, iTime;
	if (m_pClientList[iClientH] == NULL) return;
	if ((dwMsgSize)	<= 0) return;
	if (m_pClientList[iClientH]->m_iAdminUserLevel < m_iAdminLevelShutup) 
	{	SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_ADMINUSERLEVELLOW, NULL, NULL, NULL, NULL);
		return;
	}
	ZeroMemory(cName, sizeof(cName));
	ZeroMemory(cBuff, sizeof(cBuff));
	memcpy(cBuff, pMsg, dwMsgSize);
	pStrTok = new class CStrTok(cBuff, seps);
	token = pStrTok->pGet();
	token = pStrTok->pGet();   	
	if (token != NULL) 
	{	if (strlen(token) > 10) 
			 memcpy(cName, token, 10);
		else memcpy(cName, token, strlen(token));		
		token = pStrTok->pGet();
		if (token == NULL) 
			 iTime = 0;
		else iTime = atoi(token);	
		if (iTime < 0) iTime = 0;	 		
		for (i = 1; i < DEF_MAXCLIENTS; i++) 
		if ((m_pClientList[i] != NULL) && (memcmp(m_pClientList[i]->m_cCharName, cName, 10) == 0)) 
		{	m_pClientList[i]->m_iTimeLeft_ShutUp = iTime * 20; 
			SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_PLAYERSHUTUP, iTime *60, NULL, NULL, cName);
			SendNotifyMsg(NULL, i, DEF_NOTIFY_PLAYERSHUTUP, iTime * 60, NULL, NULL, cName);
			// Admin Log
			wsprintf(G_cTxt, "Admin Order(%s): Shutup PC(%s) (%d)Min\tAdminIP(%s)"
				, m_pClientList[iClientH]->m_cCharName
				, m_pClientList[i]->m_cCharName
				, iTime
				, m_pClientList[iClientH]->m_cIPaddress);
			PutAdminLogFileList(G_cTxt);
			wsprintf(G_cTxt, "GM Order(%-10s): /shutup (%s)", m_pClientList[iClientH]->m_cCharName, m_pClientList[i]->m_cCharName);
			bSendMsgToLS(MSGID_GAMEMASTERLOG, iClientH, FALSE, G_cTxt);

			delete pStrTok;
			return;
		}
		ZeroMemory(cBuff, sizeof(cBuff));
		char *cp;
		WORD *wp;
		cp = (char *)cBuff;
		*cp = GSM_REQUEST_SHUTUPPLAYER;
		cp++;
		wp = (WORD *)cp;
		*wp = m_wServerID_GSS;
		cp += 2;
		wp = (WORD *)cp;
		*wp = (WORD)iClientH;
		cp += 2;
		memcpy(cp, cName, 10);
		cp += 10;
		wp = (WORD *)cp;
		*wp = iTime;
		cp += 2;
		memcpy(cp, m_pClientList[iClientH]->m_cCharName, 10);
		cp += 10;
		bStockMsgToGateServer(cBuff, 27);
	}
	delete pStrTok;
	return;
}


void CGame::SetPlayerReputation(int iClientH, char * pMsg, char cValue, DWORD dwMsgSize)
{	char   seps[] = "= \t\n";
	char   * token, cName[11], cBuff[256];
	class  CStrTok * pStrTok;
	register int i;
	if (m_pClientList[iClientH] == NULL) return;
	if ((dwMsgSize)	<= 0) return;
	if (m_pClientList[iClientH]->m_iLevel < 40)  
	{	SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_CANNOTRATING, 0, NULL, NULL, NULL);
		return;
	}
	if (m_pClientList[iClientH]->m_cSide < 1) 
	{	SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_CANNOTRATING, 0, NULL, NULL, NULL);
		return;
	}
	if (m_pClientList[iClientH]->m_cSide > 2)  
	{	SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_CANNOTRATING, 0, NULL, NULL, NULL);
		return;
	}
	if ((m_pClientList[iClientH]->m_iTimeLeft_Rating != 0) || (m_pClientList[iClientH]->m_iPKCount != 0)) 
	{	SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_CANNOTRATING, m_pClientList[iClientH]->m_iTimeLeft_Rating, NULL, NULL, NULL);
		return;
	}
	/*else if (memcmp(m_pClientList[iClientH]->m_cLocation, "NONE", 4) == 0) {
		SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_CANNOTRATING, 0, NULL, NULL, NULL);
		return;	
	}*/
	ZeroMemory(cName, sizeof(cName));
	ZeroMemory(cBuff, sizeof(cBuff));
	memcpy(cBuff, pMsg, dwMsgSize);
	pStrTok = new class CStrTok(cBuff, seps);
	token = pStrTok->pGet();
	token = pStrTok->pGet();
   	
	if (token != NULL) {
		// token
		if (strlen(token) > 10) 
			 memcpy(cName, token, 10);
		else memcpy(cName, token, strlen(token));		
		for (i = 1; i < DEF_MAXCLIENTS; i++) 
		if ((m_pClientList[i] != NULL) && (memcmp(m_pClientList[i]->m_cCharName, cName, 10) == 0)) 
		{	if (i != iClientH) 
			{	if (cValue == 0) 
					m_pClientList[i]->m_iRating--;
				else if (cValue == 1)
					m_pClientList[i]->m_iRating++;				
				if (m_pClientList[i]->m_iRating > 10000)  m_pClientList[i]->m_iRating = 10000;
				if (m_pClientList[i]->m_iRating < -10000) m_pClientList[i]->m_iRating = -10000;
				AdjustClientDropRate(i);
				m_pClientList[iClientH]->m_iTimeLeft_Rating = 20*60;
				SendNotifyMsg(NULL, i, DEF_NOTIFY_RATINGPLAYER, cValue, NULL, NULL, cName);
				SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_RATINGPLAYER, cValue, NULL, NULL, cName);				
				delete pStrTok;
				return;
			}
		}
		SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_PLAYERNOTONGAME, NULL, NULL, NULL, cName);
	}	
	delete pStrTok;
	return;
}

BOOL CGame::bReadNotifyMsgListFile(char * cFn)
{FILE * pFile;
 HANDLE hFile;
 DWORD  dwFileSize;
 char * cp, * token, cReadMode;
 char seps[] = "=\t\n;";
 class CStrTok * pStrTok;
 int   i;
	cReadMode = 0;
	m_iTotalNoticeMsg = 0;
	hFile = CreateFile(cFn, GENERIC_READ, NULL, NULL, OPEN_EXISTING, NULL, NULL);
	dwFileSize = GetFileSize(hFile, NULL);
	if (hFile != INVALID_HANDLE_VALUE) CloseHandle(hFile);
	pFile = fopen(cFn, "rt");
	if (pFile == NULL) 
	{	PutLogList("(!) Notify Message list file (notice.txt), not found!...");
		return FALSE;
	}else 
	{	PutLogList("(!) Reading Notify Message list file...");
		cp = new char[dwFileSize+2];
		ZeroMemory(cp, dwFileSize+2);
		fread(cp, dwFileSize, 1, pFile);

		pStrTok = new class CStrTok(cp, seps);
		token = pStrTok->pGet();
		//token = strtok( cp, seps );   
		while( token != NULL )   			
		{	if (cReadMode != 0) {
				switch (cReadMode) {
				case 1:
					for (i = 0; i < DEF_MAXNOTIFYMSGS; i++) 
					if (m_pNoticeMsgList[i] == NULL) 
					{	m_pNoticeMsgList[i] = new class CMsg;	
						m_pNoticeMsgList[i]->bPut(NULL, token, strlen(token), NULL, NULL, NULL);
						m_iTotalNoticeMsg++;
						goto LNML_NEXTSTEP1;
					}
LNML_NEXTSTEP1:;					
					cReadMode = 0;
					break;
				}
			}else 
			{	if (memcmp(token, "notify_msg", 10) == 0) cReadMode = 1;
			}			
			token = pStrTok->pGet();
			//token = strtok( NULL, seps );
		}
		delete pStrTok;
		delete cp;
	}
	if (pFile != NULL) fclose(pFile);
	return TRUE;
}

void CGame::NoticeHandler()
{char  cTemp, cBuffer[1000], cKey;
 DWORD dwSize, dwTime = timeGetTime();
 register int i, iMsgIndex, iTemp;
	if (m_iTotalNoticeMsg <= 1) return;
	if ((dwTime - m_dwNoticeTime) > DEF_NOTICETIME) 
	{ 	m_dwNoticeTime = dwTime;	
		do 
		{	iMsgIndex = iDice(1, m_iTotalNoticeMsg) - 1;
		}while (iMsgIndex == m_iPrevSendNoticeMsg);
		m_iPrevSendNoticeMsg = iMsgIndex;		
		ZeroMemory(cBuffer, sizeof(cBuffer));
		if (m_pNoticeMsgList[iMsgIndex] != NULL) 
		{	m_pNoticeMsgList[iMsgIndex]->Get(&cTemp, cBuffer, &dwSize, &iTemp, &cKey, &dwTime);// Time unused here...
		}		
		for (i = 1; i < DEF_MAXCLIENTS; i++)
		if (m_pClientList[i] != NULL) 
		{	SendNotifyMsg(NULL, i, DEF_NOTIFY_NOTICEMSG, NULL, NULL, NULL, cBuffer);
	}	}
}

void CGame::ResponseSavePlayerDataReplyHandler(char * pData, DWORD dwMsgSize)
{char * cp, cCharName[11];
 register int i;
	ZeroMemory(cCharName, sizeof(cCharName));	
	cp = (char *)(pData + DEF_INDEX2_MSGTYPE + 2);
	memcpy(cCharName, cp, 10);
	for (i = 0; i < DEF_MAXCLIENTS; i++) 
	if (m_pClientList[i] != NULL) 
	{	if (memcmp(m_pClientList[i]->m_cCharName, cCharName, 10) == 0) 
		{	SendNotifyMsg(NULL, i, DEF_NOTIFY_SERVERCHANGE, NULL, NULL, NULL, NULL);
		}
	}
}

void CGame::CalcExpStock(int iClientH)
{	BOOL bIsLevelUp;
	class CItem * pItem;
	if (m_pClientList[iClientH] == NULL) return;
	if (m_pClientList[iClientH]->m_bIsInitComplete == FALSE) return;
	if (m_pClientList[iClientH]->m_iExpStock <= 0) return;
	//if ((m_pClientList[iClientH]->m_iLevel >= m_iPlayerMaxLevel) && (m_pClientList[iClientH]->m_iExp >= m_iLevelExpTable[m_iPlayerMaxLevel])) return;
	if (m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cType == DEF_MAPTYPE_NOPENALTY_NOREWARD) 
	{	m_pClientList[iClientH]->m_iExpStock = 0;
		return;
	}
	m_pClientList[iClientH]->m_iExp += m_pClientList[iClientH]->m_iExpStock;
	m_pClientList[iClientH]->m_iAutoExpAmount += m_pClientList[iClientH]->m_iExpStock;
	m_pClientList[iClientH]->m_iExpStock = 0;
	if (bCheckLimitedUser(iClientH) == FALSE) 
	{	SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_EXP, NULL, NULL, NULL, NULL);
	}else if (bCheckPLRaider(iClientH) == FALSE) 
	{	SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_EXP, NULL, NULL, NULL, NULL);
	} 
	bIsLevelUp = bCheckLevelUp(iClientH);
	// Compute gold for travellers
	if ((bIsLevelUp == TRUE) && (m_pClientList[iClientH]->m_iLevel <= 5)) 
	{	pItem = new class CItem;
		if (_bInitItemAttr(pItem, "Gold") == FALSE) 
		{	delete pItem;	return;
		}else pItem->m_dwCount = (DWORD)100;
		bAddItem(iClientH, pItem, NULL);
	}
	if ((bIsLevelUp == TRUE) && (m_pClientList[iClientH]->m_iLevel > 5 ) &&  (m_pClientList[iClientH]->m_iLevel <= 20) ) {
		pItem = new class CItem;
		if (_bInitItemAttr(pItem, "Gold") == FALSE) 
		{	delete pItem;	return;
		}
		else pItem->m_dwCount = (DWORD)300;
		bAddItem(iClientH, pItem, NULL);
	}
}

void CGame::___RestorePlayerRating(int iClientH)
{	if (m_pClientList[iClientH] == NULL) return;
	if (m_pClientList[iClientH]->m_iRating < -1000) m_pClientList[iClientH]->m_iRating = -1000;
	if (m_pClientList[iClientH]->m_iRating >  1000) m_pClientList[iClientH]->m_iRating = 1000;	
	AdjustClientDropRate(iClientH);
}

int CGame::iGetExpLevel(int iExp)
{ register int i;
	for (i = 1; i < 1001; i++) 
	if ((m_iLevelExpTable[i] <= iExp) && (m_iLevelExpTable[i+1] > iExp)) return i;
	return 0;
}

void CGame::AdminOrder_CallGuard(int iClientH, char * pData, DWORD dwMsgSize)
{char   seps[] = "= \t\n";
 char   * token, cName[11], cTargetName[11], cBuff[256], cNpcName[21], cNpcWaypoint[11];
 class  CStrTok * pStrTok;
 register int i, iNamingValue, tX, tY;
	if (m_pClientList[iClientH] == NULL) return;
	if ((dwMsgSize)	<= 0) return;
	if (m_pClientList[iClientH]->m_iAdminUserLevel < m_iAdminLevelCallGaurd) 
	{	SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_ADMINUSERLEVELLOW, NULL, NULL, NULL, NULL);
		return;
	}
	ZeroMemory(cName, sizeof(cName));
	ZeroMemory(cNpcWaypoint, sizeof(cNpcWaypoint));
	ZeroMemory(cTargetName, sizeof(cTargetName));
	ZeroMemory(cNpcName, sizeof(cNpcName));
	ZeroMemory(cBuff, sizeof(cBuff));
	memcpy(cBuff, pData, dwMsgSize);
	pStrTok = new class CStrTok(cBuff, seps);
	token = pStrTok->pGet();
	token = pStrTok->pGet();   	
	if (token != NULL) 
	{	if (strlen(token) > 10) 
			 memcpy(cTargetName, token, 10);
		else memcpy(cTargetName, token, strlen(token));	 		
		for (i = 1; i < DEF_MAXCLIENTS; i++) 
		if ((m_pClientList[i] != NULL) && (memcmp(m_pClientList[i]->m_cCharName, cTargetName, 10) == 0)) 			
		{	if (memcmp(m_pClientList[i]->m_cMapName, "aresden", 7) == 0) 
				strcpy(cNpcName, "Guard-Aresden");			
			else if (memcmp(m_pClientList[i]->m_cMapName, "elvine", 6) == 0) 
				strcpy(cNpcName, "Guard-Elvine");
			else strcpy(cNpcName, "Guard-Neutral");		
			iNamingValue = m_pMapList[ m_pClientList[i]->m_cMapIndex ]->iGetEmptyNamingValue();
			if (iNamingValue == -1) 
			{}else 
			{	wsprintf(cName, "XX%d", iNamingValue);
				cName[0] = '_';
				cName[1] = m_pClientList[i]->m_cMapIndex+65;				
				tX = (int)m_pClientList[i]->m_sX;
				tY = (int)m_pClientList[i]->m_sY;
				if (bCreateNewNpc(cNpcName, cName, m_pMapList[ m_pClientList[i]->m_cMapIndex ]->m_cName, 0, 0, DEF_MOVETYPE_RANDOM, 
					              &tX, &tY, cNpcWaypoint, NULL, NULL, -1, FALSE, TRUE) == FALSE) {
					m_pMapList[ m_pClientList[i]->m_cMapIndex ]->SetNamingValueEmpty(iNamingValue);
				}else 
				{	bSetNpcAttackMode(cName, i, DEF_OWNERTYPE_PLAYER, TRUE);				
					wsprintf(G_cTxt, "GM Order(%-10s): /callguard (on %s)", m_pClientList[iClientH]->m_cCharName, cTargetName);
					bSendMsgToLS(MSGID_GAMEMASTERLOG, iClientH, FALSE, G_cTxt);
				}
			}
			delete pStrTok;
			return;
		}
		SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_PLAYERNOTONGAME, NULL, NULL, NULL, cTargetName);
	}
	delete pStrTok;
	return;
}
void CGame::AdminOrder_Kill(int iClientH, char * pData, DWORD dwMsgSize)
{	char   seps[] = "= \t\n";
	char   * token, cName[11], cTargetName[11], cBuff[256], cEmptyName[21];
	class  CStrTok * pStrTok;
	register int i;
	int sAttackerWeapon, sDamage, iExH;
	if (m_pClientList[iClientH] == NULL) return;
	if ((dwMsgSize)	<= 0) return;
	if (m_pClientList[iClientH]->m_iAdminUserLevel < m_iAdminLevelGMKill) {
		SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_ADMINUSERLEVELLOW, NULL, NULL, NULL, NULL);
		return;
	}
	ZeroMemory(cTargetName, sizeof(cTargetName));
	ZeroMemory(cEmptyName, sizeof(cEmptyName));
	ZeroMemory(cBuff, sizeof(cBuff));
	memcpy(cBuff, pData, dwMsgSize);
	pStrTok = new class CStrTok(cBuff, seps);
	token = pStrTok->pGet();
	token = pStrTok->pGet();
	if (token != NULL) {
		ZeroMemory(cName, sizeof(cName));
		strcpy(cName, token);
	} else {
		ZeroMemory(cName, sizeof(cName));
		strcpy(cName, "null");
	}
	token = pStrTok->pGet();
	if (token != NULL) 
	{	sDamage = atoi(token);
	}else 
	{	sDamage = 1;
	}
	if (token == NULL) { token = "null"; }
	if (cName != NULL) 
	{	token = cName;
		if (strlen(token) > 10) 
			memcpy(cTargetName, token, 10);
		else memcpy(cTargetName, token, strlen(token));
		for (i = 1; i < DEF_MAXCLIENTS; i++) 
			if ((m_pClientList[i] != NULL) && (memcmp(m_pClientList[i]->m_cCharName, cTargetName, 10) == 0)) 
			{	m_pClientList[i]->m_iHP = 0;
				m_pClientList[i]->m_bIsKilled = TRUE;
				if (m_pClientList[i]->m_bIsExchangeMode == TRUE) 
				{	iExH = m_pClientList[i]->m_iExchangeH;
					_ClearExchangeStatus(iExH);
					_ClearExchangeStatus(i);
				}
				// Admin Log
				wsprintf(G_cTxt, "Admin Order(%s): Kill player(%s)\tAdminIP(%s)PlayerIP(%s)"
					, m_pClientList[iClientH]->m_cCharName
					, m_pClientList[i]->m_cCharName
					, m_pClientList[iClientH]->m_cIPaddress
					, m_pClientList[i]->m_cIPaddress);

				PutAdminLogFileList(G_cTxt);
				wsprintf(G_cTxt, "GM Order(%-10s): /kill (%s)", m_pClientList[iClientH]->m_cCharName, m_pClientList[i]->m_cCharName);
				bSendMsgToLS(MSGID_GAMEMASTERLOG, iClientH, FALSE, G_cTxt);
				RemoveFromTarget(i, DEF_OWNERTYPE_PLAYER);
				SendNotifyMsg(NULL, i, DEF_NOTIFY_KILLED, NULL, NULL, NULL, cEmptyName);
				sAttackerWeapon = 1;
				SendEventToNearClient_TypeA(i, DEF_OWNERTYPE_PLAYER, MSGID_EVENT_MOTION, DEF_OBJECTDYING, sDamage, sAttackerWeapon, NULL);
				m_pMapList[m_pClientList[i]->m_cMapIndex]->ClearOwner(12, i, DEF_OWNERTYPE_PLAYER, m_pClientList[i]->m_sX, m_pClientList[i]->m_sY);
				m_pMapList[m_pClientList[i]->m_cMapIndex]->SetDeadOwner(i, DEF_OWNERTYPE_PLAYER, m_pClientList[i]->m_sX, m_pClientList[i]->m_sY);
				delete pStrTok;
				return;
			}
			SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_PLAYERNOTONGAME, NULL, NULL, NULL, cTargetName);
	}
	delete pStrTok;
	return;
} 

void CGame::AdminOrder_Revive(int iClientH, char * pData, DWORD dwMsgSize)
{	char   seps[] = "= \t\n";
	char   * token, cName[11], cTargetName[11], cBuff[256];
	class  CStrTok * pStrTok;
	register int i;
	int sAttackerWeapon, sDamage, sHP;
	if (m_pClientList[iClientH] == NULL) return;
	if ((dwMsgSize)	<= 0) return;
	if (m_pClientList[iClientH]->m_iAdminUserLevel < m_iAdminLevelGMRevive) {
		SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_ADMINUSERLEVELLOW, NULL, NULL, NULL, NULL);
		return;
	}
	ZeroMemory(cTargetName, sizeof(cTargetName));
	ZeroMemory(cBuff, sizeof(cBuff));
	memcpy(cBuff, pData, dwMsgSize);
	pStrTok = new class CStrTok(cBuff, seps);
	token = pStrTok->pGet();
	token = pStrTok->pGet();
	if (token != NULL) 
	{	ZeroMemory(cName, sizeof(cName));
		strcpy(cName, token);
	} else 
	{	ZeroMemory(cName, sizeof(cName));
		strcpy(cName, "null");
	}
	token = pStrTok->pGet();
	if (token != NULL) {
		sDamage = atoi(token);
	} else {
		sDamage = 1;
	}
	token = pStrTok->pGet();
	if (token != NULL) {
		sHP = atoi(token);
	} else {
		sHP = 1;
	}
	token = cName;
	if (cName != NULL) 
	{	if (strlen(token) > 10) 
			memcpy(cTargetName, token, 10);
		else memcpy(cTargetName, token, strlen(token));
		for (i = 1; i < DEF_MAXCLIENTS; i++) 
			if ((m_pClientList[i] != NULL) && (memcmp(m_pClientList[i]->m_cCharName, cTargetName, 10) == 0)) 
				// Admin Log
			{	wsprintf(G_cTxt, "Admin Order(%s): Revive(%s)\tAdminIP(%s)\tPlayerIP(%s)"
					, m_pClientList[iClientH]->m_cCharName
					, m_pClientList[i]->m_cCharName
					, m_pClientList[iClientH]->m_cIPaddress
					, m_pClientList[i]->m_cIPaddress);
				PutAdminLogFileList(G_cTxt);
				wsprintf(G_cTxt, "GM Order(%-10s): /revive (%s)", m_pClientList[iClientH]->m_cCharName, m_pClientList[i]->m_cCharName);
				bSendMsgToLS(MSGID_GAMEMASTERLOG, iClientH, FALSE, G_cTxt);

				m_pClientList[i]->m_iHP = sHP;
				if (iGetMaxHP(i) < m_pClientList[i]->m_iHP) m_pClientList[i]->m_iHP = iGetMaxHP(i, FALSE);
				m_pClientList[i]->m_bIsKilled = FALSE;
				m_pClientList[i]->m_bKilledByPlayerKiller = FALSE;
				m_pClientList[i]->m_iLastDamage = sDamage;
				SendNotifyMsg(NULL, i, DEF_NOTIFY_HP, NULL, NULL, NULL, NULL);
				sAttackerWeapon = 1;
				SendEventToNearClient_TypeA(i, DEF_OWNERTYPE_PLAYER, MSGID_EVENT_MOTION, DEF_OBJECTDAMAGE, sDamage, sAttackerWeapon, NULL);
				m_pMapList[m_pClientList[i]->m_cMapIndex]->ClearOwner(14, i, DEF_OWNERTYPE_PLAYER, m_pClientList[i]->m_sX, m_pClientList[i]->m_sY);
				m_pMapList[m_pClientList[i]->m_cMapIndex]->SetDeadOwner(i, DEF_OWNERTYPE_PLAYER, m_pClientList[i]->m_sX, m_pClientList[i]->m_sY);

				delete pStrTok;
				return;
			}
			SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_PLAYERNOTONGAME, NULL, NULL, NULL, cTargetName);
	}
	delete pStrTok;
	return;
} 
void CGame::AdminOrder_SummonDemon(int iClientH)
{char cName[21], cNpcName[21], cNpcWaypoint[11];	
 register int iNamingValue, tX, tY;
	if (m_pClientList[iClientH] == NULL) return;
	if (m_pClientList[iClientH]->m_bIsAdminCommandEnabled == FALSE) return;
	if (m_pClientList[iClientH]->m_iAdminUserLevel < m_iAdminLevelSummonDemon) {
		SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_ADMINUSERLEVELLOW, NULL, NULL, NULL, NULL);
		return;
	}
	iNamingValue = m_pMapList[ m_pClientList[iClientH]->m_cMapIndex ]->iGetEmptyNamingValue();
	if (iNamingValue == -1) 
	{}else 
	{	ZeroMemory(cNpcName, sizeof(cNpcName));
		strcpy(cNpcName, "Demon");			
		ZeroMemory(cName, sizeof(cName));
		wsprintf(cName, "XX%d", iNamingValue);
		cName[0] = '_';
		cName[1] = m_pClientList[iClientH]->m_cMapIndex+65;
		ZeroMemory(cNpcWaypoint, sizeof(cNpcWaypoint));
		tX = (int)m_pClientList[iClientH]->m_sX;
		tY = (int)m_pClientList[iClientH]->m_sY;
		if (bCreateNewNpc(cNpcName, cName, m_pMapList[ m_pClientList[iClientH]->m_cMapIndex ]->m_cName, 0, (rand() % 9), 
			              DEF_MOVETYPE_RANDOM, &tX, &tY, cNpcWaypoint, NULL, NULL, -1, FALSE, FALSE) == FALSE) 
		{	m_pMapList[ m_pClientList[iClientH]->m_cMapIndex ]->SetNamingValueEmpty(iNamingValue);
		}else // Admin Log			
		{	wsprintf(G_cTxt, "Admin Order(%s): Summon Demon\tAdminIP(%s)"
				, m_pClientList[iClientH]->m_cCharName
				, m_pClientList[iClientH]->m_cIPaddress);
			PutAdminLogFileList(G_cTxt);	
			PutLogEventFileList(G_cTxt);			
			wsprintf(G_cTxt, "GM Order(%-10s): /summondemon (done)", m_pClientList[iClientH]->m_cCharName);
			bSendMsgToLS(MSGID_GAMEMASTERLOG, iClientH, FALSE, G_cTxt);
		}
	}
}
void CGame::AdminOrder_SummonDeath(int iClientH)
{	char cName[21], cNpcName[21], cNpcWaypoint[11];	
	register int iNamingValue, tX, tY;
	if (m_pClientList[iClientH] == NULL) return;
	if (m_pClientList[iClientH]->m_bIsAdminCommandEnabled == FALSE) return;
	if (m_pClientList[iClientH]->m_iAdminUserLevel < m_iAdminLevelSummonDeath) {
		SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_ADMINUSERLEVELLOW, NULL, NULL, NULL, NULL);
		return;
	}
	iNamingValue = m_pMapList[ m_pClientList[iClientH]->m_cMapIndex ]->iGetEmptyNamingValue();
	if (iNamingValue == -1) 
	{}else 
	{	ZeroMemory(cNpcName, sizeof(cNpcName));
		strcpy(cNpcName, "Wyvern");	
		ZeroMemory(cName, sizeof(cName));
		wsprintf(cName, "XX%d", iNamingValue);
		cName[0] = '_';
		cName[1] = m_pClientList[iClientH]->m_cMapIndex+65;
		ZeroMemory(cNpcWaypoint, sizeof(cNpcWaypoint));
		tX = (int)m_pClientList[iClientH]->m_sX;
		tY = (int)m_pClientList[iClientH]->m_sY;
		if (bCreateNewNpc(cNpcName, cName, m_pMapList[ m_pClientList[iClientH]->m_cMapIndex ]->m_cName, 0, (rand() % 9), 
			DEF_MOVETYPE_RANDOM, &tX, &tY, cNpcWaypoint, NULL, NULL, -1, FALSE, FALSE) == FALSE) 
		{		m_pMapList[ m_pClientList[iClientH]->m_cMapIndex ]->SetNamingValueEmpty(iNamingValue);
		}else// Admin Log
		{	wsprintf(G_cTxt, "Admin Order(%s): Summon Death\tAdminIP(%s)"
				, m_pClientList[iClientH]->m_cCharName
				, m_pClientList[iClientH]->m_cIPaddress);
			PutAdminLogFileList(G_cTxt);
			PutLogEventFileList(G_cTxt);					
			wsprintf(G_cTxt, "GM Order(%-10s): /summondeath (done)", m_pClientList[iClientH]->m_cCharName);
			bSendMsgToLS(MSGID_GAMEMASTERLOG, iClientH, FALSE, G_cTxt);
	}	}
}
void CGame::AdminOrder_ReserveFightzone(int iClientH, char * pData, DWORD dwMsgSize)
{
 char   seps[] = "= \t\n";
 char   * token, cBuff[256];
 class  CStrTok * pStrTok;
 int iNum ;
	if (m_pClientList[iClientH] == NULL) return;
	if ((dwMsgSize)	<= 0) return;
	if (m_pClientList[iClientH]->m_iAdminUserLevel < m_iAdminLevelReserveFightzone) {
		SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_ADMINUSERLEVELLOW, NULL, NULL, NULL, NULL);
		return;
	}
	ZeroMemory(cBuff, sizeof(cBuff));
	memcpy(cBuff, pData, dwMsgSize);
	pStrTok = new class CStrTok(cBuff, seps);
	token = pStrTok->pGet();
	token = pStrTok->pGet();	
	if( m_iFightzoneNoForceRecall == 0 ) 
	{	m_iFightzoneNoForceRecall = 1 ; 
		SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_FIGHTZONERESERVE, -5, NULL, NULL, NULL);
	}else 
	{	m_iFightzoneNoForceRecall = 0 ; 
		SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_FIGHTZONERESERVE, -4, NULL, NULL, NULL);
	}
	if (token == NULL) {
		delete pStrTok;
		return;
	}
	iNum = atoi(token) - 1;			
	if ( m_iFightZoneReserve[iNum] != -1) 
	{	// Admin Log
		wsprintf(G_cTxt, "Admin Order(%s):  %d FightzoneReserved\tAdminIP(%s)"
			, m_pClientList[iClientH]->m_cCharName
			, iNum 
			, m_pClientList[iClientH]->m_cIPaddress);
		PutAdminLogFileList(G_cTxt);
		PutLogEventFileList(G_cTxt);		
		m_iFightZoneReserve[iNum] = - 1 ;
		SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_FIGHTZONERESERVE, iNum+1, NULL, NULL, NULL);		
	}else 	// Admin Log
	{	wsprintf(G_cTxt, "Admin Order(%s):  %d Cancel FightzoneReserved\tAdminIP(%s)"
			, m_pClientList[iClientH]->m_cCharName
			, iNum 
			, m_pClientList[iClientH]->m_cIPaddress);
		PutAdminLogFileList(G_cTxt);
		PutLogEventFileList(G_cTxt);
		m_iFightZoneReserve[iNum] = 0 ;       
		SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_FIGHTZONERESERVE, -3, NULL, NULL, NULL);
	}				
	wsprintf(G_cTxt, "GM Order(%-10s): /reservefightzone (done)", m_pClientList[iClientH]->m_cCharName);
	bSendMsgToLS(MSGID_GAMEMASTERLOG, iClientH, FALSE, G_cTxt);	
	delete pStrTok; // Snoopy: was missing
	return;
}


void CGame::AdminOrder_CloseConn(int iClientH, char * pData, DWORD dwMsgSize)
{char   seps[] = "= \t\n";
 char   * token, cTargetName[11], cBuff[256];
 class  CStrTok * pStrTok;
 register int i;
	if (m_pClientList[iClientH] == NULL) return;
	if ((dwMsgSize)	<= 0) return;
	if (m_pClientList[iClientH]->m_iAdminUserLevel < m_iAdminLevelGMCloseconn) 
	{	SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_ADMINUSERLEVELLOW, NULL, NULL, NULL, NULL);
		return;
	}
	ZeroMemory(cTargetName, sizeof(cTargetName));
	ZeroMemory(cBuff, sizeof(cBuff));
	memcpy(cBuff, pData, dwMsgSize);
	pStrTok = new class CStrTok(cBuff, seps);
	token = pStrTok->pGet();
	token = pStrTok->pGet();
	if (token != NULL) {
		if (strlen(token) > 10) 
			 memcpy(cTargetName, token, 10);
		else memcpy(cTargetName, token, strlen(token));
		
		for (i = 1; i < DEF_MAXCLIENTS; i++) 
		if ((m_pClientList[i] != NULL) && (memcmp(m_pClientList[i]->m_cCharName, cTargetName, 10) == 0)) 
		{	if (m_pClientList[i]->m_bIsInitComplete == TRUE) 
			{	wsprintf(G_cTxt, "Admin Order(%s): Close Conn (%s)\tAdminIP(%s)CharIP(%s)"
					, m_pClientList[iClientH]->m_cCharName
					, m_pClientList[i]->m_cCharName
					, m_pClientList[iClientH]->m_cIPaddress
					, m_pClientList[i]->m_cIPaddress);
				PutAdminLogFileList(G_cTxt); 
				wsprintf(G_cTxt, "GM Order(%-10s): /closeconn (%s)", m_pClientList[iClientH]->m_cCharName, m_pClientList[i]->m_cCharName);
				DeleteClient(i, TRUE, TRUE, TRUE, TRUE);
				bSendMsgToLS(MSGID_GAMEMASTERLOG, iClientH, FALSE, G_cTxt);
			}
			delete pStrTok;
			return;
		}
		SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_PLAYERNOTONGAME, NULL, NULL, NULL, cTargetName);
	}
	delete pStrTok;
	return;
}
void CGame::UserCommand_BanGuildsman(int iClientH, char * pData, DWORD dwMsgSize)
{ char   seps[] = "= \t\n";
 char   * token, cTargetName[11], cBuff[256];
 class  CStrTok * pStrTok;
 register int i;
	if (m_pClientList[iClientH] == NULL) return;
	if ((dwMsgSize)	<= 0) return;
	if (m_pClientList[iClientH]->m_iGuildRank != 0 ) 
	{	SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_NOGUILDMASTERLEVEL, NULL, NULL, NULL, NULL);
		return;
	}
	ZeroMemory(cTargetName, sizeof(cTargetName));
	ZeroMemory(cBuff, sizeof(cBuff));
	memcpy(cBuff, pData, dwMsgSize);
	pStrTok = new class CStrTok(cBuff, seps);
	token = pStrTok->pGet();
	token = pStrTok->pGet();   	
	if (token != NULL) 
	{	if (strlen(token) > 10) 
			 memcpy(cTargetName, token, 10);
		else memcpy(cTargetName, token, strlen(token));		
		for (i = 1; i < DEF_MAXCLIENTS; i++) 
		if ((m_pClientList[i] != NULL) && (memcmp(m_pClientList[i]->m_cCharName, cTargetName, 10) == 0) ) 
		{	if (memcmp(m_pClientList[iClientH]->m_cGuildName, m_pClientList[i]->m_cGuildName, 20) != 0)  
			{	SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_CANNOTBANGUILDMAN, NULL, NULL, NULL, NULL);
				delete pStrTok;
				return;
			}
			bSendMsgToLS(MSGID_REQUEST_UPDATE_DELGUILDSMAN, i);
			SendGuildMsg(i, DEF_NOTIFY_DISMISSGUILDSMAN, NULL, NULL, NULL);
			ZeroMemory(m_pClientList[i]->m_cGuildName, sizeof(m_pClientList[i]->m_cGuildName));
			strcpy(m_pClientList[i]->m_cGuildName, "NONE");
			m_pClientList[i]->m_iGuildRank = -1; 
			m_pClientList[i]->m_iGuildGUID = -1;
		    SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_SUCCESSBANGUILDMAN, NULL, NULL, NULL, NULL);
			SendNotifyMsg(iClientH, i, DEF_COMMONTYPE_BANGUILD, NULL, NULL, NULL, NULL);
			SendEventToNearClient_TypeA(i, DEF_OWNERTYPE_PLAYER, MSGID_EVENT_MOTION, DEF_OBJECTNULLACTION, NULL, NULL, NULL);
			delete pStrTok;
			return;
		}
		SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_PLAYERNOTONGAME, NULL, NULL, NULL, cTargetName);
	}
	delete pStrTok;
	return;
}
void CGame::UserCommand_DissmissGuild(int iClientH, char * pData, DWORD dwMsgSize)
{}

int CGame::iCreateFish(char cMapIndex, short sX, short sY, short sType, class CItem * pItem, int iDifficulty, DWORD dwLastTime)
{
 register int i, iDynamicHandle;
 
	if ((cMapIndex < 0) || (cMapIndex >= DEF_MAXMAPS)) return NULL;
	if (m_pMapList[cMapIndex] == NULL) return NULL;
	if (m_pMapList[cMapIndex]->bGetIsWater(sX, sY) == FALSE) return NULL;

	for (i = 1; i < DEF_MAXFISHS; i++) 
	if (m_pFish[i] == NULL) {
		m_pFish[i] = new class CFish(cMapIndex, sX, sY, sType, pItem, iDifficulty);
		if (m_pFish[i] == NULL) return NULL; 		
		// Dynamic Object
		switch (pItem->m_sIDnum) {
		case 101: // RedFish
		case 102: // GreenFish
		case 103: // YellowFish
		case 570:
		case 571:
		case 572:
		case 573:
		case 574:
		case 575:
		case 576:
		case 577:	
			iDynamicHandle = iAddDynamicObjectList(i, NULL, DEF_DYNAMICOBJECT_FISH, cMapIndex, sX, sY, dwLastTime);
			break;
		default: 
			iDynamicHandle = iAddDynamicObjectList(i, NULL, DEF_DYNAMICOBJECT_FISHOBJECT, cMapIndex, sX, sY, dwLastTime);
			break;
		}
		
		if (iDynamicHandle == NULL) {
			delete m_pFish[i];
			m_pFish[i] = NULL;
			return NULL;
		}
		m_pFish[i]->m_sDynamicObjectHandle = iDynamicHandle;
		m_pMapList[cMapIndex]->m_iCurFish++;
		return i;
	}
	return NULL;
}

BOOL CGame::bDeleteFish(int iHandle, int iDelMode)
{register int i, iH;
 DWORD dwTime;		
	if (m_pFish[iHandle] == NULL) return FALSE;	
	dwTime = timeGetTime();
	iH = m_pFish[iHandle]->m_sDynamicObjectHandle;	
	if (m_pDynamicObjectList[iH] != NULL) {
		SendEventToNearClient_TypeB(MSGID_DYNAMICOBJECT, DEF_MSGTYPE_REJECT, m_pDynamicObjectList[iH]->m_cMapIndex, m_pDynamicObjectList[iH]->m_sX, m_pDynamicObjectList[iH]->m_sY, m_pDynamicObjectList[iH]->m_sType, iH, NULL);
		m_pMapList[m_pDynamicObjectList[iH]->m_cMapIndex]->SetDynamicObject(NULL, NULL, m_pDynamicObjectList[iH]->m_sX, m_pDynamicObjectList[iH]->m_sY, dwTime);
		m_pMapList[m_pDynamicObjectList[iH]->m_cMapIndex]->m_iCurFish--;
		delete m_pDynamicObjectList[iH];
		m_pDynamicObjectList[iH] = NULL;
	}
	for (i = 1; i < DEF_MAXCLIENTS; i++) {
		if ((m_pClientList[i] != NULL) && (m_pClientList[i]->m_bIsInitComplete == TRUE) &&
			(m_pClientList[i]->m_iAllocatedFish == iHandle)) {
			SendNotifyMsg(NULL, i, DEF_NOTIFY_FISHCANCELED, iDelMode, NULL, NULL, NULL);
			ClearSkillUsingStatus(i); 
 		}
	}	
	delete m_pFish[iHandle];
	m_pFish[iHandle] = NULL;
	return TRUE;
}

int CGame::iCheckFish(int iClientH, char cMapIndex, short dX, short dY)
{register int i;
 short sDistX, sDistY;
	if (m_pClientList[iClientH] == NULL) return 0;
	if (m_pClientList[iClientH]->m_bIsInitComplete == FALSE) return 0;
	if ((cMapIndex < 0)	|| (cMapIndex >= DEF_MAXMAPS)) return 0;
	for (i = 1; i < DEF_MAXDYNAMICOBJECTS; i++) 
	if (m_pDynamicObjectList[i] != NULL) {
		sDistX = abs(m_pDynamicObjectList[i]->m_sX - dX);
		sDistY = abs(m_pDynamicObjectList[i]->m_sY - dY);		
		if (   (m_pDynamicObjectList[i]->m_cMapIndex == cMapIndex) 
			&& (   (m_pDynamicObjectList[i]->m_sType == DEF_DYNAMICOBJECT_FISH) 
				|| (m_pDynamicObjectList[i]->m_sType == DEF_DYNAMICOBJECT_FISHOBJECT)) 
			&& (sDistX <= 2) && (sDistY <= 2)) 
		{	if (m_pFish[ m_pDynamicObjectList[i]->m_sOwner ] == NULL) return 0;
			if (m_pFish[ m_pDynamicObjectList[i]->m_sOwner ]->m_sEngagingCount >= DEF_MAXENGAGINGFISH) return 0;
			if (m_pClientList[iClientH]->m_iAllocatedFish != NULL) return 0;
			if (m_pClientList[iClientH]->m_cMapIndex != cMapIndex) return 0;
			m_pClientList[iClientH]->m_iAllocatedFish = m_pDynamicObjectList[i]->m_sOwner;
			m_pClientList[iClientH]->m_iFishChance = 1;
			m_pClientList[iClientH]->m_bSkillUsingStatus[1] = TRUE;

			SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_EVENTFISHMODE
				, (m_pFish[m_pDynamicObjectList[i]->m_sOwner]->m_pItem->m_wPrice/2)
				, m_pFish[m_pDynamicObjectList[i]->m_sOwner]->m_pItem->m_sSprite
				, m_pFish[m_pDynamicObjectList[i]->m_sOwner]->m_pItem->m_sSpriteFrame
				, m_pFish[m_pDynamicObjectList[i]->m_sOwner]->m_pItem->m_cName);
			m_pFish[ m_pDynamicObjectList[i]->m_sOwner ]->m_sEngagingCount++;			
			return i;
		}
	}
	return 0;
}

void CGame::FishProcessor()
{register int i, iSkillLevel, iResult, iChangeValue;
	for (i = 1; i < DEF_MAXCLIENTS; i++) 
	{	if (   (m_pClientList[i] != NULL) && (m_pClientList[i]->m_bIsInitComplete == TRUE) 
			&& (m_pClientList[i]->m_iAllocatedFish != NULL)) 
		{	if (m_pFish[ m_pClientList[i]->m_iAllocatedFish ] == NULL) continue; //break; one bad fish and everydody cannot fish ?	
			iSkillLevel  = m_pClientList[i]->m_cSkillMastery[1];
			iSkillLevel -= m_pFish[m_pClientList[i]->m_iAllocatedFish]->m_iDifficulty;
			if (iSkillLevel <= 0) iSkillLevel = 1;			
			iChangeValue = iSkillLevel / 10;
			if (iChangeValue <= 0) iChangeValue = 1;
			iChangeValue = iDice(1, iChangeValue);
			iResult = iDice(1, 100);
			if (iSkillLevel >= iResult)	
			{	m_pClientList[i]->m_iFishChance += iChangeValue;
				if (m_pClientList[i]->m_iFishChance > 99) m_pClientList[i]->m_iFishChance = 99;
				SendNotifyMsg(NULL, i, DEF_NOTIFY_FISHCHANCE, m_pClientList[i]->m_iFishChance, NULL, NULL, NULL);
			}else if (iSkillLevel < iResult) 
			{	m_pClientList[i]->m_iFishChance -= iChangeValue;
				if (m_pClientList[i]->m_iFishChance < 1) m_pClientList[i]->m_iFishChance = 1;
				SendNotifyMsg(NULL, i, DEF_NOTIFY_FISHCHANCE, m_pClientList[i]->m_iFishChance, NULL, NULL, NULL);
			}
		}
	}
}

void CGame::AdminOrder_CreateFish(int iClientH, char * pData, DWORD dwMsgSize)
{	char   seps[] = "= \t\n";
	char   * token, cBuff[256], cItemName[21];
	class  CStrTok * pStrTok;
	class  CItem   * pItem;
	register int tX, tY, iType;
	if (m_pClientList[iClientH] == NULL) return;
	if ((dwMsgSize)	<= 0) return;
	if (m_pClientList[iClientH]->m_iAdminUserLevel < m_iAdminLevelCreateFish) 
	{	SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_ADMINUSERLEVELLOW, NULL, NULL, NULL, NULL);
		return;
	}
	tX = tY = iType = 0;
	ZeroMemory(cBuff, sizeof(cBuff));
	memcpy(cBuff, pData, dwMsgSize);
	pStrTok = new class CStrTok(cBuff, seps);
	token = pStrTok->pGet();	
	token = pStrTok->pGet();
	if (token != NULL) 
	{	tX = atoi(token);
	}
	token = pStrTok->pGet();
	if (token != NULL) 
	{	tY = atoi(token);
	}
	token = pStrTok->pGet();
	if (token != NULL) 
	{	iType = atoi(token);
	}
	if ((tX != 0) && (tY != 0) && (iType != 0)) 
	{	pItem = new class CItem;
		if (pItem == NULL) 
		{	delete pStrTok;
			return;
		}
		ZeroMemory(cItemName, sizeof(cItemName));
		strcpy(cItemName, "Fish");
		if (_bInitItemAttr(pItem, cItemName) == TRUE) 
   		{	iCreateFish(m_pClientList[iClientH]->m_cMapIndex, tX, tY, iType, pItem, 1, 60000*20);		
			wsprintf(G_cTxt, "GM Order(%-10s): /createfish (created)", m_pClientList[iClientH]->m_cCharName);
			bSendMsgToLS(MSGID_GAMEMASTERLOG, iClientH, FALSE, G_cTxt);	
		}else delete pItem;
   	}
	delete pStrTok;
	return;
}

void CGame::AdminOrder_Teleport(int iClientH, char * pData, DWORD dwMsgSize, BOOL bForceTP)
{char   seps[] = "= \t\n";
 char   * token, cBuff[256], cMapName[256];
 class  CStrTok * pStrTok;
 register int dX, dY;
 BOOL   bFlag;
	dX = dY = -1;
	if (m_pClientList[iClientH] == NULL) return;
	if ((dwMsgSize)	<= 0) return;
	if (m_pClientList[iClientH]->m_iAdminUserLevel < m_iAdminLevelTeleport) {
		SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_ADMINUSERLEVELLOW, NULL, NULL, NULL, NULL);
		return;
	}
	ZeroMemory(cBuff, sizeof(cBuff));
	memcpy(cBuff, pData, dwMsgSize);
	pStrTok = new class CStrTok(cBuff, seps);
	token = pStrTok->pGet();	
	token = pStrTok->pGet();
	if (token != NULL) 
	{	ZeroMemory(cMapName, sizeof(cMapName));
		strcpy(cMapName, token);
	}
	token = pStrTok->pGet();
	if (token != NULL) 
	{	dX = atoi(token);
	}
	token = pStrTok->pGet();
	if (token != NULL) 
	{	dY = atoi(token);
	}
	bFlag = FALSE;
			//Asks For Flag on maps
			if (strcmp("2ndmiddle", cMapName) == 0) bFlag = TRUE;
			if (strcmp("abaddon", cMapName) == 0) bFlag = TRUE; 
			if (strcmp("arebrk12", cMapName) == 0) bFlag = TRUE;
			if (strcmp("arefarm", cMapName) == 0) bFlag = TRUE;
			if (strcmp("arejail", cMapName) == 0) bFlag = TRUE;
			if (strcmp("aresden", cMapName) == 0) bFlag = TRUE;
			if (strcmp("aresdend1", cMapName) == 0) bFlag = TRUE;
			if (strcmp("areuni", cMapName) == 0) bFlag = TRUE;
			if (strcmp("arewrhus", cMapName) == 0) bFlag = TRUE;
			if (strcmp("bisle", cMapName) == 0)   bFlag = TRUE;
			if (strcmp("bsmith_1", cMapName) == 0) bFlag = TRUE;
			if (strcmp("bsmith_1f", cMapName) == 0) bFlag = TRUE;
			if (strcmp("bsmith_2", cMapName) == 0) bFlag = TRUE;
			if (strcmp("bsmith_2f", cMapName) == 0) bFlag = TRUE;
			if (strcmp("BtField", cMapName) == 0) bFlag = TRUE;
			if (strcmp("cath_1", cMapName) == 0) bFlag = TRUE;
			if (strcmp("cath_2", cMapName) == 0)      bFlag = TRUE;
			if (strcmp("CmdHall_1", cMapName) == 0) bFlag = TRUE;
			if (strcmp("CmdHall_2", cMapName) == 0) bFlag = TRUE;
			if (strcmp("default", cMapName) == 0) bFlag = TRUE;
			if (strcmp("dglv2", cMapName) == 0) bFlag = TRUE;
			if (strcmp("dglv3", cMapName) == 0) bFlag = TRUE;
			if (strcmp("dglv4", cMapName) == 0) bFlag = TRUE;
			if (strcmp("druncncity", cMapName) == 0) bFlag = TRUE; 
			if (strcmp("elvbrk12", cMapName) == 0) bFlag = TRUE;
			if (strcmp("elvfarm", cMapName) == 0) bFlag = TRUE;
			if (strcmp("elvine", cMapName) == 0)  bFlag = TRUE;
			if (strcmp("elvined1", cMapName) == 0)    bFlag = TRUE;
			if (strcmp("elvjail", cMapName) == 0)    bFlag = TRUE;
			if (strcmp("elvwrhus", cMapName) == 0) bFlag = TRUE;
			if (strcmp("fightzone1", cMapName) == 0) bFlag = TRUE;
			if (strcmp("fightzone2", cMapName) == 0) bFlag = TRUE;
			if (strcmp("fightzone3", cMapName) == 0) bFlag = TRUE;
			if (strcmp("fightzone4", cMapName) == 0) bFlag = TRUE;
			if (strcmp("fightzone5", cMapName) == 0) bFlag = TRUE;
			if (strcmp("fightzone6", cMapName) == 0) bFlag = TRUE;
			if (strcmp("fightzone7", cMapName) == 0) bFlag = TRUE;
			if (strcmp("fightzone8", cMapName) == 0) bFlag = TRUE;
			if (strcmp("fightzone9", cMapName) == 0) bFlag = TRUE;
			if (strcmp("GodH", cMapName) == 0)   bFlag = TRUE;
			if (strcmp("gshop_1", cMapName) == 0) bFlag = TRUE;
			if (strcmp("gshop_1f", cMapName) == 0) bFlag = TRUE;
			if (strcmp("gshop_2", cMapName) == 0)     bFlag = TRUE;
			if (strcmp("gshop_2f", cMapName) == 0)     bFlag = TRUE;
			if (strcmp("HRampart", cMapName) == 0)     bFlag = TRUE;
			if (strcmp("huntzone2", cMapName) == 0) bFlag = TRUE;
			if (strcmp("huntzone4", cMapName) == 0) bFlag = TRUE;
			if (strcmp("icebound", cMapName) == 0) bFlag = TRUE; 
			if (strcmp("inferniaA", cMapName) == 0) bFlag = TRUE; 
			if (strcmp("inferniaB", cMapName) == 0) bFlag = TRUE; 
			if (strcmp("maze", cMapName) == 0) bFlag = TRUE; 
			if (strcmp("middled1n", cMapName) == 0) bFlag = TRUE;
			if (strcmp("middled1x", cMapName) == 0) bFlag = TRUE;
			if (strcmp("middleland", cMapName) == 0) bFlag = TRUE;
			if (strcmp("penalty", cMapName) == 0) bFlag = TRUE;
			if (strcmp("procella", cMapName) == 0) bFlag = TRUE;
			if (strcmp("resurr1", cMapName) == 0) bFlag = TRUE;
			if (strcmp("resurr2", cMapName) == 0) bFlag = TRUE;
			if (strcmp("toh1", cMapName) == 0) bFlag = TRUE;
			if (strcmp("toh2", cMapName) == 0) bFlag = TRUE;
			if (strcmp("wrhus_1", cMapName) == 0) bFlag = TRUE;
			if (strcmp("wrhus_1f", cMapName) == 0) bFlag = TRUE;
			if (strcmp("wrhus_2", cMapName) == 0)     bFlag = TRUE;
			if (strcmp("wrhus_2f", cMapName) == 0)     bFlag = TRUE;
			if (strcmp("wzdtwr_1", cMapName) == 0) bFlag = TRUE;

			if (strcmp("toh3", cMapName) == 0) bFlag = TRUE;
			if (strcmp("Test", cMapName) == 0) bFlag = TRUE;
			if (strcmp("GMMap", cMapName) == 0) bFlag = TRUE;
			if (strcmp("fightzone10", cMapName) == 0) bFlag = TRUE;
//SNOOPY81 for Equilibrium
			if (   (m_bMapModeEquilibrium == TRUE) // Equilibrium maps
				|| (bForceTP == TRUE))
			{	if (strcmp("lost", cMapName) == 0) bFlag = TRUE;
				if (strcmp("bsmith_3", cMapName) == 0) bFlag = TRUE;
				if (strcmp("gshop_3", cMapName) == 0)     bFlag = TRUE;
				if (strcmp("catacombs", cMapName) == 0) bFlag = TRUE;
				if (strcmp("qusmarsh", cMapName) == 0) bFlag = TRUE;
				if (strcmp("stadium", cMapName) == 0) bFlag = TRUE;
				if (strcmp("asgarde", cMapName) == 0) bFlag = TRUE;
//SNOOPY: Easier GM TP...
	if (strcmp("QM", cMapName) == 0)	{ strcpy(cMapName,"qusmarsh"); bFlag = TRUE;}
	if (strcmp("Garden", cMapName) ==0) { strcpy(cMapName,"areuni"); bFlag = TRUE;}
	if (strcmp("WWH", cMapName) == 0)	{ strcpy(cMapName,"elvwrhus"); bFlag = TRUE;}
	if (strcmp("WH", cMapName) == 0)	{ strcpy(cMapName,"arewrhus"); bFlag = TRUE;}
	if (strcmp("BS", cMapName) == 0)	{ strcpy(cMapName,"bsmith_3"); bFlag = TRUE;}
	if (strcmp("Shop", cMapName) == 0)	{ strcpy(cMapName,"gshop_3"); bFlag = TRUE;}
			}
			if (   (m_bMapModeEquilibrium == FALSE) // Maps not hosted on Equilibrium mode
				|| (bForceTP == TRUE))							
			{	if (strcmp("cityhall_1", cMapName) == 0) bFlag = TRUE;
				if (strcmp("cityhall_2", cMapName) == 0) bFlag = TRUE;
				if (strcmp("gldhall_1",  cMapName) == 0) bFlag = TRUE;
				if (strcmp("gldhall_2",  cMapName) == 0) bFlag = TRUE;
				if (strcmp("wzdtwr_2",   cMapName) == 0) bFlag = TRUE;

				if (strcmp("elvbrk11", cMapName) == 0) bFlag = TRUE;
				if (strcmp("arebrk11", cMapName) == 0) bFlag = TRUE;
				if (strcmp("arebrk21", cMapName) == 0) bFlag = TRUE;
				if (strcmp("arebrk22", cMapName) == 0) bFlag = TRUE;
				if (strcmp("elvbrk21", cMapName) == 0) bFlag = TRUE;
				if (strcmp("elvbrk22", cMapName) == 0) bFlag = TRUE;

				if (strcmp("huntzone1", cMapName) == 0) bFlag = TRUE;
				if (strcmp("huntzone3", cMapName) == 0) bFlag = TRUE;
				if (strcmp("elvuni",	cMapName) == 0) bFlag = TRUE;
//				if (strcmp("aremidl", cMapName) == 0) bFlag = TRUE;
//				if (strcmp("aremidr", cMapName) == 0) bFlag = TRUE;
//				if (strcmp("elvmidl", cMapName) == 0) bFlag = TRUE;
//				if (strcmp("elvmidr", cMapName) == 0) bFlag = TRUE;
			}

//SNOOPY: Easier GM TP...
	if (strcmp("ML", cMapName) == 0)	{ strcpy(cMapName,"middleland"); bFlag = TRUE;}
	if (strcmp("PL", cMapName) == 0)	{ strcpy(cMapName,"2ndmiddle"); bFlag = TRUE;}
	if (strcmp("BI", cMapName) == 0)	{ strcpy(cMapName,"bisle"); bFlag = TRUE;}
	if (strcmp("EF", cMapName) == 0)	{ strcpy(cMapName,"huntzone2"); bFlag = TRUE;}
	if (strcmp("SW", cMapName) == 0)	{ strcpy(cMapName,"huntzone4"); bFlag = TRUE;}
	if (strcmp("IB", cMapName) == 0)	{ strcpy(cMapName,"icebound"); bFlag = TRUE;}	
	if (bFlag == TRUE)
	{	wsprintf(G_cTxt, "GM Order(%-10s): /tp (teleporting now)", m_pClientList[iClientH]->m_cCharName);
		bSendMsgToLS(MSGID_GAMEMASTERLOG, iClientH, FALSE, G_cTxt);	
		RequestTeleportHandler(iClientH, "2   ", cMapName, dX, dY);
	}   	
	delete pStrTok;
	return;
}

void CGame::AdminOrder_Gate(int iClientH, char * pData, DWORD dwMsgSize, BOOL bForceTP)
{char   seps[] = "= \t\n";
 char   * token, cBuff[256], cMapName[256];
 class  CStrTok * pStrTok;
 register int dX, dY;
 BOOL   bFlag;
	dX = dY = -1;
	if (m_pClientList[iClientH] == NULL) return;
	if ((dwMsgSize)	<= 0) return;
	if (m_pClientList[iClientH]->m_iAdminUserLevel < m_iAdminLevelSummonAll) 
	{	SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_ADMINUSERLEVELLOW, NULL, NULL, NULL, NULL);
		return;
	}
	// Not possible if an Apocalypse Gate is alreaddy on this map
	if (   (m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cDynamicGateType >0)
		&& (m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cDynamicGateType <5)) 
	{	SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_IPACCOUNTINFO, NULL, NULL, NULL, "A gate is already defined for this map, unable to create another one.");
		return;
	}
	ZeroMemory(cBuff, sizeof(cBuff));
	memcpy(cBuff, pData, dwMsgSize);
	pStrTok = new class CStrTok(cBuff, seps);
	token = pStrTok->pGet();	
	token = pStrTok->pGet();
	ZeroMemory(cMapName, sizeof(cMapName));
	if (token != NULL) 
	{	strcpy(cMapName, token);
	}
	token = pStrTok->pGet();
	if (token != NULL) 
	{	dX = atoi(token);
	}
	token = pStrTok->pGet();
	if (token != NULL) 
	{	dY = atoi(token);
	}
	bFlag = FALSE;
	//Asks For Flag on maps
	if (strcmp("2ndmiddle", cMapName) == 0) bFlag = TRUE;
	if (strcmp("abaddon", cMapName) == 0)	bFlag = TRUE; 
	if (strcmp("arebrk12", cMapName) == 0)	bFlag = TRUE;
	if (strcmp("arefarm", cMapName) == 0)	bFlag = TRUE;
	if (strcmp("aresden", cMapName) == 0)	bFlag = TRUE;
	if (strcmp("aresdend1", cMapName) == 0) bFlag = TRUE;
	if (strcmp("areuni", cMapName) == 0)	bFlag = TRUE;
	if (strcmp("bisle", cMapName) == 0)		bFlag = TRUE;
	if (strcmp("BtField", cMapName) == 0)	bFlag = TRUE;
	if (strcmp("default", cMapName) == 0)	bFlag = TRUE;
	if (strcmp("dglv2", cMapName) == 0)		bFlag = TRUE;
	if (strcmp("dglv3", cMapName) == 0)		bFlag = TRUE;
	if (strcmp("dglv4", cMapName) == 0)		bFlag = TRUE;
	if (strcmp("druncncity", cMapName) == 0) bFlag = TRUE; 
	if (strcmp("elvbrk12", cMapName) == 0)	bFlag = TRUE;
	if (strcmp("elvfarm", cMapName) == 0)	bFlag = TRUE;
	if (strcmp("elvine", cMapName) == 0)	bFlag = TRUE;
	if (strcmp("elvined1", cMapName) == 0)  bFlag = TRUE;
	if (strcmp("fightzone1", cMapName) == 0) bFlag = TRUE;
	if (strcmp("fightzone2", cMapName) == 0) bFlag = TRUE;
	if (strcmp("fightzone3", cMapName) == 0) bFlag = TRUE;
	if (strcmp("fightzone4", cMapName) == 0) bFlag = TRUE;
	if (strcmp("fightzone5", cMapName) == 0) bFlag = TRUE;
	if (strcmp("fightzone6", cMapName) == 0) bFlag = TRUE;
	if (strcmp("fightzone7", cMapName) == 0) bFlag = TRUE;
	if (strcmp("fightzone8", cMapName) == 0) bFlag = TRUE;
	if (strcmp("fightzone9", cMapName) == 0) bFlag = TRUE;
	if (strcmp("GodH", cMapName) == 0)		bFlag = TRUE;
	if (strcmp("HRampart", cMapName) == 0)  bFlag = TRUE;
	if (strcmp("huntzone2", cMapName) == 0) bFlag = TRUE;
	if (strcmp("huntzone4", cMapName) == 0) bFlag = TRUE;
	if (strcmp("icebound", cMapName) == 0)	bFlag = TRUE; 
	if (strcmp("inferniaA", cMapName) == 0) bFlag = TRUE; 
	if (strcmp("inferniaB", cMapName) == 0) bFlag = TRUE; 
	if (strcmp("maze", cMapName) == 0)		bFlag = TRUE; 
	if (strcmp("middled1n", cMapName) == 0) bFlag = TRUE;
	if (strcmp("middled1x", cMapName) == 0) bFlag = TRUE;
	if (strcmp("middleland", cMapName) == 0) bFlag = TRUE;
	if (strcmp("procella", cMapName) == 0)	bFlag = TRUE;
	if (strcmp("toh1", cMapName) == 0)		bFlag = TRUE;
	if (strcmp("toh2", cMapName) == 0)		bFlag = TRUE;
	if (strcmp("toh3", cMapName) == 0)		bFlag = TRUE;
//SNOOPY81 for Equilibrium
	if (   (m_bMapModeEquilibrium == TRUE) // Equilibrium maps
		|| (bForceTP == TRUE))
	{	if (strcmp("lost", cMapName) == 0) bFlag = TRUE;
		if (strcmp("catacombs", cMapName) == 0) bFlag = TRUE;
		if (strcmp("qusmarsh", cMapName) == 0)	bFlag = TRUE;
		if (strcmp("stadium", cMapName) == 0)	bFlag = TRUE;
		if (strcmp("asgarde", cMapName) == 0)	bFlag = TRUE;
//SNOOPY: Easier GM TP...
		if (strcmp("QM", cMapName) == 0)	{ strcpy(cMapName,"qusmarsh");  bFlag = TRUE;}
		if (strcmp("Garden", cMapName) ==0) { strcpy(cMapName,"areuni");	bFlag = TRUE;}
	}
	if (   (m_bMapModeEquilibrium == FALSE) // Maps not hosted on Equilibrium mode
		|| (bForceTP == TRUE))		
	{	if (strcmp("elvbrk11", cMapName) == 0)	bFlag = TRUE;
		if (strcmp("arebrk11", cMapName) == 0)	bFlag = TRUE;
		if (strcmp("arebrk21", cMapName) == 0)	bFlag = TRUE;
		if (strcmp("arebrk22", cMapName) == 0)	bFlag = TRUE;
		if (strcmp("elvbrk21", cMapName) == 0)	bFlag = TRUE;
		if (strcmp("elvbrk22", cMapName) == 0)	bFlag = TRUE;
		if (strcmp("huntzone1", cMapName) == 0) bFlag = TRUE;
		if (strcmp("huntzone3", cMapName) == 0) bFlag = TRUE;
		if (strcmp("elvuni",	cMapName) == 0) bFlag = TRUE;
	}
//SNOOPY: Easier GM TP...
	if (strcmp("ML", cMapName) == 0)	{ strcpy(cMapName,"middleland");	bFlag = TRUE;}
	if (strcmp("PL", cMapName) == 0)	{ strcpy(cMapName,"2ndmiddle");		bFlag = TRUE;}
	if (strcmp("BI", cMapName) == 0)	{ strcpy(cMapName,"bisle");			bFlag = TRUE;}
	if (strcmp("EF", cMapName) == 0)	{ strcpy(cMapName,"huntzone2");		bFlag = TRUE;}
	if (strcmp("SW", cMapName) == 0)	{ strcpy(cMapName,"huntzone4");		bFlag = TRUE;}
	if (strcmp("IB", cMapName) == 0)	{ strcpy(cMapName,"icebound");		bFlag = TRUE;}
	
	if (bFlag == TRUE)
	{	//RequestTeleportHandler(iClientH, "2   ", cMapName, dX, dY);
		m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cDynamicGateType = 5;			// 28 DynamicGateType
		m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_sDynamicGateCoordRectX1 = 	m_pClientList[iClientH]->m_sX-1;	// 29 DynamicGateCoord 
		m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_sDynamicGateCoordRectX2 = 	m_pClientList[iClientH]->m_sX+1;	 
		m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_sDynamicGateCoordRectY1 = 	m_pClientList[iClientH]->m_sY+1;	 
		m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_sDynamicGateCoordRectY2 = 	m_pClientList[iClientH]->m_sY+3;	 
		ZeroMemory(m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cDynamicGateCoordDestMap, sizeof(m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cDynamicGateCoordDestMap));
		memcpy(m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cDynamicGateCoordDestMap, cMapName, strlen(cMapName));
		m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_sDynamicGateCoordTgtX = dX;
		m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_sDynamicGateCoordTgtY = dY;
		// Admin Log
		wsprintf(G_cTxt, "Admin Order(%s): Gate opened from %s to %s \tAdminIP(%s) "
			, m_pClientList[iClientH]->m_cCharName
			, m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cName
			, cMapName
			, m_pClientList[iClientH]->m_cIPaddress);
		PutAdminLogFileList(G_cTxt);
		PutLogEventFileList(G_cTxt);	
		PutLogList(G_cTxt);	
		wsprintf(G_cTxt, "GM Order(%-10s): /gate (created)", m_pClientList[iClientH]->m_cCharName);
		bSendMsgToLS(MSGID_GAMEMASTERLOG, iClientH, FALSE, G_cTxt);	
		register int i;
		for (i = 1; i < DEF_MAXCLIENTS; i++) 
		{	if (m_pClientList[i] == NULL) continue;
			if (m_pClientList[i]->m_cMapIndex != m_pClientList[iClientH]->m_cMapIndex) continue;
			SendNotifyMsg(NULL, i, DEF_NOTIFY_APOCGATEOPEN, m_pClientList[iClientH]->m_sX, m_pClientList[iClientH]->m_sY+2, NULL, m_pClientList[i]->m_cMapName);
		} 
	}else if (m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cDynamicGateType == 5)
	{	m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cDynamicGateType = 0;			// 28 DynamicGateType
		m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_sDynamicGateCoordRectX1 = 	0;	// 29 DynamicGateCoord 
		m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_sDynamicGateCoordRectX2 = 	0;	 
		m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_sDynamicGateCoordRectY1 = 	0;	 
		m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_sDynamicGateCoordRectY2 = 	0;	 
		ZeroMemory(m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cDynamicGateCoordDestMap, sizeof(m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cDynamicGateCoordDestMap));
		m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_sDynamicGateCoordTgtX = 0;
		m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_sDynamicGateCoordTgtY = 0;
		// Admin Log
		wsprintf(G_cTxt, "Admin Order(%s): Gate closed \tAdminIP(%s) "
			, m_pClientList[iClientH]->m_cCharName
			, m_pClientList[iClientH]->m_cIPaddress);
		PutAdminLogFileList(G_cTxt);
		PutLogEventFileList(G_cTxt);
		PutLogList(G_cTxt);
		SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_IPACCOUNTINFO, NULL, NULL, NULL, "The gate on this map is destroyed.");		
		wsprintf(G_cTxt, "GM Order(%-10s): /gate (destroyed)", m_pClientList[iClientH]->m_cCharName);
		bSendMsgToLS(MSGID_GAMEMASTERLOG, iClientH, FALSE, G_cTxt);	
		register int i;
		for (i = 1; i < DEF_MAXCLIENTS; i++) 
		{	if (m_pClientList[i] == NULL) continue;
			if (m_pClientList[i]->m_cMapIndex != m_pClientList[iClientH]->m_cMapIndex) continue;
			SendNotifyMsg(NULL, i, DEF_NOTIFY_APOCGATECLOSE, 0, 0, NULL, m_pClientList[i]->m_cMapName);	
		} 	
	}
	delete pStrTok;
	return;
}

void CGame::ReqGetFishThisTimeHandler(int iClientH)
{register int iResult, iFishH;
 class CItem * pItem;
	if (m_pClientList[iClientH] == NULL) return;
	if (m_pClientList[iClientH]->m_bIsInitComplete == FALSE) return;
	if (m_pClientList[iClientH]->m_iAllocatedFish == NULL) return;
	if (m_pFish[m_pClientList[iClientH]->m_iAllocatedFish] == NULL) return;
	m_pClientList[iClientH]->m_bSkillUsingStatus[1] = FALSE;
	iResult = iDice(1, 100);
	if (m_pClientList[iClientH]->m_iFishChance >= iResult) 
	{	GetExp(iClientH, iDice(m_pFish[m_pClientList[iClientH]->m_iAllocatedFish]->m_iDifficulty, 5)); //m_pClientList[iClientH]->m_iExpStock += iDice(m_pFish[m_pClientList[iClientH]->m_iAllocatedFish]->m_iDifficulty, 5);
		CalculateSSN_SkillIndex(iClientH, 1, m_pFish[m_pClientList[iClientH]->m_iAllocatedFish]->m_iDifficulty);
		pItem = m_pFish[m_pClientList[iClientH]->m_iAllocatedFish]->m_pItem;
		m_pFish[m_pClientList[iClientH]->m_iAllocatedFish]->m_pItem = NULL;
		m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->bSetItem(m_pClientList[iClientH]->m_sX, 
			                                                       m_pClientList[iClientH]->m_sY, 
															       pItem);
		switch (pItem->m_sIDnum) {
		case 350: // diamond			
			wsprintf(G_cTxt, "(*) Fishing : Char(%s) Skill(%d) got a Diamond"
			   , m_pClientList[iClientH]->m_cCharName
			   , m_pClientList[iClientH]->m_cSkillMastery[1]); 
		     PutLogList(G_cTxt); 
			 PutItemLogFileList(G_cTxt);
			 break;
		case 961: // Ancient EGG			
			wsprintf(G_cTxt, "(*) Fishing : Char(%s) Skill(%d) got an Ancient Egg"
			   , m_pClientList[iClientH]->m_cCharName
			   , m_pClientList[iClientH]->m_cSkillMastery[1]); 
		     PutLogList(G_cTxt); 
			 PutItemLogFileList(G_cTxt);
			 break;
		case 337: // RubyRing			
			wsprintf(G_cTxt, "(*) Fishing : Char(%s) Skill(%d) got a Ruby Ring"
			   , m_pClientList[iClientH]->m_cCharName
			   , m_pClientList[iClientH]->m_cSkillMastery[1]); 
		     PutLogList(G_cTxt); 
			 PutItemLogFileList(G_cTxt);
			 break;
		case 328: // StrangeRing
		case 329: // 
		case 330: // 			
			wsprintf(G_cTxt, "(*) Fishing : Char(%s) Skill(%d) got a Strange Ring"
			   , m_pClientList[iClientH]->m_cCharName
			   , m_pClientList[iClientH]->m_cSkillMastery[1]); 
		     PutLogList(G_cTxt); 
			 PutItemLogFileList(G_cTxt);
			 break;
		case 333: // PlatinumRing			
			wsprintf(G_cTxt, "(*) Fishing : Char(%s) Skill(%d) got a PlatinumRing"
			   , m_pClientList[iClientH]->m_cCharName
			   , m_pClientList[iClientH]->m_cSkillMastery[1]); 
		     PutLogList(G_cTxt); 
			 PutItemLogFileList(G_cTxt);
			 break;
		case 336: // SapphireRing			
			wsprintf(G_cTxt, "(*) Fishing : Char(%s) Skill(%d) got a SapphireRing"
			   , m_pClientList[iClientH]->m_cCharName
			   , m_pClientList[iClientH]->m_cSkillMastery[1]); 
		     PutLogList(G_cTxt); 
			 PutItemLogFileList(G_cTxt);
			 break;
		default:
			 break;
		}
		SendEventToNearClient_TypeB(MSGID_EVENT_COMMON, DEF_COMMONTYPE_ITEMDROP, m_pClientList[iClientH]->m_cMapIndex,
			                        m_pClientList[iClientH]->m_sX, m_pClientList[iClientH]->m_sY,
			                        pItem->m_sSprite, pItem->m_sSpriteFrame, pItem->m_cItemColor); // v1.4 color
		SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_FISHSUCCESS, NULL, NULL, NULL, NULL);
		iFishH = m_pClientList[iClientH]->m_iAllocatedFish;
		m_pClientList[iClientH]->m_iAllocatedFish = NULL;				
		bDeleteFish(iFishH, 1); 
		return;
	}
	m_pFish[ m_pClientList[iClientH]->m_iAllocatedFish ]->m_sEngagingCount--;
	SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_FISHFAIL, NULL, NULL, NULL, NULL);	
	m_pClientList[iClientH]->m_iAllocatedFish = NULL;
}

void CGame::FishGenerator() 
{register int i, iP, tX, tY, iRet; 
 char  cItemName[21]; 
 short sDifficulty; 
 DWORD dwLastTime; 
 class CItem * pItem; 
	for (i = 0; i < DEF_MAXMAPS; i++) { 
		if (   (iDice(1,10) == 5) && (m_pMapList[i] != NULL) 
			&& (m_pMapList[i]->m_iCurFish < m_pMapList[i]->m_iMaxFish))      
		{	iP = iDice(1, m_pMapList[i]->m_iTotalFishPoint) - 1; 
			if ((m_pMapList[i]->m_FishPointList[iP].x == -1) || (m_pMapList[i]->m_FishPointList[iP].y == -1)) break; 
			tX = m_pMapList[i]->m_FishPointList[iP].x + (iDice(1,3) - 2); 
			tY = m_pMapList[i]->m_FishPointList[iP].y + (iDice(1,3) - 2); 
			pItem = new class CItem; 
			if (pItem == NULL) break;                    
			ZeroMemory(cItemName, sizeof(cItemName)); 
			switch (iDice(1,9)) { // Adjusted difficulties
			case 1:   strcpy(cItemName, "RedCarp");     sDifficulty = iDice(1,10) + 5;  break; 
			case 2:   strcpy(cItemName, "GreenCarp");   sDifficulty = iDice(1,10) + 8;  break; 
			case 3:   strcpy(cItemName, "GoldCarp");    sDifficulty = iDice(1,10) + 15; break; 
			case 4:   strcpy(cItemName, "CrucianCarp"); sDifficulty = iDice(1,10) + 10;	break;    
			case 5:   strcpy(cItemName, "BlueSeaBream");sDifficulty = iDice(1,15) + 5;  break; 
			case 6:   strcpy(cItemName, "RedSeaBream"); sDifficulty = iDice(1,15);		break; 
			case 7:   strcpy(cItemName, "Salmon");      sDifficulty = iDice(1,15) + 20; break; 
			case 8:   strcpy(cItemName, "GrayMullet");  sDifficulty = iDice(1,15) + 15; break; 
			case 9: 
// SNOOPY81-> Modified to suit Revival Fish List
				switch (iDice(1,150)) { 
				case 1: // if (Skill - Difficuly) > 50 % will increase
				case 2: 
				case 3: 
				case 4: 
				case 5: 
				case 6:
				case 7: 
				case 8: 
				case 9: 
				case 10: 
					strcpy(cItemName, "InvisibilityPotion"); 
					sDifficulty = iDice(5,4) + 15; //20..35
					break; 
				case 11: 
				case 12: 
				case 13: 
				case 14: 
				case 15: 
				case 16: 
					strcpy(cItemName, "PowerGreenPotion"); 
					sDifficulty = iDice(5,4) + 10; //15..30
					break; 
				case 17: 
				case 18: 
				case 19: 
				case 20: 
					strcpy(cItemName, "SuperPowerGreenPotion"); 
					sDifficulty = iDice(5,4) + 20; 
					break; 
				case 21: 
				case 22: 
				case 23: 
				case 24: 
					strcpy(cItemName, "Dagger+2"); 
					sDifficulty = iDice(5,4) + 15; 
					break; 
				case 30: 
				case 31: 
					strcpy(cItemName, "Falchion+2"); 
					sDifficulty = iDice(5,4) + 20; 
					break; 
				case 40: 
					strcpy(cItemName, "BattleAxe+2"); 
					sDifficulty = iDice(5,4) + 37; 
					break; 
				case 50: 
				case 51: 
					strcpy(cItemName, "Templar+2"); 
					sDifficulty = iDice(5,4) + 30; 
					break; 
				case 60: 
				case 61: 
					strcpy(cItemName, "Flameberge+2"); 
					sDifficulty = iDice(5,4) + 35; 
					break; 
				case 65: 
				case 66: 
					strcpy(cItemName, "WarAxe+2"); 
					sDifficulty = iDice(5,4) + 33; 
					break; 

				// AJOUTS
				case 70:
					strcpy(cItemName, "RubyRing"); 
					sDifficulty = iDice(5,4) + 40; 
					break; 
				case 71: 
					strcpy(cItemName, "PlatinumRing"); 
					sDifficulty = iDice(5,4) + 37; 
					break; 
				case 72: 
					strcpy(cItemName, "SapphireRing"); 
					sDifficulty = iDice(5,4) + 37; 
					break; 
				case 73: 
					strcpy(cItemName, "StrangeRing1"); 
					sDifficulty = iDice(5,4) + 35; 
					break; 
				case 74:  
					strcpy(cItemName, "StrangeRing2"); 
					sDifficulty = iDice(5,4) + 35; 
					break; 				
				case 75:
					strcpy(cItemName, "StrangeRing3"); 
					sDifficulty = iDice(5,4) + 35; 
					break;  
				case 80: 			
				case 81: 			
				case 82: 			
				case 83:			
				case 84: 	
					strcpy(cItemName, "LongBoots"); 
					sDifficulty = iDice(5,4) + 10; 
					break; 			
				case 90: 
					strcpy(cItemName, "Egg961");
					sDifficulty = iDice(5,4) + 39;  
					break; 
				case 95: 
				case 96: 
				case 97: 
				case 98: 
					strcpy(cItemName, "Diamond"); 
					sDifficulty = iDice(5,4) + 35; 
					break; 
				} 
			break; 
			} 
			dwLastTime  = (60000 * 10) + (iDice(1,3) - 1)*(60000 * 10); 

			if (_bInitItemAttr(pItem, cItemName) == TRUE) 
			{	// SNOOPY: Added Touch Effect on fishing items
				pItem->m_sTouchEffectType   = DEF_ITET_ID;
				pItem->m_sTouchEffectValue1 = iDice(1,100000);
				pItem->m_sTouchEffectValue2 = iDice(1,100000);
				SYSTEMTIME SysTime;
				char cTemp[256];
				GetLocalTime(&SysTime);
				ZeroMemory(cTemp, sizeof(cTemp));
				wsprintf(cTemp, "%d%2d",  (short)SysTime.wMonth, (short)SysTime.wDay);
				pItem->m_sTouchEffectValue3 = atoi(cTemp);
				iRet = iCreateFish(i, tX, tY, 1, pItem, sDifficulty, dwLastTime); 
			}else  
			{	delete pItem; 
				pItem = NULL; 
			} 
		} 
	}                                         
}

int CGame::_iCalcPlayerNum(char cMapIndex, short dX, short dY, char cRadius)
{ // Returns nb of player in given radius of given position
 register int ix, iy, iRet;
 class CTile * pTile;	

	if ((cMapIndex < 0)	|| (cMapIndex > DEF_MAXMAPS)) return 0;
	if (m_pMapList[cMapIndex] == NULL) return 0;

	iRet = 0;
	for (ix = dX - cRadius; ix <= dX + cRadius; ix++)
	for (iy = dY - cRadius; iy <= dY + cRadius; iy++) {
		if ( (ix < 0) || (ix >= m_pMapList[cMapIndex]->m_sSizeX) || 
			 (iy < 0) || (iy >= m_pMapList[cMapIndex]->m_sSizeY) ) {
		}
		else {
			pTile = (class CTile *)(m_pMapList[cMapIndex]->m_pTile + ix + iy*m_pMapList[cMapIndex]->m_sSizeY);
			if ((pTile->m_sOwner != NULL) && (pTile->m_cOwnerClass == DEF_OWNERTYPE_PLAYER))
				iRet++;
		}
	}

	return iRet;
}


void CGame::WhetherProcessor()
{
char cPrevMode;
int i, j;
DWORD dwTime;
	dwTime = timeGetTime();
// SNOOPY for snow in winter
SYSTEMTIME SysTime;

	for (i = 0; i < DEF_MAXMAPS; i++) {
		if ((m_pMapList[i] != NULL) && (m_pMapList[i]->m_bIsFixedDayMode == FALSE)) 
		{	cPrevMode = m_pMapList[i]->m_cWhetherStatus;
			if (m_pMapList[i]->m_cWhetherStatus != NULL) 
			{	if ((dwTime - m_pMapList[i]->m_dwWhetherStartTime) > m_pMapList[i]->m_dwWhetherLastTime) 
					m_pMapList[i]->m_cWhetherStatus = NULL;
				}else 
				{	GetLocalTime(&SysTime);
					switch((short)SysTime.wMonth) {
					case 12: 
					case 1: 
					case 2: // Winter
						if (iDice(1,100) == 13) 
						{	m_pMapList[i]->m_cWhetherStatus = iDice(3,2);
							m_pMapList[i]->m_dwWhetherStartTime = dwTime;
							m_pMapList[i]->m_dwWhetherLastTime  = 60000*3 + 60000*iDice(2,7);					
						}
						// Chrismas
						if (((short)SysTime.wMonth == 12) && ((short)SysTime.wMonth > 24)) 
						{	m_pMapList[i]->m_cWhetherStatus = iDice(1,2)+4;
							m_pMapList[i]->m_dwWhetherStartTime = dwTime;
							m_pMapList[i]->m_dwWhetherLastTime  = 60000*3 + 60000*iDice(2,7);					
						}
						break;
					case 6:
					case 7: 
					case 8:  // Summer weather: rare thunderstorms heavy rain
						if (iDice(1,800) == 13) 
						{	m_pMapList[i]->m_cWhetherStatus = 3;
							m_pMapList[i]->m_dwWhetherStartTime = dwTime;
							m_pMapList[i]->m_dwWhetherLastTime  = 60000 + 60000*iDice(1,3);
						}
						break;								
					default:   // Standard Weather
						if (iDice(1,300) == 13) 
						{	m_pMapList[i]->m_cWhetherStatus = iDice(1,3); 
							m_pMapList[i]->m_dwWhetherStartTime = dwTime;
							m_pMapList[i]->m_dwWhetherLastTime  = 60000*3 + 60000*iDice(1,7);
						}
						break;
					}
				}
			if (m_pMapList[i]->m_bIsSnowEnabled == TRUE) 
			{	m_pMapList[i]->m_cWhetherStatus = iDice(1,3)+3;
				m_pMapList[i]->m_dwWhetherStartTime = dwTime;
				m_pMapList[i]->m_dwWhetherLastTime  = 60000*3 + 60000*iDice(1,7);
			}

			if (cPrevMode != m_pMapList[i]->m_cWhetherStatus) 
			{	m_pMapList[i]->m_cThunder = 0;
				for (j = 1; j < DEF_MAXCLIENTS; j++) 
				if ((m_pClientList[j] != NULL) && (m_pClientList[j]->m_bIsInitComplete == TRUE) && (m_pClientList[j]->m_cMapIndex == i)) 
					SendNotifyMsg(NULL, j, DEF_NOTIFY_WHETHERCHANGE, m_pMapList[i]->m_cWhetherStatus, NULL, NULL, NULL);
			}else
			{	if (m_pMapList[i]->m_cThunder == 2) DoAbaddonThunderDamageHandler(i);			
			}
		} //If
	} //for Loop
}

void CGame::FightzoneReserveProcessor()
{/* register int i;	
	PutLogList("CAN FIGHTZONE RESERVE!!");			
	for (i=0 ; i < DEF_MAXFIGHTZONE ; i++ ) 
	{	if (m_iFightZoneReserve[i] == -1 ) continue ; 
		m_iFightZoneReserve[i] = 0 ;
	}
	for (i = 1; i < DEF_MAXCLIENTS; i++) {
		if((m_pClientList[i] != NULL) && (m_pClientList[i]->m_iFightzoneNumber != 0))
				SendNotifyMsg(NULL, i, DEF_NOTIFY_FIGHTZONERESERVE, -2, NULL, NULL, NULL);
	}*/
}

/*********************************************************************************************************************
**  int CGame::iGetWhetherMagicBonusEffect(short sType, char cWheatherStatus)										**
**  description			:: checks for a weather bonus when magic is cast											**
**  last updated		:: November 20, 2004; 10:34 PM; Hypnotoad													**
**	return value		:: int																						**
*********************************************************************************************************************/
int CGame::iGetWhetherMagicBonusEffect(short sType, char cWheatherStatus)
{
 int iWheatherBonus;

	iWheatherBonus = 0;

	// SNOOPY: Added more recent relevant spells for the bonus
	//         and snow effect on spell damage
	switch (cWheatherStatus) {
	case 0: break;
	case 1: // Rain
	case 2:
	case 3: // Heavy rain
		switch (sType) {
		case 10: // Energy Bolt
		case 37: // Lightning Arrow
		case 43: // Lightning       
		case 47: // Triple-Energy-Bolt          
		case 51: // Lightning-Bolt        
		case 56: // Mass-Lightning-Arrow        
		case 60: // Energy-Strike      
		case 74: // Lightning-Strike    
		case 93: // Mass-Lightning-Strike ?  
		//case 0: // Mass-Magic-Missile ?   
			iWheatherBonus = 2*cWheatherStatus;
			break;
		case 20: // Fire-Ball
		case 30: // Fire-Strike
		case 61: // Mass-Fire-Strike
		//case 81: // Meteor-Strike
			iWheatherBonus = -2*cWheatherStatus;
			break;
		case 70: // Bloody ShockWave
			iWheatherBonus = cWheatherStatus;
			break;   
		case 40: // FireWall FireField 
		case 46: // Poison-Cloud, CloudKill  
			iWheatherBonus = -1;
			break;   
		}
   		break;
	case 4: // Snow
	case 5:
	case 6:	// Heavy snow
		switch (sType) {    
		case 45: // Chill-Wind          
		case 57: // Ice-Strike        
		case 63: // Mass-Chill-Wind        
		case 72: // Mass-Ice-Strike    
			iWheatherBonus = cWheatherStatus; // 4 to 6
			break;
		case 55: // Ice-Storm    Need small bonus
		case 85: // Blizzard ... Already big damage!   
		case 91: // Mass-Blizzard ... Already big damage!     
			iWheatherBonus = cWheatherStatus-3; // 1 to 3
			break;
		case 20: // Fire-Ball
		case 30: // Fire-Strike
		case 61: // Mass-Fire-Strike
		case 81: // Meteor-Strike
			iWheatherBonus = (cWheatherStatus-3) * -1; 
			break;
		case 40: // FireWall FireField   
			iWheatherBonus = -1; // 4 to 6
			break;
		}
   		break;

	}
	// SNOOPY Better damage for Fire spells on summer days
	//        Worst damage for Ice spells 
	SYSTEMTIME SysTime;					
	GetLocalTime(&SysTime);	
	if (m_cDayOrNight == 1) { //Day
		switch((short)SysTime.wMonth) {
		case 7: // July
		case 8: // August
			switch (sType) {  
			case 20: // Fire-Ball
			case 30: // Fire-Strike
			case 61: // Mass-Fire-Strike
			//case 81: // Meteor-Strike
				iWheatherBonus = iWheatherBonus + 2;
				break;
			case 40: // FireWall FireField small bonus
				iWheatherBonus = iWheatherBonus + 1;
				break;   
			}				
			switch (sType) {    
			case 45: // Chill-Wind          
			case 57: // Ice-Strike        
			case 63: // Mass-Chill-Wind        
			case 72: // Mass-Ice-Strike    
			case 85: // Blizzard .
			case 91: // MassBlizzard .
				iWheatherBonus = iWheatherBonus - 2;
				break;
			case 55: // Ice-Storm    Need small bonus  
				iWheatherBonus = iWheatherBonus - 1;
				break;
			}
			break;
		}
	}else { // Night time
	}
	return iWheatherBonus;		
}

int CGame::iGetPlayerRelationship(int iClientH, int iOpponentH)
{int iRet;
	if (m_pClientList[iClientH] == NULL) return 0;
	if (m_pClientList[iClientH]->m_bIsInitComplete == FALSE) return 0;
	if (m_pClientList[iOpponentH] == NULL) return 0;
	if (m_pClientList[iOpponentH]->m_bIsInitComplete == FALSE) return 0;
	//  New by Snoopy:
	//	0: Neutral no damage
	//  1: 1/2 damage on same city if in Arenas, no damage elsewhere
	//  2: Full damage
	iRet = 2;
	if (m_pClientList[iClientH]->m_cSide == m_pClientList[iOpponentH]->m_cSide)
	{	iRet = 1;
	}
	if (   (m_pClientList[iClientH]->m_iGuildRank != -1)
		&& (m_pClientList[iClientH]->m_iGuildGUID == m_pClientList[iOpponentH]->m_iGuildGUID))
	{	iRet -= 1;
	}
	if (m_pClientList[iClientH]->m_iPKCount != 0) // Criminals
	{	iRet = 2;
	}else if (m_pClientList[iOpponentH]->m_iPKCount != 0) // Criminals
	{	iRet = 2;
	}
	return iRet;
}

int CGame::iGetPlayerABSStatus(int iWhatH, int iRecvH, BOOL & bTransparentInvi)
{	int iRet;
	// 1: isCivilian bit
	// 2: isAres bit (Elvine if absent)
	// 4: isNotNeutral bit
	// 8: isCriminal bit (or Evil side)
	bTransparentInvi = FALSE;
	if (m_pClientList[iWhatH] == NULL) return 0;
	if (m_pClientList[iRecvH] == NULL) return 0;
	iRet = 0;
	// SNOOPY: Support for confusion type spells
	// because client confuses only for npcs!
	if (m_pClientList[iRecvH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_CONFUSE ] == 2)
	{	// Confused character see every body as enemy
		switch (m_pClientList[iRecvH]->m_cSide) {
		case 0: // Confused traveller see everybody as Criminal/Executor
		case 4: // Confused evil see everybody as evil
		default: //  
			iRet = 8;
			break;
		case 1: // Confused Ares see everybody as Elvine
			iRet = 4; // isNotNeutral
			break;
		case 2: // Confused Elvines see everyboby as Ares
			iRet = 6; // isNotNeutral // isAres
			break;
		}
		if (m_pClientList[iRecvH]->m_bIsPlayerCivil == TRUE)
			iRet = iRet | 1;
	}else // Not confused character
	{	if (m_pClientList[iWhatH]->m_iPKCount != 0) 
		{	iRet = 8;
			if (m_pClientList[iWhatH]->m_iAdminUserLevel != 0) 
			{	iRet = 0;// GMs never shown as criminals
		}	}
		switch (m_pClientList[iWhatH]->m_cSide) {
		case 0: // Show a traveller, 
			iRet = 1; // devrait marcher, bleu pour tous
			break;
		case 1: // Show an Ares
			iRet = iRet | 6; // isAres// isNotNeutral
			
			if (m_pClientList[iWhatH]->m_bIsPlayerCivil == TRUE) iRet = iRet | 1;
			//else if (m_pClientList[iRecvH]->m_cSide == 4) iRet = iRet | 8; 
			// Passe ronge, sans mon patch, mais indispensable sinon, faut CTRL + Tape sinon rien a faire (inutile en v4.0 ?)
			if (   (m_pClientList[iRecvH]->m_cSide == 1)
				&& ((m_pClientList[iWhatH]->m_iStatus & 0x00000010) != 0)) bTransparentInvi = TRUE;
			break;
		case 2: // Show an Elvine
			iRet = iRet | 4; // isNotNeutral
			if (m_pClientList[iWhatH]->m_bIsPlayerCivil == TRUE) iRet = iRet | 1;
			//else if (m_pClientList[iRecvH]->m_cSide == 4) iRet = iRet | 8; 
			// Passe ronge, sans mon patch, mais indispensable sinon, faut CTRL + Tape sinon rien a faire (inutile en v4.0 ?)
			if (   (m_pClientList[iRecvH]->m_cSide == 2)
				&& ((m_pClientList[iWhatH]->m_iStatus & 0x00000010) != 0)) bTransparentInvi = TRUE;
			break;
		case 4: // Show an Executor
			if (m_pClientList[iRecvH]->m_cSide == 0)  iRet = 0;			// Blue for Trav
			else iRet = 2;	// Green for Exec, red for others
			if (   (m_pClientList[iRecvH]->m_cSide == 4)
				&& ((m_pClientList[iWhatH]->m_iStatus & 0x00000010) != 0)) bTransparentInvi = TRUE;
			//iRet = 8;	// Red for others without patch
			break;
		default:  
			iRet = 8;
			break;
		}
	}
	// FightZone
	if (m_pMapList[m_pClientList[iRecvH]->m_cMapIndex]->m_bIsFightZone == TRUE) 
	{	if ((m_pClientList[iWhatH]->m_iGuildRank != -1) && (m_pClientList[iRecvH]->m_iGuildRank != -1)) 
		{	if (memcmp(m_pClientList[iWhatH]->m_cGuildName, m_pClientList[iRecvH]->m_cGuildName, 20) != 0) 
			{	iRet = iRet | 8;
	}	}	} 
	// SNOOPY If same Party, show invis	
	if (   (m_pClientList[iWhatH]->m_iPartyID != NULL) 
		&& (m_pClientList[iRecvH]->m_iPartyID != NULL) )
	{	if ( m_pClientList[iWhatH]->m_iPartyID == m_pClientList[iRecvH]->m_iPartyID)
		{	 bTransparentInvi = TRUE;
	}	}	
	// Criminals Invis for everybody except other crims
	if ((m_pClientList[iWhatH]->m_iPKCount == 0) && (m_pClientList[iRecvH]->m_iPKCount == 0))
	{}else
	{	bTransparentInvi = FALSE;
	}
	// Beholder Neck or GM		
	if (m_pClientList[iRecvH]->m_iBeholderPower > 0)		bTransparentInvi = TRUE;
	if (   (m_pClientList[iWhatH]->m_iAdminUserLevel != 0)
		&& (m_pClientList[iRecvH]->m_iAdminUserLevel == 0)) bTransparentInvi = FALSE;		
	return iRet;
}

int CGame::iGetNpcRelationship(int iWhatH, int iRecvH, BOOL & bTransparentInvi) 
{ 	int iRet; 
	bTransparentInvi = FALSE;
	if (m_pClientList[iRecvH] == NULL) return 0; 
	if (m_pNpcList[iWhatH] == NULL) return 0; 
	// SNOOPY: Just a small change. Client is supposed to hide relationship for npc if
	//         character is confused. This is here just in case for hackers.
	if (m_pClientList[iRecvH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_CONFUSE ] == 2)
	{	return 0; 
	}
	//snoopy: fixed missing break..
	//        and revamped for executor side, and side 3 npcs....
	switch (m_pNpcList[iWhatH]->m_cSide) { 
	case 0: // neutral npcs								// 1(client patché), 0 avant		
		iRet = 1; 
		break;
	case 1: // Ares ncp									// Rien changé
		iRet = 6; // isNotNeutral// isAres -
		if (   (m_pClientList[iRecvH]->m_cSide == 4)		// Exec or Crims will see mobs as Enemy// But will see the city for mercenaries
			&& (m_pNpcList[iWhatH]->m_sType >6))		iRet |= 8;	
		else if (   (m_pClientList[iRecvH]->m_iPKCount != 0) 
			&& (m_pNpcList[iWhatH]->m_sType >6))		iRet |= 8; 
		else if (  (m_pClientList[iRecvH]->m_cSide == 1)
				&& ((m_pNpcList[iWhatH]->m_iStatus & 0x00000010) != 0)) 
														bTransparentInvi = TRUE;
		break;
	case 2: // Elvine npc								// Rien changé
		iRet = 4; // isNotNeutral
		if (   (m_pClientList[iRecvH]->m_cSide == 4) 			// Exec or Crims will see mobs as Enemy// But will see the city for mercenaries
			&& (m_pNpcList[iWhatH]->m_sType >6))		iRet |= 8;	
		else if (   (m_pClientList[iRecvH]->m_iPKCount != 0)	
			&& (m_pNpcList[iWhatH]->m_sType >6))		iRet |= 8; 
		else if (  (m_pClientList[iRecvH]->m_cSide == 2)
				&& ((m_pNpcList[iWhatH]->m_iStatus & 0x00000010) != 0)) 
														bTransparentInvi = TRUE;
		break;
	case 3: // Equi guards								// 1(client patché), 0 avant
		iRet = 1; // attack side 10 or crims only 
		if (m_pClientList[iRecvH]->m_iPKCount != 0)		iRet |= 8; 
		else if (m_pClientList[iRecvH]->m_cSide == 4)	iRet |= 8;
		else if ((m_pNpcList[iWhatH]->m_iStatus & 0x00000010) != 0)	// everybody else see them if invi
														bTransparentInvi = TRUE;				
		break;
	case 4: // Apply to evil player & summons			// 3 pour Exec(Client Patché)->Amis, 0 avant
		if (m_pClientList[iRecvH]->m_cSide == 4) // See those mobs Friendly with my client patch 
		{												iRet = 3;
			if ((m_pNpcList[iWhatH]->m_iStatus & 0x00000010) != 0) 
														bTransparentInvi = TRUE;
		}else											iRet = 8;
		break;
	case 10: // Monster
		iRet |= 8; //Fixed, Original 15 
		break;
	} 
	// Beholder Neck or GM		
	if (m_pClientList[iRecvH]->m_iBeholderPower > 0) bTransparentInvi = TRUE;
	return iRet; 
}

int CGame::iGetMapIndex(char * pMapName)
{register int i, iMapIndex;
 char cTmpName[256];
	ZeroMemory(cTmpName, sizeof(cTmpName));
	strcpy(cTmpName, pMapName);
	iMapIndex = -1;
	for (i = 0; i < DEF_MAXMAPS; i++)
	if (m_pMapList[i] != NULL) {
		if (memcmp(m_pMapList[i]->m_cName, pMapName, 10) == 0) 
			iMapIndex = i;
	}
	return iMapIndex;
}

int CGame::_iForcePlayerDisconect(int iNum)
{register int i, iCnt;
	iCnt = 0;
	for (i = 1; i < DEF_MAXCLIENTS; i++)
	if (m_pClientList[i] != NULL) 
	{	if (m_pClientList[i]->m_bIsInitComplete == TRUE)
			 DeleteClient(i, TRUE, TRUE);
		else DeleteClient(i, FALSE, FALSE);
		iCnt++;
		if (iCnt >= iNum) break;
	}
	return iCnt;
}

void CGame::SpecialEventHandler() // every 3 sec
{DWORD dwTime = timeGetTime();
	// SNOOPY: Added support for destructing some ncps
	//         If the mob number stays too high for  generating spawns	
	//         or if Magic pits created too much mobs outside pits
	if (   ((dwTime - m_dwSpecialEventTime) >= DEF_SPECIALEVENTTIME99)
		&& (m_cSpecialEventType != 99) )
	{	m_bIsSpecialEventTime = TRUE;
		m_cSpecialEventType = 99; // Will remove npcs, once
	}
	// Will stay to 99 until  standard  DEF_SPECIALEVENTTIME
	if ((dwTime - m_dwSpecialEventTime) < DEF_SPECIALEVENTTIME) return; // DEF_SPECIALEVENTTIME
	m_dwSpecialEventTime  = dwTime;
	m_bIsSpecialEventTime = TRUE;		
	if (iDice(1,60) != 53)		m_cSpecialEventType = 1; // Spawn 
	else if (iDice(1,3) == 2)	m_cSpecialEventType = 2; // Demon or Unicorn apearing 
	else						m_cSpecialEventType = 3; // Boss mob may appear if someone on the map
}

void CGame::AdminOrder_CheckIP(int iClientH, char *pData, DWORD dwMsgSize)
{char   seps[] = "= \t\n";
 char   * token, cBuff[256], cIP[21], cInfoString[500];
 class  CStrTok * pStrTok;
 register int i;
	if (m_pClientList[iClientH] == NULL) return;
	if ((dwMsgSize)	<= 0) return;
	if (m_pClientList[iClientH]->m_iAdminUserLevel < m_iAdminLevelCheckIP) {
		SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_ADMINUSERLEVELLOW, NULL, NULL, NULL, NULL);
		return;
	}
	ZeroMemory(cBuff, sizeof(cBuff));
	memcpy(cBuff, pData, dwMsgSize);
	pStrTok = new class CStrTok(cBuff, seps);
	token = pStrTok->pGet();
	token = pStrTok->pGet();	
	if (token != NULL) 
	{	ZeroMemory(cIP, sizeof(cIP));
		strcpy(cIP, token);
		for (i = 1; i < DEF_MAXCLIENTS; i++) 
		if ((m_pClientList[i] != NULL) && (memcmp(m_pClientList[i]->m_cIPaddress, cIP, strlen(cIP)) == 0)) {
			ZeroMemory(cInfoString, sizeof(cInfoString));
			wsprintf(cInfoString, "Name(%s/%s) Loc(%s: %d %d) Level(%d:%d) Init(%d) IP(%s)", 
				     m_pClientList[i]->m_cAccountName, m_pClientList[i]->m_cCharName, m_pClientList[i]->m_cMapName, 
					 m_pClientList[i]->m_sX, m_pClientList[i]->m_sY, 
					 m_pClientList[i]->m_iLevel, NULL/*m_pClientList[i]->m_cAccountStatus*/,
					 m_pClientList[i]->m_bIsInitComplete, m_pClientList[i]->m_cIPaddress);
			SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_IPACCOUNTINFO, NULL, NULL, NULL, cInfoString);			
			wsprintf(G_cTxt, "GM Order(%-10s): /checkip (%s)", m_pClientList[iClientH]->m_cCharName, m_pClientList[i]->m_cIPaddress);
			bSendMsgToLS(MSGID_GAMEMASTERLOG, iClientH, FALSE, G_cTxt);	
	}	}	
	delete pStrTok;
}

void CGame::ToggleSafeAttackModeHandler(int iClientH) //v1.1
{	if (m_pClientList[iClientH] == NULL) return;
	if (m_pClientList[iClientH]->m_bIsInitComplete == FALSE) return;
	if (m_pClientList[iClientH]->m_bIsKilled == TRUE) return;
	if (m_pClientList[iClientH]->m_bIsSafeAttackMode == TRUE) 
		 m_pClientList[iClientH]->m_bIsSafeAttackMode = FALSE;
	else m_pClientList[iClientH]->m_bIsSafeAttackMode = TRUE;
	SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_SAFEATTACKMODE, NULL, NULL, NULL, NULL);
}

void CGame::NpcRequestAssistance(int iNpcH)
{
 register int ix, iy, sX, sY;
 short sOwnerH;
 char  cOwnerType;	
	// iNpc
	if (m_pNpcList[iNpcH] == NULL) return;
	sX = m_pNpcList[iNpcH]->m_sX;
	sY = m_pNpcList[iNpcH]->m_sY;
	for (ix = sX - 8; ix <= sX + 8; ix++)
	for (iy = sY - 8; iy <= sY + 8; iy++) {
		m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, ix, iy);
		if (   (sOwnerH != NULL) && (m_pNpcList[sOwnerH] != NULL) 
			&& (cOwnerType == DEF_OWNERTYPE_NPC) && (iNpcH != sOwnerH) 
			&& (m_pNpcList[sOwnerH]->m_cSide == m_pNpcList[iNpcH]->m_cSide) 
			&& (m_pNpcList[sOwnerH]->m_bIsPermAttackMode == FALSE) 
			&& (m_pNpcList[sOwnerH]->m_cBehavior == DEF_BEHAVIOR_MOVE)) 
		{	m_pNpcList[sOwnerH]->m_cBehavior          = DEF_BEHAVIOR_ATTACK;
			m_pNpcList[sOwnerH]->m_sBehaviorTurnCount = 0;		
			m_pNpcList[sOwnerH]->m_iTargetIndex = m_pNpcList[iNpcH]->m_iTargetIndex;
			m_pNpcList[sOwnerH]->m_cTargetType  = m_pNpcList[iNpcH]->m_cTargetType;
			return;
		}
	}
}

void CGame::ForceDisconnectAccount(char *pAccountName, WORD wCount)
{bool bOK = FALSE;
 register int i;
	for (i = 1; i < DEF_MAXCLIENTS; i++)
	if ((m_pClientList[i] != NULL) && (memcmp(m_pClientList[i]->m_cAccountName, pAccountName, 10) == 0)) 
	{	wsprintf(G_cTxt, "Force disconnect:  Acc(%s) PC(%s) Count(%d). (Asking client to close conn) \tIP(%s)"
			, pAccountName					
			, m_pClientList[i]->m_cCharName
			, wCount
			, m_pClientList[i]->m_cIPaddress);
		PutLogList(G_cTxt);
		PutHackLogFileList(G_cTxt);
		SendNotifyMsg(NULL, i, DEF_NOTIFY_FORCEDISCONN, wCount, NULL, NULL, NULL);
		bOK = TRUE;
		break;
	}
	if (bOK == FALSE) // Add by snoopy
	{	DWORD dwTime = timeGetTime();
		{	for (i = 0; i < DEF_MAXCLIENTS; i++) 
			{	if (   (memcmp(m_stOldClientList[i].m_cAccountName, pAccountName, 10) == 0)
					&& (dwTime < (m_stOldClientList[i].m_dwDeleteTime + 59*1000))) // erased less than 60 sec ago
				{	wsprintf(G_cTxt, "Force disconnect:  Acc(%s) PC(%s) Count(%d). (Disconnected %dms ago!)"
						, pAccountName	
						, m_stOldClientList[i].m_cCharName
						, wCount
						, (dwTime - m_stOldClientList[i].m_dwDeleteTime));
					PutLogList(G_cTxt);
					PutHackLogFileList(G_cTxt);
					goto OUTDATED_PROUVED;						
		}	}	}		
		wsprintf(G_cTxt, "Force disconnect:  Acc(%s) PC(Not found) Count(%d). (Account not connected here!)"
			, pAccountName					
			, wCount);
		PutLogList(G_cTxt);	
		PutHackLogFileList(G_cTxt);
OUTDATED_PROUVED:;
		/*ZeroMemory(m_cBugText, sizeof(m_cBugText));
		wsprintf(m_cBugText, "IMPORTANT NOTICE: \"Character in use\" bug detected, on account: %s"
		, pAccountName);
		m_iBugWarning = 1;*/
	}
}

void CGame::AdminOrder_Polymorph(int iClientH, char *pData, DWORD dwMsgSize)
{char   seps[] = "= \t\n";
 char   * token, cBuff[256]; 
 class  CStrTok * pStrTok;
	if (m_pClientList[iClientH] == NULL) return;
	if ((dwMsgSize)	<= 0) return;
	if (m_pClientList[iClientH]->m_iAdminUserLevel < m_iAdminLevelPolymorph) {
		SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_ADMINUSERLEVELLOW, NULL, NULL, NULL, NULL);
		return;
	}
	//m_pClientList[iClientH]->m_sOriginalType = m_pClientList[iClientH]->m_sType;
	ZeroMemory(cBuff, sizeof(cBuff));
	memcpy(cBuff, pData, dwMsgSize);
	pStrTok = new class CStrTok(cBuff, seps);
	token = pStrTok->pGet();
	token = pStrTok->pGet();
	if (token != NULL) 
	{	if (memcmp(token, "off", 3) == 0) // off
			m_pClientList[iClientH]->m_sType = m_pClientList[iClientH]->m_sOriginalType;
		else if (memcmp(token, "Slime", 5) == 0)
			m_pClientList[iClientH]->m_sType = 10;
		else if (memcmp(token, "Skeleton", 8) == 0)
			m_pClientList[iClientH]->m_sType = 11;
		else if (memcmp(token, "Stone-Golem", 11) == 0)
			m_pClientList[iClientH]->m_sType = 12;
		else if (memcmp(token, "Cyclops", 7) == 0)
			m_pClientList[iClientH]->m_sType = 13;
		else if (memcmp(token, "Orc", 3) == 0)
			m_pClientList[iClientH]->m_sType = 14;
		else if (memcmp(token, "ShopKeeper", 10) == 0)
			m_pClientList[iClientH]->m_sType = 15;
		else if (memcmp(token, "Giant-Ant", 9) == 0)
			m_pClientList[iClientH]->m_sType = 16;
		else if (memcmp(token, "Scorpion", 8) == 0)
			m_pClientList[iClientH]->m_sType = 17;
		else if (memcmp(token, "Zombie", 6) == 0)
			m_pClientList[iClientH]->m_sType = 18;
		else if (memcmp(token, "Gandlf", 6) == 0)
			m_pClientList[iClientH]->m_sType = 19;
		else if (memcmp(token, "Howard", 6) == 0)
			m_pClientList[iClientH]->m_sType = 20;
		else if (memcmp(token, "Gaurd", 5) == 0)
			m_pClientList[iClientH]->m_sType = 21;
		else if (memcmp(token, "Amphis", 6) == 0)
			m_pClientList[iClientH]->m_sType = 22;
		else if (memcmp(token, "Clay-Golem", 10) == 0)
			m_pClientList[iClientH]->m_sType = 23;
		else if (memcmp(token, "Tom", 3) == 0)
			m_pClientList[iClientH]->m_sType = 24;
		else if (memcmp(token, "William", 7) == 0)
			m_pClientList[iClientH]->m_sType = 25;
		else if (memcmp(token, "Kennedy", 7) == 0)
			m_pClientList[iClientH]->m_sType = 26;
		else if (memcmp(token, "Hellbound", 9) == 0)
			m_pClientList[iClientH]->m_sType = 27;
		else if (memcmp(token, "Troll", 5) == 0)
			m_pClientList[iClientH]->m_sType = 28;
		else if (memcmp(token, "Ogre", 4) == 0)
			m_pClientList[iClientH]->m_sType = 29;
		else if (memcmp(token, "Liche", 5) == 0)
			m_pClientList[iClientH]->m_sType = 30;
		else if (memcmp(token, "Demon", 5) == 0)
			m_pClientList[iClientH]->m_sType = 31;
		else if (memcmp(token, "Unicorn", 7) == 0)
			m_pClientList[iClientH]->m_sType = 32;
		else if (memcmp(token, "WereWolf", 8) == 0)
			m_pClientList[iClientH]->m_sType = 33;
		else if (memcmp(token, "Dummy", 5) == 0)
			m_pClientList[iClientH]->m_sType = 34;
		else if (memcmp(token, "Energy-Sphere", 13) == 0)
			m_pClientList[iClientH]->m_sType = 35;
		else if (memcmp(token, "AGT", 3) == 0)
			m_pClientList[iClientH]->m_sType = 36;
		else if (memcmp(token, "CGT", 3) == 0)
			m_pClientList[iClientH]->m_sType = 37;
		else if (memcmp(token, "MS", 2) == 0)
			m_pClientList[iClientH]->m_sType = 38;
		else if (memcmp(token, "DT", 2) == 0)
			m_pClientList[iClientH]->m_sType = 39;
		else if (memcmp(token, "ESG", 3) == 0)
			m_pClientList[iClientH]->m_sType = 40;
		else if (memcmp(token, "GMG", 3) == 0)
			m_pClientList[iClientH]->m_sType = 41;
		else if (memcmp(token, "ManaStone", 9) == 0)
			m_pClientList[iClientH]->m_sType = 42;
		else if (memcmp(token, "LWB", 3) == 0)
			m_pClientList[iClientH]->m_sType = 43;
		else if (memcmp(token, "GHK", 3) == 0)
			m_pClientList[iClientH]->m_sType = 44;
		else if (memcmp(token, "GHC", 6) == 0)
			m_pClientList[iClientH]->m_sType = 45;
		else if (memcmp(token, "TK", 2) == 0)
			m_pClientList[iClientH]->m_sType = 46;
		else if (memcmp(token, "BG", 2) == 0)
			m_pClientList[iClientH]->m_sType = 47;
		else if (memcmp(token, "Stalker", 7) == 0)
			m_pClientList[iClientH]->m_sType = 48;
		else if (memcmp(token, "Hellclaw", 8) == 0)
			m_pClientList[iClientH]->m_sType = 49;
		else if (memcmp(token, "Tigerworm", 8) == 0)
			m_pClientList[iClientH]->m_sType = 50;
		else if (memcmp(token, "CP", 2) == 0)
			m_pClientList[iClientH]->m_sType = 51;
		else if (memcmp(token, "Gagoyle", 7) == 0)
			m_pClientList[iClientH]->m_sType = 52;
		else if (memcmp(token, "Beholder", 8) == 0)
			m_pClientList[iClientH]->m_sType = 53;
		else if (memcmp(token, "Dark-Elf", 8) == 0)
			m_pClientList[iClientH]->m_sType = 54;
		else if (memcmp(token, "Rabbit", 6) == 0)
			m_pClientList[iClientH]->m_sType = 55;
		else if (memcmp(token, "Cat", 3) == 0)
			m_pClientList[iClientH]->m_sType = 56;
		else if (memcmp(token, "Frog", 10) == 0)
			m_pClientList[iClientH]->m_sType = 57;
		else if (memcmp(token, "Mountain-Giant", 14) == 0)
			m_pClientList[iClientH]->m_sType = 58;
		else if (memcmp(token, "Ettin", 5) == 0)
			m_pClientList[iClientH]->m_sType = 59;
		else if (memcmp(token, "Plant", 13) == 0)
			m_pClientList[iClientH]->m_sType = 60;
		else if (memcmp(token, "Rudolph", 7) == 0)
			m_pClientList[iClientH]->m_sType = 61;
		else if (memcmp(token, "DireBoar", 8) == 0)
			m_pClientList[iClientH]->m_sType = 62;
		else if (memcmp(token, "Frost", 5) == 0)
			m_pClientList[iClientH]->m_sType = 63;
		else if (memcmp(token, "Crops", 5) == 0)
			m_pClientList[iClientH]->m_sType = 64;
		else if (memcmp(token, "Ice-Golem", 9) == 0)
			m_pClientList[iClientH]->m_sType = 65;
		//else if (memcmp(token, "Wyvern", 6) == 0)
		//	m_pClientList[iClientH]->m_sType = 66;
		else if (memcmp(token, "McGaffin", 8) == 0)
			m_pClientList[iClientH]->m_sType = 67;
		else if (memcmp(token, "Perry", 5) == 0)
			m_pClientList[iClientH]->m_sType = 68;
		else if (memcmp(token, "Devlin", 6) == 0)
			m_pClientList[iClientH]->m_sType = 69;
		else if (memcmp(token, "Dragon", 6) == 0)
			m_pClientList[iClientH]->m_sType = 70;
		else if (memcmp(token, "Centaurus", 9) == 0)
			m_pClientList[iClientH]->m_sType = 71;
		else if (memcmp(token, "Claw-Turtle", 11) == 0)
			m_pClientList[iClientH]->m_sType = 72;
		//else if (memcmp(token, "Fire-Wyvern", 11) == 0)
		//	m_pClientList[iClientH]->m_sType = 73;
		else if (memcmp(token, "Giant-Crayfish", 14) == 0)
			m_pClientList[iClientH]->m_sType = 74;
		else if (memcmp(token, "Giant-Lizard", 12) == 0)
			m_pClientList[iClientH]->m_sType = 75;
		else if (memcmp(token, "Giant-Tree", 11) == 0)
			m_pClientList[iClientH]->m_sType = 76;
		else if (memcmp(token, "MasterMage-Orc", 14) == 0)
			m_pClientList[iClientH]->m_sType = 77;
		else if (memcmp(token, "Minotaurs", 9) == 0)
			m_pClientList[iClientH]->m_sType = 78;
		else if (memcmp(token, "Nizie", 5) == 0)
			m_pClientList[iClientH]->m_sType = 79;
		else if (memcmp(token, "Tentocle", 8) == 0)
			m_pClientList[iClientH]->m_sType = 80;
		//else if (memcmp(token, "Abaddon", 7) == 0)
		//	m_pClientList[iClientH]->m_sType = 81;
		else if (memcmp(token, "Sor", 3) == 0)
			m_pClientList[iClientH]->m_sType = 82;
		else if (memcmp(token, "ATK", 3) == 0)
			m_pClientList[iClientH]->m_sType = 83;
		else if (memcmp(token, "Elf", 3) == 0)
			m_pClientList[iClientH]->m_sType = 84;
		else if (memcmp(token, "DSK", 3) == 0)
			m_pClientList[iClientH]->m_sType = 85;
		else if (memcmp(token, "HBT", 3) == 0)
			m_pClientList[iClientH]->m_sType = 86;
		else if (memcmp(token, "CT", 2) == 0)
			m_pClientList[iClientH]->m_sType = 87;
		else if (memcmp(token, "Bar", 3) == 0)
			m_pClientList[iClientH]->m_sType = 88;
		else if (memcmp(token, "AGC", 3) == 0)
			m_pClientList[iClientH]->m_sType = 89;
		else if (memcmp(token, "Gail", 4) == 0)
			m_pClientList[iClientH]->m_sType = 90;
		else if (memcmp(token, "gate", 4) == 0)
			m_pClientList[iClientH]->m_sType = 91;
	}
	SendEventToNearClient_TypeA(iClientH, DEF_OWNERTYPE_PLAYER, MSGID_EVENT_MOTION, DEF_OBJECTNULLACTION, NULL, NULL, NULL);	
	wsprintf(G_cTxt, "GM Order(%-10s): /polymorph (done)", m_pClientList[iClientH]->m_cCharName);
	bSendMsgToLS(MSGID_GAMEMASTERLOG, iClientH, FALSE, G_cTxt);	
	delete pStrTok;
}

void CGame::AdminOrder_SetInvi(int iClientH, char *pData, DWORD dwMsgSize)
{ char   seps[] = "= \t\n";
 char   * token, cBuff[256]; 
 class  CStrTok * pStrTok;
	if (m_pClientList[iClientH] == NULL) return;
	if ((dwMsgSize)	<= 0) return;
	if (m_pClientList[iClientH]->m_iAdminUserLevel < m_iAdminLevelSetInvis) {
		SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_ADMINUSERLEVELLOW, NULL, NULL, NULL, NULL);
		return;
	}
	ZeroMemory(cBuff, sizeof(cBuff));
	memcpy(cBuff, pData, dwMsgSize);
	pStrTok = new class CStrTok(cBuff, seps);
	token = pStrTok->pGet();
	token = pStrTok->pGet();
	if (token != NULL) {
		if (token[0] == '1') SetInvisibilityFlag(iClientH, DEF_OWNERTYPE_PLAYER, TRUE);
		else if (token[0] == '0') SetInvisibilityFlag(iClientH, DEF_OWNERTYPE_PLAYER, FALSE);		
		wsprintf(G_cTxt, "GM Order(%-10s): /setinvi", m_pClientList[iClientH]->m_cCharName);
		bSendMsgToLS(MSGID_GAMEMASTERLOG, iClientH, FALSE, G_cTxt);	
	}
	delete pStrTok;
}

BOOL CGame::bOnClose()
{
	if (m_bIsServerShutdowned == FALSE) 
		if (MessageBox(NULL, "Player data not saved! Shutdown server now?", m_cServerName, MB_ICONEXCLAMATION | MB_YESNO) == IDYES) return TRUE;
		else return FALSE;
	else return TRUE;
		
	return FALSE;
}

void CGame::AdminOrder_SetPkMode(int iClientH, char * pData, DWORD dwMsgSize)
{	// SNOOPY: Added this new command for GMs
	char   seps[] = "= \t\n";
	char   * token, cBuff[256]; 
	class  CStrTok * pStrTok;
	int    iPkMode;
	if (m_pClientList[iClientH] == NULL) return;
	if ((dwMsgSize)	<= 0) return;	
	if (m_pClientList[iClientH]->m_bIsAdminCommandEnabled == FALSE) return;
	if (m_pClientList[iClientH]->m_iAdminUserLevel < m_iAdminLevelSetPkMode) {
		// Admin user level
		SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_ADMINUSERLEVELLOW, NULL, NULL, NULL, NULL);
		return;
	}
	ZeroMemory(cBuff, sizeof(cBuff));
	memcpy(cBuff, pData, dwMsgSize);

	pStrTok = new class CStrTok(cBuff, seps);
	token = pStrTok->pGet();
	token = pStrTok->pGet();
	if (token == NULL) 
	{	delete pStrTok;
		return;
	}
	if (token != NULL) 
		 iPkMode = atoi(token);
	else iPkMode = 0;
	if ( iPkMode<= -5) iPkMode = 0;
	if ( iPkMode> 5) iPkMode = 0;
	// Set the PkMode for current map
	m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_iPKmode = iPkMode;

	delete pStrTok;
	// Log that!
	wsprintf(G_cTxt, "<%s> Set PK mode to %d (%s)", m_pClientList[iClientH]->m_cCharName, iPkMode ,m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cName);
	PutLogList(G_cTxt);

	// Say to GM
	char cInfoString[500];
	ZeroMemory(cInfoString, sizeof(cInfoString));
	switch (iPkMode) {
	case 0:wsprintf(cInfoString, "PK mode set 0, All EK and PK allowed.");
		break;
	case 1:wsprintf(cInfoString, "PK mode set 1, No PK but free EK.");
		break;
	case 2:wsprintf(cInfoString, "PK mode set 2, No PK no EK, but Executors can EK.");
		break;
	case 3:wsprintf(cInfoString, "PK mode set 3, No EK, no PK.");
		break;
	case 4:wsprintf(cInfoString, "PK mode set 4, Only Executors can be killed.");
		break;		
	case 5:wsprintf(cInfoString, "PK mode set 5, No EK but risk of PK !!!");
		break;
	case -1:wsprintf(cInfoString, "PK mode set -1, No PK but free EK.(crims concerned)");
		break;
	case -2:wsprintf(cInfoString, "PK mode set -2, No PK no EK, but Executors can EK.(crims concerned)");
		break;
	case -3:wsprintf(cInfoString, "PK mode set -3, No EK, no PK.(crims concerned)");
		break;
	case -4:wsprintf(cInfoString, "PK mode set -4, Only Executors can be killed.(crims concerned)");
		break;		
	case -5:wsprintf(cInfoString, "PK mode set -5, No EK but risk of PK !!!(crims concerned)");
		break;		
	}
	SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_IPACCOUNTINFO, NULL, NULL, NULL, cInfoString);
	// Admin Log
	wsprintf(G_cTxt, "Admin Order(%s): Set PK mode(%s)\tAdminIP(%s)"
		, m_pClientList[iClientH]->m_cCharName
		, cInfoString
		, m_pClientList[iClientH]->m_cIPaddress);
	PutAdminLogFileList(G_cTxt);
	PutLogEventFileList(G_cTxt);
	wsprintf(G_cTxt,"GM Order(%-10s): /setpkmode %d", m_pClientList[iClientH]->m_cCharName, iPkMode);
	bSendMsgToLS(MSGID_GAMEMASTERLOG, iClientH, FALSE, G_cTxt);	
}

void CGame::AdminOrder_SetMapType(int iClientH, char * pData, DWORD dwMsgSize)
{	// SNOOPY: Added this new command for GMs
	char   seps[] = "= \t\n";
	char   * token, cBuff[256]; 
	class  CStrTok * pStrTok;
	int    iMapType;
	if (m_pClientList[iClientH] == NULL) return;
	if ((dwMsgSize)	<= 0) return;
	if (m_pClientList[iClientH]->m_bIsAdminCommandEnabled == FALSE) return;
	if (m_pClientList[iClientH]->m_iAdminUserLevel < m_iAdminLevelSetMapType) {
		SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_ADMINUSERLEVELLOW, NULL, NULL, NULL, NULL);
		return;
	}
	ZeroMemory(cBuff, sizeof(cBuff));
	memcpy(cBuff, pData, dwMsgSize);
	pStrTok = new class CStrTok(cBuff, seps);
	token = pStrTok->pGet();
	token = pStrTok->pGet();
	if (token == NULL) {
		delete pStrTok;
		return;
	}
	if (token != NULL) 
		 iMapType = atoi(token);
	else iMapType = 0;
	if ( iMapType<= 0) iMapType = 0;
	if ( iMapType>= 4) iMapType = 0;
	// Set the map Type for current map
	m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cType = iMapType;
	delete pStrTok;	
	// Log that!
	wsprintf(G_cTxt, "<%s> Set Map Type to %d (%s)", m_pClientList[iClientH]->m_cCharName, iMapType, m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cName);
	PutLogList(G_cTxt);
	// Say to GM
	char cInfoString[500];
	ZeroMemory(cInfoString, sizeof(cInfoString));
	switch (iMapType) {
	case 0:wsprintf(cInfoString, "Map type 0, Standard.");
		break;
	case 1:wsprintf(cInfoString, "Map type 1, no Penalty, no Reward.");
		break;
	case 2:wsprintf(cInfoString, "Map type 2, no Player Drops.");
		break;
	case 3:wsprintf(cInfoString, "Map type 3, no Player Drops, no PK Penalty or Rewards.");
		break;		
	}
	SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_IPACCOUNTINFO, NULL, NULL, NULL, cInfoString);
	// Admin Log
	wsprintf(G_cTxt, "Admin Order(%s): Set map type(%s)\tAdminIP(%s)"
		, m_pClientList[iClientH]->m_cCharName
		, cInfoString
		, m_pClientList[iClientH]->m_cIPaddress);
	PutAdminLogFileList(G_cTxt);
	PutLogEventFileList(G_cTxt);
	wsprintf(G_cTxt,"GM Order(%-10s): /setmaptype %d", m_pClientList[iClientH]->m_cCharName, iMapType);
	bSendMsgToLS(MSGID_GAMEMASTERLOG, iClientH, FALSE, G_cTxt);	
}

void CGame::AdminOrder_DropType(int iClientH, char * pData, DWORD dwMsgSize)
{	// SNOOPY: Added this new command for GMs
	char   seps[] = "= \t\n";
	char   * token, cBuff[256]; 
	class  CStrTok * pStrTok;
	int    iDropType;
	if (m_pClientList[iClientH] == NULL) return;
	if ((dwMsgSize)	<= 0) return;
	if (m_pClientList[iClientH]->m_bIsAdminCommandEnabled == FALSE) return;
	if (m_pClientList[iClientH]->m_iAdminUserLevel < m_iAdminLevelSetMapType) {
		// Admin user level
		SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_ADMINUSERLEVELLOW, NULL, NULL, NULL, NULL);
		return;
	}
	ZeroMemory(cBuff, sizeof(cBuff));
	memcpy(cBuff, pData, dwMsgSize);
	pStrTok = new class CStrTok(cBuff, seps);
	token = pStrTok->pGet();
	token = pStrTok->pGet();
	if (token == NULL) 
	{	delete pStrTok;
		return;
	}
	if (token != NULL) 
		 iDropType = atoi(token);
	else iDropType = -666;
	if ( iDropType >= -1) 
	{	m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_iDropType = iDropType; 
		// Log that!
		wsprintf(G_cTxt, "<%s> Set Drop Type to %d (%s)", m_pClientList[iClientH]->m_cCharName, iDropType, m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cName);
		PutLogList(G_cTxt);
	}
	delete pStrTok;		
	// Inform GM
	char cInfoString[500];
	ZeroMemory(cInfoString, sizeof(cInfoString));
	switch (iDropType) {
	case -1:wsprintf(cInfoString, "Drop type -1, only food or potions.");
		break;
	case 0: wsprintf(cInfoString, "Drop type 0, no Player item Drops.");
		break;
	case 1: wsprintf(cInfoString, "Drop type 1, standard.");
		break;		
	}
	SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_IPACCOUNTINFO, NULL, NULL, NULL, cInfoString);
	// Admin Log
	wsprintf(G_cTxt, "Admin Order(%s): Set drop type(%s)\tAdminIP(%s)"
		, m_pClientList[iClientH]->m_cCharName
		, cInfoString
		, m_pClientList[iClientH]->m_cIPaddress);
	PutAdminLogFileList(G_cTxt);
	PutLogEventFileList(G_cTxt);
	wsprintf(G_cTxt,"GM Order(%-10s): /setdroptype %d", m_pClientList[iClientH]->m_cCharName, iDropType);
	bSendMsgToLS(MSGID_GAMEMASTERLOG, iClientH, FALSE, G_cTxt);	

}
void CGame::AdminOrder_SaveChar(int iClientH, char * pData, DWORD dwMsgSize)
{	DWORD dwTime;
	char cInfoString[500];
	dwTime = timeGetTime();
	// SNOOPY: Added this new command for GMs
	if (m_pClientList[iClientH] == NULL) return;
	if ((dwMsgSize)	<= 0) return;
	// Save char unless on Arenas...
	if ( m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_bIsFightZone == FALSE) 
	{	bSendMsgToLS(MSGID_REQUEST_SAVEPLAYERDATA, iClientH);
		m_pClientList[iClientH]->m_dwAutoSaveTime = dwTime;
		// Say to character
		ZeroMemory(cInfoString, sizeof(cInfoString));
		wsprintf(cInfoString, "%s, you character's data has been saved..."
			, m_pClientList[iClientH]->m_cCharName);
		SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_IPACCOUNTINFO, NULL, NULL, NULL, cInfoString);		
	}
}		

void CGame::AdminOrder_Test(int iClientH, char * pData, DWORD dwMsgSize)
{	char   seps[] = "= \t\n";
	char   * token, cBuff[256]; 
	class  CStrTok * pStrTok;
	int    iEffect;
	if (m_pClientList[iClientH] == NULL) return;
	if ((dwMsgSize)	<= 0) return;	
	if (m_pClientList[iClientH]->m_iAdminUserLevel < 4) {		// Admin user level
		SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_ADMINUSERLEVELLOW, NULL, NULL, NULL, NULL);
		return;
	}
	ZeroMemory(cBuff, sizeof(cBuff));
	memcpy(cBuff, pData, dwMsgSize);
	pStrTok = new class CStrTok(cBuff, seps);
	token = pStrTok->pGet();
	token = pStrTok->pGet();
	if (token == NULL) {
		delete pStrTok;
		return;
	}
	if (token != NULL) 
		 iEffect = atoi(token);
	else iEffect = 0;

	delete pStrTok;
	// m_sAppr4
	// 0x0001 GM	
	// 0x0002 Green	glow
	// 0x0003 Blue glow
	// 0x0004 Xelima red: 
	// 0x0008 Medusa Green: 
	// 0x000C Ice Bleue: 

DWORD dwTime;
	dwTime = timeGetTime();
	wsprintf(G_cTxt, "Test in progress!");
	switch(iEffect) {
	case 1: 
	// Confuse Language
		m_pClientList[iClientH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_CONFUSE ] = (char)1;
										
		bRegisterDelayEvent(DEF_DELAYEVENTTYPE_MAGICRELEASE, DEF_MAGICTYPE_CONFUSE, dwTime + (10*1000), 
				iClientH, DEF_OWNERTYPE_PLAYER, NULL, NULL, NULL, 1, NULL, NULL);
		SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_MAGICEFFECTON, DEF_MAGICTYPE_CONFUSE, 1, iClientH, NULL);
		break;
	case 2: 
	// Confuse
		m_pClientList[iClientH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_CONFUSE ] = (char)2;
										
		bRegisterDelayEvent(DEF_DELAYEVENTTYPE_MAGICRELEASE, DEF_MAGICTYPE_CONFUSE, dwTime + (10*1000), 
				iClientH, DEF_OWNERTYPE_PLAYER, NULL, NULL, NULL, 2, NULL, NULL);
		SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_MAGICEFFECTON, DEF_MAGICTYPE_CONFUSE, 2, iClientH, NULL);
		SetConfusionFlag(iClientH, DEF_OWNERTYPE_PLAYER, TRUE);	
			
		break;
	case 3: 
	// Illusion
		m_pClientList[iClientH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_CONFUSE ] = (char)3;
										
		bRegisterDelayEvent(DEF_DELAYEVENTTYPE_MAGICRELEASE, DEF_MAGICTYPE_CONFUSE, dwTime + (10*1000), 
				iClientH, DEF_OWNERTYPE_PLAYER, NULL, NULL, NULL, 3, NULL, NULL);
		SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_MAGICEFFECTON, DEF_MAGICTYPE_CONFUSE, 3, iClientH, NULL);
		
		break;
	case 4:  
	// Illusion mouvement
		m_pClientList[iClientH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_CONFUSE ] = (char)4;
										
		bRegisterDelayEvent(DEF_DELAYEVENTTYPE_MAGICRELEASE, DEF_MAGICTYPE_CONFUSE, dwTime + (10*1000), 
				iClientH, DEF_OWNERTYPE_PLAYER, NULL, NULL, NULL, 4, NULL, NULL);
		SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_MAGICEFFECTON, DEF_MAGICTYPE_CONFUSE, 4, iClientH, NULL);
		break;
	case 0: 
		m_pClientList[iClientH]->m_iStatus = m_pClientList[iClientH]->m_iStatus = 0x00000000;
		SendEventToNearClient_TypeA(iClientH, DEF_OWNERTYPE_PLAYER, MSGID_EVENT_MOTION, DEF_OBJECTNULLACTION, NULL, NULL, NULL);
		break;
	case 11: 
		m_pClientList[iClientH]->m_iStatus = m_pClientList[iClientH]->m_iStatus | 0x10000000;
		SendEventToNearClient_TypeA(iClientH, DEF_OWNERTYPE_PLAYER, MSGID_EVENT_MOTION, DEF_OBJECTNULLACTION, NULL, NULL, NULL);
		break;
	case 12: 
		m_pClientList[iClientH]->m_iStatus = m_pClientList[iClientH]->m_iStatus | 0x20000000;
		SendEventToNearClient_TypeA(iClientH, DEF_OWNERTYPE_PLAYER, MSGID_EVENT_MOTION, DEF_OBJECTNULLACTION, NULL, NULL, NULL);
		break;
	case 14: 
		m_pClientList[iClientH]->m_iStatus = m_pClientList[iClientH]->m_iStatus | 0x40000000;
		SendEventToNearClient_TypeA(iClientH, DEF_OWNERTYPE_PLAYER, MSGID_EVENT_MOTION, DEF_OBJECTNULLACTION, NULL, NULL, NULL);
		break;
	case 18: 
		m_pClientList[iClientH]->m_iStatus = m_pClientList[iClientH]->m_iStatus | 0x80000000;
		SendEventToNearClient_TypeA(iClientH, DEF_OWNERTYPE_PLAYER, MSGID_EVENT_MOTION, DEF_OBJECTNULLACTION, NULL, NULL, NULL);
		break;

	case 21: 
		m_pClientList[iClientH]->m_iStatus = m_pClientList[iClientH]->m_iStatus | 0x01000000;
		SendEventToNearClient_TypeA(iClientH, DEF_OWNERTYPE_PLAYER, MSGID_EVENT_MOTION, DEF_OBJECTNULLACTION, NULL, NULL, NULL);
		break;
	case 22: 
		m_pClientList[iClientH]->m_iStatus = m_pClientList[iClientH]->m_iStatus | 0x02000000;
		SendEventToNearClient_TypeA(iClientH, DEF_OWNERTYPE_PLAYER, MSGID_EVENT_MOTION, DEF_OBJECTNULLACTION, NULL, NULL, NULL);
		break;
	case 24: 
		m_pClientList[iClientH]->m_iStatus = m_pClientList[iClientH]->m_iStatus | 0x04000000;
		SendEventToNearClient_TypeA(iClientH, DEF_OWNERTYPE_PLAYER, MSGID_EVENT_MOTION, DEF_OBJECTNULLACTION, NULL, NULL, NULL);
		break;
	case 28: 
		m_pClientList[iClientH]->m_iStatus = m_pClientList[iClientH]->m_iStatus | 0x08000000;
		SendEventToNearClient_TypeA(iClientH, DEF_OWNERTYPE_PLAYER, MSGID_EVENT_MOTION, DEF_OBJECTNULLACTION, NULL, NULL, NULL);
		break;

	case 31: 
		m_pClientList[iClientH]->m_iStatus = m_pClientList[iClientH]->m_iStatus | 0x00100000;
		SendEventToNearClient_TypeA(iClientH, DEF_OWNERTYPE_PLAYER, MSGID_EVENT_MOTION, DEF_OBJECTNULLACTION, NULL, NULL, NULL);
		break;
	case 32: 
		m_pClientList[iClientH]->m_iStatus = m_pClientList[iClientH]->m_iStatus | 0x00200000;
		SendEventToNearClient_TypeA(iClientH, DEF_OWNERTYPE_PLAYER, MSGID_EVENT_MOTION, DEF_OBJECTNULLACTION, NULL, NULL, NULL);
		break;
	case 34: 
		m_pClientList[iClientH]->m_iStatus = m_pClientList[iClientH]->m_iStatus | 0x00400000;
		SendEventToNearClient_TypeA(iClientH, DEF_OWNERTYPE_PLAYER, MSGID_EVENT_MOTION, DEF_OBJECTNULLACTION, NULL, NULL, NULL);
		break;
	case 38: 
		m_pClientList[iClientH]->m_iStatus = m_pClientList[iClientH]->m_iStatus | 0x00800000;
		SendEventToNearClient_TypeA(iClientH, DEF_OWNERTYPE_PLAYER, MSGID_EVENT_MOTION, DEF_OBJECTNULLACTION, NULL, NULL, NULL);
		break;

	case 41: 
		m_pClientList[iClientH]->m_iStatus = m_pClientList[iClientH]->m_iStatus | 0x00010000;
		SendEventToNearClient_TypeA(iClientH, DEF_OWNERTYPE_PLAYER, MSGID_EVENT_MOTION, DEF_OBJECTNULLACTION, NULL, NULL, NULL);
		break;
	case 42: 
		m_pClientList[iClientH]->m_iStatus = m_pClientList[iClientH]->m_iStatus | 0x00020000;
		SendEventToNearClient_TypeA(iClientH, DEF_OWNERTYPE_PLAYER, MSGID_EVENT_MOTION, DEF_OBJECTNULLACTION, NULL, NULL, NULL);
		break;
	case 44: 
		m_pClientList[iClientH]->m_iStatus = m_pClientList[iClientH]->m_iStatus | 0x00040000;
		SendEventToNearClient_TypeA(iClientH, DEF_OWNERTYPE_PLAYER, MSGID_EVENT_MOTION, DEF_OBJECTNULLACTION, NULL, NULL, NULL);
		break;
	case 48: 
		m_pClientList[iClientH]->m_iStatus = m_pClientList[iClientH]->m_iStatus | 0x00080000;
		SendEventToNearClient_TypeA(iClientH, DEF_OWNERTYPE_PLAYER, MSGID_EVENT_MOTION, DEF_OBJECTNULLACTION, NULL, NULL, NULL);
		break;	

	case 51: 
		m_pClientList[iClientH]->m_iStatus = m_pClientList[iClientH]->m_iStatus | 0x00001000;
		SendEventToNearClient_TypeA(iClientH, DEF_OWNERTYPE_PLAYER, MSGID_EVENT_MOTION, DEF_OBJECTNULLACTION, NULL, NULL, NULL);
		break;
	case 52: 
		m_pClientList[iClientH]->m_iStatus = m_pClientList[iClientH]->m_iStatus | 0x00002000;
		SendEventToNearClient_TypeA(iClientH, DEF_OWNERTYPE_PLAYER, MSGID_EVENT_MOTION, DEF_OBJECTNULLACTION, NULL, NULL, NULL);
		break;
	case 54: 
		m_pClientList[iClientH]->m_iStatus = m_pClientList[iClientH]->m_iStatus | 0x00004000;
		SendEventToNearClient_TypeA(iClientH, DEF_OWNERTYPE_PLAYER, MSGID_EVENT_MOTION, DEF_OBJECTNULLACTION, NULL, NULL, NULL);
		break;
	case 58: 
		m_pClientList[iClientH]->m_iStatus = m_pClientList[iClientH]->m_iStatus | 0x00008000;
		SendEventToNearClient_TypeA(iClientH, DEF_OWNERTYPE_PLAYER, MSGID_EVENT_MOTION, DEF_OBJECTNULLACTION, NULL, NULL, NULL);
		break;	

	case 61: 
		m_pClientList[iClientH]->m_iStatus = m_pClientList[iClientH]->m_iStatus | 0x00000100;
		SendEventToNearClient_TypeA(iClientH, DEF_OWNERTYPE_PLAYER, MSGID_EVENT_MOTION, DEF_OBJECTNULLACTION, NULL, NULL, NULL);
		break;
	case 62: 
		m_pClientList[iClientH]->m_iStatus = m_pClientList[iClientH]->m_iStatus | 0x00000200;
		SendEventToNearClient_TypeA(iClientH, DEF_OWNERTYPE_PLAYER, MSGID_EVENT_MOTION, DEF_OBJECTNULLACTION, NULL, NULL, NULL);
		break;
	case 64: 
		m_pClientList[iClientH]->m_iStatus = m_pClientList[iClientH]->m_iStatus | 0x00000400;
		SendEventToNearClient_TypeA(iClientH, DEF_OWNERTYPE_PLAYER, MSGID_EVENT_MOTION, DEF_OBJECTNULLACTION, NULL, NULL, NULL);
		break;
	case 68: 
		m_pClientList[iClientH]->m_iStatus = m_pClientList[iClientH]->m_iStatus | 0x00000800;
		SendEventToNearClient_TypeA(iClientH, DEF_OWNERTYPE_PLAYER, MSGID_EVENT_MOTION, DEF_OBJECTNULLACTION, NULL, NULL, NULL);
		break;		

	case 71: 
		m_pClientList[iClientH]->m_iStatus = m_pClientList[iClientH]->m_iStatus | 0x00000010;
		SendEventToNearClient_TypeA(iClientH, DEF_OWNERTYPE_PLAYER, MSGID_EVENT_MOTION, DEF_OBJECTNULLACTION, NULL, NULL, NULL);
		break;
	case 72: 
		m_pClientList[iClientH]->m_iStatus = m_pClientList[iClientH]->m_iStatus | 0x00000020;
		SendEventToNearClient_TypeA(iClientH, DEF_OWNERTYPE_PLAYER, MSGID_EVENT_MOTION, DEF_OBJECTNULLACTION, NULL, NULL, NULL);
		break;
	case 74: 
		m_pClientList[iClientH]->m_iStatus = m_pClientList[iClientH]->m_iStatus | 0x00000040;
		SendEventToNearClient_TypeA(iClientH, DEF_OWNERTYPE_PLAYER, MSGID_EVENT_MOTION, DEF_OBJECTNULLACTION, NULL, NULL, NULL);
		break;
	case 78: 
		m_pClientList[iClientH]->m_iStatus = m_pClientList[iClientH]->m_iStatus | 0x00000080;
		SendEventToNearClient_TypeA(iClientH, DEF_OWNERTYPE_PLAYER, MSGID_EVENT_MOTION, DEF_OBJECTNULLACTION, NULL, NULL, NULL);
		break;	


	case 81: 
		m_pClientList[iClientH]->m_iStatus = m_pClientList[iClientH]->m_iStatus | 0x00000001;
		SendEventToNearClient_TypeA(iClientH, DEF_OWNERTYPE_PLAYER, MSGID_EVENT_MOTION, DEF_OBJECTNULLACTION, NULL, NULL, NULL);
		break;
	case 82: 
		m_pClientList[iClientH]->m_iStatus = m_pClientList[iClientH]->m_iStatus | 0x00000002;
		SendEventToNearClient_TypeA(iClientH, DEF_OWNERTYPE_PLAYER, MSGID_EVENT_MOTION, DEF_OBJECTNULLACTION, NULL, NULL, NULL);
		break;
	case 84: 
		m_pClientList[iClientH]->m_iStatus = m_pClientList[iClientH]->m_iStatus | 0x00000004;
		SendEventToNearClient_TypeA(iClientH, DEF_OWNERTYPE_PLAYER, MSGID_EVENT_MOTION, DEF_OBJECTNULLACTION, NULL, NULL, NULL);
		break;
	case 88: 
		m_pClientList[iClientH]->m_iStatus = m_pClientList[iClientH]->m_iStatus | 0x00000008;
		SendEventToNearClient_TypeA(iClientH, DEF_OWNERTYPE_PLAYER, MSGID_EVENT_MOTION, DEF_OBJECTNULLACTION, NULL, NULL, NULL);
		break;	

	case 666:		
		SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_0BE5, NULL, NULL, NULL, NULL);
		wsprintf(G_cTxt, "Test DEF_NOTIFY_0BE5 in progress!");
		break;	

	case 667:		
		SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_HELDENIANVICTORY,  0, NULL, NULL, NULL); 	
		wsprintf(G_cTxt, "Test DEF_NOTIFY_HELDENIANVICTORY in progress!");
		break;	
	case 668:		
		SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_HELDENIANVICTORY,  1, NULL, NULL, NULL); 	
		wsprintf(G_cTxt, "Test DEF_NOTIFY_HELDENIANVICTORY in progress!");	
		break;
	case 669:		
		SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_HELDENIANVICTORY,  2, NULL, NULL, NULL); 	
		wsprintf(G_cTxt, "Test DEF_NOTIFY_HELDENIANVICTORY in progress!");	
		break;

	case 247:
		SendEventToNearClient_TypeB(MSGID_EVENT_COMMON, DEF_COMMONTYPE_MAGIC, m_pClientList[iClientH]->m_cMapIndex
				, m_pClientList[iClientH]->m_sX, m_pClientList[iClientH]->m_sY
				, m_pClientList[iClientH]->m_sX, m_pClientList[iClientH]->m_sY
				, 247, m_pClientList[iClientH]->m_sType);
		wsprintf(G_cTxt, "Test ZzZz in progress!");	
		break;

	case 501: // Angels
		SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_SPECIALABILITYSTATUS, 5, 0, 0, NULL); // 5: Angel
		m_pClientList[iClientH]->m_iStatus = m_pClientList[iClientH]->m_iStatus | 0x00001000;
		SendEventToNearClient_TypeA(iClientH, DEF_OWNERTYPE_PLAYER, MSGID_EVENT_MOTION, DEF_OBJECTNULLACTION, NULL, NULL, NULL);
		wsprintf(G_cTxt, "Test Angel 1");	
		break;

	case 101:
		iAddDynamicObjectList(NULL, NULL, DEF_DYNAMICOBJECT_STATUE1
			, m_pClientList[iClientH]->m_cMapIndex
			, m_pClientList[iClientH]->m_sX, m_pClientList[iClientH]->m_sY + 2
			, NULL, 0);	
		wsprintf(G_cTxt, "Created Dragon Statue (1)");	
		break;

	case 102:
		iAddDynamicObjectList(NULL, NULL, DEF_DYNAMICOBJECT_STATUE2
			, m_pClientList[iClientH]->m_cMapIndex
			, m_pClientList[iClientH]->m_sX, m_pClientList[iClientH]->m_sY + 2
			, NULL, 0);	
		wsprintf(G_cTxt, "Created Centaur Statue (2)");	
		break;

	case 103:
		iAddDynamicObjectList(NULL, NULL, DEF_DYNAMICOBJECT_STATUE3
			, m_pClientList[iClientH]->m_cMapIndex
			, m_pClientList[iClientH]->m_sX, m_pClientList[iClientH]->m_sY + 2
			, NULL, 0);	
		wsprintf(G_cTxt, "Created Allien Statue (3)");	
		break;
		
	case 104:
		iAddDynamicObjectList(NULL, NULL, DEF_DYNAMICOBJECT_STATUE4
			, m_pClientList[iClientH]->m_cMapIndex
			, m_pClientList[iClientH]->m_sX, m_pClientList[iClientH]->m_sY + 2
			, NULL, 0);	
		wsprintf(G_cTxt, "Created Demon Statue (4)");	
		break;
		
	case 105:
		iAddDynamicObjectList(NULL, NULL, DEF_DYNAMICOBJECT_STATUE5
			, m_pClientList[iClientH]->m_cMapIndex
			, m_pClientList[iClientH]->m_sX, m_pClientList[iClientH]->m_sY + 2
			, NULL, 0);	
		wsprintf(G_cTxt, "Created Lady Statue (5)");	
		break;
		
	case 106:
		iAddDynamicObjectList(NULL, NULL, DEF_DYNAMICOBJECT_STATUE6
			, m_pClientList[iClientH]->m_cMapIndex
			, m_pClientList[iClientH]->m_sX, m_pClientList[iClientH]->m_sY + 2
			, NULL, 0);	
		wsprintf(G_cTxt, "Created Man Statue (6)");	
		break;
		
	case 107:
		iAddDynamicObjectList(NULL, NULL, DEF_DYNAMICOBJECT_STATUE7
			, m_pClientList[iClientH]->m_cMapIndex
			, m_pClientList[iClientH]->m_sX, m_pClientList[iClientH]->m_sY + 2
			, NULL, 0);	
		wsprintf(G_cTxt, "Created Kloness Statue (7)");	
		break;
	default: 
		m_pClientList[iClientH]->m_iStatus = m_pClientList[iClientH]->m_iStatus | 0x00000000;
		// m_pClientList[iClientH]->m_iStatus = m_pClientList[iClientH]->m_iStatus & 0xFEFFFFFF;
		SendEventToNearClient_TypeA(iClientH, DEF_OWNERTYPE_PLAYER, MSGID_EVENT_MOTION, DEF_OBJECTNULLACTION, NULL, NULL, NULL);

		break;
	}
	SendEventToNearClient_TypeA(iClientH, DEF_OWNERTYPE_PLAYER, MSGID_EVENT_MOTION, DEF_OBJECTNULLACTION, NULL, NULL, NULL);
	SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_IPACCOUNTINFO, NULL, NULL, NULL, G_cTxt);		

}

void CGame::AdminOrder_StartServer(int iClientH, char * pData, DWORD dwMsgSize)
{	// SNOOPY: Added this new command for GMs
	char	seps[] = "= \t\n";
	char	* token, cBuff[256];
	class	CStrTok * pStrTok;
	if (m_pClientList[iClientH] == NULL) return;
	if ((dwMsgSize)	<= 0) return;
	if (m_pClientList[iClientH]->m_bIsAdminCommandEnabled == FALSE) return;
	if (   (m_pClientList[iClientH]->m_iAdminUserLevel < m_iAdminLevelShutdown)
		&& (m_pClientList[iClientH]->m_bIsAdminStopStart == FALSE))
	{	SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_ADMINUSERLEVELLOW, NULL, NULL, NULL, NULL);
		return;
	}
	ZeroMemory(cBuff, sizeof(cBuff));
	memcpy(cBuff, pData, dwMsgSize);
	pStrTok = new class CStrTok(cBuff, seps);
	token = pStrTok->pGet();
	token = pStrTok->pGet();
	if (token == NULL) {
		delete pStrTok;
		return;
	}	
	char cPath[512];		// Copy of parsed line
	char * pPath;			// Pointer to this copy with \hgserver.exe added
	char cExeName[] = "\\hgserver.exe";
	ZeroMemory(cPath, sizeof(cPath));
	strcpy (cPath, token);
	pPath = lstrcat(cPath, cExeName);
	_chdir( token );
	PutLogList(token);	
	// Start serveur here
	int iSpawnlResult  = spawnle( _P_NOWAIT, pPath, pPath, NULL, NULL );
	if (iSpawnlResult == -1)
	{	char cErrorString[500];
		ZeroMemory(cErrorString, sizeof(cErrorString));
		switch (errno){
		case E2BIG:
			wsprintf(cErrorString, "Argument list exceeds 1024 bytes");
			break;
		case EINVAL:
			wsprintf(cErrorString, "Mode argument is invalid");
			break;
		case ENOENT:
			wsprintf(cErrorString, "File or path is not found");
			break;
		case ENOEXEC:
			wsprintf(cErrorString, "Specified file is not executable or has invalid executable-file format");
			break;
		case ENOMEM:
			wsprintf(cErrorString, "Not enough memory is available to execute new process");
			break;
		default :
			wsprintf(cErrorString, "Unknown error spawning new process");
			break;
		}
		SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_IPACCOUNTINFO, NULL, NULL, NULL, cErrorString);
		delete pStrTok;
		return;
	}		
	// Say to GM
	char cInfoString[500];
	ZeroMemory(cInfoString, sizeof(cInfoString));
	wsprintf(cInfoString, "<%s> Started a server: [%s]"
		, m_pClientList[iClientH]->m_cCharName
		, token);
	SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_IPACCOUNTINFO, NULL, NULL, NULL, cInfoString);
	PutLogList(cInfoString);
	// Admin Log
	wsprintf(G_cTxt, "Admin Order(%s): Start a server(%s)\tAdminIP(%s)"
		, m_pClientList[iClientH]->m_cCharName
		, token
		, m_pClientList[iClientH]->m_cIPaddress);
	PutAdminLogFileList(G_cTxt);
	ZeroMemory(m_cBugText, sizeof(m_cBugText));
	wsprintf(m_cBugText, "IMPORTANT NOTICE: A server was remotelly started by: %s"
		, m_pClientList[iClientH]->m_cCharName);
	m_iBugWarning = 1;
	wsprintf(G_cTxt,"GM Order(%-10s): /start %s", m_pClientList[iClientH]->m_cCharName, token);
	bSendMsgToLS(MSGID_GAMEMASTERLOG, iClientH, FALSE, G_cTxt);	
	delete pStrTok;
}
	
void CGame::AdminOrder_SetXPRate(int iClientH, char * pData, DWORD dwMsgSize)
{	// SNOOPY: Added this new command for GMs
	char	seps[] = "= \t\n";
	char	* token, cBuff[256];
	class	CStrTok * pStrTok;
	char cInfoString[500];
	int iXpRate;
	ZeroMemory(cInfoString,  sizeof(cInfoString));
	if (m_pClientList[iClientH] == NULL) return;
	if ((dwMsgSize)	<= 0) return;
	if (m_pClientList[iClientH]->m_iAdminUserLevel < m_iAdminLevelSpecialEvents)
	{	SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_ADMINUSERLEVELLOW, NULL, NULL, NULL, NULL);
		return;
	}
	char cMapIndex = m_pClientList[iClientH]->m_cMapIndex;
	ZeroMemory(cBuff, sizeof(cBuff));
	memcpy(cBuff, pData, dwMsgSize);
	pStrTok = new class CStrTok(cBuff, seps);
	token = pStrTok->pGet();
	token = pStrTok->pGet();
	if ((token == NULL) || (m_pClientList[iClientH]->m_bIsAdminCommandEnabled == FALSE))
	{	// say current XP rate
		wsprintf(cInfoString, "Current map XP rate: %d%%", m_pMapList[cMapIndex]->m_iXPRate);
		SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_IPACCOUNTINFO, NULL, NULL, NULL, cInfoString);
		delete pStrTok;
		return;
	}
	if (token != NULL) 
		 iXpRate = atoi(token);
	if (iXpRate < 1 ) iXpRate = 100;
	if (iXpRate > 1000 ) iXpRate = 100;
	m_pMapList[cMapIndex]->m_iXPRate = iXpRate;
	if (m_pMapList[cMapIndex]->m_iXPRate != 100)
	{	m_iHourllyXP250 = 250*10*m_pMapList[cMapIndex]->m_iXPRate;
		m_iHourllyXP300 = 300*10*m_pMapList[cMapIndex]->m_iXPRate;
		m_iHourllyXP400 = 400*10*m_pMapList[cMapIndex]->m_iXPRate;
		if (m_iHourllyXP250 < 50000) m_iHourllyXP250 = 50000;
		if (m_iHourllyXP300 < 60000) m_iHourllyXP300 = 60000;
		if (m_iHourllyXP400 < 80000) m_iHourllyXP400 = 80000;
	}
	wsprintf(cInfoString, "Current map XP rate set to: %d%%", iXpRate);
	SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_IPACCOUNTINFO, NULL, NULL, NULL, cInfoString);
	wsprintf(G_cTxt, "%s XP rate: PC(%s) - Set XP rate to %d%%"
		, m_pClientList[iClientH]->m_cMapName	
		, m_pClientList[iClientH]->m_cCharName
		, iXpRate);
	PutLogList(G_cTxt);
	PutAdminLogFileList(G_cTxt);	
	PutLogEventFileList(G_cTxt);
	PutHackLogFileList(G_cTxt); // To explain possible High XP deco.
	wsprintf(G_cTxt,"GM Order(%-10s): /setxprate %d", m_pClientList[iClientH]->m_cCharName, iXpRate);
	bSendMsgToLS(MSGID_GAMEMASTERLOG, iClientH, FALSE, G_cTxt);	
	delete pStrTok;	
}
void CGame::AdminOrder_SetExtraDrop(int iClientH, char * pData, DWORD dwMsgSize)
{	// SNOOPY: Added this new command for GMs
	char	seps[] = "= \t\n";
	char	* token, cBuff[256];
	class	CStrTok * pStrTok;
	char cInfoString[500];
	int iExtraDrop;
	ZeroMemory(cInfoString,  sizeof(cInfoString));
	if (m_pClientList[iClientH] == NULL) return;
	if ((dwMsgSize)	<= 0) return;
	if (m_pClientList[iClientH]->m_iAdminUserLevel < m_iAdminLevelSpecialEvents)
	{	SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_ADMINUSERLEVELLOW, NULL, NULL, NULL, NULL);
		return;
	}
	char cMapIndex = m_pClientList[iClientH]->m_cMapIndex;
	ZeroMemory(cBuff, sizeof(cBuff));
	memcpy(cBuff, pData, dwMsgSize);
	pStrTok = new class CStrTok(cBuff, seps);
	token = pStrTok->pGet();
	token = pStrTok->pGet();
	if ((token == NULL) || (m_pClientList[iClientH]->m_bIsAdminCommandEnabled == FALSE))
	{	// say current drop rate
		if (m_pMapList[cMapIndex]->m_iExtraDrop <=0)
			wsprintf(cInfoString, "Current map secondary drop rate: %d (standard)", m_iSecondaryDropRate);
		else
			wsprintf(cInfoString, "Current map secondary drop rate: %d", m_pMapList[cMapIndex]->m_iExtraDrop);
		SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_IPACCOUNTINFO, NULL, NULL, NULL, cInfoString);
		delete pStrTok;
		return;
	}
	if (token != NULL) 
	iExtraDrop	 = atoi(token);
	else iExtraDrop = 0;
	if (iExtraDrop < 0 ) iExtraDrop = 0;
	if (iExtraDrop > 10000 ) iExtraDrop = 10000;
	m_pMapList[cMapIndex]->m_iExtraDrop = iExtraDrop;
	if (iExtraDrop == 0)
	{	wsprintf(cInfoString, "Current map Extra secondary DropRate reset to default (%d)", m_iSecondaryDropRate);	
	}else 
		wsprintf(cInfoString, "Current map Extra secondary DropRate set to: %d", iExtraDrop);
	SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_IPACCOUNTINFO, NULL, NULL, NULL, cInfoString);
	wsprintf(G_cTxt, "%s Extra drop rate: PC(%s) - Set Extra drop rate to %d"
		, m_pClientList[iClientH]->m_cMapName	
		, m_pClientList[iClientH]->m_cCharName
		, iExtraDrop);
	PutLogList(G_cTxt);
	PutAdminLogFileList(G_cTxt);	
	PutLogEventFileList(G_cTxt);
	wsprintf(G_cTxt,"GM Order(%-10s): /setextradrop %d", m_pClientList[iClientH]->m_cCharName, iExtraDrop);
	bSendMsgToLS(MSGID_GAMEMASTERLOG, iClientH, FALSE, G_cTxt);	
	delete pStrTok;	
}
void CGame::AdminOrder_SetBossAdjust(int iClientH, char * pData, DWORD dwMsgSize)
{	// SNOOPY: Added this new command for GMs
	char	seps[] = "= \t\n";
	char	* token, cBuff[256];
	class	CStrTok * pStrTok;
	char cInfoString[500];
	int iBossAdjust;
	ZeroMemory(cInfoString,  sizeof(cInfoString));
	if (m_pClientList[iClientH] == NULL) return;
	if ((dwMsgSize)	<= 0) return;
	if (m_pClientList[iClientH]->m_iAdminUserLevel < m_iAdminLevelSpecialEvents)
	{	SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_ADMINUSERLEVELLOW, NULL, NULL, NULL, NULL);
		return;
	}
	char cMapIndex = m_pClientList[iClientH]->m_cMapIndex;
	ZeroMemory(cBuff, sizeof(cBuff));
	memcpy(cBuff, pData, dwMsgSize);
	pStrTok = new class CStrTok(cBuff, seps);
	token = pStrTok->pGet();
	token = pStrTok->pGet();
	if ((token == NULL) || (m_pClientList[iClientH]->m_bIsAdminCommandEnabled == FALSE))
	{	// say current drop rate
		if (m_pMapList[cMapIndex]->m_iBossAdjust == 100)
			wsprintf(cInfoString, "Current map boss-rate: 100%% (standard)");
		else
			wsprintf(cInfoString, "Current map boss-rate: %d%%", m_pMapList[cMapIndex]->m_iBossAdjust);
		SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_IPACCOUNTINFO, NULL, NULL, NULL, cInfoString);
		delete pStrTok;
		return;
	}
	if (token != NULL) 
		iBossAdjust = atoi(token);
	else iBossAdjust = 100;
	if (iBossAdjust < 1 ) iBossAdjust = 100;
	if (iBossAdjust > 2000 ) iBossAdjust = 2000;
	m_pMapList[cMapIndex]->m_iBossAdjust = iBossAdjust;
	wsprintf(cInfoString, "Current map boss-rate set to: %d%%", iBossAdjust);
	SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_IPACCOUNTINFO, NULL, NULL, NULL, cInfoString);
	wsprintf(G_cTxt, "%s boss-rate: PC(%s) - Set boss-rate to %d"
		, m_pClientList[iClientH]->m_cMapName	
		, m_pClientList[iClientH]->m_cCharName
		, iBossAdjust);
	PutLogList(G_cTxt);
	PutAdminLogFileList(G_cTxt);	
	PutLogEventFileList(G_cTxt);
	wsprintf(G_cTxt,"GM Order(%-10s): /setbossrate %d", m_pClientList[iClientH]->m_cCharName, iBossAdjust);
	bSendMsgToLS(MSGID_GAMEMASTERLOG, iClientH, FALSE, G_cTxt);	
	delete pStrTok;	
}
void CGame::AdminOrder_MonitorPlayer(int iClientH, char * pData, DWORD dwMsgSize)
{	// By Snoopy: Monitor this character for a while....	
	if ((dwMsgSize)	<= 0) return;
	char   seps[] = "= \t\n";
	char   * token, cBuff[256], cName[11]; 
	int i;
	class  CStrTok * pStrTok;
	if (m_pClientList[iClientH] == NULL) return;
	if (m_pClientList[iClientH]->m_iAdminUserLevel < m_iAdminLevelSummonPlayer) {
		SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_ADMINUSERLEVELLOW, NULL, NULL, NULL, NULL);
		return;
	}
	char cInfoString[500];
	ZeroMemory(cInfoString,  sizeof(cInfoString));
	ZeroMemory(cBuff, sizeof(cBuff));
	ZeroMemory(cName, sizeof(cName));
	memcpy(cBuff, pData, dwMsgSize);
	pStrTok = new class CStrTok(cBuff, seps);
	token = pStrTok->pGet();
	token = pStrTok->pGet();
	if (token == NULL) 
	{	for (i = 0; i < DEF_MAXCLIENTS; i++)
		{	if (m_pClientList[i] != NULL)
			{	m_pClientList[i]->m_bMonitorThisChar = FALSE;
			}
		}
		wsprintf(G_cTxt, "Monitoring end:    All monitoring terminated.");
		wsprintf(cInfoString, "All monitoring finished.", cName);
		PutMonitorLogFileList(G_cTxt);
		SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_IPACCOUNTINFO, NULL, NULL, NULL, cInfoString);
		wsprintf(G_cTxt, "GM Order(%-10s): /monitor (all terminated)", m_pClientList[iClientH]->m_cCharName);
		bSendMsgToLS(MSGID_GAMEMASTERLOG, iClientH, FALSE, G_cTxt);	
		delete pStrTok;
		return;
	}
	if (strlen(token) > 10)
		memcpy(cName, token, 10);
	else memcpy(cName, token, strlen(token));
	for (i = 0; i < DEF_MAXCLIENTS; i++)
	{	if ((m_pClientList[i] != NULL) && (memcmp(m_pClientList[i]->m_cCharName, cName, 10) == 0)) 
		{	if (m_pClientList[i]->m_bMonitorThisChar != TRUE)
			{	wsprintf(G_cTxt, "GM Order(%-10s): /monitor (start)", m_pClientList[iClientH]->m_cCharName);
				bSendMsgToLS(MSGID_GAMEMASTERLOG, iClientH, FALSE, G_cTxt);	
				m_pClientList[i]->m_bMonitorThisChar = TRUE;
				wsprintf(G_cTxt, "Monitoring start:  PC(%s) \tIP(%s)"				
					, cName
					, m_pClientList[i]->m_cIPaddress);
				wsprintf(cInfoString, "Monitoring %s until he leaves this server.", cName);
			}else
			{	wsprintf(G_cTxt, "GM Order(%-10s): /monitor (finished)", m_pClientList[iClientH]->m_cCharName);
				bSendMsgToLS(MSGID_GAMEMASTERLOG, iClientH, FALSE, G_cTxt);	
				m_pClientList[i]->m_bMonitorThisChar = FALSE;
				wsprintf(G_cTxt, "Monitoring end:    PC(%s) \tIP(%s)"				
					, cName
					, m_pClientList[i]->m_cIPaddress);
				wsprintf(cInfoString, "Monitoring %s finished.", cName);
			}
			PutMonitorLogFileList(G_cTxt);
			SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_IPACCOUNTINFO, NULL, NULL, NULL, cInfoString);
			delete pStrTok;
			return;						
		}
	}
	delete pStrTok;		
}
	
void CGame::AdminOrder_GetMapInfo(int iClientH, char * pData, DWORD dwMsgSize)
{	if (m_pClientList[iClientH] == NULL) return;	
	// SNOOPY: Added this new command for GMs	
	bool   FullInfo = true;
	// Search infos
	int iMapType   = m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cType;
	int iPkMode    = m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_iPKmode;
	int iMapMobNum = m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_iMaximumObject;
	int iDropType  = m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_iDropType; 
	int iXPRate    = m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_iXPRate;
	if ((dwMsgSize)	<= 0) return;		
	// This command can be used by non-GM with lower information.
	if (m_pClientList[iClientH]->m_iAdminUserLevel < m_iAdminLevelGetServerInfo) {
		FullInfo = false;
	}
	if (m_pClientList[iClientH]->m_iAdminUserLevel < 1) // Admin user level
	{	FullInfo = false;
	}
	// Prepare String
	char cInfoString2[500];
	char cInfoString[500];
	char * p_CharResult;
	ZeroMemory(cInfoString2, sizeof(cInfoString2));
	ZeroMemory(cInfoString,  sizeof(cInfoString));
	if (FullInfo) 
	{	// 1st line: Serveur MODEs
		if (m_bMapModeEquilibrium) {
			wsprintf(cInfoString, "Map mode = EQUILIBRIUM       ");
		}else {
			wsprintf(cInfoString, "Map mode = CLASSIC           ");
		}
		if (m_bPVPHPMode) {
			wsprintf(cInfoString2, "PVP HP mode = HIGH");
		}else {
			wsprintf(cInfoString2, "PVP HP mode = LOW ");
		}
		p_CharResult = lstrcat(cInfoString, cInfoString2);
		ZeroMemory(cInfoString2, sizeof(cInfoString2));		
		wsprintf(cInfoString2, "  XP rate: %d%%",iXPRate);
		p_CharResult = lstrcat(cInfoString, cInfoString2);
		SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_IPACCOUNTINFO, NULL, NULL, NULL, cInfoString);
		ZeroMemory(cInfoString, sizeof(cInfoString));
		// 2nd line PK mode
		switch (iPkMode) {
		case 0:wsprintf(cInfoString, "PK mode set 0, All EK and PK allowed.");
			break;
		case 1:wsprintf(cInfoString, "PK mode set 1, No PK but free EK.");
			break;
		case 2:wsprintf(cInfoString, "PK mode set 2, No PK or EK, but Executor can EK.");
			break;
		case 3:wsprintf(cInfoString, "PK mode set 3, No EK, no PK.");
			break;
		case 4:wsprintf(cInfoString, "PK mode set 4, Only Executor can be Killed.");
			break;		
		case 5:wsprintf(cInfoString, "PK mode set 5, No EK but risk of PK !!!");
			break;
		case -1:wsprintf(cInfoString, "PK mode set -1, No PK but free EK.(crims concerned)");
			break;
		case -2:wsprintf(cInfoString, "PK mode set -2, No PK or EK, but Executor can EK.(crims concerned)");
			break;
		case -3:wsprintf(cInfoString, "PK mode set -3, No EK, no PK.(crims concerned)");
			break;
		case -4:wsprintf(cInfoString, "PK mode set -4, Only Executor can be Killed.(crims concerned)");
			break;		
		case -5:wsprintf(cInfoString, "PK mode set -5, No EK but risk of PK !!!(crims concerned)");
			break;		
		}	
		SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_IPACCOUNTINFO, NULL, NULL, NULL, cInfoString);		
		// 3rd line Map type (Drops XP, EK points)
		ZeroMemory(cInfoString,  sizeof(cInfoString));			
		switch (iMapType) {
		case 0:wsprintf(cInfoString, "Map type 0, Standard. (Max Mobs: %d)",iMapMobNum);
			break;
		case 1:wsprintf(cInfoString, "Map type 1, no Penalty, no Reward. (Max Mobs: %d)",iMapMobNum);
			break;
		case 2:wsprintf(cInfoString, "Map type 2, no Player Drops. (Max Mobs: %d)",iMapMobNum);
			break;
		case 3:wsprintf(cInfoString, "Map type 3, no Player Drops, no PK Penalty or Rewards. (Max Mobs: %d)",iMapMobNum);
			break;		
		}
		SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_IPACCOUNTINFO, NULL, NULL, NULL, cInfoString);
		//4th line 
		ZeroMemory(cInfoString, sizeof(cInfoString));
		switch (iDropType) {
		case -1:wsprintf(cInfoString, "Drop type -1, only food or potions.");
			break;
		case 0: wsprintf(cInfoString, "Drop type 0, no Player item Drops.");
			break;
		case 1: wsprintf(cInfoString, "Drop type 1, standard.");
			break;		
		}
		SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_IPACCOUNTINFO, NULL, NULL, NULL, cInfoString);
		//5th line 
		ZeroMemory(cInfoString,  sizeof(cInfoString));
		wsprintf(cInfoString, "EnemyKill adjust: <%d>, Drop rates: 1:<%d%%> G:<%d%%> 2:<%d%%>, Rep-Drop modifier: <x%d>",
			m_iEnemyKillAdjust,	(10000-m_iPrimaryDropRate)/100, m_iGoldDropRate/100, (10000-m_iSecondaryDropRate)/100,  m_cRepDropModifier);
		SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_IPACCOUNTINFO, NULL, NULL, NULL, cInfoString);
		wsprintf(G_cTxt,"GM Order(%-10s): /readmapinfo", m_pClientList[iClientH]->m_cCharName);
		bSendMsgToLS(MSGID_GAMEMASTERLOG, iClientH, FALSE, G_cTxt);	
	}else  // Limited non GM info
	{	switch (iMapType) {
		case 0:wsprintf(cInfoString, "Be cautious, ");
			break;
		case 1:wsprintf(cInfoString, "Free duelling map, ");
			break;
		case 2:wsprintf(cInfoString, "Don't fear for your riches, ");
			break;
		case 3:wsprintf(cInfoString, "Don't fear, ");
			break;
		}
			switch (iPkMode) {
		case 0:wsprintf(cInfoString2, "beware for friend and enemy alike!");
			break;
		case 1:wsprintf(cInfoString2, "many enemies lurk around!");
			break;
		case 2:wsprintf(cInfoString2, "Abaddon's forces can hunt you!");
			break;
		case 3:wsprintf(cInfoString2, "but danger is never human.");
			break;
		case 4:wsprintf(cInfoString2, "take care for your friends!");
			break;
		case -1:wsprintf(cInfoString2, "many enemies lurk around!");
			break;
		case -2:wsprintf(cInfoString2, "Abaddon's forces can hunt you!");
			break;
		case -3:wsprintf(cInfoString2, "but danger is never human.");
			break;
		case -4:wsprintf(cInfoString2, "take care for your friends!");
			break;	
		case -5:
		case 5: wsprintf(cInfoString2, "strange things happen!");
		}
		p_CharResult = lstrcat(cInfoString, cInfoString2);
		SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_IPACCOUNTINFO, NULL, NULL, NULL, cInfoString);
	}
}

void CGame::AdminOrder_GetGizonInfo(int iClientH, char * pData, DWORD dwMsgSize)
{	if (m_pClientList[iClientH] == NULL) return;
	int i_CurrentXP, i_CurrentLevelXP, i_GizonXP;
	i_CurrentXP = m_pClientList[iClientH]->m_iExp;
	i_CurrentLevelXP = m_iLevelExpTable[m_iPlayerMaxLevel];
	i_GizonXP = m_iLevelExpTable[m_iPlayerMaxLevel + 1];
	float f1 = i_CurrentXP - i_CurrentLevelXP;
	float f2 = i_GizonXP - i_CurrentLevelXP;
	float f3 = (f1*100) / f2;
	int   i3 = (int)f3;
	char cInfoString[500];
	ZeroMemory(cInfoString,  sizeof(cInfoString));
	if(m_pClientList[iClientH]->m_iLevel < m_iPlayerMaxLevel)
	{	wsprintf(cInfoString, "%s, you are too low level for Gizon points."
			, m_pClientList[iClientH]->m_cCharName);
	}else
	{	if (m_pClientList[iClientH]->m_iGizonItemUpgradeLeft <1) {
			wsprintf(cInfoString, "%s, you currentlly have no Gizon points. ( %d %% from next gizon )"
				, m_pClientList[iClientH]->m_cCharName
				, i3);
		} else// Prepare String
		{	wsprintf(cInfoString, "%s, you currentlly have %d Gizon points. ( %d %% from next gizon )"
				, m_pClientList[iClientH]->m_cCharName
				, m_pClientList[iClientH]->m_iGizonItemUpgradeLeft 
				, i3 );
		}
		if (m_pClientList[iClientH]->m_cSide == 4)
		{	wsprintf(cInfoString, "%s, you currentlly have no Gizon points. ( Executor cannot have Gizons )"
					, m_pClientList[iClientH]->m_cCharName);	
	}	}
	//ShowClientMsg(iClientH,  "Gizons", cInfoString);
	SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_IPACCOUNTINFO, NULL, NULL, NULL, cInfoString);
	ZeroMemory(cInfoString, sizeof(cInfoString));
}

void CGame::AdminOrder_MapMobNum(int iClientH, char * pData, DWORD dwMsgSize)
{	// SNOOPY: Added this new command for GMs
	char   seps[] = "= \t\n";
	char   * token, cBuff[256]; 
	class  CStrTok * pStrTok;
	int    iMapIndex, iMapMobNum;
	if (m_pClientList[iClientH] == NULL) return;
	if ((dwMsgSize)	<= 0) return;
	iMapIndex = m_pClientList[iClientH]->m_cMapIndex;
	if (iMapIndex < 0) return;
	if (m_pClientList[iClientH]->m_bIsAdminCommandEnabled == FALSE) return;
	if (m_pClientList[iClientH]->m_iAdminUserLevel < m_iAdminLevelMapMobNum) {
		SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_ADMINUSERLEVELLOW, NULL, NULL, NULL, NULL);
		return;
	}
	ZeroMemory(cBuff, sizeof(cBuff));
	memcpy(cBuff, pData, dwMsgSize);
	pStrTok = new class CStrTok(cBuff, seps);
	token = pStrTok->pGet();
	token = pStrTok->pGet();
	if (token == NULL) {
		delete pStrTok;
		return;
	}
	if (token != NULL) 
		 iMapMobNum = atoi(token);
	else iMapMobNum = 0;
	if ( iMapMobNum  <   0 ) iMapMobNum = m_pMapList[iMapIndex]->m_iMaximumObjectDefault;
	if ( iMapMobNum >= 999 ) iMapMobNum = 999;
	// Set the map Type for current map
	if ( m_pMapList[iMapIndex] != NULL) 
		m_pMapList[iMapIndex]->m_iMaximumObject = iMapMobNum;
	delete pStrTok;	
	// Admin  & normal Log
	wsprintf(G_cTxt, "Admin Order(%s): Set map mob number to %d (default = %d)\tAdminIP(%s)"
		, m_pClientList[iClientH]->m_cCharName
		, iMapMobNum
		, m_pMapList[iMapIndex]->m_iMaximumObjectDefault
		, m_pClientList[iClientH]->m_cIPaddress);
	PutAdminLogFileList(G_cTxt);
	PutLogEventFileList(G_cTxt);
	wsprintf(G_cTxt,"GM Order(%-10s): /setmapmobnum %d", m_pClientList[iClientH]->m_cCharName, iMapMobNum);
	bSendMsgToLS(MSGID_GAMEMASTERLOG, iClientH, FALSE, G_cTxt);	
	// Say to GM
	char cInfoString[200];
	ZeroMemory(cInfoString, sizeof(cInfoString));
	wsprintf(cInfoString, "Set Map mob number to %d (default = %d)",iMapMobNum, m_pMapList[iMapIndex]->m_iMaximumObjectDefault);
	SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_IPACCOUNTINFO, NULL, NULL, NULL, cInfoString);
}

void CGame::AdminOrder_PopoEnabled(int iClientH, char * pData, DWORD dwMsgSize)
{	// SNOOPY: Added this new command for GMs
	char   seps[] = "= \t\n";
	char   * token, cBuff[256]; 
	class  CStrTok * pStrTok;
	int    iMapIndex, iEnabled;
	if (m_pClientList[iClientH] == NULL) return;
	if ((dwMsgSize)	<= 0) return;
	iMapIndex = m_pClientList[iClientH]->m_cMapIndex;
	if (iMapIndex < 0) return;
	if (m_pClientList[iClientH]->m_bIsAdminCommandEnabled == FALSE) return;
	if (m_pClientList[iClientH]->m_iAdminUserLevel < m_iAdminLevelPopoEnabled) {
		SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_ADMINUSERLEVELLOW, NULL, NULL, NULL, NULL);
		return;
	}
	ZeroMemory(cBuff, sizeof(cBuff));
	memcpy(cBuff, pData, dwMsgSize);
	pStrTok = new class CStrTok(cBuff, seps);
	token = pStrTok->pGet();
	token = pStrTok->pGet();
	if (token == NULL) {
		delete pStrTok;
		return;
	}
	if (token != NULL) 
		 iEnabled = atoi(token);
	else iEnabled = 0;
	delete pStrTok;
	if ( iEnabled != 0 ) m_pMapList[iMapIndex]->m_bHpMpSpPopoEnabled = TRUE; 
	else m_pMapList[iMapIndex]->m_bHpMpSpPopoEnabled = FALSE;
	// Admin  & normal Log
	// Say to GM
	char cInfoString[200];
	ZeroMemory(cInfoString, sizeof(cInfoString));
	if (iEnabled)
	{	wsprintf(G_cTxt, "Admin Order(%s): Allowed HP MP SP potion usage\tAdminIP(%s)"
			, m_pClientList[iClientH]->m_cCharName
			, m_pClientList[iClientH]->m_cIPaddress);
		wsprintf(cInfoString, "Allowed HP MP SP potion usage.");	
	}else
	{	wsprintf(G_cTxt, "Admin Order(%s): Fordidden HP MP SP potion usage\tAdminIP(%s)"
			, m_pClientList[iClientH]->m_cCharName
			, m_pClientList[iClientH]->m_cIPaddress);
		wsprintf(cInfoString, "Forbidden HP MP SP potion usage.");
	}
	PutAdminLogFileList(G_cTxt);
	PutLogEventFileList(G_cTxt);
	SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_IPACCOUNTINFO, NULL, NULL, NULL, cInfoString);	
	wsprintf(G_cTxt,"GM Order(%-10s): /popoenabled", m_pClientList[iClientH]->m_cCharName);
	bSendMsgToLS(MSGID_GAMEMASTERLOG, iClientH, FALSE, G_cTxt);	
}
void CGame::AdminOrder_GetGizonLevel(int iClientH, char * pData, DWORD dwMsgSize)
{	if (m_pClientList[iClientH] == NULL) return;
	if (m_pClientList[iClientH]->m_cSide == 4)// No Gizons for Executors
	{	return;
	}else
	{	if (m_pClientList[iClientH]->m_iLevel >= m_sAbsoluteMaxPlayerLevel) // Not Possible if over Max Possible Gizon level
		{	return;
		}
		if (m_pClientList[iClientH]->m_iLevel < m_iPlayerMaxLevel)  // Not possible if lower than max level
		{	return;
		}
	}
	int i_NeededGizons;
	i_NeededGizons = 4+ (4 * (m_pClientList[iClientH]->m_iLevel - m_iPlayerMaxLevel));
	// lvl 151 needs 4 gizons
	// lvl 152 needs 8 gizons
	// lvl 153 needs 12 gizons
	if ( m_pClientList[iClientH]->m_iGizonItemUpgradeLeft >= i_NeededGizons ) 
	{	// remove gizons and up level
		m_pClientList[iClientH]->m_iGizonItemUpgradeLeft -= i_NeededGizons;
		m_pClientList[iClientH]->m_iLevel++;
		m_pClientList[iClientH]->m_iLU_Pool += 3;		
		// Always Keep lvl 151 XP for next level
		m_pClientList[iClientH]->m_iNextLevelExp = m_iLevelExpTable[m_iPlayerMaxLevel+1];
		SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_GIZONITEMUPGRADELEFT, m_pClientList[iClientH]->m_iGizonItemUpgradeLeft, NULL, NULL, NULL);
		SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_LEVELUP, NULL, NULL, NULL, NULL);
		CalcTotalItemEffect(iClientH, -1, FALSE);
		wsprintf(G_cTxt, "(!) Gizon level up: %s used %d gizon for level %d. Reamaining gizons: %d"
			, m_pClientList[iClientH]->m_cCharName
			, i_NeededGizons
			, m_pClientList[iClientH]->m_iLevel
			, m_pClientList[iClientH]->m_iGizonItemUpgradeLeft);
		PutLogList(G_cTxt);		
		PutLogFileList(G_cTxt);		
	}  
}
void CGame::AdminOrder_SetZerk(int iClientH, char *pData, DWORD dwMsgSize)
{	char   seps[] = "= \t\n";
	char   * token, cBuff[256]; 
	class  CStrTok * pStrTok;
	if (m_pClientList[iClientH] == NULL) return;
	if ((dwMsgSize)	<= 0) return;
	if (m_pClientList[iClientH]->m_iAdminUserLevel < m_iAdminLevelSetZerk) {
		SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_ADMINUSERLEVELLOW, NULL, NULL, NULL, NULL);
		return;
	}
	ZeroMemory(cBuff, sizeof(cBuff));
	memcpy(cBuff, pData, dwMsgSize);
	pStrTok = new class CStrTok(cBuff, seps);
	token = pStrTok->pGet();
	token = pStrTok->pGet();
	if (token != NULL) 
	{	if (token[0] == '1')		
		{	SetBerserkFlag(iClientH, DEF_OWNERTYPE_PLAYER, TRUE);
			m_pClientList[iClientH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_BERSERK ] = (char)m_pMagicConfigList[32]->m_sValue4;
		}else if (token[0] == '0') SetBerserkFlag(iClientH, DEF_OWNERTYPE_PLAYER, FALSE);	
		wsprintf(G_cTxt, "GM Order(%-10s): /setzerk (done)", m_pClientList[iClientH]->m_cCharName);
		bSendMsgToLS(MSGID_GAMEMASTERLOG, iClientH, FALSE, G_cTxt);	
	}
	delete pStrTok;
}

void CGame::AdminOrder_SetFreeze(int iClientH, char *pData, DWORD dwMsgSize)
{	char   seps[] = "= \t\n";
	char   * token, cBuff[256]; 
	class  CStrTok * pStrTok;
	if (m_pClientList[iClientH] == NULL) return;
	if ((dwMsgSize)	<= 0) return;
	if (m_pClientList[iClientH]->m_iAdminUserLevel < m_iAdminLevelSetIce) {
		SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_ADMINUSERLEVELLOW, NULL, NULL, NULL, NULL);
		return;
	}
	ZeroMemory(cBuff, sizeof(cBuff));
	memcpy(cBuff, pData, dwMsgSize);
	pStrTok = new class CStrTok(cBuff, seps);
	token = pStrTok->pGet();
	token = pStrTok->pGet();
	if (token != NULL) 
	{	if (token[0] == '1') SetIceFlag(iClientH, DEF_OWNERTYPE_PLAYER, TRUE);
		else if (token[0] == '0') SetIceFlag(iClientH, DEF_OWNERTYPE_PLAYER, FALSE);		
		wsprintf(G_cTxt, "GM Order(%-10s): /setfreeze (done)", m_pClientList[iClientH]->m_cCharName);
		bSendMsgToLS(MSGID_GAMEMASTERLOG, iClientH, FALSE, G_cTxt);	
	}
	delete pStrTok;
}

// 05/24/2004 - Hypnotoad - Hammer and Wand train to 100% fixed
void CGame::_CheckAttackType(int iClientH, short *spType)
{	WORD wType;
	if (m_pClientList[iClientH] == NULL) return;
	wType = ((m_pClientList[iClientH]->m_sAppr2 & 0x0FF0) >> 4);
	switch (*spType) {
	case 2:	// ArrowAttack 	sent	
		if (m_pClientList[iClientH]->m_cArrowIndex == -1) *spType = 0;
		if (wType < 40) *spType = 1;
		break;
	case 20:
		if (m_pClientList[iClientH]->m_iSuperAttackLeft <= 0)  *spType = 1;
		if (m_pClientList[iClientH]->m_cSkillMastery[5] < 100) *spType = 1;
		break;
	case 21: 
		if (m_pClientList[iClientH]->m_iSuperAttackLeft <= 0)  *spType = 1;
		if (m_pClientList[iClientH]->m_cSkillMastery[7] < 100) *spType = 1;
		break;
	case 22: 
		if (m_pClientList[iClientH]->m_iSuperAttackLeft <= 0)  *spType = 1;
		if (m_pClientList[iClientH]->m_cSkillMastery[9] < 100) *spType = 1;
		break;
	case 23: 
		if (m_pClientList[iClientH]->m_iSuperAttackLeft <= 0)   *spType = 1;
		if (m_pClientList[iClientH]->m_cSkillMastery[8] < 100)  *spType = 1;
		break;
	case 24: 
		if (m_pClientList[iClientH]->m_iSuperAttackLeft <= 0)   *spType = 1;
		if (m_pClientList[iClientH]->m_cSkillMastery[10] < 100) *spType = 1;
		break;
	case 25: //arrow critical attack sent
		if (m_pClientList[iClientH]->m_iSuperAttackLeft <= 0)  *spType = 2;
		if (m_pClientList[iClientH]->m_cSkillMastery[6] < 100) *spType = 2;
		if (m_pClientList[iClientH]->m_cArrowIndex == -1)      *spType = 0;
		if (wType < 40) *spType = 1;
		break;
	case 26: 
		if (m_pClientList[iClientH]->m_iSuperAttackLeft <= 0)   *spType = 1;
		if (m_pClientList[iClientH]->m_cSkillMastery[14] < 100) *spType = 1;
		break;
	case 27: 
		if (m_pClientList[iClientH]->m_iSuperAttackLeft <= 0)   *spType = 1;
		if (m_pClientList[iClientH]->m_cSkillMastery[21] < 100) *spType = 1;
		break;
	}
}

void CGame::ReqCreatePortionHandler(int iClientH, char *pData)
{
 DWORD * dwp;
 WORD  * wp;
 char  * cp, cI[6], cPortionName[21], cData[120];
 int    iRet, i, j, iEraseReq, iSkillLimit, iSkillLevel, iResult, iDifficulty;
 short * sp, sItemIndex[6], sTemp;
 short  sItemNumber[6], sItemArray[12];
 BOOL   bDup, bFlag;
 class  CItem * pItem;
 // SNOOPY
 int i_Purity;
	if (m_pClientList[iClientH] == NULL) return;
	m_pClientList[iClientH]->m_iSkillMsgRecvCount++;
	for (i = 0; i < 6; i++) 
	{	cI[i] = -1;
		sItemIndex[i]  = -1;
		sItemNumber[i] = 0;
	}

	cp = (char *)(pData + 11);
	cI[0] = *cp;
	cp++;
	cI[1] = *cp;
	cp++;
	cI[2] = *cp;
	cp++;
	cI[3] = *cp;
	cp++;
	cI[4] = *cp;
	cp++;
	cI[5] = *cp;
	cp++;

	for (i = 0; i < 6; i++) 
	{	if (cI[i] >= DEF_MAXITEMS) return;
		if ((cI[i] >= 0) && (m_pClientList[iClientH]->m_pItemList[cI[i]] == NULL)) return;
	}

	for (i = 0; i < 6; i++)
	if (cI[i] >= 0) 
	{	bDup = FALSE;
		for (j = 0; j < 6; j++) 
		if (sItemIndex[j] == cI[i]) 
		{	sItemNumber[j]++;
			bDup = TRUE;
		}
		if (bDup == FALSE) 
		{	for (j = 0; j < 6; j++) 
			if (sItemIndex[j] == -1) 
			{	sItemIndex[j] = cI[i];
				sItemNumber[j]++;
				goto RCPH_LOOPBREAK;
			}
RCPH_LOOPBREAK:;	
	}	}
	
	for (i = 0; i < 6; i++) 
	if (sItemIndex[i] != -1) 
	{	if (sItemIndex[i] < 0) return;
		if ((sItemIndex[i] >= 0) && (sItemIndex[i] >= DEF_MAXITEMS)) return;
		if (m_pClientList[iClientH]->m_pItemList[sItemIndex[i]] == NULL) return;
		if (m_pClientList[iClientH]->m_pItemList[sItemIndex[i]]->m_dwCount < sItemNumber[i]) return;
	}

	// Bubble Sort
	bFlag = TRUE;
	while (bFlag == TRUE) 
	{	bFlag = FALSE;
		for (i = 0; i < 5; i++) 
		if ((sItemIndex[i] != -1) && (sItemIndex[i+1] != -1)) 
		{	if ((m_pClientList[iClientH]->m_pItemList[sItemIndex[i]]->m_sIDnum) < (m_pClientList[iClientH]->m_pItemList[sItemIndex[i+1]]->m_sIDnum)) 
			{	sTemp = sItemIndex[i+1];
				sItemIndex[i+1] = sItemIndex[i];
				sItemIndex[i] = sTemp;
				sTemp = sItemNumber[i+1];
				sItemNumber[i+1] = sItemNumber[i];
				sItemNumber[i] = sTemp;
				bFlag = TRUE;
	}	}	}
	j = 0;
	for (i = 0; i < 6; i++)
	{	if (sItemIndex[i] != -1)
			 sItemArray[j] = m_pClientList[iClientH]->m_pItemList[sItemIndex[i]]->m_sIDnum;
		else sItemArray[j] = sItemIndex[i];
		sItemArray[j+1] = sItemNumber[i];
		j += 2;
	}
	// sItemArray 
	ZeroMemory(cPortionName, sizeof(cPortionName));

	for (i = 0; i < DEF_MAXPORTIONTYPES; i++) 
	if (m_pPortionConfigList[i] != NULL) 
	{	bFlag = FALSE;
		for (j = 0; j < 12; j++) 
		if (m_pPortionConfigList[i]->m_sArray[j] != sItemArray[j]) bFlag = TRUE;		
		if (bFlag == FALSE) 
		{	ZeroMemory(cPortionName, sizeof(cPortionName));
			memcpy(cPortionName, m_pPortionConfigList[i]->m_cName, 20);
			iSkillLimit = m_pPortionConfigList[i]->m_iSkillLimit;
			iDifficulty = m_pPortionConfigList[i]->m_iDifficulty;
	}	}
	if (strlen(cPortionName) == 0) 
	{	SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_NOMATCHINGPORTION, NULL, NULL, NULL, NULL);
		return;
	}
	iSkillLevel = m_pClientList[iClientH]->m_cSkillMastery[12];
	if (iSkillLimit > iSkillLevel) 
	{	SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_LOWPORTIONSKILL, NULL, NULL, NULL, cPortionName);
		return;
	}

	iSkillLevel -= iDifficulty;
	if (iSkillLevel <= 0) iSkillLevel = 1;

	iResult = iDice(1,100);
	if (iResult > iSkillLevel) 
	{	SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_PORTIONFAIL, NULL, NULL, NULL, cPortionName);
		return;
	}
	// Purity
	i_Purity = iSkillLevel; // iSkillLevel - iDifficulty
	i_Purity += i_Purity/2;
	i_Purity += iDice(1,iDifficulty);
	if ( i_Purity > 100 ) i_Purity = 100;
	if ( i_Purity < 10 )  i_Purity = 10;

	// SNOOPY: Increased a bit Skill increase if difficult potion.
	//CalculateSSN_SkillIndex(iClientH, 12, 1);
	CalculateSSN_SkillIndex(iClientH, 12, iDifficulty/10);

	//  strlen(cPortionName)
	if (strlen(cPortionName) != 0) 
	{	pItem = NULL;
		pItem = new class CItem;
		if (pItem == NULL) return;
		for (i = 0; i < 6; i++)
		if (sItemIndex[i] != -1) 
		{	if (m_pClientList[iClientH]->m_pItemList[sItemIndex[i]]->m_cItemType == DEF_ITEMTYPE_CONSUME)
				SetItemCount(iClientH, sItemIndex[i], 
				//     m_pClientList[iClientH]->m_pItemList[sItemIndex[i]]->m_cName,
				m_pClientList[iClientH]->m_pItemList[sItemIndex[i]]->m_dwCount - sItemNumber[i]);
			// So if item is not Type 5 (stackable items), you deplete item
			else ItemDepleteHandler(iClientH, sItemIndex[i], FALSE);
		}
		SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_PORTIONSUCCESS, NULL, NULL, NULL, cPortionName);
		// Snoopy xp= dice difficulty   no more difficulty / 3
		m_pClientList[iClientH]->m_iExpStock += iDice(1, (iDifficulty));

		if ((_bInitItemAttr(pItem, cPortionName) == TRUE))		
		{	//if (pItem->m_sIDnum >960 )  {	}
			if (pItem->m_cItemType == DEF_ITEMTYPE_MATERIAL) // Snoopy: Added Purity to Oils/Elixirs
			{	pItem->m_sItemSpecEffectValue2 = i_Purity;
				pItem->m_dwAttribute = 1;
				pItem->m_sItemSpecEffectValue1 = 1;
			}				
			pItem->m_sTouchEffectType   = DEF_ITET_ID;
			pItem->m_sTouchEffectValue1 = iDice(1,100000);
			pItem->m_sTouchEffectValue2 = iDice(1,100000);
			// pItem->m_sTouchEffectValue3 = timeGetTime();	
			SYSTEMTIME SysTime;
			char cTemp[256];
			GetLocalTime(&SysTime);
			ZeroMemory(cTemp, sizeof(cTemp));
			wsprintf(cTemp, "%d%2d",  (short)SysTime.wMonth, (short)SysTime.wDay);
			pItem->m_sTouchEffectValue3 = atoi(cTemp);
			
			if (iDifficulty >10 ) // SNOOPY logg potion above 10 difficulty				
			{	wsprintf(G_cTxt, "PC(%s) Potion (%s) Purity(%d)"
					, m_pClientList[iClientH]->m_cCharName
					, pItem->m_cName
					, pItem->m_sItemSpecEffectValue2);			
				PutSkillLogFileList(G_cTxt);
			}
			if (_bAddClientItemList(iClientH, pItem, &iEraseReq) == TRUE) 	
			{	ZeroMemory(cData, sizeof(cData));
				dwp  = (DWORD *)(cData + DEF_INDEX4_MSGID);
				*dwp = MSGID_NOTIFY;
				wp   = (WORD *)(cData + DEF_INDEX2_MSGTYPE);
				*wp  = DEF_NOTIFY_ITEMOBTAINED;				
				cp = (char *)(cData + DEF_INDEX2_MSGTYPE + 2);	
				*cp = 1;
				cp++;				
				memcpy(cp, pItem->m_cName, 20);
				cp += 20;				
				dwp  = (DWORD *)cp;
				*dwp = pItem->m_dwCount;
				cp += 4;				
				*cp = pItem->m_cItemType;
				cp++;				
				*cp = pItem->m_cEquipPos;
				cp++;				
				*cp = (char)0; 
				cp++;				
				sp  = (short *)cp;
				*sp = pItem->m_sLevelLimit;
				cp += 2;				
				*cp = pItem->m_cGenderLimit;
				cp++;				
				wp = (WORD *)cp;
				*wp = pItem->m_wCurLifeSpan;
				cp += 2;				
				wp = (WORD *)cp;
				*wp = pItem->m_wWeight;
				cp += 2;				
				sp  = (short *)cp;
				*sp = pItem->m_sSprite;
				cp += 2;				
				sp  = (short *)cp;
				*sp = pItem->m_sSpriteFrame;
				cp += 2;
				*cp = pItem->m_cItemColor;
				cp++;
				*cp = (char)pItem->m_sItemSpecEffectValue2; // v1.41 
				cp++;				
				dwp = (DWORD *)cp;
				*dwp = pItem->m_dwAttribute;
				cp += 4;
				/*	*cp = (char)(pItem->m_dwAttribute & 0x00000001); // Custom-Item
				cp++;	*/				
				if (iEraseReq == 1) delete pItem;
				iRet = m_pClientList[iClientH]->m_pXSock->iSendMsg(cData, 53);
				switch (iRet) {
				case DEF_XSOCKEVENT_QUENEFULL:
				case DEF_XSOCKEVENT_SOCKETERROR:
				case DEF_XSOCKEVENT_CRITICALERROR:
				case DEF_XSOCKEVENT_SOCKETCLOSED:
					DeleteClient(iClientH, TRUE, TRUE);
					break;
				}
				//if ((pItem->m_wPrice * pItem->m_dwCount) > 1000) 
				//	SendMsgToLS(MSGID_REQUEST_SAVEPLAYERDATA, iClientH);
			}else 
			{	m_pMapList[ m_pClientList[iClientH]->m_cMapIndex ]->bSetItem(m_pClientList[iClientH]->m_sX, 
					                                                         m_pClientList[iClientH]->m_sY, pItem);
				SendEventToNearClient_TypeB(MSGID_EVENT_COMMON, DEF_COMMONTYPE_ITEMDROP, m_pClientList[iClientH]->m_cMapIndex,
					                        m_pClientList[iClientH]->m_sX, m_pClientList[iClientH]->m_sY,  
					                        pItem->m_sSprite, pItem->m_sSpriteFrame, pItem->m_cItemColor);
				
				dwp  = (DWORD *)(cData + DEF_INDEX4_MSGID);
				*dwp = MSGID_NOTIFY;
				wp   = (WORD *)(cData + DEF_INDEX2_MSGTYPE);
				*wp  = DEF_NOTIFY_CANNOTCARRYMOREITEM;				
				iRet = m_pClientList[iClientH]->m_pXSock->iSendMsg(cData, 6);
				switch (iRet) {
				case DEF_XSOCKEVENT_QUENEFULL:
				case DEF_XSOCKEVENT_SOCKETERROR:
				case DEF_XSOCKEVENT_CRITICALERROR:
				case DEF_XSOCKEVENT_SOCKETCLOSED:
					DeleteClient(iClientH, TRUE, TRUE);
					break;
			}	}
		}else 
		{	delete pItem;
			pItem = NULL;	
	}	}
}
//////////////////////////////////////////////////////////////////////////////////////////
///		Snoopy: Added Crafting to the same file than potions
//////////////////////////////////////////////////////////////////////////////////////////
BOOL CGame::_bDecodePortionConfigFileContents(char *pData, DWORD dwMsgSize)
{char * pContents, * token, cTxt[120];
 char seps[] = "= \t\n";
 char cReadModeA = 0;
 char cReadModeB = 0;
 int  iPortionConfigListIndex = 0;
 int  iCraftingConfigListIndex = 0;
 class CStrTok * pStrTok;

	pContents = new char[dwMsgSize+1];
	ZeroMemory(pContents, dwMsgSize+1);
	memcpy(pContents, pData, dwMsgSize);
	pStrTok = new class CStrTok(pContents, seps);
	token = pStrTok->pGet();
	while( token != NULL ) {
		if (cReadModeA != 0) {
			switch (cReadModeA) {
			case 1:
				switch (cReadModeB) {
				case 1:	// Potion's index
					if (_bGetIsStringIsNumber(token) == FALSE) 
					{	PutLogList("(!!!) CRITICAL ERROR! POTION configuration file error - Wrong Data format(1).");
						delete pContents; delete pStrTok; return FALSE;
					}					
					if (m_pPortionConfigList[atoi(token)] != NULL) 
					{	PutLogList("(!!!) CRITICAL ERROR! POTION configuration file error - Duplicate portion number.");
						delete pContents; delete pStrTok; return FALSE;
					}
					m_pPortionConfigList[atoi(token)] = new class CPortion;
					iPortionConfigListIndex = atoi(token);
					cReadModeB = 2;
					break;

				case 2: // Potion's name
					ZeroMemory(m_pPortionConfigList[iPortionConfigListIndex]->m_cName, sizeof(m_pPortionConfigList[iPortionConfigListIndex]->m_cName));
					memcpy(m_pPortionConfigList[iPortionConfigListIndex]->m_cName, token, strlen(token));
					cReadModeB = 3;
					break;

				default: // m_sArray[0~10]
					if (_bGetIsStringIsNumber(token) == FALSE) 
					{	PutLogList("(!!!) CRITICAL ERROR! POTION configuration file error - Wrong Data format.");
						delete pContents; delete pStrTok; return FALSE;
					}
					m_pPortionConfigList[iPortionConfigListIndex]->m_sArray[cReadModeB - 3] = atoi(token);
					cReadModeB++;
					break;

				case 14: // m_sArray[11]
					if (_bGetIsStringIsNumber(token) == FALSE) 
					{	PutLogList("(!!!) CRITICAL ERROR! POTION configuration file error - Wrong Data format.");
						delete pContents; delete pStrTok; return FALSE;
					}
					m_pPortionConfigList[iPortionConfigListIndex]->m_sArray[11] = atoi(token);
					cReadModeB = 15;
					break;

				case 15: // Mini Skill
					if (_bGetIsStringIsNumber(token) == FALSE) 
					{	PutLogList("(!!!) CRITICAL ERROR! POTION configuration file error - Wrong Data format.");
						delete pContents; delete pStrTok; return FALSE;
					}
					m_pPortionConfigList[iPortionConfigListIndex]->m_iSkillLimit = atoi(token);
					cReadModeB = 16;
					break;
	
				case 16:// Difficulty
					if (_bGetIsStringIsNumber(token) == FALSE) 
					{	PutLogList("(!!!) CRITICAL ERROR! POTION configuration file error - Wrong Data format.");
						delete pContents; delete pStrTok; return FALSE;
					}
					m_pPortionConfigList[iPortionConfigListIndex]->m_iDifficulty = atoi(token);
					cReadModeA = 0;
					cReadModeB = 0;
					break;
				}
				break;			
				
			case 2: // Crafting
				switch (cReadModeB) {
				case 1:	// 
					if (_bGetIsStringIsNumber(token) == FALSE) 
					{	PutLogList("(!!!) CRITICAL ERROR! CRAFTING configuration file error - Wrong Data format(1).");
						delete pContents; delete pStrTok; return FALSE;
					}					
					if (m_pCraftingConfigList[atoi(token)] != NULL) 
					{	PutLogList("(!!!) CRITICAL ERROR! CRAFTING configuration file error - Duplicate crafting number.");
						delete pContents; delete pStrTok; return FALSE;
					}
					m_pCraftingConfigList[atoi(token)] = new class CPortion;
					iCraftingConfigListIndex = atoi(token);
					cReadModeB = 2;
					break;

				case 2:
					ZeroMemory(m_pCraftingConfigList[iCraftingConfigListIndex]->m_cName, sizeof(m_pCraftingConfigList[iCraftingConfigListIndex]->m_cName));
					memcpy(m_pCraftingConfigList[iCraftingConfigListIndex]->m_cName, token, strlen(token));
					cReadModeB = 3;
					break;

				default: // m_sArray[0~10]
					if (_bGetIsStringIsNumber(token) == FALSE) 
					{	PutLogList("(!!!) CRITICAL ERROR! CRAFTING configuration file error - Wrong Data format.");
						delete pContents; delete pStrTok; return FALSE;
					}
					m_pCraftingConfigList[iCraftingConfigListIndex]->m_sArray[cReadModeB - 3] = atoi(token);
					cReadModeB++;
					break;

				case 14: // m_sArray[11]
					if (_bGetIsStringIsNumber(token) == FALSE) 
					{	PutLogList("(!!!) CRITICAL ERROR! CRAFTING configuration file error - Wrong Data format.");
						delete pContents; delete pStrTok; return FALSE;
					}
					m_pCraftingConfigList[iCraftingConfigListIndex]->m_sArray[11] = atoi(token);
					cReadModeB = 15;
					break;

				case 15: // 
					if (_bGetIsStringIsNumber(token) == FALSE) 
					{	PutLogList("(!!!) CRITICAL ERROR! CRAFTING configuration file error - Wrong Data format.");
						delete pContents; delete pStrTok; return FALSE;
					}
					m_pCraftingConfigList[iCraftingConfigListIndex]->m_iSkillLimit = atoi(token);
					cReadModeB = 16;
					break;
	
				case 16:// 
					if (_bGetIsStringIsNumber(token) == FALSE) 
					{	PutLogList("(!!!) CRITICAL ERROR! CRAFTING configuration file error - Wrong Data format.");
						delete pContents; delete pStrTok; return FALSE;
					}
					m_pCraftingConfigList[iCraftingConfigListIndex]->m_iDifficulty = atoi(token);
					cReadModeA = 0;
					cReadModeB = 0;
					break;
				}
				break;

			default: 
				break;
			}
		}else 
		{	if (memcmp(token, "potion", 5) == 0) 
			{	cReadModeA = 1;
				cReadModeB = 1;
			}	
			if (memcmp(token, "crafting", 8) == 0) 
			{	cReadModeA = 2;
				cReadModeB = 1;
			}			
		}
		token = pStrTok->pGet();
	}	
	delete pStrTok;
	delete pContents;
	if ((cReadModeA != 0) || (cReadModeB != 0)) 
	{	PutLogList("(!!!) CRITICAL ERROR! POTION configuration file contents error!");
		return FALSE;
	}
	wsprintf(cTxt, "(!) POTION(Total:%d) configuration - success!", iPortionConfigListIndex);
	PutLogList(cTxt);

	return TRUE;
}
//////////////////////////////////////////////////////////////////////////////////////////////////////
///		Crafting functions copyed on Alchemy functions...
//////////////////////////////////////////////////////////////////////////////////////////////////////
void CGame::ReqCreateCraftingHandler(int iClientH, char *pData)
{
 DWORD * dwp;
 WORD  * wp;
 char  * cp, cI[6], cCraftingName[21], cData[120];
 int    iRet, i, j, iEraseReq, iRiskLevel, iSuccesChances, iSkillLevel, iNeededContrib = 0;
 short * sp, sTemp;
 short  sItemIndex[6], sItemPurity[6], sItemNumber[6], sItemArray[12];
 BOOL   bDup, bFlag, bNeedLog;
 class  CItem * pItem;

	if (m_pClientList[iClientH] == NULL) return;
	m_pClientList[iClientH]->m_iSkillMsgRecvCount++;

	for (i = 0; i < 6; i++) 
	{	cI[i] = -1;
		sItemIndex[i]  = -1;
		sItemNumber[i] = 0;
		sItemPurity[i] = -1;
	}
	cp = (char *)(pData + 11);
	cp += 20;
	cI[0] = *cp;
	cp++;
	cI[1] = *cp;
	cp++;
	cI[2] = *cp;
	cp++;
	cI[3] = *cp;
	cp++;
	cI[4] = *cp;
	cp++;
	cI[5] = *cp;
	cp++;

	for (i = 0; i < 6; i++) 
	{	if (cI[i] >= DEF_MAXITEMS) return;
		if ((cI[i] >= 0) && (m_pClientList[iClientH]->m_pItemList[cI[i]] == NULL)) return;
	}

	for (i = 0; i < 6; i++)
	if (cI[i] >= 0) 
	{	bDup = FALSE;
		for (j = 0; j < 6; j++) 
		if (sItemIndex[j] == cI[i]) 
		{	sItemNumber[j]++;
			bDup = TRUE;
		}
		if (bDup == FALSE) 
		{	for (j = 0; j < 6; j++) 
			if (sItemIndex[j] == -1) 
			{	sItemIndex[j] = cI[i];
				sItemNumber[j]++;
				goto RCPH_LOOPBREAK;
			}
RCPH_LOOPBREAK:;	
	}	}
	
	for (i = 0; i < 6; i++) 
	if (sItemIndex[i] != -1) 
	{	if (sItemIndex[i] < 0) return;
		if ((sItemIndex[i] >= 0) && (sItemIndex[i] >= DEF_MAXITEMS)) return;
		if (m_pClientList[iClientH]->m_pItemList[sItemIndex[i]] == NULL) return;
		if (m_pClientList[iClientH]->m_pItemList[sItemIndex[i]]->m_dwCount < sItemNumber[i]) return;
		sItemPurity[i] = m_pClientList[iClientH]->m_pItemList[sItemIndex[i]]->m_sItemSpecEffectValue2;
		if (   (m_pClientList[iClientH]->m_pItemList[sItemIndex[i]]->m_cItemType == DEF_ITEMTYPE_NONE)
			&& (m_pClientList[iClientH]->m_pItemList[sItemIndex[i]]->m_sSprite == 6)
			&& (m_pClientList[iClientH]->m_pItemList[sItemIndex[i]]->m_sSpriteFrame == 129))
		{	sItemPurity[i] = 100; // Merien stones considered 100% purity.
		}		
		if (m_pClientList[iClientH]->m_pItemList[sItemIndex[i]]->m_cItemType == DEF_ITEMTYPE_CONSUME)
		{	sItemPurity[i] = -1; // Diamonds / Emeralds.etc.. never have purity
		}
		if (sItemNumber[i] > 1) // No purity for stacked items
		{	sItemPurity[i] = -1;
		}
		// Prevent upgrade of alreaddy merienned Necks
		if ((m_pClientList[iClientH]->m_pItemList[sItemIndex[i]]->m_dwAttribute & 0xF0000000) != 0)
		{	SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_CRAFTING_FAIL, 1, NULL, NULL, NULL); // "There is not enough material"
			return;
		}
		if (   (m_pClientList[iClientH]->m_pItemList[sItemIndex[i]]->m_cItemType == DEF_ITEMTYPE_EQUIP)
			&& (m_pClientList[iClientH]->m_pItemList[sItemIndex[i]]->m_cEquipPos == DEF_EQUIPPOS_NECK))
		{	iNeededContrib = 10; // Necks Crafting requires 10 contrib
	}	}

	// Bubble Sort
	bFlag = TRUE;
	while (bFlag == TRUE) 
	{	bFlag = FALSE;
		for (i = 0; i < 5; i++) 
		if ((sItemIndex[i] != -1) && (sItemIndex[i+1] != -1)) 
		{	if ((m_pClientList[iClientH]->m_pItemList[sItemIndex[i]]->m_sIDnum) < (m_pClientList[iClientH]->m_pItemList[sItemIndex[i+1]]->m_sIDnum)) 
			{	sTemp = sItemIndex[i+1];
				sItemIndex[i+1] = sItemIndex[i];
				sItemIndex[i] = sTemp;
				sTemp = sItemPurity[i+1];
				sItemPurity[i+1] = sItemPurity[i];
				sItemPurity[i] = sTemp;
				sTemp = sItemNumber[i+1];
				sItemNumber[i+1] = sItemNumber[i];
				sItemNumber[i] = sTemp;
				bFlag = TRUE;
	}	}	}
	j = 0;
	for (i = 0; i < 6; i++)
	{	if (sItemIndex[i] != -1)
			 sItemArray[j] = m_pClientList[iClientH]->m_pItemList[sItemIndex[i]]->m_sIDnum;
		else sItemArray[j] = sItemIndex[i];
		sItemArray[j+1] = sItemNumber[i];
		j += 2;
	}

	// Search Crafting you wanna build
	ZeroMemory(cCraftingName, sizeof(cCraftingName));
	for (i = 0; i < DEF_MAXPORTIONTYPES; i++) 
	if (m_pCraftingConfigList[i] != NULL) 
	{	bFlag = FALSE;
		for (j = 0; j < 12; j++) 
		{	if (m_pCraftingConfigList[i]->m_sArray[j] != sItemArray[j]) bFlag = TRUE; // one item mismatch	
		}
		if (bFlag == FALSE) // good Crafting receipe
		{	ZeroMemory(cCraftingName, sizeof(cCraftingName));
			memcpy(cCraftingName, m_pCraftingConfigList[i]->m_cName, 20);
			iRiskLevel  = m_pCraftingConfigList[i]->m_iSkillLimit;			// % to loose item if crafting fails
			iSuccesChances = m_pCraftingConfigList[i]->m_iDifficulty;
	}	}

	// Check if recipe is OK
	if (strlen(cCraftingName) == 0) 
	{	SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_CRAFTING_FAIL, 1, NULL, NULL, NULL); // "There is not enough material"
		return;
	}
	// Check for Contribution
	if (m_pClientList[iClientH]->m_iContribution < iNeededContrib)
	{	SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_CRAFTING_FAIL, 2, NULL, NULL, NULL); // "There is not enough Contribution Point"	
		return;
	}

	// Special EP: AJustement des chances de reussite selon le skill
	iSkillLevel = m_pClientList[iClientH]->m_cSkillMastery[18]; //iDifficulty
	if (iSkillLevel < 20) iSkillLevel = 20;
	iSkillLevel += ((m_pClientList[iClientH]->m_iMag + m_pClientList[iClientH]->m_iAngelicMag)/10); 
	if (iSkillLevel > iSuccesChances) 
		iSuccesChances = iSuccesChances + ((iSkillLevel - iSuccesChances)/2);
	else if (iSkillLevel < iSuccesChances) 
		iSuccesChances = iSuccesChances - ((iSuccesChances - iSkillLevel)/2);

	// Check possible Failure
	if (iDice(1,100) > iSuccesChances) 
	{	SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_CRAFTING_FAIL, 3, NULL, NULL, NULL); // "Crafting failed"
		// Remove parts...
		pItem = NULL;
		pItem = new class CItem;
		if (pItem == NULL) return;
		for (i = 0; i < 6; i++)
		if (sItemIndex[i] != -1) 
		{	// Deplete any Merien Stone
			if (   (m_pClientList[iClientH]->m_pItemList[sItemIndex[i]]->m_cItemType == DEF_ITEMTYPE_NONE)
				&& (m_pClientList[iClientH]->m_pItemList[sItemIndex[i]]->m_sSprite == 6)
				&& (m_pClientList[iClientH]->m_pItemList[sItemIndex[i]]->m_sSpriteFrame == 129))
			{	//.... Don't Deplete the Merien Stone on EP (Merien Stones are really rare stuff...)
				// ItemDepleteHandler(iClientH, sItemIndex[i], FALSE)				
			}else 
			// Risk to deplete any other items (not stackable ones) // DEF_ITEMTYPE_CONSUME
			if (   (m_pClientList[iClientH]->m_pItemList[sItemIndex[i]]->m_cItemType == DEF_ITEMTYPE_EQUIP)
				|| (m_pClientList[iClientH]->m_pItemList[sItemIndex[i]]->m_cItemType == DEF_ITEMTYPE_MATERIAL))
			{	if (iDice(1,100) < iRiskLevel)	
				{	ItemDepleteHandler(iClientH, sItemIndex[i], FALSE);
		}	}	}
		return;
	}

	// Purity
	int iPurity, iTot = 0, iCount = 0;
	for (i = 0; i < 6; i++) 
	{	if (sItemIndex[i] != -1) 
		{	if (sItemPurity[i] != -1) 
			{	iTot += sItemPurity[i];
				iCount ++;
	}	}	}
	if (iCount == 0 ) 
	{	//iPurity = 20 + iDice(1,80);			// Wares have random purity (20%..100%)
		iPurity = (iSkillLevel/2) + iDice(1,(100 - (iSkillLevel/2)));
		if (iPurity >=95) bNeedLog = TRUE;
		else 			  bNeedLog = FALSE;
	}else 
	{	iPurity = iTot/iCount;
		iTot    = (iPurity*4)/5;
		iCount  = iPurity - iTot;
		iPurity = iTot + iDice(1,iCount);	// Jewel completion depends on Wares purity (entre 80 et 100% de la purity moyenne)
		bNeedLog = TRUE;
	}
	if (iNeededContrib != 0) 
	{	iPurity = 0;						// Necks require contribution but no purity/completion
		bNeedLog = TRUE;
	}
	CalculateSSN_SkillIndex(iClientH, 18, 1);

	if (strlen(cCraftingName) != 0) 
	{	pItem = NULL;
		pItem = new class CItem;
		if (pItem == NULL) return;
		for (i = 0; i < 6; i++)
		{	if (sItemIndex[i] != -1) 
			{	if (m_pClientList[iClientH]->m_pItemList[sItemIndex[i]]->m_cItemType == DEF_ITEMTYPE_CONSUME)
				{	SetItemCount(iClientH, sItemIndex[i], 
						m_pClientList[iClientH]->m_pItemList[sItemIndex[i]]->m_dwCount - sItemNumber[i]);					
				}else // So if item is not Type 5 (stackable items), you deplete item
				{	ItemDepleteHandler(iClientH, sItemIndex[i], FALSE);
		}	}	}
		if (iNeededContrib !=0)
		{	m_pClientList[iClientH]->m_iContribution -= iNeededContrib;   
			// No known msg to send info to client, so client will compute shown Contrib himself.		
		}

		SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_CRAFTING_SUCCESS, NULL, NULL, NULL, NULL);

		m_pClientList[iClientH]->m_iExpStock += iDice(2, 100);

		if ((_bInitItemAttr(pItem, cCraftingName) == TRUE)) 
		{	// // Snoopy: Added Purity to Oils/Elixirs
			if (iPurity != 0) 
			{	pItem->m_sItemSpecEffectValue2 = iPurity;
				pItem->m_dwAttribute = 1;
			}
			pItem->m_sTouchEffectType   = DEF_ITET_ID;
			pItem->m_sTouchEffectValue1 = iDice(1,100000);
			pItem->m_sTouchEffectValue2 = iDice(1,100000);
			// pItem->m_sTouchEffectValue3 = timeGetTime();	
			SYSTEMTIME SysTime;
			char cTemp[256];
			GetLocalTime(&SysTime);
			ZeroMemory(cTemp, sizeof(cTemp));
			wsprintf(cTemp, "%d%2d",  (short)SysTime.wMonth, (short)SysTime.wDay);
			pItem->m_sTouchEffectValue3 = atoi(cTemp);

			// SNOOPY log anything above WAREs
			if (bNeedLog) 		
			{	wsprintf(G_cTxt, "PC(%s) Crafting (%s) Purity(%d)"
					, m_pClientList[iClientH]->m_cCharName
					, pItem->m_cName
					, pItem->m_sItemSpecEffectValue2);			
				PutSkillLogFileList(G_cTxt);				
				PutItemLogFileList(G_cTxt);
				_bItemLog(DEF_ITEMLOG_CRAFT, iClientH, (int) -1, pItem, TRUE);
			}
			if (_bAddClientItemList(iClientH, pItem, &iEraseReq) == TRUE) 
			{	ZeroMemory(cData, sizeof(cData));
				dwp  = (DWORD *)(cData + DEF_INDEX4_MSGID);
				*dwp = MSGID_NOTIFY;
				wp   = (WORD *)(cData + DEF_INDEX2_MSGTYPE);
				*wp  = DEF_NOTIFY_ITEMOBTAINED;				
				cp = (char *)(cData + DEF_INDEX2_MSGTYPE + 2);	
				*cp = 1;
				cp++;				
				memcpy(cp, pItem->m_cName, 20);
				cp += 20;				
				dwp  = (DWORD *)cp;
				*dwp = pItem->m_dwCount;
				cp += 4;				
				*cp = pItem->m_cItemType;
				cp++;				
				*cp = pItem->m_cEquipPos;
				cp++;				
				*cp = (char)0; 
				cp++;				
				sp  = (short *)cp;
				*sp = pItem->m_sLevelLimit;
				cp += 2;				
				*cp = pItem->m_cGenderLimit;
				cp++;				
				wp = (WORD *)cp;
				*wp = pItem->m_wCurLifeSpan;
				cp += 2;				
				wp = (WORD *)cp;
				*wp = pItem->m_wWeight;
				cp += 2;				
				sp  = (short *)cp;
				*sp = pItem->m_sSprite;
				cp += 2;				
				sp  = (short *)cp;
				*sp = pItem->m_sSpriteFrame;
				cp += 2;
				*cp = pItem->m_cItemColor;
				cp++;
				*cp = (char)pItem->m_sItemSpecEffectValue2; // v1.41 
				cp++;				
				dwp = (DWORD *)cp;
				*dwp = pItem->m_dwAttribute;
				cp += 4;
				/*	*cp = (char)(pItem->m_dwAttribute & 0x00000001); // Custom-Item
				cp++;	*/				
				if (iEraseReq == 1) delete pItem;
				iRet = m_pClientList[iClientH]->m_pXSock->iSendMsg(cData, 53);
				switch (iRet) {
				case DEF_XSOCKEVENT_QUENEFULL:
				case DEF_XSOCKEVENT_SOCKETERROR:
				case DEF_XSOCKEVENT_CRITICALERROR:
				case DEF_XSOCKEVENT_SOCKETCLOSED:
					DeleteClient(iClientH, TRUE, TRUE);
					break;
				}
				//if ((pItem->m_wPrice * pItem->m_dwCount) > 1000) 
				//	SendMsgToLS(MSGID_REQUEST_SAVEPLAYERDATA, iClientH);
			}else 
			{	m_pMapList[ m_pClientList[iClientH]->m_cMapIndex ]->bSetItem(m_pClientList[iClientH]->m_sX, 
					                                                         m_pClientList[iClientH]->m_sY, pItem);
				SendEventToNearClient_TypeB(MSGID_EVENT_COMMON, DEF_COMMONTYPE_ITEMDROP, m_pClientList[iClientH]->m_cMapIndex,
					                        m_pClientList[iClientH]->m_sX, m_pClientList[iClientH]->m_sY,  
					                        pItem->m_sSprite, pItem->m_sSpriteFrame, pItem->m_cItemColor);
				
				dwp  = (DWORD *)(cData + DEF_INDEX4_MSGID);
				*dwp = MSGID_NOTIFY;
				wp   = (WORD *)(cData + DEF_INDEX2_MSGTYPE);
				*wp  = DEF_NOTIFY_CANNOTCARRYMOREITEM;				
				iRet = m_pClientList[iClientH]->m_pXSock->iSendMsg(cData, 6);
				switch (iRet) {
				case DEF_XSOCKEVENT_QUENEFULL:
				case DEF_XSOCKEVENT_SOCKETERROR:
				case DEF_XSOCKEVENT_CRITICALERROR:
				case DEF_XSOCKEVENT_SOCKETCLOSED:
					DeleteClient(iClientH, TRUE, TRUE);
					break;
			}	}
		}else 
		{	delete pItem;
			pItem = NULL;	
	}	}
}




void CGame::LocalSavePlayerData(int iClientH)
{char * pData, * cp, cFn[256], cDir[256], cTxt[256], cCharDir[256];
 int    iSize;
 FILE * pFile;
 SYSTEMTIME SysTime;
	if (m_pClientList[iClientH] == NULL) return; 
	pData = new char[30000];
	if (pData == NULL) return;
	ZeroMemory(pData, 30000);
	cp = (char *)(pData);
	iSize = _iComposePlayerDataFileContents(iClientH, cp);
	GetLocalTime(&SysTime);
	ZeroMemory(cCharDir, sizeof(cDir));
	wsprintf(cCharDir, "Character_%d_%d_%d_%d", SysTime.wMonth, SysTime.wDay, SysTime.wHour, SysTime.wMinute);
	ZeroMemory(cDir, sizeof(cDir));
	ZeroMemory(cFn, sizeof(cFn));
	strcat(cFn,cCharDir);
	strcat(cFn,"\\");
	strcat(cFn,"\\");					  
	wsprintf(cTxt, "AscII%d", (unsigned char)m_pClientList[iClientH]->m_cCharName[0]);
	strcat(cFn, cTxt);
	strcpy(cDir, cFn);
	strcat(cFn,"\\");
	strcat(cFn,"\\");					  
	strcat(cFn, m_pClientList[iClientH]->m_cCharName);
	strcat(cFn, ".txt");
	_mkdir(cCharDir);
	_mkdir(cDir);
	if (iSize == 0) {
		PutLogList("(!) Character data body empty: Cannot create & save temporal player data file.");
		delete pData;
		return;
	}
	pFile = fopen(cFn, "wt");
	if (pFile == NULL) 
	{	wsprintf(cTxt, "(!) Cannot create temporal player data file : Name(%s)", cFn);
		PutLogList(cTxt);
	}else 
	{	wsprintf(cTxt, "(!) temporal player data file saved : Name(%s)", cFn);
		PutLogList(cTxt);
		fwrite(cp, iSize, 1, pFile);
	}	
	if (pFile != NULL) fclose(pFile);
	delete pData;
}

void CGame::MineralGenerator()
{register int i, iP, tX, tY, iRet;
 	for (i = 0; i < DEF_MAXMAPS; i++) {
		if ((iDice(1,4) == 1) && (m_pMapList[i] != NULL) && 
			(m_pMapList[i]->m_bMineralGenerator == TRUE) && 
			(m_pMapList[i]->m_iCurMineral < m_pMapList[i]->m_iMaxMineral)) {
	
			iP = iDice(1, m_pMapList[i]->m_iTotalMineralPoint) - 1;
			if ((m_pMapList[i]->m_MineralPointList[iP].x == -1) || (m_pMapList[i]->m_MineralPointList[iP].y == -1)) break;

			tX = m_pMapList[i]->m_MineralPointList[iP].x;
			tY = m_pMapList[i]->m_MineralPointList[iP].y;

		   	iRet = iCreateMineral(i, tX, tY, m_pMapList[i]->m_cMineralGeneratorLevel);
		}
	}		
}

int CGame::iCreateMineral(char cMapIndex, int tX, int tY, char cLevel)
{	register int i, iDynamicHandle, iMineralType;
	if ((cMapIndex < 0) || (cMapIndex >= DEF_MAXMAPS)) return NULL;
	if (m_pMapList[cMapIndex] == NULL) return NULL;	
	for (i = 1; i < DEF_MAXMINERALS; i++) 
	if (m_pMineral[i] == NULL) {
		iMineralType = iDice(1, cLevel);
		m_pMineral[i] = new class CMineral(iMineralType, cMapIndex, tX, tY, 1);
		if (m_pMineral[i] == NULL) return NULL; 		
		iDynamicHandle = NULL;
		switch (iMineralType) {
		case 1: // stone
		case 2:
		case 3:
		case 4:
			iDynamicHandle = iAddDynamicObjectList(NULL, NULL, DEF_DYNAMICOBJECT_MINERAL1, cMapIndex, tX, tY, NULL, i);
			break;				
		case 5: // cristal
		case 6:
			iDynamicHandle = iAddDynamicObjectList(NULL, NULL, DEF_DYNAMICOBJECT_MINERAL2, cMapIndex, tX, tY, NULL, i);
			break;		
		default:
			iDynamicHandle = iAddDynamicObjectList(NULL, NULL, DEF_DYNAMICOBJECT_MINERAL1, cMapIndex, tX, tY, NULL, i);
			break;
		}		
		if (iDynamicHandle == NULL) {
			delete m_pMineral[i];
			m_pMineral[i] = NULL;
			return NULL;
		}
		m_pMineral[i]->m_sDynamicObjectHandle = iDynamicHandle;
		m_pMineral[i]->m_cMapIndex = cMapIndex;		
		switch (iMineralType) {
		case 1: m_pMineral[i]->m_iDifficulty = 10; m_pMineral[i]->m_iRemain = 20; break;
		case 2: m_pMineral[i]->m_iDifficulty = 15; m_pMineral[i]->m_iRemain = 15; break;
		case 3: m_pMineral[i]->m_iDifficulty = 20; m_pMineral[i]->m_iRemain = 10; break;
		case 4: m_pMineral[i]->m_iDifficulty = 50; m_pMineral[i]->m_iRemain = 8; break;
		case 5: m_pMineral[i]->m_iDifficulty = 70; m_pMineral[i]->m_iRemain = 6; break;
		case 6: m_pMineral[i]->m_iDifficulty = 90; m_pMineral[i]->m_iRemain = 4; break;
		default: m_pMineral[i]->m_iDifficulty = 10; m_pMineral[i]->m_iRemain = 20; break;
		}
		m_pMapList[cMapIndex]->m_iCurMineral++;	
		return i;
	}
	return NULL;
}


void CGame::_CheckMiningAction(int iClientH, int dX, int dY)
// Function modifyed by SNOOPY (Minerals tweaks, Ancient Eggs, Some more XP)
{
	short sType;
	DWORD dwRegisterTime;
	int   iDynamicIndex, iSkillLevel, iResult, iItemID;
	class CItem * pItem;
	WORD  wWeaponType;

	if (m_pClientList[iClientH] == NULL)  return;
	m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->bGetDynamicObject(dX, dY, &sType, &dwRegisterTime, &iDynamicIndex);
	switch (sType) {
	case DEF_DYNAMICOBJECT_MINERAL1:
	case DEF_DYNAMICOBJECT_MINERAL2:
		wWeaponType = ((m_pClientList[iClientH]->m_sAppr2 & 0x0FF0) >> 4);
		if (wWeaponType == 25) 
		{}else return;
		//if ((m_pClientList[iClientH]->m_sAppr2 & 0xF000) == 0) return;		
		if (m_pClientList[iClientH]->m_IsPeaceMode == TRUE) return;	
		iSkillLevel = m_pClientList[iClientH]->m_cSkillMastery[0];		
		if (iSkillLevel == 0) break;
		if (m_pDynamicObjectList[iDynamicIndex] == NULL) break;

		iSkillLevel -= m_pMineral[ m_pDynamicObjectList[iDynamicIndex]->m_iV1 ]->m_iDifficulty;
		if (iSkillLevel <= 0) iSkillLevel = 1;
		iResult = iDice(1, 100);
		if (iResult <= iSkillLevel) {
			CalculateSSN_SkillIndex(iClientH, 0, 1);
			switch (m_pMineral[m_pDynamicObjectList[iDynamicIndex]->m_iV1]->m_cType) { 
				case 1: 
// Snoopy81-> Type1(20 -10%) have only Coals/Irons
					switch (iDice(1,4)) {
						case 1: 
						case 2: 
						case 3:    
							iItemID = 355; // Coal
							m_pClientList[iClientH]->m_iExpStock += iDice(1,3); 
							break; 
						case 4:    
							iItemID = 357; // IronOre
							m_pClientList[iClientH]->m_iExpStock += iDice(1,3); 
							break; 
					} 
					break; 

				case 2:
// Snoopy81->Type2(15 -15%) have blonde stone(1/400) and silver(1/200), but not often!
//           More XP
					switch (iDice(1,10)) {  
						case 1: 
						case 2: 
						case 3: 
						case 4: 
							iItemID = 355; // Coal
							m_pClientList[iClientH]->m_iExpStock += iDice(1,4); 
							break; 
						case 5:    
						case 6:   
						case 7: 
						case 8:  
							iItemID = 357; // IronOre
							m_pClientList[iClientH]->m_iExpStock += iDice(1,4); 
							break; 						
						case 9:
							if (iDice(1,40) == 2) { 
								iItemID = 507; // BlondeStone
								m_pClientList[iClientH]->m_iExpStock += iDice(3,4); 
							} 
							else { 
								iItemID = 355; // Coal
								m_pClientList[iClientH]->m_iExpStock += iDice(1,4); 
							}
							break;
						case 10:
							if (iDice(1,20) == 2) { 							
								iItemID = 356; // SilverNugget
								m_pClientList[iClientH]->m_iExpStock += iDice(2,4); 
							} 
							else { 
								iItemID = 357; // IronOre
								m_pClientList[iClientH]->m_iExpStock += iDice(1,4); 
							}
							break;
					} 
					break; 
// Snoopy81-> Type3(10 -20%) have Siver and Blonde stones equally(1/96)
				case 3: 
					switch (iDice(1,6)) { 
						case 1: 
							iItemID = 355; // Coal
							m_pClientList[iClientH]->m_iExpStock += iDice(1,6); 
							break; 
						case 2: 
						case 3:    
						case 4:    
						case 5: 
							iItemID = 357; // IronOre
							m_pClientList[iClientH]->m_iExpStock += iDice(1,6); 
							break; 
						case 6: 
							if (iDice(1,8) == 3) { 
								if (iDice(1,2) == 1) { 
									iItemID = 356; // SilverNugget
									m_pClientList[iClientH]->m_iExpStock += iDice(2,6); 
								} 
								else { 
									iItemID = 507; // BlondeStone // SNOOPY 357; // IronOre
									m_pClientList[iClientH]->m_iExpStock += iDice(3,6); 
								}
								break;
							} 
							else { 
								iItemID = 357; // IronOre
								m_pClientList[iClientH]->m_iExpStock += iDice(1,6); 
							} 
							break; 
					} 
					break; 

				case 4: 
// SNOOPY81-> Type4(8 -50%) Hardest rocks as in Revival (some more Mitrals)..
// Silver (1/15), Blonde(1/30), Gold(1/48), Mytral(1/275), AncientEgg(1/1920)	.
					
					switch (iDice(1,10)) { 
						case 1: 
							iItemID = 355; // Coal
							m_pClientList[iClientH]->m_iExpStock += iDice(1,8); 
							break;  
						case 2:  
							if (iDice(1,3) == 2) {
								iItemID = 507; // BlondeStone
								m_pClientList[iClientH]->m_iExpStock += iDice(3,8); 
							}
							else { 
								iItemID =  356; // SilverNugget
								m_pClientList[iClientH]->m_iExpStock += iDice(2,8); 
							}
							break;
						case 3:  
							if (iDice(1,4) == 3) 
							{	if (iDice(1,6) == 3) 
								{	if (iDice(1,6) == 3) 
									{	iItemID = 961;	//AncientEgg
										m_pClientList[iClientH]->m_iExpStock += iDice(50,8); 
									}else 
									{ 	iItemID = 508; // Mithral
										m_pClientList[iClientH]->m_iExpStock += iDice(10,8); 
									}
									break;
								}else 
								{	iItemID = 354; // GoldNugget
									m_pClientList[iClientH]->m_iExpStock += iDice(4,8); 
								}
								break;
							}else 
							{	iItemID = 355; // Coal
								m_pClientList[iClientH]->m_iExpStock += iDice(1,8); 
							} 
							break; 							
						case 4:    
						case 5:  
						case 6:    
						case 7:  
						case 8: 
						case 9:
						case 10:  
							iItemID = 357; // IronOre
							m_pClientList[iClientH]->m_iExpStock += iDice(1,8); 
							break; 
					}
					break;
//Type5 (6 -70%)
				case 5: 
					switch (iDice(1,19)) { 
						case 3: 
							iItemID = 352; // Sapphire
							m_pClientList[iClientH]->m_iExpStock += iDice(4,10); 
							break; 
						default: 
							iItemID = 358; // Crystal
							m_pClientList[iClientH]->m_iExpStock += iDice(2,10); 
							break; 
					} 
					break; 
//Type6 (4 -90%)
				case 6: 
					switch (iDice(1,5)) { 
						case 1: 
							if (iDice(1,6) == 3)  
							{	iItemID =  353; // Emerald 
								m_pClientList[iClientH]->m_iExpStock += iDice(4,15); 
							}else  
							{	iItemID =  358; // Crystal
								m_pClientList[iClientH]->m_iExpStock += iDice(2,15); 
							} 
							break; 
						case 2: 
							if (iDice(1,6) == 3)  
							{	iItemID =  352; // Saphire
								m_pClientList[iClientH]->m_iExpStock += iDice(4,15); 
							}else  
							{	iItemID =  358; // Crystal
								m_pClientList[iClientH]->m_iExpStock += iDice(2,15); 
							} 
							break; 
						case 3: 
							if (iDice(1,6) == 3)  
							{	iItemID =  351; // Ruby
								m_pClientList[iClientH]->m_iExpStock += iDice(4,15); 
							}else  
							{	iItemID =  358; // Crystal 
								m_pClientList[iClientH]->m_iExpStock += iDice(2,15); 
							} 
							break; 
						case 4: 
							iItemID =  358; // Crystal 
							m_pClientList[iClientH]->m_iExpStock += iDice(2,15); 
							break; 
						case 5: 
							if (iDice(1,12) == 3)  
							{	iItemID =  350; // Diamond
								m_pClientList[iClientH]->m_iExpStock += iDice(6,15); 
							}else  
							{	iItemID =  358; // Crystal
								m_pClientList[iClientH]->m_iExpStock += iDice(2,15); 
							} 
							break;
					} 
					break;
			} 

			pItem = new class CItem;
			if (_bInitItemAttr(pItem, iItemID) == FALSE) 
			{	delete pItem;
			}else 
			{	m_pMapList[ m_pClientList[iClientH]->m_cMapIndex ]->bSetItem(m_pClientList[iClientH]->m_sX, 
					m_pClientList[iClientH]->m_sY, pItem);
				SendEventToNearClient_TypeB(MSGID_EVENT_COMMON, DEF_COMMONTYPE_ITEMDROP, m_pClientList[iClientH]->m_cMapIndex,
					m_pClientList[iClientH]->m_sX, m_pClientList[iClientH]->m_sY,  
					pItem->m_sSprite, pItem->m_sSpriteFrame, pItem->m_cItemColor);
				// wsprintf(G_cTxt, "Mining Success: %d", iItemID); 
				// PutLogList(G_cTxt);
				switch (iItemID) {
				case 350: // diamond			
					wsprintf(G_cTxt, "(*) Mining : Char(%s) Skill(%d) Mined a Diamond"
					   , m_pClientList[iClientH]->m_cCharName
					   , m_pClientList[iClientH]->m_cSkillMastery[0]); 
				     PutLogList(G_cTxt); 
					 PutItemLogFileList(G_cTxt);
					 break;
				case 961: // Ancient EGG			
					// SNOOPY: Added Touch Effect on Ancient Eggs
					pItem->m_sTouchEffectType   = DEF_ITET_ID;
					pItem->m_sTouchEffectValue1 = iDice(1,100000);
					pItem->m_sTouchEffectValue2 = iDice(1,100000);
					SYSTEMTIME SysTime;
					char cTemp[256];
					GetLocalTime(&SysTime);
					ZeroMemory(cTemp, sizeof(cTemp));
					wsprintf(cTemp, "%d%2d",  (short)SysTime.wMonth, (short)SysTime.wDay);
					pItem->m_sTouchEffectValue3 = atoi(cTemp);						
					wsprintf(G_cTxt, "(*) Mining : Char(%s) Skill(%d) Mined a Ancient Egg"
					   , m_pClientList[iClientH]->m_cCharName
					   , m_pClientList[iClientH]->m_cSkillMastery[0]); 
				     PutLogList(G_cTxt); 
					 PutItemLogFileList(G_cTxt);
					 break;
				case 508: // Mythral					
					wsprintf(G_cTxt, "(*) Mining : Char(%s) Skill(%d) Mined a Mythral"
					   , m_pClientList[iClientH]->m_cCharName
					   , m_pClientList[iClientH]->m_cSkillMastery[0]); 
				     PutLogList(G_cTxt); 
					 PutItemLogFileList(G_cTxt);
					 break;
				default:
					 break;
				}
			}
			m_pMineral[m_pDynamicObjectList[iDynamicIndex]->m_iV1]->m_iRemain--;
			if (m_pMineral[m_pDynamicObjectList[iDynamicIndex]->m_iV1]->m_iRemain <= 0) {
				bDeleteMineral(m_pDynamicObjectList[iDynamicIndex]->m_iV1);
				delete m_pDynamicObjectList[iDynamicIndex];
				m_pDynamicObjectList[iDynamicIndex] = NULL;
			}
		}
		break;
	default: 
		break;
	}
}

BOOL CGame::bDeleteMineral(int iIndex)
{	int iDynamicIndex;
	DWORD dwTime;
	dwTime = timeGetTime();	
	if (m_pMineral[iIndex] == NULL) return FALSE;
	iDynamicIndex = m_pMineral[iIndex]->m_sDynamicObjectHandle;
	if (m_pDynamicObjectList[iDynamicIndex] == NULL) return FALSE;
	SendEventToNearClient_TypeB(MSGID_DYNAMICOBJECT, DEF_MSGTYPE_REJECT, m_pDynamicObjectList[iDynamicIndex]->m_cMapIndex, 
		                        m_pDynamicObjectList[iDynamicIndex]->m_sX, m_pDynamicObjectList[iDynamicIndex]->m_sY, 
								m_pDynamicObjectList[iDynamicIndex]->m_sType, iDynamicIndex, NULL);
	m_pMapList[m_pDynamicObjectList[iDynamicIndex]->m_cMapIndex]->SetDynamicObject(NULL, NULL, m_pDynamicObjectList[iDynamicIndex]->m_sX, m_pDynamicObjectList[iDynamicIndex]->m_sY, dwTime);
	m_pMapList[m_pMineral[iIndex]->m_cMapIndex]->SetTempMoveAllowedFlag(m_pDynamicObjectList[iDynamicIndex]->m_sX, m_pDynamicObjectList[iDynamicIndex]->m_sY, TRUE);
	m_pMapList[m_pMineral[iIndex]->m_cMapIndex]->m_iCurMineral--;
	delete m_pMineral[iIndex];
	m_pMineral[iIndex] = NULL;
	return TRUE;
}

void CGame::NpcTalkHandler(int iClientH, int iWho)
{
 char cRewardName[21], cTargetName[21];
 int iResMode, iQuestNum, iQuestType, iRewardType, iRewardAmount, iContribution, iX, iY, iRange, iTargetType, iTargetCount;

	iQuestNum = 0;
	ZeroMemory(cTargetName, sizeof(cTargetName));
	if (m_pClientList[iClientH] == NULL) return;
	switch (iWho) {
	case 1: break;
	case 2:	break;
	case 3:	break;
	case 4:
		iQuestNum = _iTalkToNpcResult_Cityhall(iClientH, &iQuestType, &iResMode, &iRewardType, &iRewardAmount, &iContribution, cTargetName, &iTargetType, &iTargetCount, &iX, &iY, &iRange); 
		break;
	case 5: break;
	case 6:	break;
	case 32: break;
	case 21: 
		iQuestNum = _iTalkToNpcResult_Guard(iClientH, &iQuestType, &iResMode, &iRewardType, &iRewardAmount, &iContribution, cTargetName, &iTargetType, &iTargetCount, &iX, &iY, &iRange); 
		if (iQuestNum >= 1000) return;
		break;
	}

	ZeroMemory(cRewardName, sizeof(cRewardName));
	if (iQuestNum > 0) {
		if (iRewardType > 1) {
			strcpy(cRewardName, m_pItemConfigList[iRewardType]->m_cName);
		}
		else {
			switch (iRewardType) {
			// SNOOPY Strange here !
			//case -10: strcpy(cRewardName, "¦µ¦F-í"); break;
			case -1: strcpy(cRewardName, "XP Points"); break;
			}
		}

		m_pClientList[iClientH]->m_iAskedQuest        = iQuestNum;
		m_pClientList[iClientH]->m_iQuestRewardType   = iRewardType;
		m_pClientList[iClientH]->m_iQuestRewardAmount = iRewardAmount;
	
		SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_NPCTALK, iQuestType, iResMode, iRewardAmount, cRewardName, iContribution,
			          iTargetType, iTargetCount, iX, iY, iRange, cTargetName);
	}
	else { // iQuestNum <= 0
		switch (iQuestNum) {
		case  0:	//  0  : Error code from ::_iTalkToNpcResult_Cityhall function
				SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_NPCTALK, (iWho+130), NULL, NULL, NULL, NULL);
				break;
		case -1:	// -1  : Quest not completed
		case -2:	// -2  : No quest obtained because asking in wrong map  
		case -3:    // -3  : Unused
		case -4:	// -4  : Wrong npc 
				SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_NPCTALK, abs(iQuestNum)+100, NULL, NULL, NULL, NULL); 
				break;
		case -5: 	// -5  : Normal return value ?
				break;
		}
	}
}

void CGame::CheckFireBluring(char cMapIndex, int sX, int sY)
{register int ix, iy, iItemNum;
 register short sSpr, sSprFrame;
 char  cItemColor;
 class CItem * pItem;

	for (ix = sX -1; ix <= sX +1; ix++)
	for (iy = sY -1; iy <= sY +1; iy++) 
	{	iItemNum = m_pMapList[cMapIndex]->iCheckItem(ix, iy);				
		switch (iItemNum) {
		case 355: 
			pItem = m_pMapList[cMapIndex]->pGetItem(ix, iy, &sSpr, &sSprFrame, &cItemColor);
			if (pItem != NULL) delete pItem;
			iAddDynamicObjectList(NULL, NULL, DEF_DYNAMICOBJECT_FIRE, cMapIndex, ix, iy, 6000);	
			SendEventToNearClient_TypeB(MSGID_EVENT_COMMON, DEF_COMMONTYPE_SETITEM, cMapIndex,
				                        ix, iy, sSpr, sSprFrame, cItemColor);
			break;
		}
	}
}

void CGame::AdminOrder_GetNpcStatus(int iClientH, char * pData, DWORD dwMsgSize)
{	char   seps[] = "= \t\n";
	char   * token, cBuff[256], cNpcName[256], cTileString[512];
	class  CStrTok * pStrTok;
	short sOwnerH;
	char  cOwnerType;	
	register int i;
	bool bFound = FALSE;
	if (m_pClientList[iClientH] == NULL) return;
	if ((dwMsgSize)	<= 0) return;
	if (m_pClientList[iClientH]->m_iAdminUserLevel < m_iAdminLevelGetNpcStatus) 
	{	SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_ADMINUSERLEVELLOW, NULL, NULL, NULL, NULL);
		return;
	}
	ZeroMemory(cBuff, sizeof(cBuff));
	ZeroMemory(G_cTxt, sizeof(G_cTxt));
	memcpy(cBuff, pData, dwMsgSize);
	pStrTok = new class CStrTok(cBuff, seps);	
	token = pStrTok->pGet();
	token = pStrTok->pGet();
	ZeroMemory(cNpcName, sizeof(cNpcName));
	if (token != NULL) 
	{	strcpy(cNpcName, token);
	}else // No npc name parsed so get the Tile info below the GM
	{	m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, m_pClientList[iClientH]->m_sX, m_pClientList[iClientH]->m_sY+1);
		ZeroMemory(cTileString, sizeof(cTileString));	
		if ((sOwnerH != NULL) && (cOwnerType == DEF_OWNERTYPE_NPC)) 
		{	wsprintf(cTileString, "%s (%d,%d) NPC: %s (%s) %dHP"
				, m_pClientList[iClientH]->m_cMapName
				, m_pClientList[iClientH]->m_sX
				, m_pClientList[iClientH]->m_sY +1
				, m_pNpcList[sOwnerH]->m_cName
				, m_pNpcList[sOwnerH]->m_cNpcName
				, m_pNpcList[sOwnerH]->m_iHP);
			ShowClientMsg(iClientH,  "Tile info", cTileString);
		}else if ((sOwnerH != NULL) && (cOwnerType == DEF_OWNERTYPE_PLAYER))
		{	wsprintf(cTileString, "%s (%d,%d) PC: %s %dHP"
				, m_pClientList[iClientH]->m_cMapName
				, m_pClientList[iClientH]->m_sX
				, m_pClientList[iClientH]->m_sY +1
				, m_pClientList[sOwnerH]->m_cCharName
				, m_pClientList[sOwnerH]->m_iHP );
			ShowClientMsg(iClientH,  "Tile info", cTileString);
		}else if (sOwnerH != NULL)
		{	wsprintf(cTileString, "%s (%d,%d) Unknown owner: %d, type:%d"
				, m_pClientList[iClientH]->m_cMapName
				, m_pClientList[iClientH]->m_sX
				, m_pClientList[iClientH]->m_sY +1
				, sOwnerH
				, cOwnerType );
			ShowClientMsg(iClientH,  "Tile info", cTileString);
		}
		m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetDeadOwner(&sOwnerH, &cOwnerType, m_pClientList[iClientH]->m_sX, m_pClientList[iClientH]->m_sY+1);
		ZeroMemory(cTileString, sizeof(cTileString));	
		if ((sOwnerH != NULL) && (cOwnerType == DEF_OWNERTYPE_NPC)) 
		{	wsprintf(cTileString, "%s (%d,%d) Dead NPC: %s (%s) %dHP"
				, m_pClientList[iClientH]->m_cMapName
				, m_pClientList[iClientH]->m_sX
				, m_pClientList[iClientH]->m_sY +1
				, m_pNpcList[sOwnerH]->m_cName
				, m_pNpcList[sOwnerH]->m_cNpcName
				, m_pNpcList[sOwnerH]->m_iHP);
			ShowClientMsg(iClientH,  "Tile info", cTileString);
		}else if ((sOwnerH != NULL) && (cOwnerType == DEF_OWNERTYPE_PLAYER))
		{	wsprintf(cTileString, "%s (%d,%d) Dead PC: %s %dHP"
				, m_pClientList[iClientH]->m_cMapName
				, m_pClientList[iClientH]->m_sX
				, m_pClientList[iClientH]->m_sY +1
				, m_pClientList[sOwnerH]->m_cCharName
				, m_pClientList[sOwnerH]->m_iHP );
			ShowClientMsg(iClientH,  "Tile info", cTileString);
		}
		ZeroMemory(cTileString, sizeof(cTileString));	 
		class CTile * pTile;
		pTile = (class CTile *)(m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_pTile + 
		                       (m_pClientList[iClientH]->m_sX) + (m_pClientList[iClientH]->m_sY +1)*m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_sSizeY);	

	
		if (pTile->m_pItem[0] != NULL)	
		{	wsprintf(cTileString, "%s (%d,%d) %d item(s): %s (n°%d)"
				, m_pClientList[iClientH]->m_cMapName
				, m_pClientList[iClientH]->m_sX
				, m_pClientList[iClientH]->m_sY +1
				, pTile->m_cTotalItem
				, pTile->m_pItem[0]->m_cName
				, pTile->m_pItem[0]->m_sIDnum);
			ShowClientMsg(iClientH,  "Tile info", cTileString);
		}
		ZeroMemory(cTileString, sizeof(cTileString));	
		if (pTile->m_sDynamicObjectType != NULL)
		{	wsprintf(cTileString, "%s (%d,%d) DynamicObject: %d"
				, m_pClientList[iClientH]->m_cMapName
				, m_pClientList[iClientH]->m_sX
				, m_pClientList[iClientH]->m_sY +1
				, pTile->m_sDynamicObjectType);
			ShowClientMsg(iClientH,  "Tile info", cTileString);		
		}
		ZeroMemory(cTileString, sizeof(cTileString));		
		wsprintf(cTileString, "%s (%d,%d) MveAlw(%d) TP(%d) Water(%d) Farm(%d) TmpMveAlw(%d) Occ(%d) Attr(0x%08X)"
			, m_pClientList[iClientH]->m_cMapName
			, m_pClientList[iClientH]->m_sX
			, m_pClientList[iClientH]->m_sY +1
			, pTile->m_bIsMoveAllowed
			, pTile->m_bIsTeleport
			, pTile->m_bIsWater
			, pTile->m_bIsFarm
			, pTile->m_bIsTempMoveAllowed
			, pTile->m_iOccupyStatus
			, pTile->m_iAttribute);
		ShowClientMsg(iClientH,  "Tile info", cTileString);	
		delete pStrTok;							
		// Admin Log
		wsprintf(G_cTxt, "Admin Order(%s): Get Tile status. \tAdminIP(%s)"
			, m_pClientList[iClientH]->m_cCharName
			, m_pClientList[iClientH]->m_cIPaddress);
		PutAdminLogFileList(G_cTxt);
		wsprintf(G_cTxt, "GM Order(%-10s): /gns (Tile Status)", m_pClientList[iClientH]->m_cCharName);
		bSendMsgToLS(MSGID_GAMEMASTERLOG, iClientH, FALSE, G_cTxt);						
		return;
	}
	delete pStrTok;
	for (i = 0; i < DEF_MAXNPCS; i++) // npc name is given (crim or I can't guess how ! )
	if ((m_pNpcList[i] != NULL) && (token != NULL))
	{	if (memcmp(m_pNpcList[i]->m_cName, cNpcName, 5) == 0) 
		{	SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_ADMINIFO, 1, i, NULL, NULL);
			// Admin Log	
			wsprintf(G_cTxt, "Admin Order(%s): Get npc status: by mob's individual name.\tAdminIP(%s)"
				, m_pClientList[iClientH]->m_cCharName
				, m_pClientList[iClientH]->m_cIPaddress);
			PutAdminLogFileList(G_cTxt);			
			wsprintf(G_cTxt, "GM Order(%-10s): /gns (by mob's individual name)", m_pClientList[iClientH]->m_cCharName);
			bSendMsgToLS(MSGID_GAMEMASTERLOG, iClientH, FALSE, G_cTxt);	
			return;
		}
	}
	// /gns by mob's type's name around the GM		
	register int ix, iy;
	for (iy = m_pClientList[iClientH]->m_sY - 4; iy <= m_pClientList[iClientH]->m_sY + 4; iy++)
	for (ix = m_pClientList[iClientH]->m_sX - 4; ix <= m_pClientList[iClientH]->m_sX + 4; ix++) 
	{	m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, ix, iy);
		if ((sOwnerH != NULL) && (cOwnerType == DEF_OWNERTYPE_NPC)) 
		{	if ((m_pNpcList[sOwnerH] != NULL) && (token != NULL))
			{	if (   (strcmp(m_pNpcList[sOwnerH]->m_cNpcName, cNpcName) == 0) 
					&& (m_pNpcList[sOwnerH]->m_cMapIndex == m_pClientList[iClientH]->m_cMapIndex))
				{	SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_ADMINIFO, 1, sOwnerH, NULL, NULL);						
					// Admin Log
					wsprintf(G_cTxt, "Admin Order(%s): Get npc status by mob's race.\tAdminIP(%s)"
						, m_pClientList[iClientH]->m_cCharName
						, m_pClientList[iClientH]->m_cIPaddress);
					PutAdminLogFileList(G_cTxt);
					wsprintf(G_cTxt, "GM Order(%-10s): /gns (by mob's race)", m_pClientList[iClientH]->m_cCharName);
					bSendMsgToLS(MSGID_GAMEMASTERLOG, iClientH, FALSE, G_cTxt);						
					return;
	}	}	}	}
	// Admin Log	
	wsprintf(G_cTxt, "Admin Order(%s): Get npc status (%s): Failed!\tAdminIP(%s)"
		, cNpcName
		, m_pClientList[iClientH]->m_cCharName
		, m_pClientList[iClientH]->m_cIPaddress);
	PutAdminLogFileList(G_cTxt);
	ZeroMemory(G_cTxt, sizeof(G_cTxt));
	wsprintf(G_cTxt, "/gns command failed !");
	SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_IPACCOUNTINFO, NULL, NULL, NULL, G_cTxt);
	return;	
}

int CGame::_iGetWeaponSkillType(int iClientH)
{
 WORD wWeaponType;

	if (m_pClientList[iClientH] == NULL) return 0;

	wWeaponType = ((m_pClientList[iClientH]->m_sAppr2 & 0x0FF0) >> 4);

	if (wWeaponType == 0) {
		return 5;
	}
	else if ((wWeaponType >= 1) && (wWeaponType <= 2)) {
		return 7;
	}
	else if ((wWeaponType > 2) && (wWeaponType < 20)) {
		if (wWeaponType == 7) 
			 return 9;
		else return 8;
	}
	else if ((wWeaponType >= 20) && (wWeaponType < 30)) {
		return 10;
	}
	else if ((wWeaponType >= 30) && (wWeaponType < 35)) {
		return 14;
	}
	else if ((wWeaponType >= 35) && (wWeaponType < 40)) {
		return 21	;
	}
	else if (wWeaponType >= 40) {
		return 6;
	}
	
	return 1;
}
static int ___iCAB5[]  = {0,0, 0,1,2}; // Hand Attack
static int ___iCAB6[]  = {0,0, 0,0,0}; // Archery, hammer             
static int ___iCAB7[]  = {0,0, 1,2,3}; // Short-Sword
static int ___iCAB8[]  = {0,0, 1,3,5}; // Long-Sword
static int ___iCAB9[]  = {0,0, 2,4,8}; // Fencing              
static int ___iCAB10[] = {0,0, 1,2,3}; // Axe-Attack, Staff
int CGame::iGetComboAttackBonus(int iSkill, int iComboCount)
{	if (iComboCount <= 1) return 0;
	if (iComboCount > 6) return 0;
	switch (iSkill) {
	case 5:
		return ___iCAB5[iComboCount];
		break;
	case 6:
		return ___iCAB6[iComboCount];
		break;
	case 7:
		return ___iCAB7[iComboCount];
		break;
	case 8:
		return ___iCAB8[iComboCount];
		break;
	case 9:
		return ___iCAB9[iComboCount];
		break;
	case 10:
		return ___iCAB10[iComboCount];
		break;
	case 14:
		return ___iCAB6[iComboCount];
		break;
	case 21:
		return ___iCAB10[iComboCount];
		break;
	}
	return 0;
}

void CGame::SetDownSkillIndexHandler(int iClientH, int iSkillIndex)
{	if (m_pClientList[iClientH] == NULL) return;
	if ((iSkillIndex < 0) || (iSkillIndex >= DEF_MAXSKILLTYPE)) return;
	if (m_pClientList[iClientH]->m_cSkillMastery[iSkillIndex] > 0)
		m_pClientList[iClientH]->m_iDownSkillIndex = iSkillIndex;
	SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_DOWNSKILLINDEXSET, m_pClientList[iClientH]->m_iDownSkillIndex, NULL, NULL, NULL);
}

BOOL CGame::_bDepleteDestTypeItemUseEffect(int iClientH, int dX, int dY, short sItemIndex, short sDestItemID)
{ BOOL bRet;
	if (m_pClientList[iClientH] == NULL) return FALSE;
	if ((sItemIndex < 0) || (sItemIndex >= DEF_MAXITEMS)) return FALSE;
	if (m_pClientList[iClientH]->m_pItemList[sItemIndex] == NULL) return FALSE;

	switch (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectType) {
	case DEF_ITEMEFFECTTYPE_OCCUPYFLAG:
		bRet = TRUE;
        if (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sTouchEffectType = DEF_ITET_UNIQUE_OWNER)
		{	if (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sTouchEffectValue1 != m_pClientList[iClientH]->m_sCharIDnum1) 
				bRet = FALSE;
			if (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sTouchEffectValue2 != m_pClientList[iClientH]->m_sCharIDnum2) 
				bRet = FALSE;
			if (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sTouchEffectValue3 != m_pClientList[iClientH]->m_sCharIDnum3) 
				bRet = FALSE;
		}
		if (bRet == TRUE)
		{	bRet =  __bSetOccupyFlag(m_pClientList[iClientH]->m_cMapIndex, dX, dY,
			                     m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectValue1,
				 				 m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemSpecEffectValue2, iClientH, FALSE);
		}
		if (bRet == TRUE) 
		{	GetExp(iClientH, (iDice(m_pClientList[iClientH]->m_iLevel, 10)));
		}else 
		{	SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_NOTFLAGSPOT, NULL, NULL, NULL, NULL);
		}
		return bRet;
	// crusade
	case DEF_ITEMEFFECTTYPE_CONSTRUCTIONKIT:
		bRet = __bSetConstructionKit(m_pClientList[iClientH]->m_cMapIndex, dX, dY, 
			                         m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectValue1,
				 				     m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectValue2, 
								     iClientH); 
		if (bRet == TRUE) {}else{}
		return bRet;	
	case DEF_ITEMEFFECTTYPE_DYE:
		if ((sDestItemID >= 0) && (sDestItemID < DEF_MAXITEMS)) 
		{	if (m_pClientList[iClientH]->m_pItemList[sDestItemID] != NULL) 
			{	if (   (m_pClientList[iClientH]->m_pItemList[sDestItemID]->m_cCategory > 9 ) 
					&& (m_pClientList[iClientH]->m_pItemList[sDestItemID]->m_cCategory < 13) ) 
				{	m_pClientList[iClientH]->m_pItemList[sDestItemID]->m_cItemColor = m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectValue1;
					SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_ITEMCOLORCHANGE, sDestItemID, m_pClientList[iClientH]->m_pItemList[sDestItemID]->m_cItemColor, NULL, NULL);
					return TRUE;
				}else  
				{	SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_ITEMCOLORCHANGE, sDestItemID, -1, NULL, NULL);
					return FALSE;
		}	}	}	
		break;
	case DEF_ITEMEFFECTTYPE_ARMORDYE:
		if ((sDestItemID >= 0) && (sDestItemID < DEF_MAXITEMS)) 
		{	if (m_pClientList[iClientH]->m_pItemList[sDestItemID] != NULL) 
			{	if (m_pClientList[iClientH]->m_pItemList[sDestItemID]->m_cCategory == 6) 
				{	m_pClientList[iClientH]->m_pItemList[sDestItemID]->m_cItemColor = m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectValue1;
					SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_ITEMCOLORCHANGE, sDestItemID, m_pClientList[iClientH]->m_pItemList[sDestItemID]->m_cItemColor, NULL, NULL);
					return TRUE;
				}else 
				{	SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_ITEMCOLORCHANGE, sDestItemID, -1, NULL, NULL);
					return FALSE;
		}	}	}	
		break;
	case DEF_ITEMEFFECTTYPE_FARMING:
		bRet = bPlantSeedBag(m_pClientList[iClientH]->m_cMapIndex, dX, dY,
			                         m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectValue1,
				 				     m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectValue2,
								     iClientH);
		return bRet;
	default:
		break;
	}
	return TRUE;
}
void CGame::SetSummonMobAction(int iClientH, int iMode, DWORD dwMsgSize, char *pData)
{register int i, iTargetIndex;
 char   seps[] = "= \t\n";
 char   * token, cTargetName[11], cBuff[256];
 class  CStrTok * pStrTok;
	if (m_pClientList[iClientH] == NULL) return;
	if (m_pClientList[iClientH]->m_cSide == 0) return;
	switch (iMode) {
	case 8: // Mobilize
		if (   (m_bIsHeldenianMode == TRUE)
			&& (m_pMapList[m_pClientList[iClientH]->m_cMapIndex] != NULL)
			&& (m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_bIsHeldenianMap == 1))
		{	iRecoverFollowers(iClientH, TRUE);
		}
		break;	
	case 0: // Free ¸
	case 1: // Hold ¸
		for (i = 0; i < DEF_MAXNPCS; i++)
		if (m_pNpcList[i] != NULL) 
		{	if (   (m_pNpcList[i]->m_iFollowOwnerIndex == iClientH) 
				&& ((m_pNpcList[i]->m_bIsSummoned == TRUE) || (m_pNpcList[i]->m_dwTamingTime != 0) )
				&& (m_pNpcList[i]->m_cFollowOwnerType == DEF_OWNERTYPE_PLAYER) ) 
			{	m_pNpcList[i]->m_iSummonControlMode = iMode;
				m_pNpcList[i]->m_bIsPermAttackMode  = FALSE;
				m_pNpcList[i]->m_cBehavior          = DEF_BEHAVIOR_MOVE;
				m_pNpcList[i]->m_sBehaviorTurnCount = 0;
				m_pNpcList[i]->m_iTargetIndex       = NULL;
			}
		}
		break;	
	case 2:	// target
		if ((dwMsgSize)	<= 0) return;
		memcpy(cBuff, pData, dwMsgSize);
		pStrTok = new class CStrTok(cBuff, seps);
		token = pStrTok->pGet();
		token = pStrTok->pGet();
   	
		iTargetIndex = 0;
		if (token != NULL) 
		{	if (strlen(token) > 10) 
				 memcpy(cTargetName, token, 10);
			else memcpy(cTargetName, token, strlen(token));
			for (i = 1; i < DEF_MAXCLIENTS; i++)
			{	if (   (m_pClientList[i] != NULL) 
					&& (memcmp(m_pClientList[i]->m_cCharName, cTargetName, 10) == 0) 
					&& (strcmp(m_pClientList[iClientH]->m_cMapName, m_pClientList[i]->m_cMapName) == 0 ) ) 
				{	iTargetIndex = i;
					goto SSMA_SKIPSEARCH;
				}
			}
		}
SSMA_SKIPSEARCH:;
		if (   (iTargetIndex != 0) && (m_pClientList[iTargetIndex]->m_cSide != 0) 
			&& (m_pClientList[iTargetIndex]->m_cSide != m_pClientList[iClientH]->m_cSide) ) 
		{	for (i = 0; i < DEF_MAXNPCS; i++)
			if (m_pNpcList[i] != NULL) 
			{	if (   (m_pNpcList[i]->m_cFollowOwnerType  == DEF_OWNERTYPE_PLAYER)
					&& ((m_pNpcList[i]->m_bIsSummoned == TRUE) || (m_pNpcList[i]->m_dwTamingTime != 0) )
					&& (m_pNpcList[i]->m_iFollowOwnerIndex == iClientH)) 
				{	m_pNpcList[i]->m_iSummonControlMode = iMode;
					m_pNpcList[i]->m_cBehavior          = DEF_BEHAVIOR_ATTACK;
					m_pNpcList[i]->m_sBehaviorTurnCount = 0;		
					m_pNpcList[i]->m_iTargetIndex       = iTargetIndex;
					m_pNpcList[i]->m_cTargetType        = DEF_OWNERTYPE_PLAYER;
					m_pNpcList[i]->m_bIsPermAttackMode  = TRUE;
				}
			}
		}
		delete pStrTok;
		break;
	}	
}
// v1.4311-3 GetFightzoneTicketHandler 
void CGame::GetFightzoneTicketHandler(int iClientH)
{int   iRet, iEraseReq, iMonth, iDay, iHour;
 char  * cp, cData[256], cItemName[21];
 class CItem * pItem;
 DWORD * dwp;
 short * sp;
 WORD  * wp; 
	if (m_pClientList[iClientH] == NULL) return;
	if (m_pClientList[iClientH]->m_iFightZoneTicketNumber <= 0)  
	{	m_pClientList[iClientH]->m_iFightzoneNumber  *= -1;
		SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_FIGHTZONERESERVE, -1, NULL, NULL, NULL);
		return;
	}
	ZeroMemory(cItemName, sizeof(cItemName));
	if (m_pClientList[iClientH]->m_iFightzoneNumber == 1) 
		strcpy(cItemName,"ArenaTicket") ;
	else  wsprintf(cItemName,"ArenaTicket(%d)",m_pClientList[iClientH]->m_iFightzoneNumber ) ;
	pItem = new class CItem;
	if (_bInitItemAttr(pItem, cItemName) == FALSE) 
	{	delete pItem;
		return;	
	}
	if (_bAddClientItemList(iClientH, pItem, &iEraseReq) == TRUE) 
	{	if (m_pClientList[iClientH]->m_iCurWeightLoad < 0) m_pClientList[iClientH]->m_iCurWeightLoad = 0;
		m_pClientList[iClientH]->m_iFightZoneTicketNumber = m_pClientList[iClientH]->m_iFightZoneTicketNumber -1 ;				
		pItem->m_sTouchEffectType   = DEF_ITET_DATE;		
		iMonth = m_pClientList[iClientH]->m_iReserveTime / 10000 ;
		iDay = (m_pClientList[iClientH]->m_iReserveTime - iMonth*10000) /100 ;
	    iHour = m_pClientList[iClientH]->m_iReserveTime - iMonth*10000 - iDay*100 ;
		pItem->m_sTouchEffectValue1 = iMonth ;
		pItem->m_sTouchEffectValue2 = iDay ;
		pItem->m_sTouchEffectValue3 = iHour ;
		wsprintf(G_cTxt, "(*) Get FIGHTZONETICKET : Char(%s) TICKENUMBER (%d)(%d)(%d)", m_pClientList[iClientH]->m_cCharName, pItem->m_sTouchEffectValue1, pItem->m_sTouchEffectValue2, pItem->m_sTouchEffectValue3	);		
		PutLogList(G_cTxt);
		PutLogEventFileList(G_cTxt);
		ZeroMemory(cData, sizeof(cData));
		dwp  = (DWORD *)(cData + DEF_INDEX4_MSGID);
		*dwp = MSGID_NOTIFY;
		wp   = (WORD *)(cData + DEF_INDEX2_MSGTYPE);
		*wp  = DEF_NOTIFY_ITEMOBTAINED;				
		cp = (char *)(cData + DEF_INDEX2_MSGTYPE + 2);
		*cp = 1;
		cp++;		
		memcpy(cp, pItem->m_cName, 20);
		cp += 20;				
		dwp  = (DWORD *)cp;
		*dwp = pItem->m_dwCount;
		cp += 4;				
		*cp = pItem->m_cItemType;
		cp++;				
		*cp = pItem->m_cEquipPos;
		cp++;				
		*cp = (char)0; 
		cp++;				
		sp  = (short *)cp;
		*sp = pItem->m_sLevelLimit;
		cp += 2;				
		*cp = pItem->m_cGenderLimit;
		cp++;				
		wp = (WORD *)cp;
		*wp = pItem->m_wCurLifeSpan;
		cp += 2;				
		wp = (WORD *)cp;
		*wp = pItem->m_wWeight;
		cp += 2;				
		sp  = (short *)cp;
		*sp = pItem->m_sSprite;
		cp += 2;				
		sp  = (short *)cp;
		*sp = pItem->m_sSpriteFrame;
		cp += 2;
		*cp = pItem->m_cItemColor;
		cp++;
		*cp = (char)pItem->m_sItemSpecEffectValue2; // v1.41 
		cp++;				
		dwp = (DWORD *)cp;
		*dwp = pItem->m_dwAttribute;
		cp += 4;													
		if (iEraseReq == 1) delete pItem;				
		iRet = m_pClientList[iClientH]->m_pXSock->iSendMsg(cData, 53);
		iCalcTotalWeight(iClientH);				
		switch (iRet) {
		case DEF_XSOCKEVENT_QUENEFULL:
		case DEF_XSOCKEVENT_SOCKETERROR:
		case DEF_XSOCKEVENT_CRITICALERROR:
		case DEF_XSOCKEVENT_SOCKETCLOSED:
			DeleteClient(iClientH, TRUE, TRUE);
			return;
		}
	}else 
	{	delete pItem;
		iCalcTotalWeight(iClientH);
		dwp  = (DWORD *)(cData + DEF_INDEX4_MSGID);
		*dwp = MSGID_NOTIFY;
		wp   = (WORD *)(cData + DEF_INDEX2_MSGTYPE);
		*wp  = DEF_NOTIFY_CANNOTCARRYMOREITEM;				
		iRet = m_pClientList[iClientH]->m_pXSock->iSendMsg(cData, 6);
		switch (iRet) {
			case DEF_XSOCKEVENT_QUENEFULL:
			case DEF_XSOCKEVENT_SOCKETERROR:
			case DEF_XSOCKEVENT_CRITICALERROR:
			case DEF_XSOCKEVENT_SOCKETCLOSED:
			DeleteClient(iClientH, TRUE, TRUE);
			return;
		}
	}		
}

//Hero Code by Zabuza
void CGame::GetHeroMantleHandler(int iClientH,int iItemID,char * pString) 
{ 
 int   i, iNum, iRet, iEraseReq; 
 char  * cp, cData[256], cItemName[21]; 
 class CItem * pItem; 
 DWORD * dwp; 
 short * sp; 
 WORD  * wp; 

	if (m_pClientList[iClientH] == NULL) return; 
	if (m_pClientList[iClientH]->m_iEnemyKillCount < 100) return; 
	// SNOOPY not possible for other than Ares/Elvines
	if (m_pClientList[iClientH]->m_cSide < 1) return; 
	if (m_pClientList[iClientH]->m_cSide > 2) return; 
	if (_iGetItemSpaceLeft(iClientH) == 0) {
		SendItemNotifyMsg(iClientH,	DEF_NOTIFY_CANNOTCARRYMOREITEM, NULL, NULL);
		return;
	}

	//Prevents a crash if item dosent exist
	if (m_pItemConfigList[iItemID] == NULL)  return;
 
	switch(iItemID) { 
	// Hero Cape
	case 400: //Aresden HeroCape
	case 401: //Elvine HeroCape
		if(m_pClientList[iClientH]->m_iEnemyKillCount<300) return; 
		m_pClientList[iClientH]->m_iEnemyKillCount -= 300; 
		break; 

	// Hero Helm
	case 403: //Aresden HeroHelm(M)
	case 404: //Aresden HeroHelm(W)
	case 405: //Elvine HeroHelm(M)
	case 406: //Elvine HeroHelm(W)
// SNOOPY81: Removed stupid Bug: EK was reduced if item was not get due to lack of conribution
		if((m_pClientList[iClientH]->m_iEnemyKillCount < 150)||(m_pClientList[iClientH]->m_iContribution < 20)) return; 
		m_pClientList[iClientH]->m_iEnemyKillCount -= 150; 
		m_pClientList[iClientH]->m_iContribution -= 20; 
		break; 

	// Hero Cap
	case 407: //Aresden HeroCap(M)
	case 408: //Aresden HeroCap(W)
	case 409: //Elvine HeroCap(M)
	case 410: //Elvine HeroCap(W)
		if((m_pClientList[iClientH]->m_iEnemyKillCount < 100)||(m_pClientList[iClientH]->m_iContribution < 20)) return;  
		m_pClientList[iClientH]->m_iEnemyKillCount -= 100; 
		m_pClientList[iClientH]->m_iContribution -= 20; 
		break;

	// Hero Armour
	case 411: //Aresden HeroArmour(M)
	case 412: //Aresden HeroArmour(W)
	case 413: //Elvine HeroArmour(M)
	case 414: //Elvine HeroArmour(W)
		if((m_pClientList[iClientH]->m_iEnemyKillCount < 300)||(m_pClientList[iClientH]->m_iContribution < 30)) return; 
		m_pClientList[iClientH]->m_iEnemyKillCount -= 300; 
		m_pClientList[iClientH]->m_iContribution -= 30; 
		break; 

	// Hero Robe
	case 415: //Aresden HeroRobe(M)
	case 416: //Aresden HeroRobe(W)
	case 417: //Elvine HeroRobe(M)
	case 418: //Elvine HeroRobe(W)
		if((m_pClientList[iClientH]->m_iEnemyKillCount < 200)||(m_pClientList[iClientH]->m_iContribution < 20)) return; 
		m_pClientList[iClientH]->m_iEnemyKillCount -= 200; 
		m_pClientList[iClientH]->m_iContribution -= 20; 
		break; 

	// Hero Hauberk
	case 419: //Aresden HeroHauberk(M)
	case 420: //Aresden HeroHauberk(W)
	case 421: //Elvine HeroHauberk(M)
	case 422: //Elvine HeroHauberk(W)
     if((m_pClientList[iClientH]->m_iEnemyKillCount < 100)||(m_pClientList[iClientH]->m_iContribution < 10)) return; 
     m_pClientList[iClientH]->m_iEnemyKillCount -= 100; 
     m_pClientList[iClientH]->m_iContribution -= 10; 
     break; 

  // Hero Leggings
  case 423: //Aresden HeroLeggings(M)
  case 424: //Aresden HeroLeggings(W)
  case 425: //Elvine HeroLeggings(M)
  case 426: //Elvine HeroLeggings(W)
     if((m_pClientList[iClientH]->m_iEnemyKillCount < 150)||(m_pClientList[iClientH]->m_iContribution < 15)) return; 
     m_pClientList[iClientH]->m_iEnemyKillCount -= 150; 
     m_pClientList[iClientH]->m_iContribution -= 15; 
     break; 
  default: 
     return;   break;   
} 

  ZeroMemory(cItemName, sizeof(cItemName)); 
  memcpy(cItemName,m_pItemConfigList[iItemID]->m_cName,20); 
  // ReqPurchaseItemHandler
  iNum = 1; 
  for (i = 1; i <= iNum; i++) 
  {  pItem = new class CItem; 
     if (_bInitItemAttr(pItem, cItemName) == FALSE) 
     {   delete pItem; 
     }else 
	 {	if (_bAddClientItemList(iClientH, pItem, &iEraseReq) == TRUE) 
		{  if (m_pClientList[iClientH]->m_iCurWeightLoad < 0) m_pClientList[iClientH]->m_iCurWeightLoad = 0;             
           wsprintf(G_cTxt, "(*) Get HeroItem : Char(%s) Player-EK(%d) Player-Contr(%d) Hero Obtained(%s)"
			   , m_pClientList[iClientH]->m_cCharName
			   , m_pClientList[iClientH]->m_iEnemyKillCount
			   , m_pClientList[iClientH]->m_iContribution
			   , cItemName); 
           PutLogList(G_cTxt); 
           PutLogFileList(G_cTxt); 

			// SNOOPY: Added special Item events Logging
		   wsprintf(G_cTxt, "PC(%s)\t Got Hero item (%s)\tEK Points(%d)\tContrib.(%d)\tIP(%s)"
				, m_pClientList[iClientH]->m_cCharName
				, cItemName
				, m_pClientList[iClientH]->m_iEnemyKillCount
				, m_pClientList[iClientH]->m_iContribution
				, m_pClientList[iClientH]->m_cIPaddress);
			PutItemLogFileList(G_cTxt);
           pItem->m_sTouchEffectType = DEF_ITET_UNIQUE_OWNER; 
           pItem->m_sTouchEffectValue1 = m_pClientList[iClientH]->m_sCharIDnum1; 
           pItem->m_sTouchEffectValue2 = m_pClientList[iClientH]->m_sCharIDnum2; 
           pItem->m_sTouchEffectValue3 = m_pClientList[iClientH]->m_sCharIDnum3; 

           dwp  = (DWORD *)(cData + DEF_INDEX4_MSGID); 
           *dwp = MSGID_NOTIFY; 
           wp   = (WORD *)(cData + DEF_INDEX2_MSGTYPE); 
           *wp  = DEF_NOTIFY_ITEMOBTAINED; 
           cp = (char *)(cData + DEF_INDEX2_MSGTYPE + 2); 
           *cp = 1; 
           cp++;             
           memcpy(cp, pItem->m_cName, 20); 
           cp += 20;             
           dwp  = (DWORD *)cp; 
           *dwp = pItem->m_dwCount; 
           cp += 4;             
           *cp = pItem->m_cItemType; 
           cp++;             
           *cp = pItem->m_cEquipPos; 
           cp++;             
           *cp = (char)0;
           cp++;             
           sp  = (short *)cp; 
           *sp = pItem->m_sLevelLimit; 
           cp += 2;             
           *cp = pItem->m_cGenderLimit; 
           cp++;             
           wp = (WORD *)cp; 
           *wp = pItem->m_wCurLifeSpan; 
           cp += 2;             
           wp = (WORD *)cp; 
           *wp = pItem->m_wWeight; 
           cp += 2;             
           sp  = (short *)cp; 
           *sp = pItem->m_sSprite; 
           cp += 2;             
           sp  = (short *)cp; 
           *sp = pItem->m_sSpriteFrame; 
           cp += 2; 
           *cp = pItem->m_cItemColor; 
           cp++; 
           *cp = (char)pItem->m_sItemSpecEffectValue2; // v1.41 
           cp++;             
           dwp = (DWORD *)cp; 
           *dwp = pItem->m_dwAttribute; 
           cp += 4; 
           /* 
           *cp = (char)(pItem->m_dwAttribute & 0x00000001); // Custom-Item??? ?? 
           cp++; 
           */                                  
           if (iEraseReq == 1) delete pItem;             
           iRet = m_pClientList[iClientH]->m_pXSock->iSendMsg(cData, 53);             
           iCalcTotalWeight(iClientH);             
           switch (iRet) { 
           case DEF_XSOCKEVENT_QUENEFULL: 
           case DEF_XSOCKEVENT_SOCKETERROR: 
           case DEF_XSOCKEVENT_CRITICALERROR: 
           case DEF_XSOCKEVENT_SOCKETCLOSED: 
              DeleteClient(iClientH, TRUE, TRUE); 
              return; 
           } 
           SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_ENEMYKILLS, m_pClientList[iClientH]->m_iEnemyKillCount, NULL, NULL, NULL); 
        }else 
        {  delete pItem; 
           iCalcTotalWeight(iClientH); 
           dwp  = (DWORD *)(cData + DEF_INDEX4_MSGID); 
           *dwp = MSGID_NOTIFY; 
           wp   = (WORD *)(cData + DEF_INDEX2_MSGTYPE); 
           *wp  = DEF_NOTIFY_CANNOTCARRYMOREITEM;             
           iRet = m_pClientList[iClientH]->m_pXSock->iSendMsg(cData, 6); 
           switch (iRet) { 
           case DEF_XSOCKEVENT_QUENEFULL: 
           case DEF_XSOCKEVENT_SOCKETERROR: 
           case DEF_XSOCKEVENT_CRITICALERROR: 
           case DEF_XSOCKEVENT_SOCKETCLOSED: 
              DeleteClient(iClientH, TRUE, TRUE); 
              return; 
           } 
        } 
     } 
   } 
}

void CGame::_SetItemPos(int iClientH, char *pData)
{
 char * cp, cItemIndex;
 short * sp, sX, sY;

	if (m_pClientList[iClientH] == NULL) return;
	
	cp = (char *)(pData + DEF_INDEX2_MSGTYPE + 2);
	cItemIndex = *cp;
	cp++;

	sp = (short *)cp;
	sX = *sp;
	cp += 2;

	sp = (short *)cp;
	sY = *sp;
	cp += 2;
	if (sY < -10) sY = -10; 
	if ((cItemIndex < 0) || (cItemIndex >= DEF_MAXITEMS)) return;
	if (m_pClientList[iClientH]->m_pItemList[cItemIndex] != NULL) 
	{	m_pClientList[iClientH]->m_ItemPosList[cItemIndex].x = sX;
		m_pClientList[iClientH]->m_ItemPosList[cItemIndex].y = sY;
	}
}

void CGame::CheckUniqueItemEquipment(int iClientH)
{	register int i, iDamage;
	if (m_pClientList[iClientH] == NULL) return;
	for (i = 0; i < DEF_MAXITEMS; i++) 
	if (m_pClientList[iClientH]->m_pItemList[i] != NULL) 
	{	if (    (m_pClientList[iClientH]->m_pItemList[i]->m_sTouchEffectType == DEF_ITET_UNIQUE_OWNER) 
			 && (m_pClientList[iClientH]->m_bIsItemEquipped[i] == TRUE) ) 
		{	// Touch Effect Type
			if ( (m_pClientList[iClientH]->m_pItemList[i]->m_sTouchEffectValue1 == m_pClientList[iClientH]->m_sCharIDnum1) &&
				 (m_pClientList[iClientH]->m_pItemList[i]->m_sTouchEffectValue2 == m_pClientList[iClientH]->m_sCharIDnum2) &&
				 (m_pClientList[iClientH]->m_pItemList[i]->m_sTouchEffectValue3 == m_pClientList[iClientH]->m_sCharIDnum3) ) 
			{}else 
			{	SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_ITEMRELEASED, m_pClientList[iClientH]->m_pItemList[i]->m_cEquipPos, i, NULL, NULL);
				ReleaseItemHandler(iClientH, i, TRUE);
				iDamage = iDice(10, 10);
				m_pClientList[iClientH]->m_iHP -= iDamage;
				if (m_pClientList[iClientH]->m_iHP <= 0) 
				{	ClientKilledHandler(iClientH, NULL, NULL, iDamage);
				}
			}
		}
	}
}

void CGame::_BWM_Init(int iClientH, char *pData)
{
	if (m_pClientList[iClientH] == NULL) return;
	m_pClientList[iClientH]->m_bIsBWMonitor = TRUE;
	wsprintf(G_cTxt, "(*) BWMonitor(%d) registered.", iClientH);
	PutLogList(G_cTxt);
}

void CGame::_BWM_Command_Shutup(char *pData)
{	// Shutup by BadWords monitoring
	char * cp, cName[11];
	register int i;
	cp = (char *)(pData + 16);
	ZeroMemory(cName, sizeof(cName));
	memcpy(cName, cp, 10);
	for (i = 1; i < DEF_MAXCLIENTS; i++) 
	if (m_pClientList[i] != NULL) 
	{	if (memcmp(m_pClientList[i]->m_cCharName, cName, 10) == 0) 
		{	m_pClientList[i]->m_iTimeLeft_ShutUp = 20*3*10; 
			SendNotifyMsg(NULL, i, DEF_NOTIFY_PLAYERSHUTUP, 20*3*10, NULL, NULL, cName);			
			// Admin Log 
			wsprintf(G_cTxt, "BWordMonitor shutup(%s %d)\tCharIP(%s)"
				, cName
				, 20*3*10
				, m_pClientList[i]->m_cIPaddress);
			PutAdminLogFileList(G_cTxt);
			return;
	}	}
}

void CGame::ExchangeItemHandler(int iClientH, short sItemIndex, int iAmount, short dX, short dY, WORD wObjectID, char *pItemName)
{
 short sOwnerH;
 char  cOwnerType;
 
	if (m_pClientList[iClientH] == NULL) return;
	if ((sItemIndex < 0) || (sItemIndex >= DEF_MAXITEMS)) return;
	if ((m_bAdminSecurity == TRUE) && (m_pClientList[iClientH]->m_iAdminUserLevel > 0)) return;
	if (m_pClientList[iClientH]->m_pItemList[sItemIndex] == NULL) return;
	if (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_dwCount < iAmount) return;
	if (m_pClientList[iClientH]->m_bIsOnWaitingProcess == TRUE) return;
	if (m_pClientList[iClientH]->m_bIsExchangeMode == TRUE) return;
	if (wObjectID >= DEF_MAXCLIENTS) return;
	m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, dX, dY);
	if ((sOwnerH != NULL) && (cOwnerType == DEF_OWNERTYPE_PLAYER)) 
	{	if ((m_bAdminSecurity == TRUE) && (m_pClientList[sOwnerH]->m_iAdminUserLevel > 0))
		{	return;
		}

		if (wObjectID != NULL) 
		{	if (wObjectID < 10000) 
			{	if (m_pClientList[wObjectID] != NULL) 
				{	if ((WORD)sOwnerH != wObjectID) sOwnerH = NULL;
				}
			}
			else sOwnerH = NULL;
		}
		
		if ((sOwnerH == NULL) || (m_pClientList[sOwnerH] == NULL)) 
		{	_ClearExchangeStatus(iClientH); 
		}else 
		{	if ((m_pClientList[sOwnerH]->m_bIsExchangeMode == TRUE) 
				//|| (m_pClientList[sOwnerH]->m_sAppr2 & 0xF000) 
				|| (m_pClientList[iClientH]->m_IsPeaceMode == FALSE)
				|| (m_pMapList[m_pClientList[sOwnerH]->m_cMapIndex]->m_bIsFightZone == TRUE)) 
			{	_ClearExchangeStatus(iClientH);
			}else 
			{	m_pClientList[iClientH]->m_bIsExchangeMode = TRUE;
				m_pClientList[iClientH]->m_iExchangeH = sOwnerH;
				ZeroMemory(m_pClientList[iClientH]->m_cExchangeName, sizeof(m_pClientList[iClientH]->m_cExchangeName));
				strcpy(m_pClientList[iClientH]->m_cExchangeName, m_pClientList[sOwnerH]->m_cCharName);
				//Clear items in the list
				m_pClientList[iClientH]->iExchangeCount = 0;
				m_pClientList[sOwnerH]->iExchangeCount = 0;
				for(int i=0; i<4 ; i++)
				{	//Clear the trader
					ZeroMemory(m_pClientList[iClientH]->m_cExchangeItemName[i], sizeof(m_pClientList[iClientH]->m_cExchangeItemName[i]));
					m_pClientList[iClientH]->m_cExchangeItemIndex[i] = -1;
					m_pClientList[iClientH]->m_iExchangeItemAmount[i] = 0;
					//Clear the guy we're trading with
					ZeroMemory(m_pClientList[sOwnerH]->m_cExchangeItemName[i], sizeof(m_pClientList[sOwnerH]->m_cExchangeItemName[i]));
					m_pClientList[sOwnerH]->m_cExchangeItemIndex[i] = -1;
					m_pClientList[sOwnerH]->m_iExchangeItemAmount[i] = 0;
				}
				m_pClientList[iClientH]->m_cExchangeItemIndex[m_pClientList[iClientH]->iExchangeCount]  = (char)sItemIndex;
				m_pClientList[iClientH]->m_iExchangeItemAmount[m_pClientList[iClientH]->iExchangeCount] = iAmount;

				//ZeroMemory(m_pClientList[iClientH]->m_cExchangeItemName, sizeof(m_pClientList[iClientH]->m_cExchangeItemName));
				memcpy(m_pClientList[iClientH]->m_cExchangeItemName[m_pClientList[iClientH]->iExchangeCount], m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cName, 20);
				
				m_pClientList[sOwnerH]->m_bIsExchangeMode  = TRUE;
				m_pClientList[sOwnerH]->m_iExchangeH = iClientH;
				ZeroMemory(m_pClientList[sOwnerH]->m_cExchangeName, sizeof(m_pClientList[sOwnerH]->m_cExchangeName));
				strcpy(m_pClientList[sOwnerH]->m_cExchangeName, m_pClientList[iClientH]->m_cCharName);

				m_pClientList[iClientH]->iExchangeCount++;
				SendNotifyMsg(iClientH, iClientH, DEF_NOTIFY_OPENEXCHANGEWINDOW, sItemIndex+1000, m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sSprite, 
				              m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sSpriteFrame, m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cName, iAmount, m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cItemColor,
							  m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_wCurLifeSpan,
							  m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_wMaxLifeSpan,
							  m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemSpecEffectValue2 +100,
							  m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_dwAttribute);

				SendNotifyMsg(iClientH, sOwnerH, DEF_NOTIFY_OPENEXCHANGEWINDOW, sItemIndex, m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sSprite, 
				              m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sSpriteFrame, m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cName, iAmount, m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cItemColor,
							  m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_wCurLifeSpan,
							  m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_wMaxLifeSpan,
							  m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemSpecEffectValue2 +100,
							  m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_dwAttribute);
			}
		}
	}else 
	{	_ClearExchangeStatus(iClientH);
	}
}

void CGame::SetExchangeItem(int iClientH, int iItemIndex, int iAmount)
{ int iExH;
	if (m_pClientList[iClientH] == NULL) return;
	if (m_pClientList[iClientH]->m_bIsOnWaitingProcess == TRUE) return;
	if (m_pClientList[iClientH]->iExchangeCount > 4) return;	//only 4 items trade
	//no admin trade
	if ((m_bAdminSecurity == TRUE) && (m_pClientList[iClientH]->m_iAdminUserLevel > 0))
	{	_ClearExchangeStatus(m_pClientList[iClientH]->m_iExchangeH);
		_ClearExchangeStatus(iClientH);
	}
	// Avatar: no exchange... DEF_ITEMEFFECTTYPE_EVENT_ITEMDROP
	if (   (m_bIsAvatarMode == TRUE)
		&& (m_iPLmapIndex != -1)
		&& (m_iAvatarMessenger == iClientH)
		&& (m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sItemEffectType == DEF_ITEMEFFECTTYPE_EVENT_ITEMDROP))
	{	DWORD dwGUID;	
		memcpy(& dwGUID, &m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sItemSpecEffectValue1, 4);				
		if ( dwGUID == m_dwAvatarGUID) 
		{	_ClearExchangeStatus(m_pClientList[iClientH]->m_iExchangeH);
			_ClearExchangeStatus(iClientH);	
	}	}

	if ((m_pClientList[iClientH]->m_bIsExchangeMode == TRUE) && (m_pClientList[iClientH]->m_iExchangeH != NULL)) 
	{	iExH = m_pClientList[iClientH]->m_iExchangeH;		
		if (   (m_pClientList[iExH] == NULL) 
			|| (memcmp(m_pClientList[iClientH]->m_cExchangeName, m_pClientList[iExH]->m_cCharName, 10) != 0) ) 
		{}else 
		{	if ((iItemIndex < 0) || (iItemIndex >= DEF_MAXITEMS)) return;
			if (m_pClientList[iClientH]->m_pItemList[iItemIndex] == NULL) return;
			if (m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwCount < iAmount) return;
			if (   (m_pClientList[iClientH]->m_bIsExchangeConfirm == TRUE)
				|| (m_pClientList[iExH]->m_bIsExchangeConfirm == TRUE))
			{	// If someone as alreaddy accepted, no more change allowed...
				_ClearExchangeStatus(iExH);
				_ClearExchangeStatus(iClientH);
				return;
			}
			//No Duplicate items
			for(int i=0; i<m_pClientList[iClientH]->iExchangeCount;i++)
			{	if (m_pClientList[iClientH]->m_cExchangeItemIndex[i] == (char)iItemIndex) 
				{	_ClearExchangeStatus(iExH);
					_ClearExchangeStatus(iClientH);
					return;
				}
			}
			m_pClientList[iClientH]->m_cExchangeItemIndex[m_pClientList[iClientH]->iExchangeCount]  = (char)iItemIndex;
			m_pClientList[iClientH]->m_iExchangeItemAmount[m_pClientList[iClientH]->iExchangeCount] = iAmount;

			//ZeroMemory(m_pClientList[iClientH]->m_cExchangeItemName, sizeof(m_pClientList[iClientH]->m_cExchangeItemName));
			memcpy(m_pClientList[iClientH]->m_cExchangeItemName[m_pClientList[iClientH]->iExchangeCount], m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_cName, 20);

			//m_pClientList[iClientH]->m_cExchangeItemIndex  = iItemIndex;
			//m_pClientList[iClientH]->m_iExchangeItemAmount = iAmount;
			//ZeroMemory(m_pClientList[iClientH]->m_cExchangeItemName, sizeof(m_pClientList[iClientH]->m_cExchangeItemName));
			//memcpy(m_pClientList[iClientH]->m_cExchangeItemName, m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_cName, 20);
			
			m_pClientList[iClientH]->iExchangeCount++;
			SendNotifyMsg(iClientH, iClientH, DEF_NOTIFY_SETEXCHANGEITEM, iItemIndex+1000, m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sSprite,
				          m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sSpriteFrame, m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_cName, iAmount, m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_cItemColor,
						  m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_wCurLifeSpan,
						  m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_wMaxLifeSpan,
						  m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sItemSpecEffectValue2 +100,
						  m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwAttribute); 

			SendNotifyMsg(iClientH, iExH, DEF_NOTIFY_SETEXCHANGEITEM, iItemIndex, m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sSprite,
				          m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sSpriteFrame, m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_cName, iAmount, m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_cItemColor,
						  m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_wCurLifeSpan,
						  m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_wMaxLifeSpan,
						  m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sItemSpecEffectValue2 +100,
						  m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwAttribute);
		}
	}
}

void CGame::ConfirmExchangeItem(int iClientH)
{ int iExH;
  int iItemWeightA, iItemWeightB, iWeightLeftA, iWeightLeftB, iAmountLeft;
  class CItem * pItemA[4], * pItemB[4], * pItemAcopy[4], * pItemBcopy[4]; 
	if (m_pClientList[iClientH] == NULL) return;
	if (m_pClientList[iClientH]->m_bIsOnWaitingProcess == TRUE) return;
	if ((m_bAdminSecurity == TRUE) && (m_pClientList[iClientH]->m_iAdminUserLevel > 0)) return;		

	if ((m_pClientList[iClientH]->m_bIsExchangeMode == TRUE) && (m_pClientList[iClientH]->m_iExchangeH != NULL)) 
	{	iExH = m_pClientList[iClientH]->m_iExchangeH;	
		if (iClientH == iExH) return;
		if (m_pClientList[iExH] != NULL) 
		{	if (    (memcmp(m_pClientList[iClientH]->m_cExchangeName, m_pClientList[iExH]->m_cCharName, 10) != 0)
				|| (m_pClientList[iExH]->m_bIsExchangeMode != TRUE) 
				|| (memcmp(m_pClientList[iExH]->m_cExchangeName, m_pClientList[iClientH]->m_cCharName, 10) != 0) ) 
			{	_ClearExchangeStatus(iClientH);
				_ClearExchangeStatus(iExH);
				return;
			}else 
			{	m_pClientList[iClientH]->m_bIsExchangeConfirm = TRUE;
				if (m_pClientList[iExH]->m_bIsExchangeConfirm == TRUE) 
				{	//Check all items
					for(int i=0; i<m_pClientList[iClientH]->iExchangeCount; i++)
					{	if (   (m_pClientList[iClientH]->m_pItemList[m_pClientList[iClientH]->m_cExchangeItemIndex[i]] == NULL) 
							|| (memcmp(m_pClientList[iClientH]->m_pItemList[m_pClientList[iClientH]->m_cExchangeItemIndex[i]]->m_cName, m_pClientList[iClientH]->m_cExchangeItemName[i], 20) != 0)) 
						{	_ClearExchangeStatus(iClientH);
							_ClearExchangeStatus(iExH);
							return;
						}
					}
					for(i=0; i<m_pClientList[iExH]->iExchangeCount; i++)
					{	if (   (m_pClientList[iExH]->m_pItemList[m_pClientList[iExH]->m_cExchangeItemIndex[i]] == NULL) 
							|| (memcmp(m_pClientList[iExH]->m_pItemList[m_pClientList[iExH]->m_cExchangeItemIndex[i]]->m_cName, m_pClientList[iExH]->m_cExchangeItemName[i], 20) != 0)) 
						{	_ClearExchangeStatus(iClientH);
							_ClearExchangeStatus(iExH);
							return;
						}
					}
					iWeightLeftA = _iCalcMaxLoad(iClientH) - iCalcTotalWeight(iClientH);
					iWeightLeftB = _iCalcMaxLoad(iExH) - iCalcTotalWeight(iExH);
					//Calculate weight for items
					iItemWeightA = 0;
					for(i=0; i<m_pClientList[iClientH]->iExchangeCount; i++)
					{	iItemWeightA = iGetItemWeight(m_pClientList[iClientH]->m_pItemList[m_pClientList[iClientH]->m_cExchangeItemIndex[i]],
							m_pClientList[iClientH]->m_iExchangeItemAmount[i]);
					}
					iItemWeightB = 0;
					for(i=0; i<m_pClientList[iExH]->iExchangeCount; i++)
					{	iItemWeightB = iGetItemWeight(m_pClientList[iExH]->m_pItemList[m_pClientList[iExH]->m_cExchangeItemIndex[i]],
							m_pClientList[iExH]->m_iExchangeItemAmount[i]);
					}
					//See if the other person can take the item weightload
					if ((iWeightLeftA < iItemWeightB) || (iWeightLeftB < iItemWeightA)) 
					{	_ClearExchangeStatus(iClientH);
						_ClearExchangeStatus(iExH);
						return;
					}
					for(i=0; i<m_pClientList[iClientH]->iExchangeCount; i++)
					{	if (   (m_pClientList[iClientH]->m_pItemList[m_pClientList[iClientH]->m_cExchangeItemIndex[i]]->m_cItemType == DEF_ITEMTYPE_CONSUME) 
							|| (m_pClientList[iClientH]->m_pItemList[m_pClientList[iClientH]->m_cExchangeItemIndex[i]]->m_cItemType == DEF_ITEMTYPE_ARROW) ) 
						{	if (m_pClientList[iClientH]->m_iExchangeItemAmount[i] > m_pClientList[iClientH]->m_pItemList[m_pClientList[iClientH]->m_cExchangeItemIndex[i]]->m_dwCount) 
							{	_ClearExchangeStatus(iClientH);
								_ClearExchangeStatus(iExH);
								return;		
							}
							pItemA[i] = new class CItem;
							_bInitItemAttr(pItemA[i], m_pClientList[iClientH]->m_pItemList[m_pClientList[iClientH]->m_cExchangeItemIndex[i]]->m_cName);
							pItemA[i]->m_dwCount = m_pClientList[iClientH]->m_iExchangeItemAmount[i];
							pItemAcopy[i] = new class CItem;
							_bInitItemAttr(pItemAcopy[i], m_pClientList[iClientH]->m_pItemList[m_pClientList[iClientH]->m_cExchangeItemIndex[i]]->m_cName);
							bCopyItemContents(pItemAcopy[i], pItemA[i]);
							pItemAcopy[i]->m_dwCount = m_pClientList[iClientH]->m_iExchangeItemAmount[i];
						}else 
						{	pItemA[i] = (class CItem *)m_pClientList[iClientH]->m_pItemList[m_pClientList[iClientH]->m_cExchangeItemIndex[i]];
							pItemA[i]->m_dwCount = m_pClientList[iClientH]->m_iExchangeItemAmount[i];
							pItemAcopy[i] = new class CItem;
							_bInitItemAttr(pItemAcopy[i], m_pClientList[iClientH]->m_pItemList[m_pClientList[iClientH]->m_cExchangeItemIndex[i]]->m_cName);
							bCopyItemContents(pItemAcopy[i], pItemA[i]);
							pItemAcopy[i]->m_dwCount = m_pClientList[iClientH]->m_iExchangeItemAmount[i];
						}
					}
					for(i=0; i<m_pClientList[iExH]->iExchangeCount; i++)
					{	if (   (m_pClientList[iExH]->m_pItemList[m_pClientList[iExH]->m_cExchangeItemIndex[i]]->m_cItemType == DEF_ITEMTYPE_CONSUME) 
							|| (m_pClientList[iExH]->m_pItemList[m_pClientList[iExH]->m_cExchangeItemIndex[i]]->m_cItemType == DEF_ITEMTYPE_ARROW) ) 
						{	if (m_pClientList[iExH]->m_iExchangeItemAmount[i] > m_pClientList[iExH]->m_pItemList[m_pClientList[iExH]->m_cExchangeItemIndex[i]]->m_dwCount) 
							{	_ClearExchangeStatus(iClientH);
								_ClearExchangeStatus(iExH);
								return;		
							}
							pItemB[i] = new class CItem;
							_bInitItemAttr(pItemB[i], m_pClientList[iExH]->m_pItemList[m_pClientList[iExH]->m_cExchangeItemIndex[i]]->m_cName);
							pItemB[i]->m_dwCount = m_pClientList[iExH]->m_iExchangeItemAmount[i];
							pItemBcopy[i] = new class CItem;
							_bInitItemAttr(pItemBcopy[i], m_pClientList[iExH]->m_pItemList[m_pClientList[iExH]->m_cExchangeItemIndex[i]]->m_cName);
							bCopyItemContents(pItemBcopy[i], pItemB[i]);
							pItemBcopy[i]->m_dwCount = m_pClientList[iExH]->m_iExchangeItemAmount[i];
						}else 
						{	pItemB[i] = (class CItem *)m_pClientList[iExH]->m_pItemList[m_pClientList[iExH]->m_cExchangeItemIndex[i]];
							pItemB[i]->m_dwCount = m_pClientList[iExH]->m_iExchangeItemAmount[i];
							pItemBcopy[i] = new class CItem;
							_bInitItemAttr(pItemBcopy[i], m_pClientList[iExH]->m_pItemList[m_pClientList[iExH]->m_cExchangeItemIndex[i]]->m_cName);
							bCopyItemContents(pItemBcopy[i], pItemB[i]);
							pItemBcopy[i]->m_dwCount = m_pClientList[iExH]->m_iExchangeItemAmount[i];
						}
					}
					for(i=0; i<m_pClientList[iExH]->iExchangeCount; i++)
					{	bAddItem(iClientH, pItemB[i], NULL);
						_bItemLog(DEF_ITEMLOG_EXCHANGE, iExH, iClientH, pItemBcopy[i]);
						delete pItemBcopy[i];
						pItemBcopy[i] = NULL;
						if (   (m_pClientList[iExH]->m_pItemList[m_pClientList[iExH]->m_cExchangeItemIndex[i]]->m_cItemType == DEF_ITEMTYPE_CONSUME) 
							|| (m_pClientList[iExH]->m_pItemList[m_pClientList[iExH]->m_cExchangeItemIndex[i]]->m_cItemType == DEF_ITEMTYPE_ARROW) ) 
						{	iAmountLeft = (int)m_pClientList[iExH]->m_pItemList[m_pClientList[iExH]->m_cExchangeItemIndex[i]]->m_dwCount - m_pClientList[iExH]->m_iExchangeItemAmount[i];
							if (iAmountLeft < 0) iAmountLeft = 0;	
							SetItemCount(iExH, m_pClientList[iExH]->m_cExchangeItemIndex[i], iAmountLeft);
							// m_pClientList[iExH]->m_pItemList[m_pClientList[iExH]->m_cExchangeItemIndex]->m_cName, iAmountLeft);
						}else 
						{	ReleaseItemHandler(iExH, m_pClientList[iExH]->m_cExchangeItemIndex[i], TRUE);
							SendNotifyMsg(NULL, iExH, DEF_NOTIFY_GIVEITEMFIN_ERASEITEM, m_pClientList[iExH]->m_cExchangeItemIndex[i], m_pClientList[iExH]->m_iExchangeItemAmount[i], NULL, m_pClientList[iClientH]->m_cCharName);
							m_pClientList[iExH]->m_pItemList[m_pClientList[iExH]->m_cExchangeItemIndex[i]] = NULL;
						}
					}
					for(i=0; i<m_pClientList[iClientH]->iExchangeCount; i++)
					{	bAddItem(iExH, pItemA[i], NULL);
						_bItemLog(DEF_ITEMLOG_EXCHANGE, iClientH, iExH, pItemAcopy[i]);
						delete pItemAcopy[i];
						pItemAcopy[i] = NULL;
						if (   (m_pClientList[iClientH]->m_pItemList[m_pClientList[iClientH]->m_cExchangeItemIndex[i]]->m_cItemType == DEF_ITEMTYPE_CONSUME) 
							|| (m_pClientList[iClientH]->m_pItemList[m_pClientList[iClientH]->m_cExchangeItemIndex[i]]->m_cItemType == DEF_ITEMTYPE_ARROW) ) 
						{	iAmountLeft = (int)m_pClientList[iClientH]->m_pItemList[m_pClientList[iClientH]->m_cExchangeItemIndex[i]]->m_dwCount - m_pClientList[iClientH]->m_iExchangeItemAmount[i];
							if (iAmountLeft < 0) iAmountLeft = 0;	 
							SetItemCount(iClientH, m_pClientList[iClientH]->m_cExchangeItemIndex[i], iAmountLeft);
								// m_pClientList[iClientH]->m_pItemList[m_pClientList[iClientH]->m_cExchangeItemIndex]->m_cName, iAmountLeft);
						}else 
						{	ReleaseItemHandler(iClientH, m_pClientList[iClientH]->m_cExchangeItemIndex[i], TRUE);
							SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_GIVEITEMFIN_ERASEITEM, m_pClientList[iClientH]->m_cExchangeItemIndex[i], m_pClientList[iClientH]->m_iExchangeItemAmount[i], NULL, m_pClientList[iExH]->m_cCharName);
							m_pClientList[iClientH]->m_pItemList[m_pClientList[iClientH]->m_cExchangeItemIndex[i]] = NULL;
						}
					}
					m_pClientList[iClientH]->m_bIsExchangeMode = FALSE;
					m_pClientList[iClientH]->m_bIsExchangeConfirm = FALSE;
					ZeroMemory(m_pClientList[iClientH]->m_cExchangeName, sizeof(m_pClientList[iClientH]->m_cExchangeName));
					m_pClientList[iClientH]->m_iExchangeH = NULL;
					m_pClientList[iClientH]->iExchangeCount = 0;
					m_pClientList[iExH]->m_bIsExchangeMode = FALSE;
					m_pClientList[iExH]->m_bIsExchangeConfirm = FALSE;
					ZeroMemory(m_pClientList[iExH]->m_cExchangeName, sizeof(m_pClientList[iExH]->m_cExchangeName));
					m_pClientList[iExH]->m_iExchangeH = NULL;
					m_pClientList[iExH]->iExchangeCount = 0;
					for(i=0;i<4;i++)
					{	m_pClientList[iClientH]->m_cExchangeItemIndex[i] = -1;
						m_pClientList[iExH]->m_cExchangeItemIndex[i] = -1;
					}
					SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_EXCHANGEITEMCOMPLETE, NULL, NULL, NULL, NULL);
					SendNotifyMsg(NULL, iExH,     DEF_NOTIFY_EXCHANGEITEMCOMPLETE, NULL, NULL, NULL, NULL);
					iCalcTotalWeight(iClientH);
					iCalcTotalWeight(iExH);
					return;
				}else // other client has not yet confirmed
				{}
			}
		}else 
		{	_ClearExchangeStatus(iClientH);
			return;
		}
	}
}

int CGame::_iGetItemSpaceLeft(int iClientH)
{
 int i, iTotalItem;

	iTotalItem = 0;
	for (i = 0; i < DEF_MAXITEMS; i++) 
	if (m_pClientList[iClientH]->m_pItemList[i] != NULL) iTotalItem++;

	return (DEF_MAXITEMS - iTotalItem);
}

BOOL CGame::bAddItem(int iClientH, CItem * pItem, char cMode)
{char * cp, cData[256];
 DWORD * dwp;
 WORD  * wp;
 short * sp;
 int iRet, iEraseReq;
	ZeroMemory(cData, sizeof(cData));
	if (_bAddClientItemList(iClientH, pItem, &iEraseReq) == TRUE) 
	{	dwp  = (DWORD *)(cData + DEF_INDEX4_MSGID);
		*dwp = MSGID_NOTIFY;
		wp   = (WORD *)(cData + DEF_INDEX2_MSGTYPE);
		*wp  = DEF_NOTIFY_ITEMOBTAINED;		
		cp = (char *)(cData + DEF_INDEX2_MSGTYPE + 2);		
		*cp = 1;
		cp++;		
		memcpy(cp, pItem->m_cName, 20);
		cp += 20;		
		dwp  = (DWORD *)cp;
		*dwp = pItem->m_dwCount;
		cp += 4;		
		*cp = pItem->m_cItemType;
		cp++;		
		*cp = pItem->m_cEquipPos;
		cp++;		
		*cp = (char)0; 
		cp++;		
		sp  = (short *)cp;
		*sp = pItem->m_sLevelLimit;
		cp += 2;		
		*cp = pItem->m_cGenderLimit;
		cp++;		
		wp = (WORD *)cp;
		*wp = pItem->m_wCurLifeSpan;
		cp += 2;		
		wp = (WORD *)cp;
		*wp = pItem->m_wWeight;
		cp += 2;		
		sp  = (short *)cp;
		*sp = pItem->m_sSprite;
		cp += 2;		
		sp  = (short *)cp;
		*sp = pItem->m_sSpriteFrame;
		cp += 2;		
		*cp = pItem->m_cItemColor;
		cp++;
		*cp = (char)pItem->m_sItemSpecEffectValue2; // v1.41 
		cp++;		
		dwp = (DWORD *)cp;
		*dwp = pItem->m_dwAttribute;
		cp += 4;
		/*
		*cp = (char)(pItem->m_dwAttribute & 0x00000001); // Custom-ItemÃ€ÃŽÃÃ¶Ã€Ã‡ Â¿Â©ÂºÃŽ 
		cp++;
		*/		
		if (iEraseReq == 1) 
		{	delete pItem;
			pItem = NULL;
		}
		iRet = m_pClientList[iClientH]->m_pXSock->iSendMsg(cData, 53);		
		return TRUE;
	}else 
	{	m_pMapList[ m_pClientList[iClientH]->m_cMapIndex ]->bSetItem(m_pClientList[iClientH]->m_sX, 
			                                                         m_pClientList[iClientH]->m_sY, 
			                                                         pItem);
		SendEventToNearClient_TypeB(MSGID_EVENT_COMMON, DEF_COMMONTYPE_ITEMDROP, m_pClientList[iClientH]->m_cMapIndex,
			                        m_pClientList[iClientH]->m_sX, m_pClientList[iClientH]->m_sY,  
			                        pItem->m_sSprite, pItem->m_sSpriteFrame, pItem->m_cItemColor); 
		dwp  = (DWORD *)(cData + DEF_INDEX4_MSGID);
		*dwp = MSGID_NOTIFY;
		wp   = (WORD *)(cData + DEF_INDEX2_MSGTYPE);
		*wp  = DEF_NOTIFY_CANNOTCARRYMOREITEM;		
		iRet = m_pClientList[iClientH]->m_pXSock->iSendMsg(cData, 6);		
		return TRUE;
	}
	return FALSE;
}

int CGame::_iTalkToNpcResult_Cityhall(int iClientH, int * pQuestType, int * pMode, int * pRewardType, int * pRewardAmount, int * pContribution, char * pTargetName, int * pTargetType, int * pTargetCount, int * pX, int * pY, int * pRange)
{int iQuest, iEraseReq, iExp;
 class CItem * pItem;
	// Return Code
	// -1  : Quest not completed
	// -2  : No quest obtained because asking in wrong map    
	// -3  : No Quest for criminals
	// -4  : Wrong npc
	// -5  : Normal return value ?
	if (m_pClientList[iClientH] == NULL) return 0;
	/*if (((memcmp(m_pClientList[iClientH]->m_cMapName, "cityhall_1", 10) != 1) || 
		(memcmp(m_pClientList[iClientH]->m_cMapName, "cityhall_2", 10) != 1)) &&
		(memcmp(m_pClientList[i]->m_cLocation, "NONE",4) != 0)) {
			wsprintf(G_cTxt, "Traveller hack: (%s) Player: (%s) - is talking to William from a remote map.", m_pClientList[iClientH]->m_cIPaddress, m_pClientList[iClientH]->m_cCharName);
			PutHackLogFileList(G_cTxt);
			DeleteClient(iClientH, TRUE, TRUE);
			return 0;
	}*/
	if (m_pClientList[iClientH]->m_iQuest != NULL) 
	{	if (m_pQuestConfigList[m_pClientList[iClientH]->m_iQuest] == NULL) return -4;
		else if (m_pQuestConfigList[m_pClientList[iClientH]->m_iQuest]->m_iFrom == 4) 
		{	if (m_pClientList[iClientH]->m_bIsQuestCompleted == TRUE) 
			{	if (   (m_pClientList[iClientH]->m_iQuestRewardType > 0)
					&& (m_pItemConfigList[m_pClientList[iClientH]->m_iQuestRewardType] > 0) ) 					
				{	pItem = new class CItem;// Item reward
					_bInitItemAttr(pItem, m_pItemConfigList[m_pClientList[iClientH]->m_iQuestRewardType]->m_cName);
					pItem->m_dwCount = m_pClientList[iClientH]->m_iQuestRewardAmount;
					if (_bCheckItemReceiveCondition(iClientH, pItem) == TRUE) 
					{	if (pItem->m_dwCount == 1) //SNOOPY: Added n°s to the item...	
						{	pItem->m_sTouchEffectType   = DEF_ITET_ID;
							pItem->m_sTouchEffectValue1 = iDice(1,100000);
							pItem->m_sTouchEffectValue2 = iDice(1,100000);
							//pItem->m_sTouchEffectValue3 = timeGetTime();	
							if (pItem->m_cItemType == DEF_ITEMTYPE_MATERIAL) // Snoopy: Added Purity to Oils/Elixirs
							{	pItem->m_sItemSpecEffectValue2 = 40 + iDice(1,60);
								pItem->m_sItemSpecEffectValue1 = pItem->m_wCurLifeSpan;
								pItem->m_dwAttribute = 1;
							}
							SYSTEMTIME SysTime;
							char cTemp[256];
							GetLocalTime(&SysTime);		
							ZeroMemory(cTemp, sizeof(cTemp));
							wsprintf(cTemp, "%d%2d",  (short)SysTime.wMonth, (short)SysTime.wDay);
							pItem->m_sTouchEffectValue3 = atoi(cTemp);
						}else // Useless ?
						{	pItem->m_sTouchEffectType   = DEF_ITET_ID;
							pItem->m_sTouchEffectValue1 = 0;
							pItem->m_sTouchEffectValue2 = 0;
							pItem->m_sTouchEffectValue3 = 0;
						}
						// Give contrib 1st
						m_pClientList[iClientH]->m_iContribution += m_pQuestConfigList[m_pClientList[iClientH]->m_iQuest]->m_iContribution;
						// Add the item to the client					
						_bAddClientItemList(iClientH, pItem, &iEraseReq);					
						SendItemNotifyMsg(iClientH, DEF_NOTIFY_ITEMOBTAINED, pItem, NULL);						
						// SNOOPY Logg you have item or Gold
						wsprintf(G_cTxt, "Quest completed!    PC(%s) - Account(%s) has obtained %d %s \t(Contrib +%d = %d) \t%s(%d %d)\tIP(%s)"
							, m_pClientList[iClientH]->m_cCharName
							, m_pClientList[iClientH]->m_cAccountName
							, pItem->m_dwCount
							, pItem->m_cName
							, m_pQuestConfigList[m_pClientList[iClientH]->m_iQuest]->m_iContribution
							, m_pClientList[iClientH]->m_iContribution
							, m_pClientList[iClientH]->m_cMapName
							, m_pClientList[iClientH]->m_sX
							, m_pClientList[iClientH]->m_sY
							, m_pClientList[iClientH]->m_cIPaddress);
						PutLogFileList(G_cTxt);							
						// Then, remove the item, if it has been added
						// to alreaddy existing stackable item (ie: Gold)
						if (iEraseReq == 1) delete pItem;							
						// Last notify client about quest result
						SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_QUESTREWARD, 4, 1
							, m_pClientList[iClientH]->m_iQuestRewardAmount
							, m_pItemConfigList[m_pClientList[iClientH]->m_iQuestRewardType]->m_cName
							, m_pClientList[iClientH]->m_iContribution);						
						_ClearQuestStatus(iClientH);
						return -5;
					}else 	// Not allowed to receive this item
							// Come back later with less items in bag
							// Quest not resolved
					{	delete pItem;
						// SNOOPY Logging this here as well
						wsprintf(G_cTxt, "Quest completed!    PC(%s) - Account(%s) Bag full! (Contrib = %d)\t%s(%d %d)\tIP(%s)"
							, m_pClientList[iClientH]->m_cCharName
							, m_pClientList[iClientH]->m_cAccountName
							, m_pClientList[iClientH]->m_iContribution
							, m_pClientList[iClientH]->m_cMapName
							, m_pClientList[iClientH]->m_sX
							, m_pClientList[iClientH]->m_sY
							, m_pClientList[iClientH]->m_cIPaddress);
						PutLogFileList(G_cTxt);

						// Item is too heavy or bag is full
						SendItemNotifyMsg(iClientH,	DEF_NOTIFY_CANNOTCARRYMOREITEM, NULL, NULL);

						SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_QUESTREWARD, 4, 0
							, m_pClientList[iClientH]->m_iQuestRewardAmount
							, m_pItemConfigList[m_pClientList[iClientH]->m_iQuestRewardType]->m_cName
							, m_pClientList[iClientH]->m_iContribution);
						return -5;
					}
				}else if (m_pClientList[iClientH]->m_iQuestRewardType == -1) 
				{	// Reward is Experience (XP stock)
					m_pClientList[iClientH]->m_iExpStock += m_pClientList[iClientH]->m_iQuestRewardAmount;
					m_pClientList[iClientH]->m_iContribution += m_pQuestConfigList[m_pClientList[iClientH]->m_iQuest]->m_iContribution;
					// SNOOPY Logging this here as well
					wsprintf(G_cTxt, "Quest completed!    PC(%s) - Account(%s) XP (Fixed) +%d  (Contrib +%d = %d) \t%s(%d %d)\tIP(%s)"
						, m_pClientList[iClientH]->m_cCharName
						, m_pClientList[iClientH]->m_cAccountName
						, m_pClientList[iClientH]->m_iQuestRewardAmount
						, m_pQuestConfigList[m_pClientList[iClientH]->m_iQuest]->m_iContribution
						, m_pClientList[iClientH]->m_iContribution
						, m_pClientList[iClientH]->m_cMapName
						, m_pClientList[iClientH]->m_sX
						, m_pClientList[iClientH]->m_sY
						, m_pClientList[iClientH]->m_cIPaddress);
					PutLogFileList(G_cTxt); 
					SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_QUESTREWARD, 4, 1
						, m_pClientList[iClientH]->m_iQuestRewardAmount
						, "Experience points"
						, m_pClientList[iClientH]->m_iContribution);
					_ClearQuestStatus(iClientH);
					return -5;
				}else if (m_pClientList[iClientH]->m_iQuestRewardType == -2) 
				{	// Reward type -2 : XP Random
					iExp = iDice(1, (10*m_pClientList[iClientH]->m_iLevel));
					iExp = iExp * m_pClientList[iClientH]->m_iQuestRewardAmount;
					m_pClientList[iClientH]->m_iExpStock += iExp;
					m_pClientList[iClientH]->m_iContribution += m_pQuestConfigList[m_pClientList[iClientH]->m_iQuest]->m_iContribution;
					// SNOOPY Logging this here as well
					wsprintf(G_cTxt, "Quest completed!    PC(%s) - Account(%s) XP (Random) +%d  (Contrib +%d = %d) \t%s(%d %d)\tIP(%s)"
						, m_pClientList[iClientH]->m_cCharName
						, m_pClientList[iClientH]->m_cAccountName
						, m_pClientList[iClientH]->m_iQuestRewardAmount
						, m_pQuestConfigList[m_pClientList[iClientH]->m_iQuest]->m_iContribution
						, m_pClientList[iClientH]->m_iContribution
						, m_pClientList[iClientH]->m_cMapName
						, m_pClientList[iClientH]->m_sX
						, m_pClientList[iClientH]->m_sY
						, m_pClientList[iClientH]->m_cIPaddress);
					PutLogFileList(G_cTxt); 					
					SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_QUESTREWARD, 4, 1
						, iExp
						, "Experience points"
						, m_pClientList[iClientH]->m_iContribution);
					
					_ClearQuestStatus(iClientH);
					return -5;
				}else //  Other Reward types
				{	m_pClientList[iClientH]->m_iContribution += m_pQuestConfigList[m_pClientList[iClientH]->m_iQuest]->m_iContribution;
					// SNOOPY Logging this here as well
					wsprintf(G_cTxt, "Quest completed!    PC(%s) - Account(%s) Unknown reward (Contrib +%d = %d) \t%s(%d %d)\tIP(%s)"
						, m_pClientList[iClientH]->m_cCharName
						, m_pClientList[iClientH]->m_cAccountName
						, m_pQuestConfigList[m_pClientList[iClientH]->m_iQuest]->m_iContribution
						, m_pClientList[iClientH]->m_iContribution
						, m_pClientList[iClientH]->m_cMapName
						, m_pClientList[iClientH]->m_sX
						, m_pClientList[iClientH]->m_sY
						, m_pClientList[iClientH]->m_cIPaddress);
					PutLogFileList(G_cTxt); 
					SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_QUESTREWARD, 4, 1
						, 0
						, "                     "
						, m_pClientList[iClientH]->m_iContribution);					
					_ClearQuestStatus(iClientH);
					return -5;
				}
			}else return -1;
		}		
		return -4;
	}	
	if (   (m_bMapModeEquilibrium == TRUE)	
		|| (memcmp(m_pClientList[iClientH]->m_cLocation,m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cLocationName, 10) == 0)
		 ) {// SNOOPY: No m_cLocationName in Equilibrium Mode 
/*    (memcmp(m_pClientList[iClientH]->m_cLocation
		, m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cLocationName
			, 10) != 0)  */				
		if (m_pClientList[iClientH]->m_iPKCount > 0) return -3;			
		// SNOOPY Logging this here as well
		wsprintf(G_cTxt, "Asking for a quest: PC(%s) - Account(%s) (Contrib = %d) \t%s(%d %d)\tIP(%s)"
			, m_pClientList[iClientH]->m_cCharName
			, m_pClientList[iClientH]->m_cAccountName
			, m_pClientList[iClientH]->m_iContribution
			, m_pClientList[iClientH]->m_cMapName
			, m_pClientList[iClientH]->m_sX
			, m_pClientList[iClientH]->m_sY
			, m_pClientList[iClientH]->m_cIPaddress);
		PutLogFileList(G_cTxt); 		
		iQuest = __iSearchForQuest(iClientH, 4, pQuestType, pMode, pRewardType, pRewardAmount, pContribution, pTargetName, pTargetType, pTargetCount, pX, pY, pRange);
		// SNOOPY Logging this here as well
		wsprintf(G_cTxt, "Quest searched    : PC(%s) - Account(%s) Quest = %d \t(Contrib = %d) \t%s(%d %d)\tIP(%s)"
			, m_pClientList[iClientH]->m_cCharName
			, m_pClientList[iClientH]->m_cAccountName
			, iQuest
			, m_pClientList[iClientH]->m_iContribution
			, m_pClientList[iClientH]->m_cMapName
			, m_pClientList[iClientH]->m_sX
			, m_pClientList[iClientH]->m_sY
			, m_pClientList[iClientH]->m_cIPaddress);
		PutLogFileList(G_cTxt); 
		if (iQuest <= 0) return -4;
		return iQuest;
	}else return -2;
	return -4;
}

int CGame::_iTalkToNpcResult_Guard(int iClientH, int * pQuestType, int * pMode, int * pRewardType, int * pRewardAmount, int * pContribution, char * pTargetName, int * pTargetType, int * pTargetCount, int * pX, int * pY, int * pRange)
{	if (m_pClientList[iClientH] == NULL) return 0;
	if (memcmp(m_pClientList[iClientH]->m_cLocation, "are", 3) == 0) 
	{	if (memcmp(m_pClientList[iClientH]->m_cMapName, "aresden", 7) == 0) 
		{	SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_NPCTALK, (200), NULL, NULL, NULL, NULL);
			return 1000;
		}else if (memcmp(m_pClientList[iClientH]->m_cMapName, "elv", 3) == 0) 
		{	SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_NPCTALK, (201), NULL, NULL, NULL, NULL);
			return 1001;
		}
	}else if (memcmp(m_pClientList[iClientH]->m_cLocation, "elv", 3) == 0) 
	{	if (memcmp(m_pClientList[iClientH]->m_cMapName, "aresden", 7) == 0) 
		{	SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_NPCTALK, (202), NULL, NULL, NULL, NULL);
			return 1002;
		}else if (memcmp(m_pClientList[iClientH]->m_cMapName, "elv", 3) == 0) 
		{	SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_NPCTALK, (203), NULL, NULL, NULL, NULL);
			return 1003;
		}
	}else if (memcmp(m_pClientList[iClientH]->m_cLocation, "NONE", 4) == 0) 
	{	if (memcmp(m_pClientList[iClientH]->m_cMapName, "aresden", 7) == 0) 
		{	SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_NPCTALK, (204), NULL, NULL, NULL, NULL);
			return 1004;
		}else if (memcmp(m_pClientList[iClientH]->m_cMapName, "elvine", 6) == 0) 
		{	SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_NPCTALK, (205), NULL, NULL, NULL, NULL);
			return 1005;
		}else if (memcmp(m_pClientList[iClientH]->m_cMapName, "default", 7) == 0) 
		{	SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_NPCTALK, (206), NULL, NULL, NULL, NULL);
			return 1006;
		}
	}
	return 0;
}

BOOL CGame::_bDecodeQuestConfigFileContents(char * pData, DWORD dwMsgSize)
{char * pContents, * token, cTxt[120];
 char seps[] = "= \t\n";
 char cReadModeA = 0;
 char cReadModeB = 0;
 int  iQuestConfigListIndex = 0;
 class CStrTok * pStrTok;

	pContents = new char[dwMsgSize+1];
	ZeroMemory(pContents, dwMsgSize+1);
	memcpy(pContents, pData, dwMsgSize);

	pStrTok = new class CStrTok(pContents, seps);
	token = pStrTok->pGet();
	
	while( token != NULL ) {
		if (cReadModeA != 0) {
			switch (cReadModeA) {
			case 1:
				switch (cReadModeB) {
				case 1:
					if (_bGetIsStringIsNumber(token) == FALSE) 
					{	PutLogList("(!!!) CRITICAL ERROR! QUEST configuration file error - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}					
					if (m_pQuestConfigList[atoi(token)] != NULL) 
					{	PutLogList("(!!!) CRITICAL ERROR! QUEST configuration file error - Duplicate quest number.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pQuestConfigList[atoi(token)] = new class CQuest;
					iQuestConfigListIndex = atoi(token);
					cReadModeB = 2;
					break;

				case 2:
					if (_bGetIsStringIsNumber(token) == FALSE) 
					{	PutLogList("(!!!) CRITICAL ERROR! QUEST configuration file error - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pQuestConfigList[iQuestConfigListIndex]->m_cSide = atoi(token);
					cReadModeB = 3;
					break;

				case 3:
					if (_bGetIsStringIsNumber(token) == FALSE) 
					{	PutLogList("(!!!) CRITICAL ERROR! QUEST configuration file error - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pQuestConfigList[iQuestConfigListIndex]->m_iType = atoi(token);
					cReadModeB = 4;
					break;

				case 4:	// TargetType
					if (_bGetIsStringIsNumber(token) == FALSE) 
					{	PutLogList("(!!!) CRITICAL ERROR! QUEST configuration file error - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pQuestConfigList[iQuestConfigListIndex]->m_iTargetType = atoi(token);
					cReadModeB = 5;
					break;

				case 5:	// MaxCount
					if (_bGetIsStringIsNumber(token) == FALSE) 
					{	PutLogList("(!!!) CRITICAL ERROR! QUEST configuration file error - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pQuestConfigList[iQuestConfigListIndex]->m_iMaxCount= atoi(token);
					cReadModeB = 6;
					break;

				case 6:	// 
					if (_bGetIsStringIsNumber(token) == FALSE) 
					{	PutLogList("(!!!) CRITICAL ERROR! QUEST configuration file error - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pQuestConfigList[iQuestConfigListIndex]->m_iFrom = atoi(token);
					cReadModeB = 7;
					break;

				case 7:	// 
					if (_bGetIsStringIsNumber(token) == FALSE) 
					{	PutLogList("(!!!) CRITICAL ERROR! QUEST configuration file error - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pQuestConfigList[iQuestConfigListIndex]->m_iMinLevel = atoi(token);
					cReadModeB = 8;
					break;

				case 8:	// 
					if (_bGetIsStringIsNumber(token) == FALSE) 
					{	PutLogList("(!!!) CRITICAL ERROR! QUEST configuration file error - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pQuestConfigList[iQuestConfigListIndex]->m_iMaxLevel = atoi(token);
					cReadModeB = 9;
					break;

				case 9:	// 
					if (_bGetIsStringIsNumber(token) == FALSE) 
					{	PutLogList("(!!!) CRITICAL ERROR! QUEST configuration file error - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pQuestConfigList[iQuestConfigListIndex]->m_iRequiredSkillNum = atoi(token);
					cReadModeB = 10;
					break;

				case 10:// 
					if (_bGetIsStringIsNumber(token) == FALSE) 
					{	PutLogList("(!!!) CRITICAL ERROR! QUEST configuration file error - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pQuestConfigList[iQuestConfigListIndex]->m_iRequiredSkillLevel = atoi(token);
					cReadModeB = 11;
					break;

				case 11: // 
					if (_bGetIsStringIsNumber(token) == FALSE) 
					{	PutLogList("(!!!) CRITICAL ERROR! QUEST configuration file error - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pQuestConfigList[iQuestConfigListIndex]->m_iTimeLimit = atoi(token);
					cReadModeB = 12;
					break;

				case 12: // 
					if (_bGetIsStringIsNumber(token) == FALSE) 
					{	PutLogList("(!!!) CRITICAL ERROR! QUEST configuration file error - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pQuestConfigList[iQuestConfigListIndex]->m_iAssignType = atoi(token);
					cReadModeB = 13;
					break;

				case 13: // 
					if (_bGetIsStringIsNumber(token) == FALSE) 
					{	PutLogList("(!!!) CRITICAL ERROR! QUEST configuration file error - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pQuestConfigList[iQuestConfigListIndex]->m_iRewardType[1] = atoi(token);
					cReadModeB = 14;
					break;

				case 14: // 
					if (_bGetIsStringIsNumber(token) == FALSE) 
					{	PutLogList("(!!!) CRITICAL ERROR! QUEST configuration file error - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pQuestConfigList[iQuestConfigListIndex]->m_iRewardAmount[1] = atoi(token);
					cReadModeB = 15;
					break;

				case 15: // 
					if (_bGetIsStringIsNumber(token) == FALSE) 
					{	PutLogList("(!!!) CRITICAL ERROR! QUEST configuration file error - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pQuestConfigList[iQuestConfigListIndex]->m_iRewardType[2] = atoi(token);
					cReadModeB = 16;
					break;

				case 16: // 
					if (_bGetIsStringIsNumber(token) == FALSE) 
					{	PutLogList("(!!!) CRITICAL ERROR! QUEST configuration file error - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pQuestConfigList[iQuestConfigListIndex]->m_iRewardAmount[2] = atoi(token);
					cReadModeB = 17;
					break;

				case 17:// 
					if (_bGetIsStringIsNumber(token) == FALSE) 
					{	PutLogList("(!!!) CRITICAL ERROR! QUEST configuration file error - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pQuestConfigList[iQuestConfigListIndex]->m_iRewardType[3] = atoi(token);
					cReadModeB = 18;
					break;

				case 18: // 
					if (_bGetIsStringIsNumber(token) == FALSE) 
					{	PutLogList("(!!!) CRITICAL ERROR! QUEST configuration file error - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pQuestConfigList[iQuestConfigListIndex]->m_iRewardAmount[3] = atoi(token);
					cReadModeB = 19;
					break;

				case 19: // 
					if (_bGetIsStringIsNumber(token) == FALSE) 
					{	PutLogList("(!!!) CRITICAL ERROR! QUEST configuration file error - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pQuestConfigList[iQuestConfigListIndex]->m_iContribution = atoi(token);
					cReadModeB = 20;
					break;

				case 20: // 
					if (_bGetIsStringIsNumber(token) == FALSE) 
					{	PutLogList("(!!!) CRITICAL ERROR! QUEST configuration file error - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pQuestConfigList[iQuestConfigListIndex]->m_iContributionLimit = atoi(token);
					cReadModeB = 21;
					break;

				case 21:// 
					if (_bGetIsStringIsNumber(token) == FALSE) 
					{	PutLogList("(!!!) CRITICAL ERROR! QUEST configuration file error - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pQuestConfigList[iQuestConfigListIndex]->m_iResponseMode = atoi(token);
					cReadModeB = 22;
					break;

				case 22:
					ZeroMemory(m_pQuestConfigList[iQuestConfigListIndex]->m_cTargetName, sizeof(m_pQuestConfigList[iQuestConfigListIndex]->m_cTargetName));
					strcpy(m_pQuestConfigList[iQuestConfigListIndex]->m_cTargetName, token);
					cReadModeB = 23;
					break;

				case 23:
					if (_bGetIsStringIsNumber(token) == FALSE)
					{	PutLogList("(!!!) CRITICAL ERROR! QUEST configuration file error - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pQuestConfigList[iQuestConfigListIndex]->m_sX = atoi(token);
					cReadModeB = 24;
					break;

				case 24:
					if (_bGetIsStringIsNumber(token) == FALSE)
					{	PutLogList("(!!!) CRITICAL ERROR! QUEST configuration file error - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pQuestConfigList[iQuestConfigListIndex]->m_sY = atoi(token);
					cReadModeB = 25;
					break;

				case 25:
					if (_bGetIsStringIsNumber(token) == FALSE) 
					{	PutLogList("(!!!) CRITICAL ERROR! QUEST configuration file error - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pQuestConfigList[iQuestConfigListIndex]->m_iRange = atoi(token);
					cReadModeB = 26;
					break;

				case 26:
					if (_bGetIsStringIsNumber(token) == FALSE) 
					{	PutLogList("(!!!) CRITICAL ERROR! QUEST configuration file error - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pQuestConfigList[iQuestConfigListIndex]->m_iQuestID = atoi(token);
					cReadModeB = 27;
					break;

				case 27:
					if (_bGetIsStringIsNumber(token) == FALSE) 
					{	PutLogList("(!!!) CRITICAL ERROR! QUEST configuration file error - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pQuestConfigList[iQuestConfigListIndex]->m_iReqContribution = atoi(token);
					cReadModeA = 0;
					cReadModeB = 0;
					break;
				}
				break;
			default: 
				break;
			}
		}else 
		{	if (memcmp(token, "quest", 5) == 0) 
			{	cReadModeA = 1;
				cReadModeB = 1;
			}
		}
		token = pStrTok->pGet();
	}
	delete pStrTok;
	delete pContents;
	if ((cReadModeA != 0) || (cReadModeB != 0)) 
	{	PutLogList("(!!!) CRITICAL ERROR! QUEST configuration file contents error!");
		return FALSE;
	}
	wsprintf(cTxt, "(!) QUEST (Total:%d) configuration - success!", iQuestConfigListIndex);
	PutLogList(cTxt);
	return TRUE;
}

int CGame::__iSearchForQuest(int iClientH, int iWho, int * pQuestType, int * pMode, int * pRewardType, int * pRewardAmount, int * pContribution, char * pTargetName, int * pTargetType, int * pTargetCount, int * pX, int * pY, int * pRange)
{int i, iQuestList[DEF_MAXQUESTTYPE], iIndex, iQuest, iReward, iQuestIndex;
	if (m_pClientList[iClientH] == NULL) return -1; 
	iIndex = 0;
	for (i = 0; i < DEF_MAXQUESTTYPE; i++)
		iQuestList[i] = -1;
	for (i = 1; i < DEF_MAXQUESTTYPE; i++) 
	if (m_pQuestConfigList[i] != NULL) 
	{	if (m_pQuestConfigList[i]->m_iFrom != iWho) goto SFQ_SKIP;
		if (m_pQuestConfigList[i]->m_cSide != m_pClientList[iClientH]->m_cSide) goto SFQ_SKIP;
		if (m_pQuestConfigList[i]->m_iMinLevel > m_pClientList[iClientH]->m_iLevel) goto SFQ_SKIP;
		if (m_pQuestConfigList[i]->m_iMaxLevel < m_pClientList[iClientH]->m_iLevel) goto SFQ_SKIP;
		// Mini contrib
		if (m_pQuestConfigList[i]->m_iReqContribution > m_pClientList[iClientH]->m_iContribution) goto SFQ_SKIP;		
		// minimum skill
		if (m_pQuestConfigList[i]->m_iRequiredSkillNum != -1) { 
			if (m_pClientList[iClientH]->m_cSkillMastery[m_pQuestConfigList[i]->m_iRequiredSkillNum] < 
				m_pQuestConfigList[i]->m_iRequiredSkillLevel) goto SFQ_SKIP;
		}		
		// Type: Crusade or not
		if ((m_bIsCrusadeMode == TRUE) && (m_pQuestConfigList[i]->m_iAssignType != 1)) goto SFQ_SKIP; 
		if ((m_bIsCrusadeMode == FALSE) && (m_pQuestConfigList[i]->m_iAssignType == 1)) goto SFQ_SKIP; 		
		// Max contrib
		if (m_pQuestConfigList[i]->m_iContributionLimit < m_pClientList[iClientH]->m_iContribution) goto SFQ_SKIP;
		// 
		iQuestList[iIndex] = i;
		iIndex++;
SFQ_SKIP:;
	}
	// iIndex
	if (iIndex == 0) return -1;
	iQuest		 = (iDice(1, iIndex)) - 1;
	iQuestIndex  = iQuestList[iQuest];
	// 
	iReward = iDice(1,3);
	*pMode = m_pQuestConfigList[iQuestIndex]->m_iResponseMode;	
	*pRewardType   = m_pQuestConfigList[iQuestIndex]->m_iRewardType[iReward];	
	// SNOOPY: Added a trap for item non existing on the server...
	if (m_pItemConfigList[m_pQuestConfigList[iQuestIndex]->m_iRewardType[iReward]] == NULL) 
	{	*pRewardAmount = -1; // Replaces by Experience				
	}
	*pRewardAmount = m_pQuestConfigList[iQuestIndex]->m_iRewardAmount[iReward];	 
	*pContribution = m_pQuestConfigList[iQuestIndex]->m_iContribution;	
	strcpy(pTargetName, m_pQuestConfigList[iQuestIndex]->m_cTargetName);
	*pX     = m_pQuestConfigList[iQuestIndex]->m_sX;
	*pY     = m_pQuestConfigList[iQuestIndex]->m_sY;
	*pRange = m_pQuestConfigList[iQuestIndex]->m_iRange;
	*pTargetType  = m_pQuestConfigList[iQuestIndex]->m_iTargetType;
	*pTargetCount = m_pQuestConfigList[iQuestIndex]->m_iMaxCount;
	*pQuestType   = m_pQuestConfigList[iQuestIndex]->m_iType;
	return iQuestIndex;
}

void CGame::QuestAcceptedHandler(int iClientH)
{ int iIndex;
	if (m_pClientList[iClientH] == NULL) return;	
	// Does the quest exist ??
	if(m_pQuestConfigList[m_pClientList[iClientH]->m_iAskedQuest] == NULL) return;
	if (m_pQuestConfigList[m_pClientList[iClientH]->m_iAskedQuest]->m_iAssignType == 1) 
	{	switch (m_pQuestConfigList[m_pClientList[iClientH]->m_iAskedQuest]->m_iType) {
		case 10: 
			_ClearQuestStatus(iClientH);
			RequestTeleportHandler(iClientH, "2   ", m_pQuestConfigList[m_pClientList[iClientH]->m_iAskedQuest]->m_cTargetName,
				                   m_pQuestConfigList[m_pClientList[iClientH]->m_iAskedQuest]->m_sX, m_pQuestConfigList[m_pClientList[iClientH]->m_iAskedQuest]->m_sY);
			return;
		}
	}
	m_pClientList[iClientH]->m_iQuest = m_pClientList[iClientH]->m_iAskedQuest;
	iIndex = m_pClientList[iClientH]->m_iQuest;
	m_pClientList[iClientH]->m_iQuestID = m_pQuestConfigList[iIndex]->m_iQuestID;
	m_pClientList[iClientH]->m_iCurQuestCount    = 0;
	m_pClientList[iClientH]->m_bIsQuestCompleted = FALSE;	
	_CheckQuestEnvironment(iClientH);
	_SendQuestContents(iClientH);
}

void CGame::_SendQuestContents(int iClientH)
{int iWho, iIndex, iQuestType, iContribution, iTargetType, iTargetCount, iX, iY, iRange, iQuestCompleted;
 char cTargetName[21];
	if (m_pClientList[iClientH] == NULL) return;
	iIndex = m_pClientList[iClientH]->m_iQuest;
	if (iIndex == NULL) 
	{	SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_QUESTCONTENTS, NULL, NULL, NULL, NULL,  
		              NULL, NULL, NULL, NULL, NULL, NULL, NULL);
	}else 
	{	iWho          = m_pQuestConfigList[iIndex]->m_iFrom;
		iQuestType    = m_pQuestConfigList[iIndex]->m_iType;
		iContribution = m_pQuestConfigList[iIndex]->m_iContribution;
		iTargetType   = m_pQuestConfigList[iIndex]->m_iTargetType;
		iTargetCount  = m_pQuestConfigList[iIndex]->m_iMaxCount;
		iX            = m_pQuestConfigList[iIndex]->m_sX;
		iY            = m_pQuestConfigList[iIndex]->m_sY;
		iRange        = m_pQuestConfigList[iIndex]->m_iRange;
		ZeroMemory(cTargetName, sizeof(cTargetName));
		memcpy(cTargetName, m_pQuestConfigList[iIndex]->m_cTargetName, 20);
		iQuestCompleted = (int)m_pClientList[iClientH]->m_bIsQuestCompleted;
		SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_QUESTCONTENTS, iWho, iQuestType, iContribution, NULL,  
			          iTargetType, iTargetCount, iX, iY, iRange, iQuestCompleted, cTargetName);
	}
}

void CGame::_CheckQuestEnvironment(int iClientH)
{int iIndex;
 char cTargetName[21];
	if (m_pClientList[iClientH] == NULL) return;
	iIndex = m_pClientList[iClientH]->m_iQuest;
	if (iIndex == NULL) return;
	if (m_pQuestConfigList[iIndex] == NULL) return;
// SNOOPY: Why forbid some quests numbres ?
/*	if (iIndex >= 35 && iIndex <= 40) {
		m_pClientList[iClientH]->m_iQuest = 0;
		m_pClientList[iClientH]->m_iQuestID = NULL;
		m_pClientList[iClientH]->m_iQuestRewardAmount = NULL;
		m_pClientList[iClientH]->m_iQuestRewardType   = NULL;
		SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_QUESTABORTED, NULL, NULL, NULL, NULL);
		return;
	}*/
	if (m_pQuestConfigList[iIndex]->m_iQuestID != m_pClientList[iClientH]->m_iQuestID) 
	{	m_pClientList[iClientH]->m_iQuest   = NULL;
		m_pClientList[iClientH]->m_iQuestID = NULL;
		m_pClientList[iClientH]->m_iQuestRewardAmount = NULL;
		m_pClientList[iClientH]->m_iQuestRewardType   = NULL;		
		SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_QUESTABORTED, NULL, NULL, NULL, NULL);
		return;
	}
	switch (m_pQuestConfigList[iIndex]->m_iType) {
	case DEF_QUESTTYPE_MONSTERHUNT:
	case DEF_QUESTTYPE_GOPLACE:
		ZeroMemory(cTargetName, sizeof(cTargetName));
		memcpy(cTargetName, m_pQuestConfigList[iIndex]->m_cTargetName, 20);
		if (memcmp(m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cName, cTargetName, 10) == 0)
			 m_pClientList[iClientH]->m_bQuestMatchFlag_Loc = TRUE;
		else m_pClientList[iClientH]->m_bQuestMatchFlag_Loc = FALSE;
		break;
	}
}

BOOL CGame::_bCheckIsQuestCompleted(int iClientH)
{int iQuestIndex;
	if (m_pClientList[iClientH] == NULL) return FALSE;
	if (m_pClientList[iClientH]->m_bIsQuestCompleted == TRUE) return FALSE;
	iQuestIndex = m_pClientList[iClientH]->m_iQuest;
	if (iQuestIndex == NULL) return FALSE;		
	if (m_pQuestConfigList[iQuestIndex] != NULL) 
	{	switch (m_pQuestConfigList[iQuestIndex]->m_iType) {
		case DEF_QUESTTYPE_MONSTERHUNT:
			if (   (m_pClientList[iClientH]->m_bQuestMatchFlag_Loc == TRUE) 
				&& (m_pClientList[iClientH]->m_iCurQuestCount >= m_pQuestConfigList[iQuestIndex]->m_iMaxCount) ) 
			{	m_pClientList[iClientH]->m_bIsQuestCompleted = TRUE;					
				SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_QUESTCOMPLETED, NULL, NULL, NULL, NULL);
				return TRUE;
			}
			break;

		case DEF_QUESTTYPE_GOPLACE:
			if (   (m_pClientList[iClientH]->m_bQuestMatchFlag_Loc == TRUE) 
				&& (m_pClientList[iClientH]->m_sX >= m_pQuestConfigList[iQuestIndex]->m_sX - m_pQuestConfigList[iQuestIndex]->m_iRange) 
				&& (m_pClientList[iClientH]->m_sX <= m_pQuestConfigList[iQuestIndex]->m_sX + m_pQuestConfigList[iQuestIndex]->m_iRange) 
				&& (m_pClientList[iClientH]->m_sY >= m_pQuestConfigList[iQuestIndex]->m_sY - m_pQuestConfigList[iQuestIndex]->m_iRange) 
				&& (m_pClientList[iClientH]->m_sY <= m_pQuestConfigList[iQuestIndex]->m_sY + m_pQuestConfigList[iQuestIndex]->m_iRange) ) 
			{	m_pClientList[iClientH]->m_bIsQuestCompleted = TRUE;					
				SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_QUESTCOMPLETED, NULL, NULL, NULL, NULL);
				return TRUE;
			}
			break;
		}
	}
	return FALSE;
}
int CGame::_iTalkToNpcResult_GuildHall(int iClientH, int *pQuestType, int *pMode, int *pRewardType, int *pRewardAmount, int *pContribution, char *pTargetName, int *pTargetType, int *pTargetCount, int *pX, int *pY, int *pRange)
{	return -4;
}
int CGame::_iTalkToNpcResult_GShop(int iClientH, int *pQuestType, int *pMode, int *pRewardType, int *pRewardAmount, int *pContribution, char *pTargetName, int *pTargetType, int *pTargetCount, int *pX, int *pY, int *pRange)
{	return -4;
}
int CGame::_iTalkToNpcResult_BSmith(int iClientH, int *pQuestType, int *pMode, int *pRewardType, int *pRewardAmount, int *pContribution, char *pTargetName, int *pTargetType, int *pTargetCount, int *pX, int *pY, int *pRange)
{	return -4;
}
int CGame::_iTalkToNpcResult_WHouse(int iClientH, int *pQuestType, int *pMode, int *pRewardType, int *pRewardAmount, int *pContribution, char *pTargetName, int *pTargetType, int *pTargetCount, int *pX, int *pY, int *pRange)
{	return -4;
}
int CGame::_iTalkToNpcResult_WTower(int iClientH, int *pQuestType, int *pMode, int *pRewardType, int *pRewardAmount, int *pContribution, char *pTargetName, int *pTargetType, int *pTargetCount, int *pX, int *pY, int *pRange)
{	return -4;
}

void CGame::SendItemNotifyMsg(int iClientH, WORD wMsgType, CItem *pItem, int iV1)
{ char  * cp, cData[512];
 DWORD * dwp;
 WORD  * wp;
 short * sp;
 int     iRet;
	if (m_pClientList[iClientH] == NULL) return;
	dwp  = (DWORD *)(cData + DEF_INDEX4_MSGID);
	*dwp = MSGID_NOTIFY;
	wp   = (WORD *)(cData + DEF_INDEX2_MSGTYPE);
	*wp  = wMsgType;
	cp = (char *)(cData + DEF_INDEX2_MSGTYPE + 2);

	switch (wMsgType) {
	case DEF_NOTIFY_ITEMOBTAINED:
		*cp = 1;
		cp++;		
		memcpy(cp, pItem->m_cName, 20);
		cp += 20;		
		dwp  = (DWORD *)cp;
		*dwp = pItem->m_dwCount;
		cp += 4;		
		*cp = pItem->m_cItemType;
		cp++;		
		*cp = pItem->m_cEquipPos;
		cp++;		
		*cp = (char)0;
		cp++;		
		sp  = (short *)cp;
		*sp = pItem->m_sLevelLimit;
		cp += 2;		
		*cp = pItem->m_cGenderLimit;
		cp++;		
		wp = (WORD *)cp;
		*wp = pItem->m_wCurLifeSpan;
		cp += 2;		
		wp = (WORD *)cp;
		*wp = pItem->m_wWeight;
		cp += 2;		
		sp  = (short *)cp;
		*sp = pItem->m_sSprite;
		cp += 2;		
		sp  = (short *)cp;
		*sp = pItem->m_sSpriteFrame;
		cp += 2;		
		*cp = pItem->m_cItemColor;
		cp++;
		*cp = (char)pItem->m_sItemSpecEffectValue2; // v1.41 
		cp++;		
		dwp = (DWORD *)cp;
		*dwp = pItem->m_dwAttribute;
		cp += 4;		
		/**cp = (char)(pItem->m_dwAttribute & 0x00000001); // Custom-ItemÃ€ÃŽÃÃ¶Ã€Ã‡ Â¿Â©ÂºÃŽ 
		cp++;*/
		iRet = m_pClientList[iClientH]->m_pXSock->iSendMsg(cData, 53);
		break;
	
	case DEF_NOTIFY_ITEMPURCHASED:
		*cp = 1;
		cp++;		
		memcpy(cp, pItem->m_cName, 20);
		cp += 20;		
		dwp  = (DWORD *)cp;
		*dwp = pItem->m_dwCount;
		cp += 4;		
		*cp = pItem->m_cItemType;
		cp++;		
		*cp = pItem->m_cEquipPos;
		cp++;		
		*cp = (char)0;
		cp++;		
		sp  = (short *)cp;
		*sp = pItem->m_sLevelLimit;
		cp += 2;		
		*cp = pItem->m_cGenderLimit;
		cp++;		
		wp = (WORD *)cp;
		*wp = pItem->m_wCurLifeSpan;
		cp += 2;		
		wp = (WORD *)cp;
		*wp = pItem->m_wWeight;
		cp += 2;		
		sp  = (short *)cp;
		*sp = pItem->m_sSprite;
		cp += 2;		
		sp  = (short *)cp;
		*sp = pItem->m_sSpriteFrame;
		cp += 2;		
		*cp = pItem->m_cItemColor;
		cp++;		
		wp  = (WORD *)cp;
		*wp = iV1; // (iCost - iDiscountCost);		
		iRet = m_pClientList[iClientH]->m_pXSock->iSendMsg(cData, 48);
		break;

	case DEF_NOTIFY_CANNOTCARRYMOREITEM:
		iRet =m_pClientList[iClientH]->m_pXSock->iSendMsg(cData, 6);
		break;
	}
}

BOOL CGame::_bCheckItemReceiveCondition(int iClientH, CItem *pItem)
{int i;
	if (m_pClientList[iClientH] == NULL) return FALSE;
	if (m_pClientList[iClientH]->m_iCurWeightLoad + iGetItemWeight(pItem, pItem->m_dwCount) > (DWORD)_iCalcMaxLoad(iClientH)) 
		return FALSE;
	for (i = 0; i < DEF_MAXITEMS; i++)
		if (m_pClientList[iClientH]->m_pItemList[i] == NULL) return TRUE;
	return FALSE;
}

void CGame::_ClearQuestStatus(int iClientH)
{	if (m_pClientList[iClientH] == NULL) return;
	m_pClientList[iClientH]->m_iQuest   = NULL;
	m_pClientList[iClientH]->m_iQuestID = NULL;
	m_pClientList[iClientH]->m_iQuestRewardType   = NULL;
	m_pClientList[iClientH]->m_iQuestRewardAmount = NULL;
	m_pClientList[iClientH]->m_bIsQuestCompleted  = FALSE;
}

int CGame::iGetMaxHP(int iClientH, BOOL bBloodEffect)
{int iRet;
	if (m_pClientList[iClientH] == NULL) return 0;
// SNOOPY: Reduced to lvl*1.5 as in v3.70+ HBint
//	iRet = m_pClientList[iClientH]->m_iVit*3 + m_pClientList[iClientH]->m_iLevel*1.5 + m_pClientList[iClientH]->m_iStr/2;
	// Changed to this due to patch in client that in case of odd level and Str gives 1 more HP.
	iRet = m_pClientList[iClientH]->m_iVit*3 + (m_pClientList[iClientH]->m_iLevel*3 
			+ (m_pClientList[iClientH]->m_iStr + m_pClientList[iClientH]->m_iAngelicStr))/2;

	if ((bBloodEffect == TRUE) && (m_pClientList[iClientH]->m_iSideEffect_MaxHPdown != 0))
		iRet = iRet - (iRet/m_pClientList[iClientH]->m_iSideEffect_MaxHPdown);

	return iRet;
}

int CGame::iGetMaxMP(int iClientH)
{ int iRet;
	if (m_pClientList[iClientH] == NULL) return 0;
	iRet = (2 *(m_pClientList[iClientH]->m_iMag + m_pClientList[iClientH]->m_iAngelicMag)) + (2*m_pClientList[iClientH]->m_iLevel) 
			+ ((m_pClientList[iClientH]->m_iInt + m_pClientList[iClientH]->m_iAngelicInt)/2);	
	return iRet;
}

int CGame::iGetMaxSP(int iClientH)
{ int iRet;
	if (m_pClientList[iClientH] == NULL) return 0;
	iRet = (2*(m_pClientList[iClientH]->m_iStr + m_pClientList[iClientH]->m_iAngelicStr)) + (2*m_pClientList[iClientH]->m_iLevel);	
	return iRet;
}

void CGame::GetMapInitialPoint(int iMapIndex, short *pX, short *pY, char cSide)
{int i, iTotalPoint;
 POINT  pList[DEF_MAXINITIALPOINT];
	if (m_pMapList[iMapIndex] == NULL) return;
	iTotalPoint = 0;
	for (i = 0; i < DEF_MAXINITIALPOINT; i++)//initial-point 
	if (m_pMapList[iMapIndex]->m_pInitialPoint[i].x != -1) 
	{	if (cSide == i) // Snoopy: changed to go to point of same nbe than client's side
		{	*pX = m_pMapList[iMapIndex]->m_pInitialPoint[i].x;
			*pY = m_pMapList[iMapIndex]->m_pInitialPoint[i].y;
			return;
		}
		pList[iTotalPoint].x = m_pMapList[iMapIndex]->m_pInitialPoint[i].x;
		pList[iTotalPoint].y = m_pMapList[iMapIndex]->m_pInitialPoint[i].y;
		iTotalPoint++;		
	}
	if (iTotalPoint == 0) return;
	if (cSide == 0)
	{	 i = cSide;
	}else 
	{	i = iDice(1, iTotalPoint) - 1;
	}
	*pX = pList[i].x;
	*pY = pList[i].y;
}

void CGame::_CheckStrategicPointOccupyStatus(char cMapIndex)
{ // Never called !
 class CTile * pTile;
 int i, iX, iY, iSide, iValue;
	m_iStrategicStatus = 0;
	for (i = 0; i < DEF_MAXSTRATEGICPOINTS; i++)
	if (m_pMapList[cMapIndex]->m_pStrategicPointList[i] != NULL) {	
		iSide  = m_pMapList[cMapIndex]->m_pStrategicPointList[i]->m_iSide;
		iValue = m_pMapList[cMapIndex]->m_pStrategicPointList[i]->m_iValue;
		iX = m_pMapList[cMapIndex]->m_pStrategicPointList[i]->m_iX;
		iY = m_pMapList[cMapIndex]->m_pStrategicPointList[i]->m_iY;
		pTile = (class CTile *)(m_pMapList[cMapIndex]->m_pTile + iX + iY*m_pMapList[cMapIndex]->m_sSizeY);
		m_iStrategicStatus += pTile->m_iOccupyStatus * iValue;
	}
}

void CGame::OnSubLogSocketEvent(UINT message, WPARAM wParam, LPARAM lParam)
{UINT iTmp;
 register int iLogSockH, iRet;
	iTmp = (WM_ONLOGSOCKETEVENT + 1);
	iLogSockH = message - iTmp;	
	if (m_pSubLogSock[iLogSockH] == NULL)
	{	wsprintf(G_cTxt, "(???W) WorldServer sub-socket event on NULL socket   Log#(%d)", iLogSockH);
		PutLogList(G_cTxt);
		return;
	}	
	if (m_bIsSubLogSockInitialPointer[iLogSockH] != (int) m_pSubLogSock[iLogSockH])
	{	wsprintf(G_cTxt, "(???W) WorldServer sub-socket event on corrupted socket   Log#(%d)", iLogSockH);
		PutLogList(G_cTxt);
		return;
	}
	iRet = m_pSubLogSock[iLogSockH]->iOnSocketEvent(wParam, lParam);
	switch (iRet) {
	case DEF_XSOCKEVENT_UNSENTDATASENDCOMPLETE:
		wsprintf(G_cTxt, "(>>>W) WorldServer sub-socket connected!  Log#(%d) Address:%s  Port:%d", iLogSockH, m_cLogServerAddr, m_iLogServerPort);
		PutLogList(G_cTxt);
		m_bIsSubLogSockAvailable[iLogSockH] = TRUE;
		m_iSubLogSockActiveCount++;
		break;
	case DEF_XSOCKEVENT_CONNECTIONESTABLISH:
		//wsprintf(G_cTxt, "(>>>W) Log Socket Connection Established Log#(%d) Address:%s  Port:%d", iLogSockH, m_cLogServerAddr, m_iLogServerPort);
		//PutLogList(G_cTxt);	
		break;	
	case DEF_XSOCKEVENT_READCOMPLETE:
		OnSubLogRead(iLogSockH);
		break;	
	case DEF_XSOCKEVENT_BLOCK:
		wsprintf(G_cTxt, "(###W) WorldServer sub-socket(%d) BLOCKED!", iLogSockH);
		PutLogList(G_cTxt);
		break;
	case DEF_XSOCKEVENT_SOCKETMISMATCH:
		wsprintf(G_cTxt, "(###W) WorldServer sub-socket(%d) MISMATCH!", iLogSockH);
		PutLogList(G_cTxt);
		break;		
	case DEF_XSOCKEVENT_NOTINITIALIZED:
		wsprintf(G_cTxt, "(###W) WorldServer sub-socket(%d) NOT INITIALIZED!", iLogSockH);
		PutLogList(G_cTxt);
		break;
	case DEF_XSOCKEVENT_RETRYINGCONNECTION:
		wsprintf(G_cTxt, "(###W) WorldServer sub-socket(%d) RETRYING CONNECTION!", iLogSockH);
		PutLogList(G_cTxt);
		break;
	case DEF_XSOCKEVENT_UNKNOWN:
		wsprintf(G_cTxt, "(###W) WorldServer sub-socket(%d) UNKNOWN!", iLogSockH);
		PutLogList(G_cTxt);
		break;
	case DEF_XSOCKEVENT_CONFIRMCODENOTMATCH:
	case DEF_XSOCKEVENT_MSGSIZETOOLARGE:
	case DEF_XSOCKEVENT_SOCKETERROR:
	case DEF_XSOCKEVENT_SOCKETCLOSED:
		delete m_pSubLogSock[iLogSockH];
		m_pSubLogSock[iLogSockH] = NULL;
		m_bIsSubLogSockAvailable[iLogSockH] = FALSE;
		m_bIsSubLogSockInitialPointer[iLogSockH] = 0;
		m_iSubLogSockFailCount++;
		m_iSubLogSockActiveCount--;
		wsprintf(G_cTxt, "(---W) Sub-log-socket(%d) connection lost!", iLogSockH);
		PutLogList(G_cTxt);
		PutLogFileList(G_cTxt);		
		m_pSubLogSock[iLogSockH] = new class XSocket(m_hWnd, DEF_SERVERSOCKETBLOCKLIMIT);
		m_bIsSubLogSockInitialPointer[iLogSockH] = (int) m_pSubLogSock[iLogSockH];
		m_pSubLogSock[iLogSockH]->bConnect(m_cLogServerAddr, m_iLogServerPort, (WM_ONLOGSOCKETEVENT + iLogSockH + 1));
		m_pSubLogSock[iLogSockH]->bInitBufferSize(DEF_MSGBUFFERSIZE);
		wsprintf(G_cTxt, "(...W) Try to reconnect sub-log-socket(%d)... Addr:%s  Port:%d", iLogSockH, m_cLogServerAddr, m_iLogServerPort);
		PutLogList(G_cTxt);		
		break;
	}
}

void CGame::OnSubLogRead(int iIndex)
{DWORD dwMsgSize;
 char * pData, cKey;
	pData = m_pSubLogSock[iIndex]->pGetRcvDataPointer(&dwMsgSize, &cKey);
	if (bPutMsgQuene(DEF_MSGFROM_LOGSERVER, pData, dwMsgSize, NULL, cKey, NULL) == FALSE) {
		PutLogList("(@@@W) CRITICAL ERROR in MsgQuene!!! @@@@@@");
	}	
}

void CGame::_CheckGateSockConnection()
{	if (m_bIsServerShutdowned == TRUE) return;
	if (m_iGateSockConnRetryTimes != 0) 
	{	wsprintf(G_cTxt, "(...G) Gate-socket connection counting...%d", m_iGateSockConnRetryTimes); 
		PutLogList(G_cTxt);
		m_iGateSockConnRetryTimes++;
	}
	// Gate-socket
	if (m_iGateSockConnRetryTimes > 20) {
		if (m_bOnExitProcess == FALSE) {
			m_iFinalShutdownCount = 1;
			m_bOnExitProcess     = TRUE;
			m_dwExitProcessTime  = timeGetTime();
			PutLogList("(!) GAME SERVER SHUTDOWN PROCESS BEGIN(by gate-server connection Lost)!!!");
	}	}
}

BOOL CGame::_bCheckSubLogSocketIndex()
{
 int  /*i,*/ iCnt;
 BOOL bLoopFlag;
	m_iCurSubLogSockIndex++;
	if (m_iCurSubLogSockIndex >= DEF_MAXSUBLOGSOCK) m_iCurSubLogSockIndex = 0;
	iCnt = 0;
	bLoopFlag = FALSE;

	// Snoopy: test for valid pointer...
	if (   (m_bIsSubLogSockInitialPointer[m_iCurSubLogSockIndex] != (int)m_pSubLogSock[m_iCurSubLogSockIndex])
		&& (m_bIsSubLogSockAvailable[m_iCurSubLogSockIndex] == TRUE))
	{	ZeroMemory(G_cTxt, sizeof(G_cTxt));
		wsprintf(G_cTxt, "########Wrong SubLogSock(%d) pointer detected: %d - %d"
		, m_iCurSubLogSockIndex
		, m_bIsSubLogSockInitialPointer[m_iCurSubLogSockIndex]
		, m_pSubLogSock[m_iCurSubLogSockIndex]);
		PutLogList(G_cTxt);		
		ZeroMemory(m_cBugText, sizeof(m_cBugText));
		wsprintf(m_cBugText, "IMPORTANT NOTICE: Wrong SubLogSock(%d) pointer detected: %d - %d"
			, m_iCurSubLogSockIndex
			, m_bIsSubLogSockInitialPointer[m_iCurSubLogSockIndex]
			, m_pSubLogSock[m_iCurSubLogSockIndex]);
		m_iBugWarning = 1;	
		// Then block this socket.
		m_iSubLogSockActiveCount--;
		m_bIsSubLogSockAvailable[m_iCurSubLogSockIndex] = FALSE;
	}
	while (bLoopFlag == FALSE) 
	{	if ((m_pSubLogSock[m_iCurSubLogSockIndex] != NULL) && (m_bIsSubLogSockAvailable[m_iCurSubLogSockIndex] == TRUE)
			&& m_bIsSubLogSockInitialPointer[m_iCurSubLogSockIndex] == (int)m_pSubLogSock[m_iCurSubLogSockIndex] ) 
		{	 bLoopFlag = TRUE;
		}else 
		{	m_iCurSubLogSockIndex++;
			if (m_iCurSubLogSockIndex >= DEF_MAXSUBLOGSOCK) m_iCurSubLogSockIndex = 0; // Added by Snoopy
		}
		iCnt++;
		if (iCnt >= DEF_MAXSUBLOGSOCK) {
			if (m_bOnExitProcess == FALSE) {
				// m_cShutDownCode      = 3;
				m_cShutDownCode      = 1; // snoopy: changed to one to try a restart instead of stop
				m_bOnExitProcess     = TRUE;
				m_dwExitProcessTime  = timeGetTime();
				PutLogList("(!) GAME SERVER SHUTDOWN PROCESS BEGIN(by Log-server connection Lost)!!!");
			}
			return FALSE;
		}
	}	
	return TRUE;
}

BOOL CGame::_bDecodeBuildItemConfigFileContents(char *pData, DWORD dwMsgSize)
{
 char * pContents, * token, cTxt[120];
 char seps[] = "= \t\n";
 char cReadModeA = 0;
 char cReadModeB = 0;
 int  i, iIndex = 0;
 class CStrTok * pStrTok;
 class CItem * pItem;

	pContents = new char[dwMsgSize+1];
	ZeroMemory(pContents, dwMsgSize+1);
	memcpy(pContents, pData, dwMsgSize);

	pStrTok = new class CStrTok(pContents, seps);
	token = pStrTok->pGet();
	while( token != NULL ) {
		if (cReadModeA != 0) {
			switch (cReadModeA) {
			case 1:
				switch (cReadModeB) {
				case 1:
					ZeroMemory(m_pBuildItemList[iIndex]->m_cName, sizeof(m_pBuildItemList[iIndex]->m_cName));
					memcpy(m_pBuildItemList[iIndex]->m_cName, token, strlen(token));										
					cReadModeB = 2;
					break;

				case 2:
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! BuildItem configuration file error - Wrong Data format(1).");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}					
					m_pBuildItemList[iIndex]->m_iSkillLimit = atoi(token);
					cReadModeB = 3;
					break;

				case 3:
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! BuildItem configuration file error - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}					
					m_pBuildItemList[iIndex]->m_iMaterialItemID[0] = atoi(token);
					cReadModeB = 4;
					break;

				case 4:
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! BuildItem configuration file error - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}					
					m_pBuildItemList[iIndex]->m_iMaterialItemCount[0] = atoi(token);
					cReadModeB = 5;
					break;

				case 5:
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! BuildItem configuration file error - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}					
					m_pBuildItemList[iIndex]->m_iMaterialItemValue[0] = atoi(token);
					cReadModeB = 6;
					break;

				case 6:	// 
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! BuildItem configuration file error - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}					
					m_pBuildItemList[iIndex]->m_iMaterialItemID[1] = atoi(token);
					cReadModeB = 7;
					break;

				case 7:
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! BuildItem configuration file error - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}					
					m_pBuildItemList[iIndex]->m_iMaterialItemCount[1] = atoi(token);
					cReadModeB = 8;
					break;

				case 8:
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! BuildItem configuration file error - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}					
					m_pBuildItemList[iIndex]->m_iMaterialItemValue[1] = atoi(token);
					cReadModeB = 9;
					break;

				case 9:
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! BuildItem configuration file error - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}					
					m_pBuildItemList[iIndex]->m_iMaterialItemID[2] = atoi(token);
					cReadModeB = 10;
					break;

				case 10:
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! BuildItem configuration file error - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}					
					m_pBuildItemList[iIndex]->m_iMaterialItemCount[2] = atoi(token);
					cReadModeB = 11;
					break;

				case 11:
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! BuildItem configuration file error - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}					
					m_pBuildItemList[iIndex]->m_iMaterialItemValue[2] = atoi(token);
					cReadModeB = 12;
					break;

				case 12:// 
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! BuildItem configuration file error - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}					
					m_pBuildItemList[iIndex]->m_iMaterialItemID[3] = atoi(token);
					cReadModeB = 13;
					break;

				case 13:
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! BuildItem configuration file error - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pBuildItemList[iIndex]->m_iMaterialItemCount[3] = atoi(token);
					cReadModeB = 14;
					break;

				case 14:
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! BuildItem configuration file error - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}					
					m_pBuildItemList[iIndex]->m_iMaterialItemValue[3] = atoi(token);
					cReadModeB = 15;
					break;

				case 15:// 
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! BuildItem configuration file error - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}					
					m_pBuildItemList[iIndex]->m_iMaterialItemID[4] = atoi(token);
					cReadModeB = 16;
					break;

				case 16:
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! BuildItem configuration file error - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pBuildItemList[iIndex]->m_iMaterialItemCount[4] = atoi(token);					
					cReadModeB = 17;
					break;

				case 17:
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! BuildItem configuration file error - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}					
					m_pBuildItemList[iIndex]->m_iMaterialItemValue[4] = atoi(token);					
					cReadModeB = 18;
					break;
				
				case 18:
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! BuildItem configuration file error - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}					
					m_pBuildItemList[iIndex]->m_iMaterialItemID[5] = atoi(token);
					cReadModeB = 19;
					break;

				case 19:
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! BuildItem configuration file error - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pBuildItemList[iIndex]->m_iMaterialItemCount[5] = atoi(token);					
					cReadModeB = 20;
					break;

				case 20:
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! BuildItem configuration file error - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}					
					m_pBuildItemList[iIndex]->m_iMaterialItemValue[5] = atoi(token);					
					cReadModeB = 21;
					break;

				case 21:// m_iAverageValue
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! BuildItem configuration file error - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}					
					m_pBuildItemList[iIndex]->m_iAverageValue = atoi(token);					
					cReadModeB = 22;
					break;

				case 22:// m_iMaxSkill
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! BuildItem configuration file error - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}					
					m_pBuildItemList[iIndex]->m_iMaxSkill = atoi(token);					
					cReadModeB = 23;
					break;

				case 23:	// m_wAttribute
					if (_bGetIsStringIsNumber(token) == FALSE) 
					{	PutLogList("(!!!) CRITICAL ERROR! BuildItem configuration file error - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}					
					m_pBuildItemList[iIndex]->m_wAttribute = atoi(token);					
					cReadModeA = 0;
					cReadModeB = 0;					
					pItem = new class CItem;
					if (_bInitItemAttr(pItem, m_pBuildItemList[iIndex]->m_cName) == TRUE) 
					{	m_pBuildItemList[iIndex]->m_sItemID = pItem->m_sIDnum;
						for (i = 0; i < 6; i++)
							m_pBuildItemList[iIndex]->m_iMaxValue += (m_pBuildItemList[iIndex]->m_iMaterialItemValue[i]*100);
						iIndex++;	
					}else 
					{	wsprintf(G_cTxt, "(!!!) CRITICAL ERROR! BuildItem configuration file error - Not Existing Item(%s)", m_pBuildItemList[iIndex]->m_cName);
						PutLogList(G_cTxt);
						
						delete m_pBuildItemList[iIndex];
						m_pBuildItemList[iIndex] = NULL;
						
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					delete pItem;
					break;
				}
				break;

			default: 
				break;
			}
		}else 
		{	if (memcmp(token, "BuildItem", 9) == 0) 
			{	cReadModeA = 1;
				cReadModeB = 1;
				m_pBuildItemList[iIndex] = new class CBuildItem;
			}
			
		}
		token = pStrTok->pGet();
	}	
	delete pStrTok;
	delete pContents;
	if ((cReadModeA != 0) || (cReadModeB != 0)) {
		PutLogList("(!!!) CRITICAL ERROR! BUILD-ITEM configuration file contents error!");
		return FALSE;
	}
	wsprintf(cTxt, "(!) BUILD-ITEM (Total:%d) configuration - success!", iIndex);
	PutLogList(cTxt);
	return TRUE;
}


void CGame::BuildItemHandler(int iClientH, char *pData)
{
 char * cp, cName[21], cElementItemID[6];
 int    i, x, z, iMatch, iCount, iPlayerSkillLevel, iResult, iTotalValue, iResultValue, iTemp, iItemCount[DEF_MAXITEMS];
 class  CItem * pItem;
 BOOL   bFlag, bItemFlag[6];
 double dV1, dV2, dV3;
 DWORD  dwTemp, dwTemp2;
 WORD   wTemp;
 char cTemp[256];

	if (m_pClientList[iClientH] == NULL) return;
	m_pClientList[iClientH]->m_iSkillMsgRecvCount++;

	cp = (char *)(pData + 11);
	ZeroMemory(cName, sizeof(cName));
	memcpy(cName, cp, 20);
	cp += 20;

	ZeroMemory(cElementItemID, sizeof(cElementItemID));
	cElementItemID[0] = *cp;
	cp++;
	cElementItemID[1] = *cp;
	cp++;
	cElementItemID[2] = *cp;
	cp++;
	cElementItemID[3] = *cp;
	cp++;
	cElementItemID[4] = *cp;
	cp++;
	cElementItemID[5] = *cp;
	cp++;
	
	bFlag = TRUE;
	while (bFlag == TRUE) {
		bFlag = FALSE;
		for (i = 0; i <= 4; i++) 
		if ((cElementItemID[i] == -1) && (cElementItemID[i+1] != -1)) {
			cElementItemID[i] = cElementItemID[i+1];
			cElementItemID[i+1] = -1;
			bFlag = TRUE;
		}
	}
	for (i = 0; i < 6; i++) bItemFlag[i] = FALSE;

	iPlayerSkillLevel = m_pClientList[iClientH]->m_cSkillMastery[13];
	iResult = iDice(1, 100);

	if (iResult > iPlayerSkillLevel) {
		SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_BUILDITEMFAIL, NULL, NULL, NULL, NULL);
		return;
	}

	for (i = 0; i < 6; i++)
	if (cElementItemID[i] != -1) {
		if ((cElementItemID[i] < 0) || (cElementItemID[i] > DEF_MAXITEMS)) {return;};
		if (m_pClientList[iClientH]->m_pItemList[cElementItemID[i]] == NULL) {return;};		
	}

	for (i = 0; i < DEF_MAXBUILDITEMS; i++)
	if (m_pBuildItemList[i] != NULL) {
		if (memcmp(m_pBuildItemList[i]->m_cName, cName, 20) == 0) {
			if (m_pBuildItemList[i]->m_iSkillLimit > m_pClientList[iClientH]->m_cSkillMastery[13]) {return;};						
			for (x = 0; x < DEF_MAXITEMS; x++) 
			if (m_pClientList[iClientH]->m_pItemList[x] != NULL) 
				 iItemCount[x] = m_pClientList[iClientH]->m_pItemList[x]->m_dwCount;
			else iItemCount[x] = 0;
			
			iMatch = 0;
			iTotalValue = 0;			
			for (x = 0; x < 6; x++) {
				if (m_pBuildItemList[i]->m_iMaterialItemCount[x] == 0) {
					iMatch++;
				}
				else {
					for (z = 0; z < 6; z++) 
					if ((cElementItemID[z] != -1) && (bItemFlag[z] == FALSE)) {												
						if (   (m_pClientList[iClientH]->m_pItemList[cElementItemID[z]]->m_sIDnum  == m_pBuildItemList[i]->m_iMaterialItemID[x]) 
							&& (m_pClientList[iClientH]->m_pItemList[cElementItemID[z]]->m_dwCount >= m_pBuildItemList[i]->m_iMaterialItemCount[x]) 
							&& (iItemCount[cElementItemID[z]] > 0)) 
						{	iTemp = m_pClientList[iClientH]->m_pItemList[cElementItemID[z]]->m_sItemSpecEffectValue2;
							if (iTemp > m_pClientList[iClientH]->m_cSkillMastery[13]) 
							{	iTemp = iTemp - (iTemp - m_pClientList[iClientH]->m_cSkillMastery[13])/2;
							}
							iTotalValue += (iTemp * m_pBuildItemList[i]->m_iMaterialItemValue[x]);
							iItemCount[cElementItemID[z]] -= m_pBuildItemList[i]->m_iMaterialItemCount[x];
							iMatch++;
							bItemFlag[z] = TRUE;						
							goto BIH_LOOPBREAK;
						}
					}
BIH_LOOPBREAK:;
				}
			}
			if (iMatch != 6) {
				SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_BUILDITEMFAIL, NULL, NULL, NULL, NULL);
				return;
			}
			dV2 = (double)m_pBuildItemList[i]->m_iMaxValue;
			if (iTotalValue <= 0) 
				 dV3 = 1.0f;
			else dV3 = (double)iTotalValue;
			dV1 = (double)(dV3/dV2)*100.0f;
			iTotalValue = (int)dV1; // represents average purity % value
			pItem = new class CItem;
			if (_bInitItemAttr(pItem, m_pBuildItemList[i]->m_cName) == FALSE) 
			{	delete pItem;
				return;
			}
			dwTemp = pItem->m_dwAttribute;
			dwTemp = dwTemp & 0xFFFFFFFE;
			dwTemp = dwTemp | 0x00000001;
			pItem->m_dwAttribute = dwTemp;

			if (pItem->m_cItemType == DEF_ITEMTYPE_MATERIAL) 
			{	iTemp = iDice(1, (iPlayerSkillLevel/2)+1) -1;
				pItem->m_sItemSpecEffectValue2 = (iPlayerSkillLevel/2) + iTemp;
				pItem->m_sTouchEffectType   = DEF_ITET_ID;
				pItem->m_sTouchEffectValue1 = iDice(1,100000);
				pItem->m_sTouchEffectValue2 = iDice(1,100000);
				//pItem->m_sTouchEffectValue3 = timeGetTime();	
				SYSTEMTIME SysTime;
				// Alreaddy declared char cTemp[256];
				GetLocalTime(&SysTime);
				ZeroMemory(cTemp, sizeof(cTemp));
				wsprintf(cTemp, "%d%2d",  (short)SysTime.wMonth, (short)SysTime.wDay);
				pItem->m_sTouchEffectValue3 = atoi(cTemp);
			}else // completion item
			{	dwTemp = pItem->m_dwAttribute;
				dwTemp = dwTemp & 0x0000FFFF;
				dwTemp2 = (WORD)m_pBuildItemList[i]->m_wAttribute;
				dwTemp2 = dwTemp2 << 16;
				dwTemp  = dwTemp | dwTemp2;
				pItem->m_dwAttribute = dwTemp;
				iResultValue = (iTotalValue - m_pBuildItemList[i]->m_iAverageValue);
				//: SpecEffectValue1 , SpecEffectValue2´ 				
				if (iResultValue > 0) 
				{	dV2 = (double)iResultValue;
					dV3 = (double)(100 - m_pBuildItemList[i]->m_iAverageValue);
					dV1 = (dV2/dV3)*100.0f;
					pItem->m_sItemSpecEffectValue2 = (int)dV1;
				}else if (iResultValue < 0) 
				{	dV2 = (double)(iResultValue);
					dV3 = (double)(m_pBuildItemList[i]->m_iAverageValue);
					dV1 = (dV2/dV3)*100.0f;
					pItem->m_sItemSpecEffectValue2 = (int)dV1;
				}else pItem->m_sItemSpecEffectValue2 = 0;

				dV2 = (double)pItem->m_sItemSpecEffectValue2;
				dV3 = (double)pItem->m_wMaxLifeSpan;
				dV1 = (dV2/100.0f)*dV3;

				iTemp  = (int)pItem->m_wMaxLifeSpan;
				iTemp += (int)dV1;
				pItem->m_sTouchEffectType   = DEF_ITET_ID;
				pItem->m_sTouchEffectValue1 = iDice(1,100000);
				pItem->m_sTouchEffectValue2 = iDice(1,100000);
				//pItem->m_sTouchEffectValue3 = timeGetTime();	
				SYSTEMTIME SysTime;
				// Alreaddy declared char cTemp[256];
				GetLocalTime(&SysTime);
				ZeroMemory(cTemp, sizeof(cTemp));
				wsprintf(cTemp, "%d%2d",  (short)SysTime.wMonth, (short)SysTime.wDay);
				pItem->m_sTouchEffectValue3 = atoi(cTemp);
				if (iTemp <= 0) 
					 wTemp = 1;
				else wTemp = (WORD)iTemp;
				if (wTemp <= pItem->m_wMaxLifeSpan*2) 
				{	pItem->m_wMaxLifeSpan = wTemp;
					pItem->m_sItemSpecEffectValue1 = (short)wTemp;
					pItem->m_wCurLifeSpan = pItem->m_wMaxLifeSpan;
				}
				else pItem->m_sItemSpecEffectValue1 = (short)pItem->m_wMaxLifeSpan;
				pItem->m_cItemColor = 2;
			}
			switch (pItem->m_sIDnum) {
			case  500: // SuperCoal
			case  501: // IronBar
				break;
			default: //testcode
				wsprintf(G_cTxt, "PC(%s) Custom-Item(%s) Value(%d) Life(%d/%d)"
					, m_pClientList[iClientH]->m_cCharName
					, pItem->m_cName
					, pItem->m_sItemSpecEffectValue2
					, pItem->m_wCurLifeSpan
					, pItem->m_wMaxLifeSpan);
				// SNOOPY to special log PutLogList(G_cTxt);
				PutSkillLogFileList(G_cTxt);
				break;
			}
			bAddItem(iClientH, pItem, NULL);
			SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_BUILDITEMSUCCESS, pItem->m_sItemSpecEffectValue2, pItem->m_cItemType, NULL, NULL); // Integer¸¦ Àü´ÞÇÏ±â À§ÇØ 

#ifdef DEF_TAIWANLOG
			_bItemLog(DEF_ITEMLOG_MAKE, iClientH, (int) -1, pItem);
#endif	
			for (x = 0; x < 6; x++)
			if (cElementItemID[x] != -1) {
				if (m_pClientList[iClientH]->m_pItemList[cElementItemID[x]] == NULL) {
					// ### BUG POINT!!!
					wsprintf(G_cTxt, "(?) Char(%s) ElementItemID(%d)", m_pClientList[iClientH]->m_cCharName, cElementItemID[x]);
					PutLogList(G_cTxt);
					PutLogFileList(G_cTxt);	
					PutSkillLogFileList(G_cTxt);				
				}
				else {
					iCount = m_pClientList[iClientH]->m_pItemList[cElementItemID[x]]->m_dwCount - m_pBuildItemList[i]->m_iMaterialItemCount[x];
					if (iCount < 0) iCount = 0;
					SetItemCount(iClientH, cElementItemID[x], iCount);
				}
			}

			// Some Manuf count for mulptiple sucesses
			if  (m_pBuildItemList[i]->m_iMaxSkill > m_pClientList[iClientH]->m_cSkillMastery[13])
			{	if (pItem->m_cItemType != DEF_ITEMTYPE_MATERIAL) 			
				{	//pItem->m_sItemSpecEffectValue2
					if (pItem->m_sItemSpecEffectValue2>99)	CalculateSSN_SkillIndex(iClientH, 13, 1);
					//if (pItem->m_sItemSpecEffectValue2>89)	CalculateSSN_SkillIndex(iClientH, 13, 1);
					if (pItem->m_sItemSpecEffectValue2>79)	CalculateSSN_SkillIndex(iClientH, 13, 1);
					//if (pItem->m_sItemSpecEffectValue2>69)	CalculateSSN_SkillIndex(iClientH, 13, 1);
					if (pItem->m_sItemSpecEffectValue2>59)	CalculateSSN_SkillIndex(iClientH, 13, 1);
					//if (pItem->m_sItemSpecEffectValue2>49)	CalculateSSN_SkillIndex(iClientH, 13, 1);
					if (pItem->m_sItemSpecEffectValue2>39)	CalculateSSN_SkillIndex(iClientH, 13, 1);
					//if (pItem->m_sItemSpecEffectValue2>29)	CalculateSSN_SkillIndex(iClientH, 13, 1);
					if (pItem->m_sItemSpecEffectValue2>19)	CalculateSSN_SkillIndex(iClientH, 13, 1);
					//if (pItem->m_sItemSpecEffectValue2>9)	CalculateSSN_SkillIndex(iClientH, 13, 1);
				}
				CalculateSSN_SkillIndex(iClientH, 13, 1);
			}
			GetExp(iClientH, iDice(1, (m_pBuildItemList[i]->m_iSkillLimit/4))); //m_pClientList[iClientH]->m_iExpStock += iDice(1, (m_pBuildItemList[i]->m_iSkillLimit/4));
			return;
		}
	}
}

void CGame::AdminOrder_Safe(int iClientH, bool bIsSafe)
{	register int i; // By snoopy, as a simpler /setattackmode 0/1
	if (m_pClientList[iClientH] == NULL) return;
	if (m_pClientList[iClientH]->m_iAdminUserLevel < m_iAdminLevelSetAttackMode) {
		SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_ADMINUSERLEVELLOW, NULL, NULL, NULL, NULL);
		return;
	}	
	if (bIsSafe  == false)
	{	m_pMapList[ m_pClientList[iClientH]->m_cMapIndex ]->m_bIsAttackEnabled = TRUE;
		for (i = 1; i < DEF_MAXCLIENTS; i++) 
		if ((m_pClientList[i] != NULL) && (m_pClientList[i]->m_bIsInitComplete == TRUE) && (m_pClientList[i]->m_cMapIndex == m_pClientList[iClientH]->m_cMapIndex)) 
			SendNotifyMsg(NULL, i, DEF_NOTIFY_GLOBALATTACKMODE, (int)m_pMapList[ m_pClientList[iClientH]->m_cMapIndex ]->m_bIsAttackEnabled, NULL, NULL, NULL);	
	}else 
	{	m_pMapList[ m_pClientList[iClientH]->m_cMapIndex ]->m_bIsAttackEnabled = FALSE;
		for (i = 1; i < DEF_MAXCLIENTS; i++) 
		if ((m_pClientList[i] != NULL) && (m_pClientList[i]->m_bIsInitComplete == TRUE) && (m_pClientList[i]->m_cMapIndex == m_pClientList[iClientH]->m_cMapIndex)) 
			SendNotifyMsg(NULL, i, DEF_NOTIFY_GLOBALATTACKMODE, (int)m_pMapList[ m_pClientList[iClientH]->m_cMapIndex ]->m_bIsAttackEnabled, NULL, NULL, NULL);	
	}
}

void CGame::AdminOrder_UnsummonAll(int iClientH)
{   int i;
	if (m_pClientList[iClientH] == NULL) return;	
	if (m_pClientList[iClientH]->m_bIsAdminCommandEnabled == FALSE) return;
	if (m_pClientList[iClientH]->m_iAdminUserLevel < m_iAdminLevelUnsummonAll) {
		SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_ADMINUSERLEVELLOW, NULL, NULL, NULL, NULL);
		return;
	}
	for (i = 1; i < DEF_MAXNPCS; i++)
	if (m_pNpcList[i] != NULL) 
	{	if ((m_pNpcList[i]->m_bIsSummoned == TRUE) && (m_pNpcList[i]->m_bIsKilled == FALSE)) 
			NpcKilledHandler(iClientH, DEF_OWNERTYPE_PLAYER, i, 0);
	}	// Admin Log
	wsprintf(G_cTxt, "Admin Order(%s): Unsummon all\tAdminIP(%s)"
		, m_pClientList[iClientH]->m_cCharName
		, m_pClientList[iClientH]->m_cIPaddress);
	PutAdminLogFileList(G_cTxt);	
	PutLogEventFileList(G_cTxt);	
	wsprintf(G_cTxt, "GM Order(%-10s): /unsummonall (done)", m_pClientList[iClientH]->m_cCharName);
	bSendMsgToLS(MSGID_GAMEMASTERLOG, iClientH, FALSE, G_cTxt);	
}

void CGame::AdminOrder_UnsummonDemon(int iClientH)
{	int i;
	if (m_pClientList[iClientH] == NULL) return;	
	if (m_pClientList[iClientH]->m_bIsAdminCommandEnabled == FALSE) return;
	if (m_pClientList[iClientH]->m_iAdminUserLevel < m_iAdminLevelUnsummonDemon) {
		SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_ADMINUSERLEVELLOW, NULL, NULL, NULL, NULL);
		return;
	}
	for (i = 1; i < DEF_MAXNPCS; i++)
	if (m_pNpcList[i] != NULL) 
	{	if ((m_pNpcList[i]->m_sType == 31) && (m_pNpcList[i]->m_bIsKilled == FALSE)) 
			NpcKilledHandler(iClientH, DEF_OWNERTYPE_PLAYER, i, 0);
	}
	wsprintf(G_cTxt, "Admin Order(%s): Unsummon Demon\tAdminIP(%s)"
		, m_pClientList[iClientH]->m_cCharName
		, m_pClientList[iClientH]->m_cIPaddress);
	PutAdminLogFileList(G_cTxt);
	PutLogEventFileList(G_cTxt);	
	wsprintf(G_cTxt, "GM Order(%-10s): /unsummondemon (done)", m_pClientList[iClientH]->m_cCharName);
	bSendMsgToLS(MSGID_GAMEMASTERLOG, iClientH, FALSE, G_cTxt);	
}

// 3.51 - 05/17/2004 - Hypnotoad/[KLKS] - Monster Special Abilities
char CGame::_cGetSpecialAbility(int iKindSA)
{	char cSA;
	switch (iKindSA) {
	default:
	case 1: // Slime, Rabbit, Tentocle, Stalker, Giant-Tree, Claw-Turtle, Giant-Cray-Fish 
		// Wyvern, Fire-Wyvern, Abaddon 
		switch (iDice(1,2)) {
		case 1: cSA = 3; break; // Anti-Physical Damage
		case 2: cSA = 4; break; // Anti-Magic Damage
		}
		break;
	case 2: // Giant-Ant, Cat, Frog
		switch (iDice(1,3)) {
		case 1: cSA = 3; break; // Anti-Physical Damage
		case 2: cSA = 4; break; // Anti-Magic Damage
		case 3: cSA = 5; break; // Poisonous
		}
		break;
	case 3: // Zombie, Scorpion, Amphis, Troll, Dark-Elf
		switch (iDice(1,4)) {
		case 1: cSA = 3; break; // Anti-Physical Damage
		case 2: cSA = 4; break; // Anti-Magic Damage
		case 3: cSA = 5; break; // Poisonous
		case 4: cSA = 6; break; // Critical Poisonous
		}
		break;
	case 4: // no linked Npc // SNOOPY: Changed
		switch (iDice(1,3)) {
		case 1: cSA = 4; break; // Anti-Magic Damage
		case 2: cSA = 8; break; // Critical-Explosive
		case 3: cSA = 6; break; // Critical Poisonous
		}
		break;
	case 5: // Stone-Golem, Clay-Golem, Ice-Golem, Beholder, Plant, Rudolph, DireBoar
		switch (iDice(1,8)) {
		case 1: 
		case 2: cSA = 3;  break; // Anti-Physical Damage
		case 3: 
		case 4: cSA = 4;  break; // Anti-Magic Damage
		case 5: cSA = 7;  break; // Explosive
		case 6: cSA = 8;  break; // Critical-Explosive
		case 7: cSA = 10; break; // Mighty
		case 8: cSA = 12; break; // Crippled
		}
		break;
	case 6: // no linked Npc // SNOOPY Changed 
		switch (iDice(1,3)) {
		case 1: cSA = 4; break; // Anti-Magic Damage
		case 2: cSA = 1; break; // Clairvoyant
		case 3: cSA = 8; break; // Critical-Explosive
		}
		break;
	case 7: // Unicorn, hellcats
		switch (iDice(1,3)) {
		case 1: cSA = 1; break; // Clairvoyant
		case 2: cSA = 2; break; // Distruction of Magic Protection
		case 3: cSA = 4; break; // Anti-Magic Damage
		}
		break;
	case 8: // Hellbound, Cyclops, Skeleton, HC, TW, Skelleton
		switch (iDice(1,7)) {
		case 1: cSA = 1;  break; // Clairvoyant
		case 2: cSA = 2;  break; // Distruction of Magic Protection
		case 3: cSA = 3;  break; // Anti-Physical Damage
		case 4: cSA = 4;  break; // Anti-Magic Damage
		case 5: cSA = 8;  break; // Critical-Explosive
		case 6: cSA = 10; break; // Mighty
		case 7: cSA = 12; break; // Crippled
		}
		break;
	case 9: // no linked Npc
		cSA = iDice(1,12); // All abilities available
		break;
	case 10: // Primate Humanoids that can be shamans
		// Orc, Ogre, WereWolf, YB-, Mountain-Giant
		switch (iDice(1,6)) {
			case 1: cSA = 3;  break; // Anti-Physical Damage
			case 2: cSA = 4;  break; // Anti-Magic Damage
			case 3: cSA = 9;  break; // Swift
			case 4: cSA = 10; break; // Mighty
			case 5: cSA = 11; break; // Shaman
			case 6: cSA = 12; break; // Crippled
		}
		break;
	case 11: // Humanoids that can be shamans
		// WereWolf, Ettins
		// Centaurus, Minotaurus, Nizie, Giant-Lizard, MasterMage-Orc,
		switch (iDice(1,7)) {
		case 1: cSA = 1;  break; // Clairvoyant
		case 2: cSA = 2;  break; // Distruction of Magic Protection
		case 3: cSA = 4;  break; // Anti-Magic Damage
		case 4: cSA = 9;  break; // Swift
		case 5: cSA = 10; break; // Mighty
		case 6: cSA = 11; break; // Shaman
		case 7: cSA = 12; break; // Crippled
		}
		break;
	case 12: // Hunt mobs
		// Gagoyle, Demon, Liche, Frost, Orc-Mage
		switch (iDice(1,7)) {
		case 1: 
		case 2: cSA = 1;  break; // Clairvoyant
		case 3: 
		case 4: cSA = 2;  break; // Distruction of Magic Protection
		case 5: cSA = 10; break; // Mighty
		case 6: cSA = 11; break; // Shaman
		case 7: cSA = 12; break; // Crippled
		}
		break;
	case 13: // Dragons
		switch (iDice(1,5)) {
		case 1: cSA = 1;  break; // Clairvoyant 
		case 2: 
		case 3: cSA = 4;  break; // Anti-Magic Damage
		case 4: cSA = 10; break; // Mighty
		case 5: cSA = 11; break; // Shaman
		}
		break;
	case 14: // Dark-Elf
		switch (iDice(1,7)) {
		case 1: 
		case 2: cSA = 3;  break; // Anti-Physical Damage
		case 3: 
		case 4: cSA = 6;  break; // Critical Poisonous
		case 5: cSA = 9;  break; // Swift
		case 6: cSA = 10; break; // Mighty
		case 7: cSA = 11; break; // Shaman
		}
		break;
	case 15: // Wars Elvine Ares, Guards; soldats summons  Heldenian
		switch (iDice(1,4)) {
		case 1: cSA = 9;  break; // Swift
		case 2: cSA = 10; break; // Mighty
		case 3: cSA = 11; break; // Shaman
		case 4: cSA = 12; break; // Crippled
		}
		break;
	}
	return cSA;
}

void CGame::AdminOrder_Summon(int iClientH, char *pData, DWORD dwMsgSize, char cSpecialAbility)
{char   seps[] = "= \t\n";
 char   * token, cBuff[256], cName_Master[10], cName_Slave[10], cNpcName[256], cWaypoint[11], cSA; 
 int    pX, pY, j, iNum, iNamingValue;
 class  CStrTok * pStrTok;
 BOOL   bMaster;
	if (m_pClientList[iClientH] == NULL) return;
	if ((dwMsgSize)	<= 0) return;
	if (m_pClientList[iClientH]->m_bIsAdminCommandEnabled == FALSE) return;
	if (m_pClientList[iClientH]->m_iAdminUserLevel < m_iAdminLevelSummon) 
	{	SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_ADMINUSERLEVELLOW, NULL, NULL, NULL, NULL);
		return;
	}
	ZeroMemory(cBuff, sizeof(cBuff));
	memcpy(cBuff, pData, dwMsgSize);
	pStrTok = new class CStrTok(cBuff, seps);
	token = pStrTok->pGet();
	token = pStrTok->pGet();
	if (token == NULL) {
		delete pStrTok;
		return;
	}
	ZeroMemory(cNpcName, sizeof(cNpcName));
	strcpy(cNpcName, token);
	//Do not allow summon of Energy-Sphere
	if ((strcmp(cNpcName, "Energy-Sphere") == 0)) return;
	token = pStrTok->pGet();	
	if (token != NULL) 
		 iNum = atoi(token);
	else iNum = 1;
	if (iNum <= 0)  iNum = 1;
	if (iNum >= 50)  iNum = 50;	
	cSA = 0;
	if ((cSpecialAbility < -12) || (cSpecialAbility > 12)) cSA = 0;
	else cSA = cSpecialAbility;
	pX = m_pClientList[iClientH]->m_sX;
	pY = m_pClientList[iClientH]->m_sY;
	wsprintf(G_cTxt, "(!) Admin Order: Summon(%s)-(%d)", cNpcName, iNum);
	PutAdminLogFileList(G_cTxt);
	PutLogList(G_cTxt);	
	wsprintf(G_cTxt, "GM Order(%-10s): /summon (summoned)", m_pClientList[iClientH]->m_cCharName);
	bSendMsgToLS(MSGID_GAMEMASTERLOG, iClientH, FALSE, G_cTxt);	
	iNamingValue = m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->iGetEmptyNamingValue();
	if (iNamingValue != -1) {
		ZeroMemory(cName_Master, sizeof(cName_Master));
		wsprintf(cName_Master, "XX%d", iNamingValue);
		cName_Master[0] = '_';
		cName_Master[1] = m_pClientList[iClientH]->m_cMapIndex + 65;
		if ((bMaster = bCreateNewNpc(cNpcName, cName_Master, m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cName, (rand() % 3), cSA, DEF_MOVETYPE_RANDOM, &pX, &pY, cWaypoint, NULL, NULL, -1, FALSE, FALSE, FALSE, TRUE)) == FALSE) {
			m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->SetNamingValueEmpty(iNamingValue);
		}
	}	
	for (j = 0; j < (iNum - 1); j++) {
		iNamingValue = m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->iGetEmptyNamingValue();
		if (iNamingValue != -1) {
			ZeroMemory(cName_Slave, sizeof(cName_Slave));
			wsprintf(cName_Slave, "XX%d", iNamingValue);
			cName_Slave[0] = '_';
			cName_Slave[1] = m_pClientList[iClientH]->m_cMapIndex + 65;
			if (bCreateNewNpc(cNpcName, cName_Slave, m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cName, (rand() % 3), cSA, DEF_MOVETYPE_RANDOM, &pX, &pY, cWaypoint, NULL, NULL, -1, FALSE, FALSE, FALSE) == FALSE) 
			{	m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->SetNamingValueEmpty(iNamingValue);
			}else 
			{	bSetNpcFollowMode(cName_Slave, cName_Master, DEF_OWNERTYPE_NPC);
			}
		}
	}
	delete pStrTok;
}

void CGame::AdminOrder_SummonAll(int iClientH, char *pData, DWORD dwMsgSize)
{char   seps[] = "= \t\n";
 char   * token, * cp, cBuff[256], cLocation[11], cMapName[11];
 WORD   *wp;
 int    pX, pY, i;
 class  CStrTok * pStrTok;
	if (m_pClientList[iClientH] == NULL) return;
	if ((dwMsgSize) <= 0) return;
	if (m_pClientList[iClientH]->m_bIsAdminCommandEnabled == FALSE) return;
	if (m_pClientList[iClientH]->m_iAdminUserLevel < m_iAdminLevelSummonAll) 
	{	 SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_ADMINUSERLEVELLOW, NULL, NULL, NULL, NULL);
		 return;
	}
	ZeroMemory(cBuff, sizeof(cBuff));
	memcpy(cBuff, pData, dwMsgSize);
	pStrTok = new class CStrTok(cBuff, seps);
	token = pStrTok->pGet();
	token = pStrTok->pGet();
	if (token == NULL) 
	{	 delete pStrTok;
		 return;
	}
	pX = m_pClientList[iClientH]->m_sX;
	pY = m_pClientList[iClientH]->m_sY;
	memcpy(cMapName, m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cName, 11);
	ZeroMemory(cLocation, sizeof(cLocation));
	if (strlen(token) > 10)
		memcpy(cLocation, token, 10);
	else memcpy(cLocation, token, strlen(token));
	for (i = 0; i < DEF_MAXCLIENTS; i++)
	if ((m_pClientList[i] != NULL) && (strcmp(m_pClientList[i]->m_cLocation, token) == 0)) 
	{	wsprintf(G_cTxt,"PC(%s) summoned by Admin(%s) to %s.", m_pClientList[i]->m_cCharName, m_pClientList[iClientH]->m_cCharName, cMapName);
		PutLogList(G_cTxt);
		RequestTeleportHandler(i, "2   ", cMapName, pX, pY);
	}
	wsprintf(G_cTxt, "Admin Order(%s): SummonAll (%s)"
		, m_pClientList[iClientH]->m_cCharName
		, cLocation);
	PutAdminLogFileList(G_cTxt);
	PutLogEventFileList(G_cTxt);
	wsprintf(G_cTxt, "GM Order(%-10s): /summonall %s", m_pClientList[iClientH]->m_cCharName, cLocation);
	bSendMsgToLS(MSGID_GAMEMASTERLOG, iClientH, FALSE, G_cTxt);	

	ZeroMemory(cBuff, sizeof(cBuff));
	cp = (char *)cBuff;
	*cp = GSM_REQUEST_SUMMONALL;
	cp++;
	memcpy(cp, cLocation, 10);
	cp += 10;
	memcpy(cp, cMapName, 10);
	cp += 10;
	wp = (WORD *)cp;
	*wp = m_pClientList[iClientH]->m_sX;
	cp += 2;
	wp = (WORD *)cp;
	*wp = m_pClientList[iClientH]->m_sY;
	cp += 2;
	bStockMsgToGateServer(cBuff, 25);	
	delete pStrTok;
}

void CGame::AdminOrder_SummonPlayer(int iClientH, char *pData, DWORD dwMsgSize)
{	char   seps[] = "= \t\n";
	char   * token, * cp, cBuff[256], cMapName[11], cName[11]; 
	WORD   *wp;
	int    pX, pY, i;
	class  CStrTok * pStrTok;
	if (m_pClientList[iClientH] == NULL) return;
	if ((dwMsgSize)	<= 0) return;
	if (m_pClientList[iClientH]->m_iAdminUserLevel < m_iAdminLevelSummonPlayer) {
		SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_ADMINUSERLEVELLOW, NULL, NULL, NULL, NULL);
		return;
	}
	ZeroMemory(cBuff, sizeof(cBuff));
	ZeroMemory(cName, sizeof(cName));
	memcpy(cBuff, pData, dwMsgSize);
	pStrTok = new class CStrTok(cBuff, seps);
	token = pStrTok->pGet();
	token = pStrTok->pGet();
	if (token == NULL) 
	{	delete pStrTok;
		return;
	}
	pX = m_pClientList[iClientH]->m_sX;
	pY = m_pClientList[iClientH]->m_sY;
	memcpy(cMapName, m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cName, 11);
	if (strlen(token) > 10)
		memcpy(cName, token, 10);
	else memcpy(cName, token, strlen(token));
	for (i = 0; i < DEF_MAXCLIENTS; i++)
	{	if ((m_pClientList[i] != NULL) && (memcmp(m_pClientList[i]->m_cCharName, cName, 10) == 0)) 
		{	if (i == iClientH) 
			{	delete pStrTok;
				return;
			}
			wsprintf(G_cTxt, "GM Order(%-10s): /summonplayer (%s)", m_pClientList[iClientH]->m_cCharName, cName);
			bSendMsgToLS(MSGID_GAMEMASTERLOG, iClientH, FALSE, G_cTxt);	
			RequestTeleportHandler(i, "2   ", cMapName, pX, pY);
			delete pStrTok;
			return;
		}//m_pClientList[i]->m_cCharName
	}
	// find char on other hg's
	ZeroMemory(cBuff, sizeof(cBuff));
	cp = (char *)cBuff;
	*cp = GSM_REQUEST_SUMMONPLAYER;
	cp++;
	memcpy(cp, cName, 10);
	cp += 10;
	memcpy(cp, cMapName, 10);
	cp += 10;
	wp = (WORD *)cp;
	*wp = m_pClientList[iClientH]->m_sX;
	cp += 2;
	wp = (WORD *)cp;
	*wp = m_pClientList[iClientH]->m_sY;
	cp += 2;
	bStockMsgToGateServer(cBuff, 25);
	delete pStrTok;
}

void CGame::CheckSpecialEvent(int iClientH)
{class CItem * pItem;
 char  cItemName[21];
 int   iEraseReq;
	if (m_pClientList[iClientH] == NULL) return;
	// Strange this value were set to 200081 for all v2.191 characters
	// Keeping it like this gives a Memorial Ring to each character!
	if (m_pClientList[iClientH]->m_iSpecialEventID == 200082) 	
	{	if (m_pClientList[iClientH]->m_iLevel < 11) 
		{	m_pClientList[iClientH]->m_iSpecialEventID = 0;
			return;
		}
		if (   (_iGetItemSpaceLeft(iClientH) < 1) 
			|| ((iCalcTotalWeight(iClientH)+ 20000) < _iCalcMaxLoad(iClientH)))
		{	SendItemNotifyMsg(iClientH,	DEF_NOTIFY_CANNOTCARRYMOREITEM, NULL, NULL);
			return;
		}
		ZeroMemory(cItemName, sizeof(cItemName));
		strcpy(cItemName, "MemorialRing"); 
		
		pItem = new class CItem;
		if (_bInitItemAttr(pItem, cItemName) == FALSE) 
		{	delete pItem;
		}else 
		{	if (_bAddClientItemList(iClientH, pItem, &iEraseReq) == TRUE) 
			{	if (m_pClientList[iClientH]->m_iCurWeightLoad < 0) m_pClientList[iClientH]->m_iCurWeightLoad = 0;
				wsprintf(G_cTxt, "PC(%s)\tGet MemorialRing\tIP(%s)"
					, m_pClientList[iClientH]->m_cCharName					
					, m_pClientList[iClientH]->m_cIPaddress);
				PutLogList(G_cTxt);				
				PutItemLogFileList(G_cTxt);					
				bSendMsgToLS(MSGID_GAMEITEMLOG, iClientH, NULL, G_cTxt);
				pItem->m_sTouchEffectType = DEF_ITET_UNIQUE_OWNER;
				pItem->m_sTouchEffectValue1 = m_pClientList[iClientH]->m_sCharIDnum1;
				pItem->m_sTouchEffectValue2 = m_pClientList[iClientH]->m_sCharIDnum2;
				pItem->m_sTouchEffectValue3 = m_pClientList[iClientH]->m_sCharIDnum3;
				pItem->m_cItemColor         = 9;
				m_pClientList[iClientH]->m_iSpecialEventID = 0;
	}	}	}
/*
;------Num--Name--------------Type-EPos-Effect--ETValue----------MaxLife-SEff--Spr-SFrame--Price--Wgt--ApprV-Speed-L.Lmt-G.Lmt--HR-R.------Skill-Cat--Color	
Item = 700	DarkKnightHauberkM  1	3	2	15	15	0	66	0	0	2000	0	7	3	-4000 1000	4	0	100	1	0	-3	0	6	15
Item = 701	DarkKnightHauberkW  1	3	2	15	15	0	66	0	0	2000	0	11	4	-4000 1000	5	0	100	2	0	-3	0	6	15
Item = 702	DarkKnightLeggingsM 1	4	2	18	25	1	66	0	0	3000	0	8	5	-6000 1000	6	0	100	1	0	-6	0	6	15
Item = 703	DarkKnightLeggingsW 1	4	2	18	25	1	66	0	0	3000	0	12	6	-6000 1000	7	0	100	2	0	-6	0	6	15
Item = 704	DarkKnightHelm 	    1	1	2	18	24	0	66	0	0	2500	0	21	7	-5000 1000	11	0	100	0	0	-7	0	6	15
Item = 705	DarkKnightArmorM 	1	2	2	45	48	0	66	0	0	5000	0	9	8	-10000 5000 9	0	100	1	0	-5	0	6	15
Item = 706	DarkKnightArmorW 	1	2	2	45	48	0	66	0	0	5000	0	13	9	-10000 5000 10	0	100	2	0	-5	0	6	15
Item = 707	DarkMageRobeM		1	2	2	20	20	0	66	0	0	4000	0	9	10	-10000 1000	11	0	100	1	0	0	0	13	15
Item = 708	DarkMageRobeW		1	2	2	20	20	0	66	0	0	4000	0	13	11	-10000 1000	12	0	100	2	0	0	0	13	15
Item = 709	DarkKnightBlade 	1	9	1	2	13	3	2	14	3	3000	0	1	26	-5000 6000	15	12	100	0	25	10	8	1	0
// Special for Evil side, Server will not drop them or allow anyone else to equip
*/
	if (m_pClientList[iClientH]->m_iSpecialEventID == 666) 	
	{	if (m_pClientList[iClientH]->m_cSide != 4) 
		{	m_pClientList[iClientH]->m_iSpecialEventID = 0;
			return;
		}
		if (   (_iGetItemSpaceLeft(iClientH) < 5) 
			|| ((iCalcTotalWeight(iClientH)+ 20000) > _iCalcMaxLoad(iClientH)))
		{	SendItemNotifyMsg(iClientH,	DEF_NOTIFY_CANNOTCARRYMOREITEM, NULL, NULL);
			return;
		}	
		// Hauberk
		ZeroMemory(cItemName, sizeof(cItemName));
		if (m_pClientList[iClientH]->m_cSex == 1) 
			 strcpy(cItemName, "DarkKnightHauberkM"); 
		else strcpy(cItemName, "DarkKnightHauberkW"); 
		pItem = new class CItem;
		if (_bInitItemAttr(pItem, cItemName) == FALSE) 
		{	delete pItem;
		}else 
		{	if (_bAddClientItemList(iClientH, pItem, &iEraseReq) == TRUE) 
			{	if (m_pClientList[iClientH]->m_iCurWeightLoad < 0) m_pClientList[iClientH]->m_iCurWeightLoad = 0;
				pItem->m_sTouchEffectType = DEF_ITET_UNIQUE_OWNER;
				pItem->m_sTouchEffectValue1 = m_pClientList[iClientH]->m_sCharIDnum1;
				pItem->m_sTouchEffectValue2 = m_pClientList[iClientH]->m_sCharIDnum2;
				pItem->m_sTouchEffectValue3 = m_pClientList[iClientH]->m_sCharIDnum3;
				pItem->m_cItemColor         = 15;
				m_pClientList[iClientH]->m_iSpecialEventID = 0;
		}	}
		// Leggings
		ZeroMemory(cItemName, sizeof(cItemName));
		if (m_pClientList[iClientH]->m_cSex == 1) 
			 strcpy(cItemName, "DarkKnightLeggingsM"); 
		else strcpy(cItemName, "DarkKnightLeggingsW"); 
		pItem = new class CItem;
		if (_bInitItemAttr(pItem, cItemName) == FALSE) 
		{	delete pItem;
		}else 
		{	if (_bAddClientItemList(iClientH, pItem, &iEraseReq) == TRUE) {
				if (m_pClientList[iClientH]->m_iCurWeightLoad < 0) m_pClientList[iClientH]->m_iCurWeightLoad = 0;
				pItem->m_sTouchEffectType = DEF_ITET_UNIQUE_OWNER;
				pItem->m_sTouchEffectValue1 = m_pClientList[iClientH]->m_sCharIDnum1;
				pItem->m_sTouchEffectValue2 = m_pClientList[iClientH]->m_sCharIDnum2;
				pItem->m_sTouchEffectValue3 = m_pClientList[iClientH]->m_sCharIDnum3;
				pItem->m_cItemColor         = 15;
		}	}
		// Head
		ZeroMemory(cItemName, sizeof(cItemName));
		strcpy(cItemName, "DarkKnightHelm");  
		pItem = new class CItem;
		if (_bInitItemAttr(pItem, cItemName) == FALSE) 
		{	delete pItem;
		}else 
		{	if (_bAddClientItemList(iClientH, pItem, &iEraseReq) == TRUE) {
				if (m_pClientList[iClientH]->m_iCurWeightLoad < 0) m_pClientList[iClientH]->m_iCurWeightLoad = 0;
				pItem->m_sTouchEffectType = DEF_ITET_UNIQUE_OWNER;
				pItem->m_sTouchEffectValue1 = m_pClientList[iClientH]->m_sCharIDnum1;
				pItem->m_sTouchEffectValue2 = m_pClientList[iClientH]->m_sCharIDnum2;
				pItem->m_sTouchEffectValue3 = m_pClientList[iClientH]->m_sCharIDnum3;
				pItem->m_cItemColor         = 15;
		}	}
		// Blade
		if (m_pClientList[iClientH]->m_iStr > m_pClientList[iClientH]->m_iInt) 
		{	ZeroMemory(cItemName, sizeof(cItemName));
			strcpy(cItemName, "DarkKnightBlade");  
			pItem = new class CItem;
			if (_bInitItemAttr(pItem, cItemName) == FALSE) 
			{	delete pItem;
			}else 
			{	if (_bAddClientItemList(iClientH, pItem, &iEraseReq) == TRUE) 
				{	if (m_pClientList[iClientH]->m_iCurWeightLoad < 0) m_pClientList[iClientH]->m_iCurWeightLoad = 0;
					pItem->m_sTouchEffectType = DEF_ITET_UNIQUE_OWNER;
					pItem->m_sTouchEffectValue1 = m_pClientList[iClientH]->m_sCharIDnum1;
					pItem->m_sTouchEffectValue2 = m_pClientList[iClientH]->m_sCharIDnum2;
					pItem->m_sTouchEffectValue3 = m_pClientList[iClientH]->m_sCharIDnum3;
					pItem->m_cItemColor         = 15;
		}	}	}
		// Armor
		ZeroMemory(cItemName, sizeof(cItemName));
		if (m_pClientList[iClientH]->m_cSex == 1) 
			 strcpy(cItemName, "DarkKnightArmorM"); 
		else strcpy(cItemName, "DarkKnightArmorW"); 
		if (m_pClientList[iClientH]->m_iStr < m_pClientList[iClientH]->m_iInt) 
		{	ZeroMemory(cItemName, sizeof(cItemName));
			if (m_pClientList[iClientH]->m_cSex == 1) 
				 strcpy(cItemName, "DarkMageRobeM"); // or Robe
			else strcpy(cItemName, "DarkMageRobeW"); 		
		}
		pItem = new class CItem;
		if (_bInitItemAttr(pItem, cItemName) == FALSE) 
		{	delete pItem;
		}else 
		{	if (_bAddClientItemList(iClientH, pItem, &iEraseReq) == TRUE) {
				if (m_pClientList[iClientH]->m_iCurWeightLoad < 0) m_pClientList[iClientH]->m_iCurWeightLoad = 0;
				pItem->m_sTouchEffectType = DEF_ITET_UNIQUE_OWNER;
				pItem->m_sTouchEffectValue1 = m_pClientList[iClientH]->m_sCharIDnum1;
				pItem->m_sTouchEffectValue2 = m_pClientList[iClientH]->m_sCharIDnum2;
				pItem->m_sTouchEffectValue3 = m_pClientList[iClientH]->m_sCharIDnum3;
				pItem->m_cItemColor         = 15;		
		}	}
		wsprintf(G_cTxt, "PC(%s)\tGet Executor items\tIP(%s)"
			, m_pClientList[iClientH]->m_cCharName					
			, m_pClientList[iClientH]->m_cIPaddress);
		PutLogList(G_cTxt);				
		PutItemLogFileList(G_cTxt);					
		bSendMsgToLS(MSGID_GAMEITEMLOG, iClientH, NULL, G_cTxt);
	}
}

void CGame::AdminOrder_DisconnectAll(int iClientH, char *pData, DWORD dwMsgSize)
{	if (m_pClientList[iClientH] == NULL) return;
	if ((dwMsgSize)	<= 0) return;
	if (m_pClientList[iClientH]->m_bIsAdminCommandEnabled == FALSE) return;
	if (m_pClientList[iClientH]->m_iAdminUserLevel < m_iAdminLevelDisconnectAll) {
		SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_ADMINUSERLEVELLOW, NULL, NULL, NULL, NULL);
		return;
	}
	wsprintf(G_cTxt, "Admin Order(%s): Disconnect all\tAdminIP(%s)"
		, m_pClientList[iClientH]->m_cCharName
		, m_pClientList[iClientH]->m_cIPaddress);
	PutAdminLogFileList(G_cTxt);	
	wsprintf(G_cTxt, "GM Order(%-10s): /disconnectall (done)", m_pClientList[iClientH]->m_cCharName);
	bSendMsgToLS(MSGID_GAMEMASTERLOG, iClientH, FALSE, G_cTxt);	
	_iForcePlayerDisconect(DEF_MAXCLIENTS);
}

BOOL CGame::_bDecodeDupItemIDFileContents(char *pData, DWORD dwMsgSize)
{
 char * pContents, * token, cTxt[120];
 char seps[] = "= \t\n";
 char cReadModeA = 0;
 char cReadModeB = 0;
 int  iIndex = 0;
 class CStrTok * pStrTok;

	pContents = new char[dwMsgSize+1];
	ZeroMemory(pContents, dwMsgSize+1);
	memcpy(pContents, pData, dwMsgSize);

	pStrTok = new class CStrTok(pContents, seps);
	token = pStrTok->pGet();
	
	while( token != NULL ) {
		if (cReadModeA != 0) {
			switch (cReadModeA) {
			case 1:
				switch (cReadModeB) {
				case 1:
					// ½ºÅ³ ¹øÈ£ 
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) ERROR! DupItemID configuration file error - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					
					if (m_pDupItemIDList[atoi(token)] != NULL) {
						// ÀÌ¹Ì ÇÒ´çµÈ ¹øÈ£°¡ ÀÖ´Ù. ¿¡·¯ÀÌ´Ù.
						PutLogList("(!!!) ERROR! DupItemID configuration file error - Duplicate magic number.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pDupItemIDList[atoi(token)] = new class CItem;
					iIndex = atoi(token);

					cReadModeB = 2;
					break;

				case 2:
					// m_sTouchEffectType
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) ERROR! DupItemID configuration file error - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pDupItemIDList[iIndex]->m_sTouchEffectType = atoi(token);
					cReadModeB = 3;
					break;

				case 3:
					// m_sTouchEffectValue1
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) ERROR! DupItemID configuration file error - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pDupItemIDList[iIndex]->m_sTouchEffectValue1 = atoi(token);
					cReadModeB = 4;
					break;
				
				case 4:
					// m_sTouchEffectValue2
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) ERROR! DupItemID configuration file error - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pDupItemIDList[iIndex]->m_sTouchEffectValue2 = atoi(token);
					cReadModeB = 5;
					break;

				case 5:
					// m_sTouchEffectValue3
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) ERROR! DupItemID configuration file error - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pDupItemIDList[iIndex]->m_sTouchEffectValue3 = atoi(token);
					cReadModeB = 6;
					break;

				case 6:
					// m_wPrice
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) ERROR! DupItemID configuration file error - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pDupItemIDList[iIndex]->m_wPrice = (WORD)atoi(token);
					cReadModeA = 0;
					cReadModeB = 0;

					//testcode
					//wsprintf(G_cTxt, "(%d) %d %d %d %d", iIndex, m_pDupItemIDList[iIndex]->m_sTouchEffectType, m_pDupItemIDList[iIndex]->m_sTouchEffectValue1, m_pDupItemIDList[iIndex]->m_sTouchEffectValue2, m_pDupItemIDList[iIndex]->m_sTouchEffectValue3); 
					//PutLogList(G_cTxt);
					break;
				}
				break;

			default: 
				break;
			}
		}
		else {
			if (memcmp(token, "DupItemID", 9) == 0) {
				cReadModeA = 1;
				cReadModeB = 1;
			}
			
		}
		token = pStrTok->pGet();
	}	

	delete pStrTok;
	delete pContents;

	if ((cReadModeA != 0) || (cReadModeB != 0)) {
		PutLogList("(!!!) ERROR! DupItemID configuration file contents error!");
		return FALSE;
	}

	wsprintf(cTxt, "(!) DupItemID (Total:%d) configuration - success!", iIndex);
	PutLogList(cTxt);
	
	return TRUE;
}

BOOL CGame::_bCheckDupItemID(CItem *pItem)
{	register int i;
	for (i = 0; i < DEF_MAXDUPITEMID; i++)
	if (m_pDupItemIDList[i] != NULL) 
	{	if (   (pItem->m_sTouchEffectType   == m_pDupItemIDList[i]->m_sTouchEffectType)
			&& (pItem->m_sTouchEffectValue1 == m_pDupItemIDList[i]->m_sTouchEffectValue1)
			&& (pItem->m_sTouchEffectValue2 == m_pDupItemIDList[i]->m_sTouchEffectValue2)
			&& (pItem->m_sTouchEffectValue3 == m_pDupItemIDList[i]->m_sTouchEffectValue3)
			&& (pItem->m_sTouchEffectValue1 != 0)// Snoopy: 0 0 0 items are not dupes....
			&& (pItem->m_sTouchEffectValue2 != 0)
			&& (pItem->m_sTouchEffectValue3 != 0) ) 
		{	pItem->m_wPrice = m_pDupItemIDList[i]->m_wPrice;
			return TRUE;
		}
	}	
	return FALSE;
}

void CGame::_AdjustRareItemValue(CItem *pItem)
{	DWORD dwSWEType, dwSWEValue;
	double dV1, dV2, dV3;
	if ((pItem->m_dwAttribute & 0x00F00000) != NULL) 
	{	dwSWEType  = (pItem->m_dwAttribute & 0x00F00000) >> 20;  
		dwSWEValue = (pItem->m_dwAttribute & 0x000F0000) >> 16;
		switch (dwSWEType) {
		case 0: break;		
		case 5: // Agile
			pItem->m_cSpeed--;
			if (pItem->m_sIDnum == 231) pItem->m_cSpeed--;
			if (pItem->m_cSpeed < 0) pItem->m_cSpeed = 0;
			break;
		case 6: // Light 
			dV2 = (double)pItem->m_wWeight;
			dV3 = (double)(dwSWEValue*4);
			dV1 = (dV3/100.0f)*dV2;
			pItem->m_wWeight -= (int)dV1;
			if (pItem->m_wWeight < 1) pItem->m_wWeight = 1;
			break;

		case 8: //  Strong
		case 9: //  Ancient
			dV2 = (double)pItem->m_wMaxLifeSpan;
			dV3 = (double)(dwSWEValue*7);
			dV1 = (dV3/100.0f)*dV2;
			pItem->m_wMaxLifeSpan += (int)dV1;
			break;
		}
	}
}

void CGame::RequestNoticementHandler(int iClientH, char * pData)
{
 char * cp, cData[120];
 int  * ip, iRet, iClientSize;
 DWORD * dwp;
 WORD  * wp;
 
	if (m_pClientList[iClientH] == NULL) return;
	if (m_dwNoticementDataSize < 10) return;

	ip = (int *)(pData + DEF_INDEX2_MSGTYPE + 2);
	iClientSize = *ip;

	if (iClientSize != m_dwNoticementDataSize) {
		cp = new char[m_dwNoticementDataSize + 2 + DEF_INDEX2_MSGTYPE + 2];
		ZeroMemory(cp, m_dwNoticementDataSize + 2 + DEF_INDEX2_MSGTYPE + 2);
		memcpy((cp + DEF_INDEX2_MSGTYPE + 2), m_pNoticementData, m_dwNoticementDataSize);
		
		dwp  = (DWORD *)(cp + DEF_INDEX4_MSGID);
		*dwp = MSGID_RESPONSE_NOTICEMENT;
		wp   = (WORD *)(cp + DEF_INDEX2_MSGTYPE);
		*wp  = DEF_MSGTYPE_REJECT;
		
		iRet = m_pClientList[iClientH]->m_pXSock->iSendMsg(cp, m_dwNoticementDataSize + 2 + DEF_INDEX2_MSGTYPE + 2);
	
		delete cp;
	}
	else {
		ZeroMemory(cData, sizeof(cData));
		
		dwp  = (DWORD *)(cData + DEF_INDEX4_MSGID);
		*dwp = MSGID_RESPONSE_NOTICEMENT;
		wp   = (WORD *)(cData + DEF_INDEX2_MSGTYPE);
		*wp  = DEF_MSGTYPE_CONFIRM;
		
		iRet = m_pClientList[iClientH]->m_pXSock->iSendMsg(cData, 6);
	}
}

void CGame::_bDecodeNoticementFileContents(char *pData, DWORD dwMsgSize)
{
 char * cp;	
	
	cp = (pData);
	
	if (m_pNoticementData != NULL) {
		delete m_pNoticementData;
		m_pNoticementData = NULL;
	}

	m_pNoticementData = new char[strlen(cp) + 2];
	ZeroMemory(m_pNoticementData, strlen(cp) + 2);

	memcpy(m_pNoticementData, cp, strlen(cp));
	m_dwNoticementDataSize = strlen(cp);

	wsprintf(G_cTxt, "(!) Noticement Data Size: %d", m_dwNoticementDataSize);
	PutLogList(G_cTxt);
}

void CGame::RequestCheckAccountPasswordHandler(char *pData, DWORD dwMsgSize)
{
 int * ip, i, iLevel;
 char * cp, cAccountName[11], cAccountPassword[11];

	cp = (char *)(pData + 6);
	ZeroMemory(cAccountName, sizeof(cAccountName));
	ZeroMemory(cAccountPassword, sizeof(cAccountPassword));
	memcpy(cAccountName, cp, 10);
	cp += 10;
	memcpy(cAccountPassword, cp, 10);
	cp += 10;
	ip = (int *)cp;
	iLevel = *ip;
	cp += 4;

	for (i = 0; i < DEF_MAXCLIENTS; i++)
	if ((m_pClientList[i] != NULL) && (strcmp(m_pClientList[i]->m_cAccountName, cAccountName) == 0)) {
		if ((strcmp(m_pClientList[i]->m_cAccountPassword, cAccountPassword) != 0) || (m_pClientList[i]->m_iLevel != iLevel)) {
			wsprintf(G_cTxt, "(TestLog) Error! Account(%s)-Level(%d) password(or level) mismatch! Disconnect.", cAccountName, iLevel);
			PutLogList(G_cTxt);
			DeleteClient(i, FALSE, TRUE);
			return;
		}
	}
}
// SNOOPY: redisigned all this for a druid class
void CGame::_TamingHandler(int iClientH, int iSkillNum, char cMapIndex, int dX, int dY)
{	int iSkillLevel, iRange, iTamingLevel, iResult; 
	register int iX, iY;
	short sOwnerH;
	char  cOwnerType;
	int iNbeTamed = 0;
	if (m_pClientList[iClientH] == NULL) return;
	if (m_pMapList[cMapIndex] == NULL) return;	
	if (m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_bIsFightZone == TRUE) 
	{	SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_SKILLUSINGEND, NULL, NULL, NULL, NULL);
		return;
	}
	int iTamingType = 0; // 0: Standard, 1: Mage, 2: Paladin, 3 Priest, 4: Druid, 5: Executor, 9: GM			
	int sItemIndex;
	sItemIndex = m_pClientList[iClientH]->m_sItemEquipmentStatus[DEF_EQUIPPOS_HEAD];
	if (m_pClientList[iClientH]->m_iAdminUserLevel == 0) 
	{	if (  (m_pClientList[iClientH]->m_iStr > 30)
			&&(m_pClientList[iClientH]->m_iCharisma >30))
		{	iTamingType = 3; // Paladin
		} 
		if (   (m_pClientList[iClientH]->m_iInt > 49)
			&& (m_pClientList[iClientH]->m_iCharisma < m_pClientList[iClientH]->m_iInt))
		{	iTamingType = 4; // Mage
		}
		if (m_pClientList[iClientH]->m_cSide > 2) 
		{	iTamingType = 5; // Executor
		}  
		if (m_pClientList[iClientH]->m_iPriestDruidID == 1) 
		{	iTamingType = 1; // Priest
		} 
		if (m_pClientList[iClientH]->m_iPriestDruidID == 2) 
		{	iTamingType = 2; // Druid
		} 
			
	}else iTamingType = 9; // GM or Admin	

	iSkillLevel = (int)m_pClientList[iClientH]->m_cSkillMastery[iSkillNum];
	iRange = 2 + iSkillLevel / 20; 

	for (iX = dX - iRange; iX <= dX + iRange; iX++)
	for (iY = dY - iRange; iY <= dY + iRange; iY++) {
		sOwnerH = NULL;
		if ((iX > 0) && (iY > 0) && (iX < m_pMapList[cMapIndex]->m_sSizeX) && (iY < m_pMapList[cMapIndex]->m_sSizeY))
			m_pMapList[cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, iX, iY);

		if (sOwnerH != NULL) {
			switch (cOwnerType) {
			case DEF_OWNERTYPE_PLAYER:
				continue;
				break;
			case DEF_OWNERTYPE_NPC:
				if (m_pNpcList[sOwnerH] == NULL) break;
				// 1st list for everybody			
				iTamingLevel = 201; // 201 means impossible
				switch (m_pNpcList[sOwnerH]->m_sType) {
				case 14:iTamingLevel = 35; break;	// Orc
				case 28:iTamingLevel = 65; break;	// Troll
				case 29:iTamingLevel = 100; break;	// Ogre
				case 58:iTamingLevel = 100; break;	// MG
				case 59:iTamingLevel = 120; break;	// Ettin
				case 77:iTamingLevel = 160; break;	// MasterMage-Orc 
				case 78:iTamingLevel = 170; break;	// Minos 
				}
				switch (iTamingType) {
				case 4: // Mages					
					if (iTamingLevel > 199) iTamingLevel = 199;
					switch (m_pNpcList[sOwnerH]->m_sType) {
					case 12:							// Stone
					case 23:iTamingLevel = 40; break;	// Clay
					case 65:iTamingLevel = 70; break;	// IceGolem
					case 80:iTamingLevel = 80; break;	// Tentocle
					case 53:iTamingLevel = 100; break;	// BB
					case 31:iTamingLevel = 170; break;	// DD
					}
					break;
				case 3: // Paladins			
					if (iTamingLevel > 197) iTamingLevel = 197;
					switch (m_pNpcList[sOwnerH]->m_sType) { 
					case 18:							// Zombie 
					case 11:iTamingLevel = 35; break;	// Skel
					case 27:iTamingLevel = 65; break;	// hh
					case 30:iTamingLevel = 120; break;	// Liche
					case 31:iTamingLevel = 170; break;	// DD
					case 32: // Uni possible for some purest Paladins
						if (   (m_pClientList[iClientH]->m_iPKCount == 0) 	// Uni
							&& (m_pClientList[iClientH]->m_iEnemyKillCount == 0)
							&& (m_pClientList[iClientH]->m_iRating > 0) )
						{	iTamingLevel = 100;
						};					
						break;
					}
					break;
				case 1: // Priests		
					if (iTamingLevel > 195) iTamingLevel = 195;
					switch (m_pNpcList[sOwnerH]->m_sType) { 
					case 18:							// Zombie 
					case 11:iTamingLevel = 35; break;	// Skel
					case 27:iTamingLevel = 60; break;	// hh
					case 30:iTamingLevel = 110; break;	// Liche
					case 31:iTamingLevel = 160; break;	// DD
					}
					break;
				case 2: // Druids	
					if (iTamingLevel > 185) iTamingLevel = 185;
					switch (m_pNpcList[sOwnerH]->m_sType) {
					case 55:							// Rabbit 
					case 56:iTamingLevel = 25; break;	// Cat  
					case 16:							// Ant 
					case 22:iTamingLevel = 30; break;	// Snake  
					case 17:iTamingLevel = 35; break;	// Scorpion 
					case 57:							// Frog
					case 61:iTamingLevel = 50; break;	// Rudolph
					case 74:iTamingLevel = 60; break;	// Giant-Crayfish
					case 60:							// Plant
					case 62:							// DireBoar
					case 76:iTamingLevel = 75; break;	// Giant-Tree
					case 72:iTamingLevel = 90; break;	// Claw-Turtle
					case 48:iTamingLevel = 100; break;	// SK
					case 32:// Uni possible for some purest Druids only
						if (   (m_pClientList[iClientH]->m_iPKCount == 0) 	// Uni
							&& (m_pClientList[iClientH]->m_iEnemyKillCount == 0)
							&& (m_pClientList[iClientH]->m_iRating > 0) )
						{	iTamingLevel = 100;
						};	
					case 70:iTamingLevel = 140; break;	// Dragon
					case 71:							// Centaurus
					case 78:							// Minotaurs
					case 75:iTamingLevel = 150; break;	// Giant-Lizard
					}
					break;
				case 5: // Executors can tame any creature
					iTamingLevel = m_pNpcList[sOwnerH]->m_iHitDice /2;
					iTamingLevel += 30;
					if (m_pNpcList[sOwnerH]->m_iHitDice > 140) 
					{	iTamingLevel = m_pNpcList[sOwnerH]->m_iHitDice /4;
						iTamingLevel += 65;
					}
					if (iTamingLevel > 195 ) iTamingLevel = 195;
					// But not evil creatures a not Tamable
					if (m_pNpcList[sOwnerH]->m_cSide <4 ) iTamingLevel = 199;
					break;

				case 9: // GM
					iTamingLevel = 30;
					if (m_pNpcList[sOwnerH]->m_cSide == 0) iTamingLevel = 201;
					break;
				}
				iResult = iDice(2,iSkillLevel);
				if (   (iResult >= iTamingLevel)
					&& (m_pNpcList[sOwnerH]->m_dwTamingTime == 0)
					&& (m_pNpcList[sOwnerH]->m_cSide != m_pClientList[iClientH]->m_cSide))
				{	iNbeTamed ++;
					// Now change npc side...
					m_pNpcList[sOwnerH]->m_cOriginalSide = m_pNpcList[sOwnerH]->m_cSide;
					switch (iTamingType) {
					case 0: // Default -> npc becomes neutral 					
						m_pNpcList[sOwnerH]->m_cSide = 0;
						break;
					case 4: // Mages -> npc becomes neutral 					
						switch (m_pNpcList[sOwnerH]->m_sType) {	
						case 31: // DD						
							m_pNpcList[sOwnerH]->m_cSide = m_pClientList[iClientH]->m_cSide;
							break;
						default:
							m_pNpcList[sOwnerH]->m_cSide = 0;
							break;	
						}	
						break;
					case 3: // Paladins		
						switch (m_pNpcList[sOwnerH]->m_sType) { 
						case 18: // Zombie 
						case 11: // Skel
							if (iDice(1,95) <= iSkillLevel) m_pNpcList[sOwnerH]->m_cSide = m_pClientList[iClientH]->m_cSide;
							else m_pNpcList[sOwnerH]->m_cSide = 0;
						case 32: // Uni
							m_pNpcList[sOwnerH]->m_cSide = m_pClientList[iClientH]->m_cSide;				
							break;
						default:  m_pNpcList[sOwnerH]->m_cSide = 0;
							break;						
						}
						break;
					case 1: // Priests			
						switch (m_pNpcList[sOwnerH]->m_sType) { 
						case 18: // Zombie 
						case 11: // Skel
							if (iDice(1,85) <= iSkillLevel) m_pNpcList[sOwnerH]->m_cSide = m_pClientList[iClientH]->m_cSide;
							else m_pNpcList[sOwnerH]->m_cSide = 0;
							break;
						case 27: // HH
						case 30: // Liche
							if (iDice(1,150) <= iSkillLevel) m_pNpcList[sOwnerH]->m_cSide = m_pClientList[iClientH]->m_cSide;
							else m_pNpcList[sOwnerH]->m_cSide = 0;
							break;
						default:  m_pNpcList[sOwnerH]->m_cSide = 0;
							break;						
						}
						break;	
					case 2: // Druids	
						switch (m_pNpcList[sOwnerH]->m_sType) {
						case 55: // Rabbit 
						case 56: // Cat  
						case 16: // Ant 
						case 22: // Snake  
						case 17: // Scorpion 
						case 57: // Frog
						case 61: // Rudolph
						case 74: // Giant-Crayfish
						case 60: // Plant
						case 62: // DireBoar
						case 76: // Giant-Tree
						case 72: // Claw-Turtle
						case 48: // SK
							m_pNpcList[sOwnerH]->m_cSide = m_pClientList[iClientH]->m_cSide;
							break;	
						case 70: // Dragon
							if (iDice(1,100) <= iSkillLevel) m_pNpcList[sOwnerH]->m_cSide = m_pClientList[iClientH]->m_cSide;
							else m_pNpcList[sOwnerH]->m_cSide = 0;
							break;
						case 71: // Centaurus
						case 78: // Minotaurs
						case 75: // Giant-Lizard
							if (iDice(1,150) <= iSkillLevel) m_pNpcList[sOwnerH]->m_cSide = 0;
							break;
						default:  m_pNpcList[sOwnerH]->m_cSide = 0;
							break;	
						}
						break;
					case 5: // Executors -> npc becomes side 4 					
						m_pNpcList[sOwnerH]->m_cSide = 4;
						break;
					default:
						break;
					case 9: // GM
						m_pNpcList[sOwnerH]->m_cSide = 0;
						break;
					}				
					m_pNpcList[sOwnerH]->m_dwTamingTime = timeGetTime() + 3000*iSkillLevel + 120000;
					m_pNpcList[sOwnerH]->m_cBehavior          = DEF_BEHAVIOR_MOVE;
					m_pNpcList[sOwnerH]->m_sBehaviorTurnCount = 0;
					m_pNpcList[sOwnerH]->m_iTargetIndex       = NULL;
					if (m_pNpcList[sOwnerH]->m_cSide == m_pClientList[iClientH]->m_cSide)
					{	m_pNpcList[sOwnerH]->m_cMoveType		 = DEF_MOVETYPE_FOLLOW;
						m_pNpcList[sOwnerH]->m_cFollowOwnerType  = DEF_OWNERTYPE_PLAYER;
						m_pNpcList[sOwnerH]->m_iFollowOwnerIndex = iClientH;								
					}
					SendEventToNearClient_TypeA(sOwnerH, DEF_OWNERTYPE_NPC, MSGID_EVENT_MOTION, DEF_OBJECTNULLACTION, NULL, NULL, NULL);
					// Increase skill if not easy Taming
					if (iTamingLevel >= iSkillLevel)
					{	CalculateSSN_SkillIndex(iClientH, 22, 1);
					}
				} break;// End of succes in taming 1 creature
			} // End of OWNERTYPE Switch
		}
	}
	if (iNbeTamed == 0)  // No creature tamed
	{	SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_SKILLUSINGEND, 0, NULL, NULL, NULL);
	}else 
	{	SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_SKILLUSINGEND, 1, NULL, NULL, NULL);		
		char cTamedString[500];
		ZeroMemory(cTamedString,  sizeof(cTamedString));
		switch (iTamingType) {
		case 1:	
		case 3:	wsprintf(cTamedString, "Undead turned: %d", iNbeTamed);
			break;
		case 2:	wsprintf(cTamedString, "Woodland beings enchanted: %d", iNbeTamed);
			break;
		case 4:	wsprintf(cTamedString, "Magic things controled: %d", iNbeTamed);
			break;
		case 5:	wsprintf(cTamedString, "Abaddon's fiends taken under control: %d", iNbeTamed);
			break;
		default: // and case 0
		case 9:	wsprintf(cTamedString, "Creatures neutralised: %d", iNbeTamed);
			break;
		}
		ShowClientMsg(iClientH,  "Taming", cTamedString);	
		//SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_IPACCOUNTINFO, NULL, NULL, NULL, cTamedString);
		// Debug
		ZeroMemory(cTamedString,  sizeof(cTamedString));	
			wsprintf(cTamedString, "(!) Taming skill: %s is using Taming skill (%d%%) (Type %d), he tamed %d creatures."
			, m_pClientList[iClientH]->m_cCharName
			, iSkillLevel
			, iTamingType
			, iNbeTamed);
		PutLogList(cTamedString);
	}
}
void CGame::GetMagicAbilityHandler(int iClientH)
{	if (m_pClientList[iClientH] == NULL) return;
	if (m_pClientList[iClientH]->m_cSkillMastery[4] != 0) return;
	m_pClientList[iClientH]->m_cSkillMastery[4] = 20;
	SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_SKILL, 4, m_pClientList[iClientH]->m_cSkillMastery[4], NULL, NULL);
	bCheckTotalSkillMasteryPoints(iClientH, 4);
}

int CGame::iRequestPanningMapDataRequest(int iClientH, char * pData)
{char  * cp, cDir, cData[3000];
 DWORD * dwp;
 WORD  * wp;
 short * sp, dX, dY;
 int   iRet, iSize;
	if (m_pClientList[iClientH] == NULL) return 0;
	if (m_pClientList[iClientH]->m_bIsObserverMode == FALSE) return 0;
	if (m_pClientList[iClientH]->m_bIsKilled == TRUE) return 0;
	if (m_pClientList[iClientH]->m_bIsInitComplete == FALSE) return 0;
	dX = m_pClientList[iClientH]->m_sX;
	dY = m_pClientList[iClientH]->m_sY;
	cDir = *(pData + DEF_INDEX2_MSGTYPE +2);
	if ((cDir <= 0) || (cDir > 8)) return 0;		
	switch (cDir) {
	case 1:	dY--; break; // responding when mouse is placed north
	case 2:	dX++; dY--;	break;
	case 3:	dX++; break;
	case 4:	dX++; dY++;	break;
	case 5: dY++; break;
	case 6:	dX--; dY++;	break;
	case 7:	dX--; break; // responding when mouse placed at west side of screen
	case 8:	dX--; dY--;	break; // responding when mouse is placed north west
	}
	m_pClientList[iClientH]->m_sX   = dX;
	m_pClientList[iClientH]->m_sY   = dY;
	m_pClientList[iClientH]->m_cDir = cDir;	
	dwp  = (DWORD *)(cData + DEF_INDEX4_MSGID);
	*dwp = MSGID_RESPONSE_PANNING;
	wp   = (WORD *)(cData + DEF_INDEX2_MSGTYPE);
	*wp  = DEF_OBJECTMOVE_CONFIRM;		
	cp = (char *)(cData + DEF_INDEX2_MSGTYPE+2);		
	sp  = (short *)cp;
	*sp = (short)(dX - 10); 
	cp += 2;		
	sp  = (short *)cp;
	*sp = (short)(dY - 7); 
	cp += 2;
	*cp = cDir;
	cp++;		
	iSize = iComposeMoveMapData((short)(dX - 10), (short)(dY - 7), iClientH, cDir, cp);
	iRet = m_pClientList[iClientH]->m_pXSock->iSendMsg(cData, iSize + 12 + 1 + 4);
	switch (iRet) {
	case DEF_XSOCKEVENT_QUENEFULL:
	case DEF_XSOCKEVENT_SOCKETERROR:
	case DEF_XSOCKEVENT_CRITICALERROR:
	case DEF_XSOCKEVENT_SOCKETCLOSED:

		DeleteClient(iClientH, TRUE, TRUE);
		return 0;
	}
	return 1;
}

void CGame::AdminOrder_SetObserverMode(int iClientH)
{	if (m_pClientList[iClientH] == NULL) return;
	if (   (m_pClientList[iClientH]->m_iAdminUserLevel < m_iAdminLevelObserver)
		|| (m_pClientList[iClientH]->m_iAdminUserLevel == 0))
	{	m_pClientList[iClientH]->m_bIsObserverMode = FALSE;
		return;
	}
	if (m_pClientList[iClientH]->m_bIsObserverMode == TRUE)   
	{	m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->SetOwner(iClientH, DEF_OWNERTYPE_PLAYER, m_pClientList[iClientH]->m_sX, m_pClientList[iClientH]->m_sY);		
		SendEventToNearClient_TypeA(iClientH, DEF_OWNERTYPE_PLAYER, MSGID_EVENT_LOG, DEF_MSGTYPE_CONFIRM, NULL, NULL, NULL);
		SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_OBSERVERMODE, 0, NULL, NULL, NULL);
		m_pClientList[iClientH]->m_bIsObserverMode = FALSE;
	}else 
	{	m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->ClearOwner(1, iClientH, DEF_OWNERTYPE_PLAYER, m_pClientList[iClientH]->m_sX, m_pClientList[iClientH]->m_sY);
		SendEventToNearClient_TypeA(iClientH, DEF_OWNERTYPE_PLAYER, MSGID_EVENT_LOG, DEF_MSGTYPE_REJECT, NULL, NULL, NULL);
		SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_OBSERVERMODE, 1, NULL, NULL, NULL);
		m_pClientList[iClientH]->m_bIsObserverMode = TRUE;
	}				
	wsprintf(G_cTxt, "GM Order(%-10s): /setobservermode", m_pClientList[iClientH]->m_cCharName);				
	bSendMsgToLS(MSGID_GAMEMASTERLOG, iClientH, FALSE, G_cTxt);
}

void CGame::RequestRestartHandler(int iClientH)
{	char  cTmpMap[32];
	if (m_pClientList[iClientH] == NULL) return;
	if (m_pClientList[iClientH]->m_bIsKilled == TRUE) 		
	{	strcpy(cTmpMap,m_pClientList[iClientH]->m_cMapName) ;
		ZeroMemory(m_pClientList[iClientH]->m_cMapName, sizeof(m_pClientList[iClientH]->m_cMapName));
		// SNOOPY: revamped for evil side
		switch(m_pClientList[iClientH]->m_cSide){
		case 0:
			strcpy(m_pClientList[iClientH]->m_cMapName, "default");
			break;
		case 1:	// Ares			
			if (m_bIsCrusadeMode == TRUE) 
			{	// .Lock in Jail at Crusade time
				if (m_pClientList[iClientH]->m_iDeadPenaltyTime > 0) 
				{	ZeroMemory(m_pClientList[iClientH]->m_cLockedMapName, sizeof(m_pClientList[iClientH]->m_cLockedMapName));
					strcpy(m_pClientList[iClientH]->m_cLockedMapName, "aresden");
					m_pClientList[iClientH]->m_iLockedMapTime = 60*5;
					m_pClientList[iClientH]->m_iDeadPenaltyTime = 60*10; 
				}else 
				{	memcpy(m_pClientList[iClientH]->m_cMapName, "resurr1", 7);
					m_pClientList[iClientH]->m_iDeadPenaltyTime = 60*10; 
				}
			}
			// Not Crusade
			// SNOOPY: No Jail if death in other city in EQUILIBRIUM mode
			if ((strcmp(cTmpMap, "elvine") == 0) && (!m_bMapModeEquilibrium))
			{	memcpy(m_pClientList[iClientH]->m_cMapName, "elvjail", 7);
				strcpy(m_pClientList[iClientH]->m_cLockedMapName, "elvjail");
				m_pClientList[iClientH]->m_iLockedMapTime = 60*3 ; // 3 min 
			}else if (m_pClientList[iClientH]->m_iLevel > 80)
				 memcpy(m_pClientList[iClientH]->m_cMapName, "resurr1", 7);
				else memcpy(m_pClientList[iClientH]->m_cMapName, "arefarm", 7);
			break;
		case 2: // Elvine
			if (m_bIsCrusadeMode == TRUE) 
			{	// Lock in Jail at Crusade time
				if (m_pClientList[iClientH]->m_iDeadPenaltyTime > 0) 
				{	ZeroMemory(m_pClientList[iClientH]->m_cLockedMapName, sizeof(m_pClientList[iClientH]->m_cLockedMapName));
					strcpy(m_pClientList[iClientH]->m_cLockedMapName, "elvine");
					m_pClientList[iClientH]->m_iLockedMapTime = 60*5;
					m_pClientList[iClientH]->m_iDeadPenaltyTime = 60*10; // v2.04
				}else 
				{	memcpy(m_pClientList[iClientH]->m_cMapName, "resurr2", 7);
					m_pClientList[iClientH]->m_iDeadPenaltyTime = 60*10; // v2.04 10ºÐ ¾È¿¡ ¶Ç Á×À¸¸é ¸¶À»¿¡ °®Èù´Ù.
				}
			}
			// Not Crusade
			// SNOOPY: No Jail if death in other city in EQUILIBRIUM mode
			if ((strcmp(cTmpMap, "aresden") == 0) && (!m_bMapModeEquilibrium))
			{	memcpy(m_pClientList[iClientH]->m_cMapName, "arejail", 7);
				strcpy(m_pClientList[iClientH]->m_cLockedMapName, "arejail");
				m_pClientList[iClientH]->m_iLockedMapTime = 60*3 ; // 3ºÐ 
			}else if (m_pClientList[iClientH]->m_iLevel > 80)
					memcpy(m_pClientList[iClientH]->m_cMapName, "resurr2", 7);
				else memcpy(m_pClientList[iClientH]->m_cMapName, "elvfarm", 7);
			break;
		default:
		case 4:	// evil goes to Elvine Revival zone
			memcpy(m_pClientList[iClientH]->m_cMapName, "resurr2", 7);
			break;
		}		
		m_pClientList[iClientH]->m_bIsKilled = FALSE;
		m_pClientList[iClientH]->m_bKilledByPlayerKiller = FALSE;
		m_pClientList[iClientH]->m_iHP = iGetMaxHP(iClientH, TRUE); // BloodEffect limite le regen
		m_pClientList[iClientH]->m_iHungerStatus = 100;

		ZeroMemory(cTmpMap, sizeof(cTmpMap));
		strcpy(cTmpMap, m_pClientList[iClientH]->m_cMapName);
		RequestTeleportHandler(iClientH, "2   ", cTmpMap, -1, -1);
	}
}

void CGame::AdminOrder_EnableAdminCommand(int iClientH, char *pData, DWORD dwMsgSize)
{char   * token, cBuff[256], len;
 char   seps[] = "= \t\n";
 class  CStrTok * pStrTok;
	if (m_pClientList[iClientH] == NULL) return;
	if ((dwMsgSize)	<= 0) return;
	ZeroMemory(cBuff, sizeof(cBuff));
	memcpy(cBuff, pData, dwMsgSize);
	pStrTok = new class CStrTok(cBuff, seps);
	token = pStrTok->pGet();
	token = pStrTok->pGet();
	if (token != NULL) 
	{	len = strlen(token);
		if(len > 10) len = 10;
		if (   (memcmp(token, m_cSecurityNumber, len) == 0)
			&& (m_pClientList[iClientH]->m_iAdminUserLevel > 0))
		{	m_pClientList[iClientH]->m_bIsAdminCommandEnabled = TRUE;			
			char cInfoString[500]; // SNOOPY: Say to GM
			ZeroMemory(cInfoString, sizeof(cInfoString));
			wsprintf(cInfoString, "Admin command ON !");
			SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_IPACCOUNTINFO, NULL, NULL, NULL, cInfoString);
			wsprintf(G_cTxt, "GM Order(%-10s): /enableadmincommand (enabled)", m_pClientList[iClientH]->m_cCharName);
			bSendMsgToLS(MSGID_GAMEMASTERLOG, iClientH, FALSE, G_cTxt);
				
		}else 
		{	wsprintf(G_cTxt, "Not admin player:  PC(%s) - Attempts to access /enableadmincommand with %s. \tIP(%s)"
				, m_pClientList[iClientH]->m_cCharName
				, token
				, m_pClientList[iClientH]->m_cIPaddress);
			PutHackLogFileList(G_cTxt);
			delete pStrTok;
			return;
	}	}
	delete pStrTok;
}

void CGame::AdminOrder_CreateItem(int iClientH, char *pData, DWORD dwMsgSize)
{char   seps[] = "= \t\n";
 char   * cp, * token, cBuff[256], cItemName[256], cData[256], cTemp[256], cAttribute[256], cValue[256];
 SYSTEMTIME SysTime;
 class  CStrTok * pStrTok;
 class  CItem * pItem;
 short  * sp;
 int    iRet, iTemp, iEraseReq, iValue;
 DWORD * dwp;
 WORD  * wp, wTemp;
 double dV1, dV2, dV3; 	
	if ((dwMsgSize)	<= 0) return;								// if the command is just "/createitem " than no effect.		
	if (m_pClientList[iClientH] == NULL) return;				// if the client doesnt exist than no effect.
	if (m_pClientList[iClientH]->m_bIsAdminCommandEnabled == FALSE) return;	
	if (m_pClientList[iClientH]->m_iAdminUserLevel <2) return;	// Do not allow item creation to 0 or 1 AdminLevel characters
	if (m_pClientList[iClientH]->m_iAdminUserLevel < m_iAdminLevelCreateItem)
	{	// if the admin user level is not 0 and less than 4 send message 
		if (m_pClientList[iClientH]->m_iAdminUserLevel !=  0)	
			SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_ADMINUSERLEVELLOW, NULL, NULL, NULL, NULL);
		return;
	}
	ZeroMemory(cBuff, sizeof(cBuff));
	memcpy(cBuff, pData, dwMsgSize);
	pStrTok = new class CStrTok(cBuff, seps);
	token = pStrTok->pGet();
	token = pStrTok->pGet();
	// if the token is something it is an item name
	if (token != NULL) {
		ZeroMemory(cItemName, sizeof(cItemName));
		strcpy(cItemName, token);
	} // close if (token != NULL) {
	// if the 2nd token is true it is the item attribute
	ZeroMemory(cAttribute, sizeof(cAttribute));
	token = pStrTok->pGet();
	if (token != NULL) {
		ZeroMemory(cAttribute, sizeof(cAttribute));
		strcpy(cAttribute, token);
	} // close if (token != NULL) {

	// if the 3rd token is true it is the item value
	ZeroMemory(cValue, sizeof(cValue));
	iValue = 0;
	token = pStrTok->pGet();
	if (token != NULL) {
		ZeroMemory(cValue, sizeof(cValue));
		strcpy(cValue, token);
		iValue = atoi(cValue);
	} // close if (token != NULL) {

	pItem = new class CItem;
	// if the given itemname doesnt exist delete item
	if (_bInitItemAttr(pItem, cItemName) == FALSE) 
	{	delete pItem;
		delete pStrTok;
		return;	
	} //close if (_bInitItemAttr(pItem, cItemName) == FALSE) {

	if ((strlen(cAttribute) != 0) && (pItem->m_cItemType != DEF_ITEMTYPE_MATERIAL))
	{	pItem->m_dwAttribute = atoi(cAttribute);
		if (pItem->m_dwAttribute == 1) 
		{	if ((iValue >= 1) && (iValue <= 200)) 
			{	pItem->m_cItemColor = 2;
				pItem->m_sItemSpecEffectValue2 = iValue - 100;
								
				dV2 = (double)pItem->m_sItemSpecEffectValue2;
				dV3 = (double)pItem->m_wMaxLifeSpan;
				dV1 = (dV2/100.0f)*dV3;

				iTemp  = (int)pItem->m_wMaxLifeSpan;
				iTemp += (int)dV1;

				if (iTemp <= 0) 
					 wTemp = 1;
				else wTemp = (WORD)iTemp;

				if (wTemp <= pItem->m_wMaxLifeSpan*2) {
					pItem->m_wMaxLifeSpan = wTemp;
					pItem->m_sItemSpecEffectValue1 = (short)wTemp;
					pItem->m_wCurLifeSpan = pItem->m_wMaxLifeSpan;
				} // close if (wTemp <= pItem->m_wMaxLifeSpan*2) {
				else pItem->m_sItemSpecEffectValue1 = (short)pItem->m_wMaxLifeSpan;
			} // close if ((iValue >= 1) && (iValue <= 200)) {
			else pItem->m_dwAttribute = NULL;
		} // close if (pItem->m_dwAttribute == 1) {
		else 
		{	if (pItem->m_sItemEffectType == DEF_ITEMEFFECTTYPE_ATTACK) 
			{	switch ((pItem->m_dwAttribute & 0xF00000) >> 20) {
				case 6:	pItem->m_cItemColor = 2; break;
				case 8: pItem->m_cItemColor = 3; break;
				case 1:	pItem->m_cItemColor = 5; break;
				case 5:	pItem->m_cItemColor = 1; break;
				case 3:	pItem->m_cItemColor = 7; break;
				case 2:	pItem->m_cItemColor = 4; break;
				case 7:	pItem->m_cItemColor = 6; break;
				case 9:	pItem->m_cItemColor = 8; break;
				} // close switch ((pItem->m_dwAttribute & 0xF00000) >> 20) {
			} // close if (pItem->m_sItemEffectType == DEF_ITEMEFFECTTYPE_ATTACK) {
			else if (pItem->m_sItemEffectType == DEF_ITEMEFFECTTYPE_ATTACK_MANASAVE) {
				switch ((pItem->m_dwAttribute & 0xF00000) >> 20) {
				case 10: pItem->m_cItemColor = 5; break;
				} // close switch ((pItem->m_dwAttribute & 0xF00000) >> 20) {
			} // close else if (pItem->m_sItemEffectType == DEF_ITEMEFFECTTYPE_ATTACK_MANASAVE) {
		} // close else {
	} // close if (strlen(cAttribute) != 0) {

	// if the item id is
	switch (pItem->m_sIDnum) {
	case 511: // ArenaTicket
	case 513: // ArenaTicket(2)
	case 515: // ArenaTicket(3)
	case 517: // ArenaTicket(4)
	case 530: // ArenaTicket(5)
	case 531: // ArenaTicket(6)
	case 532: // ArenaTicket(7)
	case 533: // ArenaTicket(8)
	case 534: // ArenaTicket(9)
		GetLocalTime(&SysTime);
		pItem->m_sTouchEffectType   = DEF_ITET_DATE;
		pItem->m_sTouchEffectValue1 = (short)SysTime.wMonth;
		pItem->m_sTouchEffectValue2 = (short)SysTime.wDay;
		pItem->m_sTouchEffectValue3 = 24 ;
		break;
	default:
		GetLocalTime(&SysTime);
		if (pItem->m_sItemEffectType == DEF_ITEMEFFECTTYPE_EVENT_ITEMDROP) 
		{	pItem->m_sTouchEffectType   = DEF_ITET_DATE;
			pItem->m_sTouchEffectValue1 = (short)SysTime.wMonth;
			pItem->m_sTouchEffectValue2 = (short)SysTime.wDay;
			pItem->m_sTouchEffectValue3 = (short)SysTime.wHour;
		}else
		{	pItem->m_sTouchEffectType   = DEF_ITET_ID;
			pItem->m_sTouchEffectValue1 = iDice(1,100000);
			pItem->m_sTouchEffectValue2 = iDice(1,100000);
			ZeroMemory(cTemp, sizeof(cTemp));
			wsprintf(cTemp, "%d%2d",  (short)SysTime.wMonth, (short)SysTime.wDay);
			pItem->m_sTouchEffectValue3 = atoi(cTemp);		
		}
		break;
	}
	if (pItem->m_cItemType == DEF_ITEMTYPE_MATERIAL) // Snoopy: Added Purity to Oils/Elixirs
	{	pItem->m_sItemSpecEffectValue2 = atoi(cAttribute);
		pItem->m_dwAttribute = 1;
		pItem->m_sItemSpecEffectValue1 = pItem->m_wCurLifeSpan;
	}

	ZeroMemory(cData, sizeof(cData));
	if (_bAddClientItemList(iClientH, pItem, &iEraseReq) == TRUE) 
	{	dwp  = (DWORD *)(cData + DEF_INDEX4_MSGID);
		*dwp = MSGID_NOTIFY;
		wp   = (WORD *)(cData + DEF_INDEX2_MSGTYPE);
		*wp  = DEF_NOTIFY_ITEMOBTAINED;		
		cp = (char *)(cData + DEF_INDEX2_MSGTYPE + 2);		
		*cp = 1;
		cp++;		
		memcpy(cp, pItem->m_cName, 20);
		cp += 20;		
		dwp  = (DWORD *)cp;
		*dwp = pItem->m_dwCount;
		cp += 4;		
		*cp = pItem->m_cItemType;
		cp++;		
		*cp = pItem->m_cEquipPos;
		cp++;		
		*cp = (char)0; 
		cp++;		
		sp  = (short *)cp;
		*sp = pItem->m_sLevelLimit;
		cp += 2;		
		*cp = pItem->m_cGenderLimit;
		cp++;		
		wp = (WORD *)cp;
		*wp = pItem->m_wCurLifeSpan;
		cp += 2;		
		wp = (WORD *)cp;
		*wp = pItem->m_wWeight;
		cp += 2;		
		sp  = (short *)cp;
		*sp = pItem->m_sSprite;
		cp += 2;		
		sp  = (short *)cp;
		*sp = pItem->m_sSpriteFrame;
		cp += 2;		
		*cp = pItem->m_cItemColor;
		cp++;
		*cp = (char)pItem->m_sItemSpecEffectValue2; // v1.41 
		cp++;		
		dwp = (DWORD *)cp;
		*dwp = pItem->m_dwAttribute;
		cp += 4;
		if (iEraseReq == 1) 
		{	delete pItem;
			pItem = NULL ;
		}
		iRet = m_pClientList[iClientH]->m_pXSock->iSendMsg(cData, 53);			
		wsprintf(G_cTxt, "GM Order(%-10s): Create ItemName(%s)", m_pClientList[iClientH]->m_cCharName, cItemName);
		bSendMsgToLS(MSGID_GAMEMASTERLOG, iClientH, NULL, G_cTxt);
		wsprintf(G_cTxt, "Admin Order(%s): Create Item(%s)\tAdminIP(%s)"
			, m_pClientList[iClientH]->m_cCharName
			, cItemName
			, m_pClientList[iClientH]->m_cIPaddress);
		PutAdminLogFileList(G_cTxt);
		delete pStrTok;
		return;
	}else 
	{	delete pItem;
		delete pStrTok;
		return;
	}
}

void CGame::AdminOrder_CreateToken(int iClientH, char *pData, DWORD dwMsgSize)
{char   seps[] = "= \t\n";
 char   * cp, * token, cBuff[256], cItemName[256], cData[256], cAttribute[256], cValue[256];
 SYSTEMTIME SysTime;
 class  CStrTok * pStrTok;
 class  CItem * pItem;
 short  * sp;
 int    iRet, iEraseReq, iValue;
 DWORD * dwp;
 WORD  * wp;
	if ((dwMsgSize)	<= 0) return;								// if the command is just "/createitem " than no effect.		
	if (m_pClientList[iClientH] == NULL) return;				// if the client doesnt exist than no effect.
	if (m_pClientList[iClientH]->m_bIsAdminCommandEnabled == FALSE) return;	
	if (m_pClientList[iClientH]->m_iAdminUserLevel <2) return;	// Do not allow item creation to 0 or 1 AdminLevel characters
	if (m_pClientList[iClientH]->m_iAdminUserLevel < m_iAdminLevelSummon)
	{	// if the admin user level is not 0 and less than 4 send message 
		if (m_pClientList[iClientH]->m_iAdminUserLevel !=  0)	
			SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_ADMINUSERLEVELLOW, NULL, NULL, NULL, NULL);
		return;
	}
	ZeroMemory(cBuff, sizeof(cBuff));
	memcpy(cBuff, pData, dwMsgSize);
	pStrTok = new class CStrTok(cBuff, seps);
	token = pStrTok->pGet();
	token = pStrTok->pGet();
	// if the token is something it is an item name
	if (token != NULL) 
	{	ZeroMemory(cItemName, sizeof(cItemName));
		strcpy(cItemName, token);
	} 
	// if the 2nd token is true it is the item attribute
	ZeroMemory(cAttribute, sizeof(cAttribute));
	token = pStrTok->pGet();
	if (token != NULL) 
	{	ZeroMemory(cAttribute, sizeof(cAttribute));
		strcpy(cAttribute, token);
	}
	// if the 3rd token is true it is the item value
	ZeroMemory(cValue, sizeof(cValue));
	iValue = 0;
	token = pStrTok->pGet();
	if (token != NULL)
	{	ZeroMemory(cValue, sizeof(cValue));
		strcpy(cValue, token);
		iValue = atoi(cValue);
	}
	pItem = new class CItem;	// if the given itemname doesnt exist delete item
	if (_bInitItemAttr(pItem, cItemName) == FALSE) 
	{	delete pItem;	delete pStrTok;	return;	
	}
	if (pItem->m_sItemEffectType == DEF_ITEMEFFECTTYPE_EVENT_ITEMDROP) 
	{	GetLocalTime(&SysTime);
		pItem->m_sTouchEffectType   = DEF_ITET_DATE;
		pItem->m_sTouchEffectValue1 = (short)SysTime.wMonth;
		pItem->m_sTouchEffectValue2 = (short)SysTime.wDay;
		pItem->m_sTouchEffectValue3 = (short)SysTime.wHour;
	}else 
	{	delete pItem;	delete pStrTok;	return;	
	}	
	ZeroMemory(cData, sizeof(cData));
	if (_bAddClientItemList(iClientH, pItem, &iEraseReq) == TRUE) 
	{	dwp  = (DWORD *)(cData + DEF_INDEX4_MSGID);
		*dwp = MSGID_NOTIFY;
		wp   = (WORD *)(cData + DEF_INDEX2_MSGTYPE);
		*wp  = DEF_NOTIFY_ITEMOBTAINED;		
		cp = (char *)(cData + DEF_INDEX2_MSGTYPE + 2);		
		*cp = 1;
		cp++;		
		memcpy(cp, pItem->m_cName, 20);
		cp += 20;		
		dwp  = (DWORD *)cp;
		*dwp = pItem->m_dwCount;
		cp += 4;		
		*cp = pItem->m_cItemType;
		cp++;		
		*cp = pItem->m_cEquipPos;
		cp++;		
		*cp = (char)0; 
		cp++;		
		sp  = (short *)cp;
		*sp = pItem->m_sLevelLimit;
		cp += 2;		
		*cp = pItem->m_cGenderLimit;
		cp++;		
		wp = (WORD *)cp;
		*wp = pItem->m_wCurLifeSpan;
		cp += 2;		
		wp = (WORD *)cp;
		*wp = pItem->m_wWeight;
		cp += 2;		
		sp  = (short *)cp;
		*sp = pItem->m_sSprite;
		cp += 2;		
		sp  = (short *)cp;
		*sp = pItem->m_sSpriteFrame;
		cp += 2;		
		*cp = pItem->m_cItemColor;
		cp++;
		*cp = (char)pItem->m_sItemSpecEffectValue2; // v1.41 
		cp++;		
		dwp = (DWORD *)cp;
		*dwp = pItem->m_dwAttribute;
		cp += 4;
		if (iEraseReq == 1) 
		{	delete pItem;
			pItem = NULL ;
		}
		iRet = m_pClientList[iClientH]->m_pXSock->iSendMsg(cData, 53);	
		wsprintf(G_cTxt, "GM Order(%-10s): Create TokenName(%s)\t(%s)", m_pClientList[iClientH]->m_cCharName, cItemName);
		bSendMsgToLS(MSGID_GAMEMASTERLOG, iClientH, NULL,G_cTxt);
		wsprintf(G_cTxt, "Admin Order(%s): Create Token(%s)\tAdminIP(%s)"
			, m_pClientList[iClientH]->m_cCharName
			, cItemName
			, m_pClientList[iClientH]->m_cIPaddress);
		PutAdminLogFileList(G_cTxt);
		delete pStrTok;	return;
	}else 
	{	delete pItem; delete pStrTok;return;
	}
}

void CGame::AdminOrder_ItemEventNow(int iClientH, char *pData, DWORD dwMsgSize)
{	if (m_pClientList[iClientH]->m_bIsAdminCommandEnabled == FALSE) return;	
	if (m_pClientList[iClientH]->m_iAdminUserLevel <2) return;	// Do not allow item creation to 0 or 1 AdminLevel characters
	if (m_pClientList[iClientH]->m_iAdminUserLevel < m_iAdminLevelSummon)
	{	// if the admin user level is not 0 and less than 4 send message 
		if (m_pClientList[iClientH]->m_iAdminUserLevel !=  0)	
			SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_ADMINUSERLEVELLOW, NULL, NULL, NULL, NULL);
		return;
	}	
 int i;	
 SYSTEMTIME SysTime;
	if (m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_iTotalItemEvents != NULL)
	{	GetLocalTime(&SysTime);
		for ( i = 0; i < m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_iTotalItemEvents; i++ )
		{	m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_stItemEventList[i].iMonth   = SysTime.wMonth;
			m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_stItemEventList[i].iDay     = SysTime.wDay;	
			m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_stItemEventList[i].iDropped = 0; 
		}
		wsprintf(G_cTxt, "Admin Order(%s): ItemEvent now at %s. \tAdminIP(%s)"
			, m_pClientList[iClientH]->m_cCharName
			, m_pClientList[iClientH]->m_cMapName
			, m_pClientList[iClientH]->m_cIPaddress);
		PutAdminLogFileList(G_cTxt);	
		PutLogEventFileList(G_cTxt);
		PutLogList(G_cTxt);
		wsprintf(G_cTxt, "GM Order(%-10s): /itemeventnow (done)", m_pClientList[iClientH]->m_cCharName);
		bSendMsgToLS(MSGID_GAMEMASTERLOG, iClientH, FALSE, G_cTxt);	
	}
	return;
}
void CGame::RequestSellItemListHandler(int iClientH, char * pData)
{int i, * ip, iAmount;
 char * cp, cIndex;
 struct {
	char cIndex;
	int  iAmount;
 } stTemp[12];
	if (m_pClientList[iClientH] == NULL) return;

	cp = (char *)(pData + 6);
	for (i = 0; i < 12; i++) {
		stTemp[i].cIndex = *cp;
		cp++;

		ip = (int *)cp;
		stTemp[i].iAmount = *ip;
		cp += 4;
	}
	for (i = 0; i < 12; i++) {
		cIndex = stTemp[i].cIndex;
		iAmount = stTemp[i].iAmount;
		if ((cIndex == -1) || (cIndex < 0) || (cIndex >= DEF_MAXITEMS)) return;
		if (m_pClientList[iClientH]->m_pItemList[cIndex] == NULL) return;
		ReqSellItemConfirmHandler(iClientH, cIndex, iAmount, NULL);
		if (m_pClientList[iClientH] == NULL) return;
	}
}


// Unused
void CGame::CreateNewPartyHandler(int iClientH)
{
 BOOL bFlag;

	if (m_pClientList[iClientH] == NULL) return;

	bFlag = m_pClientList[iClientH]->bCreateNewParty();
	SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_RESPONSE_CREATENEWPARTY, (int)bFlag, NULL, NULL, NULL);
}
// SNOOPY: Fixed Party Bugs
void CGame::JoinPartyHandler(int iClientH, int iV1, char *pMemberName)
{
	char * cp, cData[120];
	//short sAppr2;
	DWORD * dwp;
	WORD * wp;
	int i;

	if (m_pClientList[iClientH] == NULL) return;
	if ((m_bAdminSecurity == TRUE) && (m_pClientList[iClientH]->m_iAdminUserLevel > 0)) return;


	// SNOOPY: Added code against  n°0 party	
	if (m_pClientList[iClientH]->m_iPartyID == NULL)
	{	m_pClientList[iClientH]->m_iPartyStatus = DEF_PARTYSTATUS_NULL;
		m_pClientList[iClientH]->m_iReqJoinPartyClientH = NULL;
		ZeroMemory(m_pClientList[iClientH]->m_cReqJoinPartyName, sizeof(m_pClientList[iClientH]->m_cReqJoinPartyName));
	}
	// destruct the n°0 party in all cases ?!?
	for (i = 0; i < DEF_MAXPARTYMEMBERS; i++)
		{	m_stPartyInfo[0].iIndex[i] = 0;
		}
	m_stPartyInfo[0].iTotalMembers = 0;	

	switch (iV1) {
	case 0: // Remove party
		if (m_iPartyLog == TRUE) 
		{	wsprintf(G_cTxt, "<Client Msg0> (withdraw request): PartyID:%d %s<%d>"
				, m_pClientList[iClientH]->m_iPartyID
				, m_pClientList[iClientH]->m_cCharName
				, iClientH);	
			PutPartyLogFileList(G_cTxt);
		}
		RequestDeletePartyHandler(iClientH);
		break;

	case 1: // Join Party
		if (m_iPartyLog == TRUE) 
		{	wsprintf(G_cTxt, "<Client Msg1> (join request): PartyID:%d %s<%d> ReqJoinH(%d) ReqJoinName(%s)"
				, m_pClientList[iClientH]->m_iPartyID
				, m_pClientList[iClientH]->m_cCharName
				, iClientH
				, m_pClientList[iClientH]->m_iReqJoinPartyClientH
				, m_pClientList[iClientH]->m_cReqJoinPartyName);	
			PutPartyLogFileList(G_cTxt);
		}
		if ((m_pClientList[iClientH]->m_iPartyID != NULL) ) 
		{	SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_PARTY, 7, 0, NULL, NULL);
			m_pClientList[iClientH]->m_iReqJoinPartyClientH = NULL;
			ZeroMemory(m_pClientList[iClientH]->m_cReqJoinPartyName, sizeof(m_pClientList[iClientH]->m_cReqJoinPartyName));
			m_pClientList[iClientH]->m_iPartyStatus = DEF_PARTYSTATUS_NULL;
			//testcode
			if (m_iPartyLog == TRUE) PutPartyLogFileList("<Client Msg1> (join request): Reject (1a:Asker already in Party)");
			return;
		}
		if ( (m_pClientList[iClientH]->m_iPartyStatus != DEF_PARTYSTATUS_NULL)) 
		{	SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_PARTY, 7, 0, NULL, NULL);
			m_pClientList[iClientH]->m_iReqJoinPartyClientH = NULL;
			ZeroMemory(m_pClientList[iClientH]->m_cReqJoinPartyName, sizeof(m_pClientList[iClientH]->m_cReqJoinPartyName));
			m_pClientList[iClientH]->m_iPartyStatus = DEF_PARTYSTATUS_NULL;
			//testcode
			if (m_iPartyLog == TRUE) PutPartyLogFileList("<Client Msg1> (join request): Reject (1b:Asker already Party Processing)");
			return;
		}
		for (i = 1; i < DEF_MAXCLIENTS; i++)
			if ((m_pClientList[i] != NULL) && (strcmp(m_pClientList[i]->m_cCharName, pMemberName) == 0)) 
			{	// sAppr2 = (short)((m_pClientList[i]->m_sAppr2 & 0xF000) >> 12);
				// if (sAppr2 != 0) 				
				if (m_pClientList[i]->m_IsPeaceMode == FALSE)
				{	SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_PARTY, 7, 0, NULL, NULL);	
					//testcode
					if (m_iPartyLog == TRUE) PutPartyLogFileList("<Client Msg1> (join request): Reject (2: Target not peace mode");
				}else if (  (m_pClientList[i]->m_cSide != m_pClientList[iClientH]->m_cSide)
					     &&(!m_bMapModeEquilibrium))
					// CLASSIC mode reject party between Ares and Elvines
				{	SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_PARTY, 7, 0, NULL, NULL);
					//testcode
					if (m_iPartyLog == TRUE) PutPartyLogFileList("<Client Msg1> (join request): Reject (3:Different city)");	
//SNOOPY: Added possibility to Party Aresden & Elvines
				}else if (  (m_pClientList[i]->m_cSide != m_pClientList[iClientH]->m_cSide)
					     && (m_bMapModeEquilibrium)
						 && (    (m_pClientList[i]->m_cSide < 1) || (m_pClientList[i]->m_cSide > 2)
						      || (m_pClientList[iClientH]->m_cSide < 1) || (m_pClientList[iClientH]->m_cSide > 2)) ) 
				{	// Reject if one is not Ares or Elvine
					// Party still possible if both same side
					// only possible for different sides if Ares/Elvine
					SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_PARTY, 7, 0, NULL, NULL);	
					//testcode						
					if (m_iPartyLog == TRUE) PutPartyLogFileList("<Client Msg1> (join request): Reject (3:Different from Are/Elv city)");
				}else if (m_pClientList[i]->m_iPartyStatus == DEF_PARTYSTATUS_PROCESSING) 
				{	SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_PARTY, 7, 0, NULL, NULL);					
					//testcode
					PutLogList("<Client Msg1> (join request): Reject (4:Target already party processing)");
					m_pClientList[iClientH]->m_iReqJoinPartyClientH = NULL;
					ZeroMemory(m_pClientList[iClientH]->m_cReqJoinPartyName, sizeof(m_pClientList[iClientH]->m_cReqJoinPartyName));
					m_pClientList[iClientH]->m_iPartyStatus = DEF_PARTYSTATUS_NULL;
				}else 	// Join party possible
				{	m_pClientList[i]->m_iReqJoinPartyClientH = iClientH;
					ZeroMemory(m_pClientList[i]->m_cReqJoinPartyName, sizeof(m_pClientList[i]->m_cReqJoinPartyName));
					strcpy(m_pClientList[i]->m_cReqJoinPartyName, m_pClientList[iClientH]->m_cCharName);
					// Party message
					if (m_iPartyLog == TRUE) 					
					{	wsprintf(G_cTxt, "<Client Msg1> (join request): Ok, asking to PartyID:%d %s<%d> (total %d)"
							, m_pClientList[i]->m_iPartyID
							, m_pClientList[i]->m_cCharName
							, i
							, m_stPartyInfo[m_pClientList[i]->m_iPartyID].iTotalMembers);
						PutPartyLogFileList(G_cTxt);
					}
					// Ask the player					
					SendNotifyMsg(NULL, i, DEF_NOTIFY_QUERY_JOINPARTY, NULL, NULL, NULL, m_pClientList[iClientH]->m_cCharName); 
					m_pClientList[iClientH]->m_iReqJoinPartyClientH = i;
					ZeroMemory(m_pClientList[iClientH]->m_cReqJoinPartyName, sizeof(m_pClientList[iClientH]->m_cReqJoinPartyName));
					strcpy(m_pClientList[iClientH]->m_cReqJoinPartyName, m_pClientList[i]->m_cCharName);
					m_pClientList[iClientH]->m_iPartyStatus = DEF_PARTYSTATUS_PROCESSING;
				}
				return;
			}
			break;

	case 2: // confirmation au gate envoyée par le client que la partie est bien crée
			// ??? Will inform other party members
			// will provoque  info msg by gate
		if (m_pClientList[iClientH]->m_iPartyStatus == DEF_PARTYSTATUS_CONFIRM) 					
		{	//testcode				
			if (m_iPartyLog == TRUE) 
			{	wsprintf(G_cTxt, "<Client Msg2> (info request). PartyID:%d %s<%d>"
					, m_pClientList[iClientH]->m_iPartyID
					, m_pClientList[iClientH]->m_cCharName
					, iClientH);
				PutPartyLogFileList(G_cTxt);
			}
			ZeroMemory(cData, sizeof(cData));
			cp = (char *)cData;
			dwp = (DWORD *)cp;
			*dwp = MSGID_PARTYOPERATION;
			cp += 4;
			wp = (WORD*)cp;
			*wp = 6; // 6: Confirm acceptation
			cp += 2;
			wp = (WORD *)cp;
			*wp = iClientH;
			cp += 2;
			memcpy(cp, m_pClientList[iClientH]->m_cCharName, 10);
			cp += 10;
			wp = (WORD *)cp;
			*wp = m_pClientList[iClientH]->m_iPartyID;
			cp += 2;
			// Party message
			if (m_iPartyLog == TRUE) 
			{	wsprintf(G_cTxt, "<Msg6 -> Gate> (info request): PartyID:%d %s<%d>"
					, m_pClientList[iClientH]->m_iPartyID
					, m_pClientList[iClientH]->m_cCharName
					, iClientH);	
				PutPartyLogFileList(G_cTxt);
			}
			SendMsgToGateServer(MSGID_PARTYOPERATION, iClientH, cData);
		}
		break;
	}
}

BOOL CGame::bCheckEnergySphereDestination(int iNpcH, short sAttackerH, char cAttackerType)
{	int i, sX,sY, dX, dY, iGoalMapIndex;
	char cResult, cContrib;
	if (m_pNpcList[iNpcH] == NULL) return FALSE;
	if (m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->m_iCurEnergySphereGoalPointIndex == -1) return FALSE;
	if (m_pNpcList[iNpcH]->m_cMapIndex != m_iMiddlelandMapIndex) 
	{	iGoalMapIndex = m_pNpcList[iNpcH]->m_cMapIndex;		
		sX = m_pNpcList[iNpcH]->m_sX;
		sY = m_pNpcList[iNpcH]->m_sY;	
		cResult = m_pMapList[iGoalMapIndex]->m_stEnergySphereGoalList[m_pMapList[iGoalMapIndex]->m_iCurEnergySphereGoalPointIndex].cResult;
		dX = m_pMapList[iGoalMapIndex]->m_stEnergySphereGoalList[m_pMapList[iGoalMapIndex]->m_iCurEnergySphereGoalPointIndex].aresdenX;
		dY = m_pMapList[iGoalMapIndex]->m_stEnergySphereGoalList[m_pMapList[iGoalMapIndex]->m_iCurEnergySphereGoalPointIndex].aresdenY;
		if ((sX >= dX-2) && (sX <= dX+2) && (sY >= dY-2) && (sY <= dY+2)) 
		{	m_pMapList[iGoalMapIndex]->m_iCurEnergySphereGoalPointIndex = -1;		
			if ((cAttackerType == DEF_OWNERTYPE_PLAYER) && (m_pClientList[sAttackerH] != NULL)) 
			{	if (m_pClientList[sAttackerH]->m_cSide == 1)  // Aresden (Side:1)
				{	cContrib = iDice(1,5);
					m_pClientList[sAttackerH]->m_iContribution += cContrib;
					m_pClientList[sAttackerH]->m_iRewardGold += 10000;
					if (m_pClientList[sAttackerH]->m_iRewardGold > DEF_MAXREWARDGOLD) 
						m_pClientList[sAttackerH]->m_iRewardGold = DEF_MAXREWARDGOLD;
					SendNotifyMsg(NULL, sAttackerH, DEF_NOTIFY_REWARDGOLD, NULL, NULL, NULL, NULL);
					wsprintf(G_cTxt, "(!) EnergySphere Goal for Aresden (%s)", m_pClientList[sAttackerH]->m_cCharName);
					PutLogList(G_cTxt);	
					PutLogEventFileList(G_cTxt);
				}else 
				{	m_pClientList[sAttackerH]->m_iContribution -= 10;
					cContrib = -10;
					wsprintf(G_cTxt, "(!) EnergySphere Goal for Aresden (by Elvine player %s)", m_pClientList[sAttackerH]->m_cCharName);
					PutLogList(G_cTxt);	
					PutLogEventFileList(G_cTxt);
				}  
				for (i = 1; i < DEF_MAXCLIENTS; i++)
				if ((m_pClientList[i] != NULL) && (m_pClientList[i]->m_bIsInitComplete == TRUE)) 
				{	SendNotifyMsg(NULL, i, DEF_NOTIFY_ENERGYSPHEREGOALIN, cContrib, m_pClientList[sAttackerH]->m_cSide, 2, m_pClientList[sAttackerH]->m_cCharName);
				
				}
				SendEventToNearClient_TypeB(MSGID_EVENT_COMMON, DEF_COMMONTYPE_MAGIC, m_pClientList[sAttackerH]->m_cMapIndex
					, dX, dY, dX, dY, 246, m_pClientList[sAttackerH]->m_sType); // Aresden Goal
			}
			return TRUE;
		}
		dX = m_pMapList[iGoalMapIndex]->m_stEnergySphereGoalList[m_pMapList[iGoalMapIndex]->m_iCurEnergySphereGoalPointIndex].elvineX;
		dY = m_pMapList[iGoalMapIndex]->m_stEnergySphereGoalList[m_pMapList[iGoalMapIndex]->m_iCurEnergySphereGoalPointIndex].elvineY;
		if ((sX >= dX-2) && (sX <= dX+2) && (sY >= dY-2) && (sY <= dY+2)) 
		{	m_pMapList[iGoalMapIndex]->m_iCurEnergySphereGoalPointIndex = -1;
			if ((cAttackerType == DEF_OWNERTYPE_PLAYER) && (m_pClientList[sAttackerH] != NULL)) 
			{	if (m_pClientList[sAttackerH]->m_cSide == 2) // Elvine (Side:2)
				{ 	cContrib = iDice(1,5);
					m_pClientList[sAttackerH]->m_iContribution += cContrib; 
					m_pClientList[sAttackerH]->m_iRewardGold += 10000;
					if (m_pClientList[sAttackerH]->m_iRewardGold > DEF_MAXREWARDGOLD) 
						m_pClientList[sAttackerH]->m_iRewardGold = DEF_MAXREWARDGOLD;
					SendNotifyMsg(NULL, sAttackerH, DEF_NOTIFY_REWARDGOLD, NULL, NULL, NULL, NULL);
					wsprintf(G_cTxt, "(!) EnergySphere Goal for Elvine (%s)", m_pClientList[sAttackerH]->m_cCharName);
					PutLogList(G_cTxt);
					PutLogEventFileList(G_cTxt);
				}else 
				{	m_pClientList[sAttackerH]->m_iContribution -= 10;
					cContrib = -10;
					wsprintf(G_cTxt, "(!) EnergySphere Goal for Elvine (by Aresden player %s)", m_pClientList[sAttackerH]->m_cCharName);
					PutLogList(G_cTxt);	
					PutLogEventFileList(G_cTxt);	
				}
				for (i = 1; i < DEF_MAXCLIENTS; i++)
				if ((m_pClientList[i] != NULL) && (m_pClientList[i]->m_bIsInitComplete == TRUE)) 
				{	SendNotifyMsg(NULL, i, DEF_NOTIFY_ENERGYSPHEREGOALIN, cContrib, m_pClientList[sAttackerH]->m_cSide, 1, m_pClientList[sAttackerH]->m_cCharName);
				}
				SendEventToNearClient_TypeB(MSGID_EVENT_COMMON, DEF_COMMONTYPE_MAGIC, m_pClientList[sAttackerH]->m_cMapIndex
					, dX, dY, dX, dY, 245, m_pClientList[sAttackerH]->m_sType); // Elvine Goal
			}
			return TRUE;
		}
		return FALSE;
	}else //  Next case: in MiddleLand
	{	sX = m_pNpcList[iNpcH]->m_sX;
		sY = m_pNpcList[iNpcH]->m_sY;	
		cResult = m_pMapList[m_iMiddlelandMapIndex]->m_stEnergySphereGoalList[m_pMapList[m_iMiddlelandMapIndex]->m_iCurEnergySphereGoalPointIndex].cResult;
		dX = m_pMapList[m_iMiddlelandMapIndex]->m_stEnergySphereGoalList[m_pMapList[m_iMiddlelandMapIndex]->m_iCurEnergySphereGoalPointIndex].aresdenX;
		dY = m_pMapList[m_iMiddlelandMapIndex]->m_stEnergySphereGoalList[m_pMapList[m_iMiddlelandMapIndex]->m_iCurEnergySphereGoalPointIndex].aresdenY;
		if ((sX >= dX-4) && (sX <= dX+4) && (sY >= dY-4) && (sY <= dY+4)) 
		{	m_pMapList[m_iMiddlelandMapIndex]->m_iCurEnergySphereGoalPointIndex = -1;		
			if ((cAttackerType == DEF_OWNERTYPE_PLAYER) && (m_pClientList[sAttackerH] != NULL)) 
			{	if (m_pClientList[sAttackerH]->m_cSide == 1)  // Aresden (Side:1)
				{	cContrib = iDice(1,5);
					m_pClientList[sAttackerH]->m_iContribution += cContrib;
					m_pClientList[sAttackerH]->m_iRewardGold += 10000;
					if (m_pClientList[sAttackerH]->m_iRewardGold > DEF_MAXREWARDGOLD) 
						m_pClientList[sAttackerH]->m_iRewardGold = DEF_MAXREWARDGOLD;
					SendNotifyMsg(NULL, sAttackerH, DEF_NOTIFY_REWARDGOLD, NULL, NULL, NULL, NULL);
					wsprintf(G_cTxt, "(!) ML EnergySphere Goal for Aresden (%s)", m_pClientList[sAttackerH]->m_cCharName);
					PutLogList(G_cTxt);
					PutLogFileList(G_cTxt);
				}else 
				{	m_pClientList[sAttackerH]->m_iContribution -= 10;
					cContrib = -10;					
					wsprintf(G_cTxt, "(!) ML EnergySphere Goal for Aresden (by Elvine player %s)", m_pClientList[sAttackerH]->m_cCharName);
					PutLogList(G_cTxt);	
					PutLogFileList(G_cTxt);
				}
				for (i = 1; i < DEF_MAXCLIENTS; i++)
				if ((m_pClientList[i] != NULL) && (m_pClientList[i]->m_bIsInitComplete == TRUE)) 
				{	SendNotifyMsg(NULL, i, DEF_NOTIFY_ENERGYSPHEREGOALIN, cContrib, m_pClientList[sAttackerH]->m_cSide, 2, m_pClientList[sAttackerH]->m_cCharName);
				}
				SendEventToNearClient_TypeB(MSGID_EVENT_COMMON, DEF_COMMONTYPE_MAGIC, m_pClientList[sAttackerH]->m_cMapIndex
					, dX, dY, dX, dY, 246, m_pClientList[sAttackerH]->m_sType); // Aresden Goal
			}
			return TRUE;
		}
		dX = m_pMapList[m_iMiddlelandMapIndex]->m_stEnergySphereGoalList[m_pMapList[m_iMiddlelandMapIndex]->m_iCurEnergySphereGoalPointIndex].elvineX;
		dY = m_pMapList[m_iMiddlelandMapIndex]->m_stEnergySphereGoalList[m_pMapList[m_iMiddlelandMapIndex]->m_iCurEnergySphereGoalPointIndex].elvineY;
		if ((sX >= dX-4) && (sX <= dX+4) && (sY >= dY-4) && (sY <= dY+4)) 
		{	m_pMapList[m_iMiddlelandMapIndex]->m_iCurEnergySphereGoalPointIndex = -1;
			if ((cAttackerType == DEF_OWNERTYPE_PLAYER) && (m_pClientList[sAttackerH] != NULL)) 
			{	if (m_pClientList[sAttackerH]->m_cSide == 2)  // Elvine (Side:2)
				{	cContrib = iDice(1,5);
					m_pClientList[sAttackerH]->m_iContribution += cContrib;
					m_pClientList[sAttackerH]->m_iRewardGold += 10000;
					if (m_pClientList[sAttackerH]->m_iRewardGold > DEF_MAXREWARDGOLD) 
						m_pClientList[sAttackerH]->m_iRewardGold = DEF_MAXREWARDGOLD;
					SendNotifyMsg(NULL, sAttackerH, DEF_NOTIFY_REWARDGOLD, NULL, NULL, NULL, NULL);
					wsprintf(G_cTxt, "(!) ML EnergySphere Goal for Elvine (%s)", m_pClientList[sAttackerH]->m_cCharName);
					PutLogList(G_cTxt);
					PutLogFileList(G_cTxt);
				}else 
				{	m_pClientList[sAttackerH]->m_iContribution -= 10;
					cContrib = -10;					
					wsprintf(G_cTxt, "(!) ML EnergySphere Goal for Elvine (by Aresden player %s)", m_pClientList[sAttackerH]->m_cCharName);
					PutLogList(G_cTxt);	
					PutLogFileList(G_cTxt);	
				}
				for (i = 1; i < DEF_MAXCLIENTS; i++)
				if ((m_pClientList[i] != NULL) && (m_pClientList[i]->m_bIsInitComplete == TRUE)) 
				{	SendNotifyMsg(NULL, i, DEF_NOTIFY_ENERGYSPHEREGOALIN, cContrib, m_pClientList[sAttackerH]->m_cSide, 1, m_pClientList[sAttackerH]->m_cCharName);
				}
				SendEventToNearClient_TypeB(MSGID_EVENT_COMMON, DEF_COMMONTYPE_MAGIC, m_pClientList[sAttackerH]->m_cMapIndex
					, dX, dY, dX, dY, 245, m_pClientList[sAttackerH]->m_sType); // Elvine Goal
			}
			return TRUE;
		}
		return FALSE;
	}
}

void CGame::EnergySphereProcessor(BOOL bIsAdminCreate, int iClientH)
{	register int i; 
	int iNamingValue, iCIndex, iTemp, pX, pY, inbePlayersML;
	char cSA, cName_Internal[31], cWaypoint[31];
	if (bIsAdminCreate != TRUE) // Generated randomlly, not by admin order...	
	{	if (m_iMiddlelandMapIndex < 0) return;
		if (m_pMapList[m_iMiddlelandMapIndex] == NULL) return;
		if (iDice(1,600) != 123) return; 
		if (m_bIsCrusadeMode == TRUE) return;
		//if (m_iTotalGameServerClients < 500) return;
		if (m_iTotalGameServerClients < 15) return; // Snoopy: 500 characters i huge for auto-creating energyball at ML...
		inbePlayersML = 0;
		for (i = 1; i < DEF_MAXCLIENTS; i++) // Snoopy: 10 players mini at ML
		if ((m_pClientList[i] != NULL) && (m_pClientList[i]->m_bIsInitComplete == TRUE)) 
		{	if (m_pClientList[i]->m_cMapIndex == m_iMiddlelandMapIndex) inbePlayersML ++;
		}
		if (inbePlayersML < 10) return; 
		// Snoopy: 500 characters i huge for auto-creating energyball at ML...			
		if (m_pMapList[m_iMiddlelandMapIndex]->m_iCurEnergySphereGoalPointIndex >= 0) return;
		iCIndex = iDice(1, m_pMapList[m_iMiddlelandMapIndex]->m_iTotalEnergySphereCreationPoint);
		if (m_pMapList[m_iMiddlelandMapIndex]->m_stEnergySphereCreationList[iCIndex].cType == NULL) return;
		cSA = 0;
 		pX = m_pMapList[m_iMiddlelandMapIndex]->m_stEnergySphereCreationList[iCIndex].sX;
		pY = m_pMapList[m_iMiddlelandMapIndex]->m_stEnergySphereCreationList[iCIndex].sY;
		ZeroMemory(cWaypoint, sizeof(cWaypoint));	
		iNamingValue = m_pMapList[m_iMiddlelandMapIndex]->iGetEmptyNamingValue();
		if (iNamingValue != -1) 
		{	ZeroMemory(cName_Internal, sizeof(cName_Internal));
			wsprintf(cName_Internal, "XX%d", iNamingValue);
			cName_Internal[0] = '_';
			cName_Internal[1] = m_iMiddlelandMapIndex + 65;			
			if ((bCreateNewNpc("Energy-Sphere", cName_Internal, m_pMapList[m_iMiddlelandMapIndex]->m_cName, (rand() % 5), cSA, DEF_MOVETYPE_RANDOM, &pX, &pY, cWaypoint, NULL, NULL, -1, FALSE, FALSE, FALSE)) == FALSE) 
			{	m_pMapList[m_iMiddlelandMapIndex]->SetNamingValueEmpty(iNamingValue);
				return;
			}
		}
		iTemp  = iDice(1, m_pMapList[m_iMiddlelandMapIndex]->m_iTotalEnergySphereGoalPoint);
		if (m_pMapList[m_iMiddlelandMapIndex]->m_stEnergySphereGoalList[iTemp].cResult == NULL) return;	
		m_pMapList[m_iMiddlelandMapIndex]->m_iCurEnergySphereGoalPointIndex = iTemp;
		for (i = 1; i < DEF_MAXCLIENTS; i++)
		if ((m_pClientList[i] != NULL) && (m_pClientList[i]->m_bIsInitComplete == TRUE)) {
			SendNotifyMsg(NULL, i, DEF_NOTIFY_ENERGYSPHERECREATED, pX, pY, NULL, NULL);
		}
		//testcode
		wsprintf(G_cTxt, "(!) ML Energy Sphere Auto-Created! (%d, %d)", pX, pY);
		PutLogList(G_cTxt);
		PutLogEventFileList(G_cTxt);
	}else // GM created the EnergySphere
	{	if (m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_iCurEnergySphereGoalPointIndex >= 0) return;
		iCIndex = iDice(1, m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_iTotalEnergySphereCreationPoint);
		if (m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_stEnergySphereCreationList[iCIndex].cType == NULL) return;
		cSA = 0;
 		pX = m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_stEnergySphereCreationList[iCIndex].sX;
		pY = m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_stEnergySphereCreationList[iCIndex].sY;
		ZeroMemory(cWaypoint, sizeof(cWaypoint));	
		iNamingValue = m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->iGetEmptyNamingValue();
		if (iNamingValue != -1)
		{	ZeroMemory(cName_Internal, sizeof(cName_Internal));
			wsprintf(cName_Internal, "XX%d", iNamingValue);
			cName_Internal[0] = '_';
			cName_Internal[1] = m_pClientList[iClientH]->m_cMapIndex + 65;			
			if ((bCreateNewNpc("Energy-Sphere", cName_Internal, m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cName, (rand() % 5), cSA, DEF_MOVETYPE_RANDOM, &pX, &pY, cWaypoint, NULL, NULL, -1, FALSE, FALSE, FALSE)) == FALSE) 
			{	m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->SetNamingValueEmpty(iNamingValue);
				return;
			}
		}	
		iTemp  = iDice(1, m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_iTotalEnergySphereGoalPoint);
		if (m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_stEnergySphereGoalList[iTemp].cResult == NULL) return;

		m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_iCurEnergySphereGoalPointIndex = iTemp;
		for (i = 1; i < DEF_MAXCLIENTS; i++)
		if (   (m_pClientList[i] != NULL) && (m_pClientList[i]->m_bIsInitComplete == TRUE)
			&& (m_pClientList[i]->m_cMapIndex == m_pClientList[iClientH]->m_cMapIndex)) 
		{	SendNotifyMsg(NULL, i, DEF_NOTIFY_ENERGYSPHERECREATED, pX, pY, NULL, NULL);
		} // Don not tell players if not in same map!
		// Admin Log
		wsprintf(G_cTxt, "Admin Order(%s): Energy Sphere Created! (%d, %d)", m_pClientList[iClientH]->m_cCharName, pX, pY);			
		PutAdminLogFileList(G_cTxt);		
		wsprintf(G_cTxt, "(!) Admin Energy Sphere Created! (%d, %d)", pX, pY);
				PutLogEventFileList(G_cTxt);
		PutLogList(G_cTxt);
	}
}

void CGame::ActivateSpecialAbilityHandler(int iClientH)
{	DWORD dwTime = timeGetTime();
	short sTemp;
	if (m_pClientList[iClientH] == NULL) return;
	if (m_pClientList[iClientH]->m_iSpecialAbilityTime != 0) return;
	if (m_pClientList[iClientH]->m_iSpecialAbilityType == 0) return;
	if (m_pClientList[iClientH]->m_bIsSpecialAbilityEnabled == TRUE) return;
	m_pClientList[iClientH]->m_bIsSpecialAbilityEnabled  = TRUE;
	m_pClientList[iClientH]->m_dwSpecialAbilityStartTime = dwTime;
	m_pClientList[iClientH]->m_iSpecialAbilityTime = DEF_SPECABLTYTIMESEC; //1200
	sTemp = m_pClientList[iClientH]->m_sAppr4;
	sTemp = sTemp & 0xFF0F;
	switch (m_pClientList[iClientH]->m_iSpecialAbilityType) {
	case 1: // Xelima weapon
	case 2: // Ice weapon
	case 3: // Medusa sword
	case 4: // Instant kill weapon
	case 5: // Vampiric weapon
		sTemp = sTemp | 0x0010;
		break;
	case 50: // Merien Plate
	case 51: // Merien Shield effect on armor piece
	case 52: // Merien Shield
	case 53: // GM Shield
	case 54: // ?? no game effect ? Snoopy: Added Blue Glowing armor
		sTemp = sTemp | 0x0020;
		break;
	case 55: // Snoopy: Spell effect
		sTemp = sTemp | 0x0040;
		break;
	}
	m_pClientList[iClientH]->m_sAppr4 = sTemp;
	SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_SPECIALABILITYSTATUS, 1, m_pClientList[iClientH]->m_iSpecialAbilityType, m_pClientList[iClientH]->m_iSpecialAbilityLastSec, NULL);
	SendEventToNearClient_TypeA(iClientH, DEF_OWNERTYPE_PLAYER, MSGID_EVENT_MOTION, DEF_OBJECTNULLACTION, NULL, NULL, NULL);
}

void CGame::CancelQuestHandler(int iClientH)
{	if (m_pClientList[iClientH] == NULL) return;
	_ClearQuestStatus(iClientH);
	SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_QUESTABORTED, NULL, NULL, NULL, NULL);
}

int CGame::iGetItemWeight(CItem *pItem, int iCount)
{	int iWeight;
	iWeight = (pItem->m_wWeight);
	if (iCount < 0) iCount = 1;
	iWeight = iWeight * iCount;
	if (pItem->m_sIDnum == 90) iWeight = iWeight / 20;
	if (iWeight <= 0) iWeight = 1;
	return iWeight;
}

void CGame::UpdateMapSectorInfo()
{	int i, ix, iy;
	int iMaxNeutralActivity, iMaxAresdenActivity, iMaxElvineActivity, iMaxMonsterActivity, iMaxPlayerActivity, iMaxExecutorActivity;
	for (i = 0; i < DEF_MAXMAPS; i++) 
	if (m_pMapList[i] != NULL)  // Snoopy: Added Executor activity	
	{	iMaxNeutralActivity = iMaxAresdenActivity = iMaxElvineActivity = iMaxMonsterActivity = iMaxPlayerActivity = iMaxExecutorActivity = 0;	
		m_pMapList[i]->m_iMaxNx = m_pMapList[i]->m_iMaxNy = m_pMapList[i]->m_iMaxAx = m_pMapList[i]->m_iMaxAy = 0;
		m_pMapList[i]->m_iMaxEx = m_pMapList[i]->m_iMaxEy = m_pMapList[i]->m_iMaxMx = m_pMapList[i]->m_iMaxMy = 0;
		m_pMapList[i]->m_iMaxPx = m_pMapList[i]->m_iMaxPy = 0;
		for (ix = 0; ix < DEF_MAXSECTORS; ix++)
		for (iy = 0; iy < DEF_MAXSECTORS; iy++) 
		{	if (m_pMapList[i]->m_stTempSectorInfo[ix][iy].iNeutralActivity > iMaxNeutralActivity) 
			{	iMaxNeutralActivity = m_pMapList[i]->m_stTempSectorInfo[ix][iy].iNeutralActivity;
				m_pMapList[i]->m_iMaxNx = ix;
				m_pMapList[i]->m_iMaxNy = iy;
			}			
			if (m_pMapList[i]->m_stTempSectorInfo[ix][iy].iAresdenActivity > iMaxAresdenActivity) 
			{	iMaxAresdenActivity = m_pMapList[i]->m_stTempSectorInfo[ix][iy].iAresdenActivity;
				m_pMapList[i]->m_iMaxAx = ix;
				m_pMapList[i]->m_iMaxAy = iy;
			}
			if (m_pMapList[i]->m_stTempSectorInfo[ix][iy].iElvineActivity > iMaxElvineActivity) 
			{	iMaxElvineActivity = m_pMapList[i]->m_stTempSectorInfo[ix][iy].iElvineActivity;
				m_pMapList[i]->m_iMaxEx = ix;
				m_pMapList[i]->m_iMaxEy = iy;
			}
			if (m_pMapList[i]->m_stTempSectorInfo[ix][iy].iMonsterActivity > iMaxMonsterActivity) 
			{	iMaxMonsterActivity = m_pMapList[i]->m_stTempSectorInfo[ix][iy].iMonsterActivity;
				m_pMapList[i]->m_iMaxMx = ix;
				m_pMapList[i]->m_iMaxMy = iy;
			}
			if (m_pMapList[i]->m_stTempSectorInfo[ix][iy].iPlayerActivity > iMaxPlayerActivity) 
			{	iMaxPlayerActivity = m_pMapList[i]->m_stTempSectorInfo[ix][iy].iPlayerActivity;
				m_pMapList[i]->m_iMaxPx = ix;
				m_pMapList[i]->m_iMaxPy = iy;
			}
			if (m_pMapList[i]->m_stTempSectorInfo[ix][iy].iExecutorActivity > iMaxExecutorActivity) 
			{	iMaxExecutorActivity = m_pMapList[i]->m_stTempSectorInfo[ix][iy].iExecutorActivity;
				m_pMapList[i]->m_iMaxXx = ix;
				m_pMapList[i]->m_iMaxXy = iy;
		}	}
		m_pMapList[i]->ClearTempSectorInfo();
		// Sector Inf
		if (m_pMapList[i]->m_iMaxNx > 0) m_pMapList[i]->m_stSectorInfo[m_pMapList[i]->m_iMaxNx][m_pMapList[i]->m_iMaxNy].iNeutralActivity++;
		if (m_pMapList[i]->m_iMaxAx > 0) m_pMapList[i]->m_stSectorInfo[m_pMapList[i]->m_iMaxAx][m_pMapList[i]->m_iMaxAy].iAresdenActivity++;
		if (m_pMapList[i]->m_iMaxEx > 0) m_pMapList[i]->m_stSectorInfo[m_pMapList[i]->m_iMaxEx][m_pMapList[i]->m_iMaxEy].iElvineActivity++;
		if (m_pMapList[i]->m_iMaxMx > 0) m_pMapList[i]->m_stSectorInfo[m_pMapList[i]->m_iMaxMx][m_pMapList[i]->m_iMaxMy].iMonsterActivity++;
		if (m_pMapList[i]->m_iMaxPx > 0) m_pMapList[i]->m_stSectorInfo[m_pMapList[i]->m_iMaxPx][m_pMapList[i]->m_iMaxPy].iPlayerActivity++;
		if (m_pMapList[i]->m_iMaxXx > 0) m_pMapList[i]->m_stSectorInfo[m_pMapList[i]->m_iMaxXx][m_pMapList[i]->m_iMaxXy].iExecutorActivity++;
	}
}

void CGame::AgingMapSectorInfo()
{int i, ix, iy;
	for (i = 0; i < DEF_MAXMAPS; i++) 
	if (m_pMapList[i] != NULL) {
		for (ix = 0; ix < DEF_MAXSECTORS; ix++)
		for (iy = 0; iy < DEF_MAXSECTORS; iy++) 
		{	m_pMapList[i]->m_stSectorInfo[ix][iy].iNeutralActivity--;
			m_pMapList[i]->m_stSectorInfo[ix][iy].iAresdenActivity--;
			m_pMapList[i]->m_stSectorInfo[ix][iy].iElvineActivity--;
			m_pMapList[i]->m_stSectorInfo[ix][iy].iMonsterActivity--;
			m_pMapList[i]->m_stSectorInfo[ix][iy].iPlayerActivity--;
			m_pMapList[i]->m_stSectorInfo[ix][iy].iExecutorActivity--;
			if (m_pMapList[i]->m_stSectorInfo[ix][iy].iNeutralActivity < 0) m_pMapList[i]->m_stSectorInfo[ix][iy].iNeutralActivity = 0;
			if (m_pMapList[i]->m_stSectorInfo[ix][iy].iAresdenActivity < 0) m_pMapList[i]->m_stSectorInfo[ix][iy].iAresdenActivity = 0;
			if (m_pMapList[i]->m_stSectorInfo[ix][iy].iElvineActivity  < 0) m_pMapList[i]->m_stSectorInfo[ix][iy].iElvineActivity  = 0;
			if (m_pMapList[i]->m_stSectorInfo[ix][iy].iMonsterActivity < 0) m_pMapList[i]->m_stSectorInfo[ix][iy].iMonsterActivity = 0;
			if (m_pMapList[i]->m_stSectorInfo[ix][iy].iPlayerActivity < 0) m_pMapList[i]->m_stSectorInfo[ix][iy].iPlayerActivity   = 0;
			if (m_pMapList[i]->m_stSectorInfo[ix][iy].iExecutorActivity < 0) m_pMapList[i]->m_stSectorInfo[ix][iy].iExecutorActivity   = 0;
	}	}
}

BOOL CGame::__bSetConstructionKit(int iMapIndex, int dX, int dY, int iType, int iTimeCost, int iClientH)
{	int iNamingValue, ix, iy, tX, tY;
	char cNpcName[21], cName[21], cNpcWaypoint[11], cOwnerType;
	short sOwnerH;
	if ((m_bIsCrusadeMode == FALSE) || (m_pClientList[iClientH]->m_iCrusadeDuty != 2)) return FALSE;
	if (m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_iTotalCrusadeStructures >= DEF_MAXCRUSADESTRUCTURES) 
	{	SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_NOMORECRUSADESTRUCTURE, NULL, NULL, NULL, NULL);
		return FALSE;
	}
	iNamingValue = m_pMapList[ m_pClientList[iClientH]->m_cMapIndex ]->iGetEmptyNamingValue();
	if (iNamingValue == -1) 
	{}else 
	{	for (ix = dX -3; ix <= dX +5; ix++)
		for (iy = dY -3; iy <= dX +5; iy++) 
		{	m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, ix, iy);
			if ((sOwnerH != NULL) && (cOwnerType == DEF_OWNERTYPE_NPC) && (m_pNpcList[sOwnerH]->m_cActionLimit == 5)) return FALSE;
		}		
		ZeroMemory(cNpcName, sizeof(cNpcName));// NPC
		if (m_pClientList[iClientH]->m_cSide == 1) 
		{	switch (iType) {
			case 1: strcpy(cNpcName, "AGT-Aresden"); break;
			case 2: strcpy(cNpcName, "CGT-Aresen"); break;
			case 3: strcpy(cNpcName, "MS-Aresden"); break;
			case 4: strcpy(cNpcName, "DT-Aresden"); break;
			}
		}else if (m_pClientList[iClientH]->m_cSide == 2) 
		{	switch (iType) {
			case 1: strcpy(cNpcName, "AGT-Elvine"); break;
			case 2: strcpy(cNpcName, "CGT-Elvine"); break;
			case 3: strcpy(cNpcName, "MS-Elvine"); break;
			case 4: strcpy(cNpcName, "DT-Elvine"); break;
			}
		}else return FALSE;	
		ZeroMemory(cName, sizeof(cName));
		wsprintf(cName, "XX%d", iNamingValue);
		cName[0] = '_';
		cName[1] = m_pClientList[iClientH]->m_cMapIndex+65;		
		ZeroMemory(cNpcWaypoint, sizeof(cNpcWaypoint));
		tX = (int)dX;
		tY = (int)dY;
		if (bCreateNewNpc(cNpcName, cName, m_pMapList[ m_pClientList[iClientH]->m_cMapIndex ]->m_cName, 0, (rand() % 9), 
			              DEF_MOVETYPE_RANDOM, &tX, &tY, cNpcWaypoint, NULL, NULL, -1, FALSE, FALSE) == FALSE) {
			m_pMapList[ m_pClientList[iClientH]->m_cMapIndex ]->SetNamingValueEmpty(iNamingValue);
		}else 
		{	wsprintf(G_cTxt, "Structure(%s) construction begin(%d,%d)!", cNpcName, tX, tY);
			PutLogList(G_cTxt);		
			PutLogEventFileList(G_cTxt);
			return TRUE;
	}	}
	return FALSE;
}

void CGame::LocalStartCrusadeMode(DWORD dwCrusadeGUID)
{int i, j;
 int iTemp = 0;
	if (m_bIsCrusadeMode == TRUE) return;
	m_bIsCrusadeMode	 = TRUE;	
	m_bEverybodyAdvised  = FALSE;
	m_iCrusadeWinnerSide = 0;
	m_dwCrusadeStartTime = timeGetTime();
	if (dwCrusadeGUID != NULL) // erase previous crusade GUID.
	{	_CreateCrusadeGUID(m_dwCrusadeGUID, NULL);
		m_dwCrusadeGUID = dwCrusadeGUID;
	}
	if (m_bMapModeEquilibrium == TRUE) 
	{	m_bMapModeEquilibrium = FALSE;
		m_bMapModeEquilibriumChanged = TRUE;		
		// Remove unwanted mobs
		for (j = 0; j <DEF_MAXNPCS ; j++)  
		{	if (m_pNpcList[j] != NULL) 
			{	if (   (m_pNpcList[j]->m_bIsSummoned == FALSE)	// Not a summon
					&& (m_pNpcList[j]->m_bIsKilled == FALSE)	// Not already Killed
					&&    ((strcmp(m_pMapList[m_pNpcList[j]->m_cMapIndex]->m_cName, "aresden") == 0)// On proper map
						|| (strcmp(m_pMapList[m_pNpcList[j]->m_cMapIndex]->m_cName, "elvine") == 0)))
				{	switch (m_pNpcList[j]->m_sType) {
					case 56:  //Cats,		Hellcat
					case 13:  //Cyclops,	City-Cyclops
					case 29:  //Ogre,		City-Ogre
					case 54:  //Dark-Elf,	City-Dark-Elf
					case 21:  //Guards
					case 2:   //War-Aresden, War Aresden
						// Prevent 2nd drops							
						m_pNpcList[j]->m_bIsUnsummoned = TRUE; 	
						NpcKilledHandler(j, DEF_OWNERTYPE_NPC, j, 0);
						DeleteNpc(j);
						break;
					default:
						break;
		}	}	}	}
		// Note changed maps 			
		for (i = 0; i < DEF_MAXMAPS; i++) 
		{	if (m_pMapList[i] != NULL) 
			{	if (__bReadMapCrusadeInfo(i, TRUE))
				{	m_pMapList[i]->m_bChangedForCrusade = TRUE;
			}	}
		}// NB: Mercenaries will not spwan before 15min after crusade start
	}
	for (i = 0; i < DEF_MAXMAPS; i++)
	{	if (m_pMapList[i] != NULL) m_pMapList[i]->RestoreStrikePoints();
	} 
	CreateCrusadeStructures();	
	for (i = 1; i < DEF_MAXCLIENTS; i++)
	if ((m_pClientList[i] != NULL) && (m_pClientList[i]->m_bIsInitComplete == TRUE)) 
	{	// reset crusade duty
		m_pClientList[i]->m_iCrusadeDuty = 0;
		m_pClientList[i]->m_iConstructionPoint = 0;		
		m_pClientList[i]->m_cVar = 1; // character have been informed of crusade starting...
		m_pClientList[i]->m_dwCrusadeGUID = m_dwCrusadeGUID;
		SendNotifyMsg(NULL, i, DEF_NOTIFY_CONSTRUCTIONPOINT, 0, 0, 1, NULL); // 1: Don't show to player
		SendNotifyMsg(NULL, i, DEF_NOTIFY_CRUSADE, (DWORD)m_bIsCrusadeMode, 0, 0, NULL, 0);

		// Cancel AncientSlates effects.
		SetSlateFlag(i, DEF_NOTIFY_SLATECLEAR, FALSE);		
		// Recall from enemy city if already inside when crusade begins...
		if (m_pClientList[i]->m_iAdminUserLevel == 0)
		{	if ( (m_pClientList[i]->m_cSide == 1) 
				&& (memcmp(m_pMapList[m_pClientList[i]->m_cMapIndex]->m_cLocationName, "elvine", 6) == 0)) 		
			{	m_pClientList[i]->m_bIsWarLocation = TRUE;
				m_pClientList[i]->m_iTimeLeft_ForceRecall = 0;
			}else if ( (m_pClientList[i]->m_cSide == 2) 
				&& (memcmp(m_pMapList[m_pClientList[i]->m_cMapIndex]->m_cLocationName, "aresden", 7) == 0))
			{	m_pClientList[i]->m_bIsWarLocation = TRUE;
				m_pClientList[i]->m_iTimeLeft_ForceRecall = 0;
			}else //if ( (m_pClientList[i]->m_cSide == 4) for traveller also
			{	if (   (memcmp(m_pMapList[m_pClientList[i]->m_cMapIndex]->m_cLocationName, "aresden", 7) == 0)
					|| (memcmp(m_pMapList[m_pClientList[i]->m_cMapIndex]->m_cLocationName, "elvine", 6) == 0)
					|| (memcmp(m_pMapList[m_pClientList[i]->m_cMapIndex]->m_cLocationName, "middleland", 10) == 0))
				{	m_pClientList[i]->m_bIsWarLocation = TRUE;
					m_pClientList[i]->m_iTimeLeft_ForceRecall = 0;
	}	} 	}	}
	wsprintf(G_cTxt,"(_)Crusade Mode ON.");
	PutLogList(G_cTxt);
	PutLogList(" ");
	PutLogEventFileList(G_cTxt);
	PutLogEventFileList(" ");
}

void CGame::LocalEndCrusadeMode(int iWinnerSide) // 1= Aresden, 2 = Elvine
{ int i, j;
	wsprintf(G_cTxt, "(!)Received LocalEndCrusade. (Winner %d)", iWinnerSide);
	PutLogList(G_cTxt);
	if (m_bIsCrusadeMode == FALSE) return;
	m_bIsCrusadeMode	 = FALSE;
	m_bEverybodyAdvised  = FALSE;
	_CreateCrusadeGUID(m_dwCrusadeGUID, iWinnerSide); // logs the winner side
	RemoveCrusadeStructures();
	RemoveCrusadeNpcs();
	m_iCrusadeWinnerSide = iWinnerSide;
	m_iLastCrusadeWinner = iWinnerSide;	
	// Remove unwanted guards in Aresden/Elvine
	for (j = 0; j <DEF_MAXNPCS ; j++)  
	{	if (m_pNpcList[j] != NULL) 
		{	if (   (m_pNpcList[j]->m_bIsKilled == FALSE)	// Not already Killed
				&& (m_pNpcList[j]->m_sOriginalType == 21)   // Guards	
				&&    ((strcmp(m_pMapList[m_pNpcList[j]->m_cMapIndex]->m_cName, "aresden") == 0)// On proper map
					|| (strcmp(m_pMapList[m_pNpcList[j]->m_cMapIndex]->m_cName, "elvine") == 0)))
			{	m_pNpcList[j]->m_bIsUnsummoned = TRUE; 	
				NpcKilledHandler(j, DEF_OWNERTYPE_NPC, j, 0);
				DeleteNpc(j);
	}	}	}	
	for (i = 1; i < DEF_MAXCLIENTS; i++)
	if ((m_pClientList[i] != NULL) && (m_pClientList[i]->m_bIsInitComplete == TRUE)) 
	{	m_pClientList[i]->m_iCrusadeDuty = 0;
		m_pClientList[i]->m_iConstructionPoint = 0;
		// 1st victory/defeat message, set client to normal mode
		// XP message will be sent later...
		SendNotifyMsg(NULL, i, DEF_NOTIFY_CRUSADE, (DWORD)FALSE, 0, 0, NULL, m_iCrusadeWinnerSide);
	}
	RemoveCrusadeRecallTime();
	if (m_bMapModeEquilibriumChanged == TRUE) 
	{	m_bMapModeEquilibrium = TRUE;
		m_bMapModeEquilibriumChanged = FALSE;
		for (i = 0; i < DEF_MAXMAPS; i++) 
		{	if ((m_pMapList[i] != NULL) && (m_pMapList[i]->m_bChangedForCrusade == TRUE))
			{	__bReadMapCrusadeInfo(i, FALSE);
	}	}	}
	wsprintf(G_cTxt,"(_) Crusade Mode OFF.");
	PutLogList(G_cTxt);
	PutLogList(" ");
	PutLogEventFileList(G_cTxt);
	PutLogEventFileList(" ");
}

void CGame::CreateCrusadeStructures()
{int i, z, tX, tY, iNamingValue;
 char cName[6], cNpcName[21], cNpcWayPoint[11];
 int i_MS;
	ZeroMemory(cName, sizeof(cName));
	ZeroMemory(cNpcName, sizeof(cNpcName));
	ZeroMemory(cNpcWayPoint, sizeof(cNpcWayPoint));
	//SNOOPY: 1st choose the right Manastones
	//        if the server is hosting ML
	int i_TotalMS = 0;
	if (m_iMiddlelandMapIndex >=0)
	{	for (i = 0; i < DEF_MAXCRUSADESTRUCTURES; i++) 
		{	if (   (m_stCrusadeStructures[i].cType == 42)
				&& (strcmp("middleland", m_stCrusadeStructures[i].cMapName) == 0)) // ManaStone
			{	i_TotalMS ++;
				m_stCrusadeStructures[i].bManaStoneValid = TRUE;
				/*wsprintf(G_cTxt, "Validate ManaStone (%d) at %s(%d, %d)"
					, i
					, m_stCrusadeStructures[i].cMapName
					, (int)m_stCrusadeStructures[i].dX
					, (int)m_stCrusadeStructures[i].dY );
				PutLogList(G_cTxt);*/
			}
			//if (m_stCrusadeStructures[i].cType == NULL) break;
		}
		// If too much manastones on definition file
		while (i_TotalMS > m_iManaStoneNumber)
		{	i_MS = iDice(1,DEF_MAXCRUSADESTRUCTURES) -1;	
			if ( m_stCrusadeStructures[i_MS].bManaStoneValid == TRUE)
			{	m_stCrusadeStructures[i_MS].bManaStoneValid = FALSE;
				i_TotalMS --;
	}	}	}
	// Then create Crusade structures...
	for (i = 0; i < DEF_MAXCRUSADESTRUCTURES; i++) 
	if (m_stCrusadeStructures[i].cType != NULL) 
	{	for (z = 0; z < DEF_MAXMAPS; z++)
		{	if (   (m_pMapList[z] != NULL) 
			&& (strcmp(m_pMapList[z]->m_cName, m_stCrusadeStructures[i].cMapName) == 0)) 
			{	iNamingValue = m_pMapList[z]->iGetEmptyNamingValue();
				if (iNamingValue == -1) 
				{	// No room for a new crusade structure
				}else 
				{	// NPC
					wsprintf(cName, "XX%d", iNamingValue);
					cName[0] = '_';
					cName[1] = z+65;
				
					switch (m_stCrusadeStructures[i].cType) {
					case 36: // Arrow Guard Tower
						if (strcmp(m_pMapList[z]->m_cName, "aresden") == 0)
							 strcpy(cNpcName, "AGT-Aresden");
						else if (strcmp(m_pMapList[z]->m_cName, "elvine") == 0)
							strcpy(cNpcName, "AGT-Elvine");
						break;

					case 37: // Canon Guard Tower
						if (strcmp(m_pMapList[z]->m_cName, "aresden") == 0)
							 strcpy(cNpcName, "CGT-Aresden");
						else if (strcmp(m_pMapList[z]->m_cName, "elvine") == 0)
							strcpy(cNpcName, "CGT-Elvine");
						break;

					case 40: // Shield
						if (strcmp(m_pMapList[z]->m_cName, "aresden") == 0)
							 strcpy(cNpcName, "ESG-Aresden");
						else if (strcmp(m_pMapList[z]->m_cName, "elvine") == 0)
							strcpy(cNpcName, "ESG-Elvine");
						break;

					case 41: // Grand Magic Generator
						if (strcmp(m_pMapList[z]->m_cName, "aresden") == 0)
							 strcpy(cNpcName, "GMG-Aresden");
						else if (strcmp(m_pMapList[z]->m_cName, "elvine") == 0)
							strcpy(cNpcName, "GMG-Elvine");
						break;

					case 42: // Mana Stone
						strcpy(cNpcName, "ManaStone");
						break;

					default: // Other npcs
						strcpy(cNpcName, m_pNpcConfigList[m_stCrusadeStructures[i].cType]->m_cNpcName); 
						break;
					} // End of switch

					tX = (int)m_stCrusadeStructures[i].dX;
					tY = (int)m_stCrusadeStructures[i].dY;
					if (   (m_stCrusadeStructures[i].cType != 42)
						|| (m_stCrusadeStructures[i].bManaStoneValid == TRUE))
					{	if (bCreateNewNpc(cNpcName, cName, m_pMapList[z]->m_cName, 0, 0, DEF_MOVETYPE_RANDOM, 
					              &tX, &tY, cNpcWayPoint, NULL, NULL, -1, FALSE) == FALSE) 
						{	// Npc creation failed	
							m_pMapList[z]->SetNamingValueEmpty(iNamingValue);
						}else 
						{	m_pMapList[z]->SetStayAllowedFlag(tX, tY-1, FALSE); // Allow case behind structure
							wsprintf(G_cTxt, "(!) Creating Crusade Structure(%s) at %s(%d, %d)", cNpcName, m_stCrusadeStructures[i].cMapName, tX, tY);
							PutLogList(G_cTxt);
							PutLogEventFileList(G_cTxt);
	}	}	}	}	}	}

	// SNOOPY: Adjust Mana requested by GMG with m_iCrusadeAdvantage
	// And reduce ManaStone number if applicable...
	for (i = 1; i < DEF_MAXNPCS; i++) 
	{ 	if (m_pNpcList[i] != NULL) 
		{	if ((strcmp(m_pNpcList[i]->m_cNpcName, "GMG-Aresden") == 0) && (m_iCrusadeAdvantage < 0))
			{	// Negative value, Areden won a lot, harder for Aresden
				m_pNpcList[i]->m_iMaxMana += (8 * abs(m_iCrusadeAdvantage));
			}
			if ((strcmp(m_pNpcList[i]->m_cNpcName, "GMG-Elvine") == 0) && (m_iCrusadeAdvantage > 0))
			{	// Positive value, Elvine won a lot, harder for Elvine
				m_pNpcList[i]->m_iMaxMana += (8 * abs(m_iCrusadeAdvantage));
			}
		}
	}
}

void CGame::RequestSetGuildConstructLocHandler(int iClientH, int dX, int dY, int iGuildGUID, char * pMapName)
{char * cp, cData[120];
 register int i;
 int *ip, iIndex;
 DWORD dwTemp, dwTime;
	if (m_pClientList[iClientH] == NULL) return;
	if (m_pClientList[iClientH]->m_bIsOnWaitingProcess == TRUE) return;
	ZeroMemory(cData, sizeof(cData));
	cp = (char *)cData;
	*cp = GSM_SETGUILDCONSTRUCTLOC;
	cp++;
	ip = (int *)cp;
	*ip = iGuildGUID;
	cp += 4;
	ip = (int *)cp;
	*ip = dX;
	cp += 4;
	ip = (int *)cp;
	*ip = dY;
	cp += 4;	
	memcpy(cp, pMapName, 10);
	cp += 10;
	dwTime = timeGetTime();
	for (i = 0; i < DEF_MAXGUILDS; i++)
	if (m_pGuildTeleportLoc[i].m_iV1 == iGuildGUID)  // change loc
	{	if (   (m_pGuildTeleportLoc[i].m_sDestX2 == dX) && (m_pGuildTeleportLoc[i].m_sDestY2 == dY) 
			&& (strcmp(m_pGuildTeleportLoc[i].m_cDestMapName2, pMapName) == 0)) 
		{	m_pGuildTeleportLoc[i].m_dwTime2 = dwTime;
			return;
		}else 
		{	m_pGuildTeleportLoc[i].m_sDestX2 = dX;
			m_pGuildTeleportLoc[i].m_sDestY2 = dY;
			ZeroMemory(m_pGuildTeleportLoc[i].m_cDestMapName2, sizeof(m_pGuildTeleportLoc[i].m_cDestMapName2));
			strcpy(m_pGuildTeleportLoc[i].m_cDestMapName2, pMapName);
			m_pGuildTeleportLoc[i].m_dwTime2 = dwTime;
			wsprintf(G_cTxt, "Construction change request: %d - %s (%d/%d) - %s"
				, iGuildGUID
				, pMapName
				, dX
				, dY
				, m_pClientList[iClientH]->m_cGuildName);
			PutLogEventFileList(G_cTxt);
			PutLogList(G_cTxt);
			bStockMsgToGateServer(cData, 23);
			return;
		}
	}	
	dwTemp = 0;
	iIndex = -1;
	for (i = 0; i < DEF_MAXGUILDS; i++) 
	{	if (m_pGuildTeleportLoc[i].m_iV1 == NULL) // 1st time
		{	m_pGuildTeleportLoc[i].m_iV1 = iGuildGUID;
			m_pGuildTeleportLoc[i].m_sDestX2 = dX;
			m_pGuildTeleportLoc[i].m_sDestY2 = dY;
			ZeroMemory(m_pGuildTeleportLoc[i].m_cDestMapName2, sizeof(m_pGuildTeleportLoc[i].m_cDestMapName2));
			strcpy(m_pGuildTeleportLoc[i].m_cDestMapName2, pMapName);
			m_pGuildTeleportLoc[i].m_dwTime2 = dwTime;
			wsprintf(G_cTxt, "Construction set request   : %d - %s (%d/%d) - %s"
				, iGuildGUID
				, pMapName
				, dX
				, dY
				, m_pClientList[iClientH]->m_cGuildName);
			PutLogEventFileList(G_cTxt);
			PutLogList(G_cTxt);
			bStockMsgToGateServer(cData, 23);
			return;
		}else 
		{	if (dwTemp < (dwTime - m_pGuildTeleportLoc[i].m_dwTime2)) 
			{	dwTemp = (dwTime - m_pGuildTeleportLoc[i].m_dwTime2);
				iIndex = i;
			}
		}
	}
	if (iIndex == -1) return;
	m_pGuildTeleportLoc[i].m_iV1 = iGuildGUID;
	m_pGuildTeleportLoc[i].m_sDestX2 = dX;
	m_pGuildTeleportLoc[i].m_sDestY2 = dY;
	ZeroMemory(m_pGuildTeleportLoc[i].m_cDestMapName2, sizeof(m_pGuildTeleportLoc[i].m_cDestMapName2));
	strcpy(m_pGuildTeleportLoc[i].m_cDestMapName, pMapName);
	m_pGuildTeleportLoc[i].m_dwTime2 = dwTime;
	wsprintf(G_cTxt, "Construction borrow request: %d - %s (%d/%d) - %s"
		, iGuildGUID
		, pMapName
		, dX
		, dY
		, m_pClientList[iClientH]->m_cGuildName);
	PutLogEventFileList(G_cTxt);
	PutLogList(G_cTxt);
	bStockMsgToGateServer(cData, 23);
}
// New 14/05/2004 Changed
void CGame::RequestSummonWarUnitHandler(int iClientH, int dX, int dY, char cType, char cNum, char cMode)
{char cName[6], cNpcName[21], cMapName[11], cNpcWayPoint[11], cOwnerType;
 register int i, x;
 int iNamingValue, tX, tY, ix, iy;
 BOOL bRet;
 short sOwnerH;
 DWORD dwTime = timeGetTime(); 
	if (m_pClientList[iClientH] == NULL) return;
	if (m_pClientList[iClientH]->m_bIsInitComplete == FALSE) return;	
	ZeroMemory(cNpcWayPoint, sizeof(cNpcWayPoint));
	ZeroMemory(cNpcName, sizeof(cNpcName));	
	ZeroMemory(cMapName, sizeof(cMapName));
	if (cType < 0) return;
	if (cType >= DEF_MAXNPCTYPES) return;
	if (cNum  >  10) return;
	if (m_pClientList[iClientH]->m_iConstructionPoint < m_iNpcConstructionPoint[cType]) return;
	if (   (m_pMapList[m_pClientList[iClientH]->m_cMapIndex] != NULL) 
		&& (m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_bIsFixedDayMode == TRUE)) return; 
	cNum = 1;
	// ConstructionPoint
	for (x = 1; x <= cNum; x++) 
	{	iNamingValue = m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->iGetEmptyNamingValue();
		if (iNamingValue == -1) 
		{}else 
		{	ZeroMemory(cName, sizeof(cName));
			wsprintf(cName, "XX%d", iNamingValue);
			cName[0] = '_';
			cName[1] = m_pClientList[iClientH]->m_cMapIndex+65;
			switch (cType) {
			case 43: // Light War Beetle
				switch (m_pClientList[iClientH]->m_cSide) {
				case 1: strcpy(cNpcName, "LWB-Aresden"); break;
				case 2: strcpy(cNpcName, "LWB-Elvine"); break;
				}
				break;

			case 36: // Arrow Guard Tower
				switch (m_pClientList[iClientH]->m_cSide) {
				case 1: strcpy(cNpcName, "AGT-Aresden"); break;
				case 2: strcpy(cNpcName, "AGT-Elvine"); break;
				}
				break;

			case 37: // Cannon Guard Tower
				switch (m_pClientList[iClientH]->m_cSide) {
				case 1: strcpy(cNpcName, "CGT-Aresden"); break;
				case 2: strcpy(cNpcName, "CGT-Elvine"); break;
				}
				break;

			case 38: // Mana Collector
				switch (m_pClientList[iClientH]->m_cSide) {
				case 1: strcpy(cNpcName, "MS-Aresden"); break;
				case 2: strcpy(cNpcName, "MS-Elvine"); break;
				}
				break;

			case 39: // Detector
				switch (m_pClientList[iClientH]->m_cSide) {
				case 1: strcpy(cNpcName, "DT-Aresden"); break;
				case 2: strcpy(cNpcName, "DT-Elvine"); break;
				}
				break;

			case 51: // Catapult
				switch (m_pClientList[iClientH]->m_cSide) {
				case 1: strcpy(cNpcName, "CP-Aresden"); break;
				case 2: strcpy(cNpcName, "CP-Elvine"); break;
				}
				break;

			case 44:
				strcpy(cNpcName, "GHK");
				break;

			case 45:
				strcpy(cNpcName, "GHKABS");
				break;

			case 46:
				strcpy(cNpcName, "TK");
				break;

			case 47:
				strcpy(cNpcName, "BG");
				break;

			case 82:
				switch (m_pClientList[iClientH]->m_cSide) 
				{	case 1: strcpy(cNpcName, "Sor-Aresden"); break;
					case 2: strcpy(cNpcName, "Sor-Elvine"); break;
				}
				break;

			case 83:
				switch (m_pClientList[iClientH]->m_cSide) 
				{	case 1: strcpy(cNpcName, "ATK-Aresden"); break;
					case 2: strcpy(cNpcName, "ATK-Elvine"); break;
				}
				break;

			case 84:
				switch (m_pClientList[iClientH]->m_cSide) {
					case 1: strcpy(cNpcName, "Elf-Aresden"); break;
					case 2: strcpy(cNpcName, "Elf-Elvine"); break;
				}
				break;

			case 85:
				switch (m_pClientList[iClientH]->m_cSide) {
					case 1: strcpy(cNpcName, "DSK-Aresden"); break;
					case 2: strcpy(cNpcName, "DSK-Elvine"); break;
				}
				break;

			case 86:
				switch (m_pClientList[iClientH]->m_cSide) {
					case 1: strcpy(cNpcName, "HBT-Aresden"); break;
					case 2: strcpy(cNpcName, "HBT-Elvine"); break;
				}
				break;

			case 87:
				switch (m_pClientList[iClientH]->m_cSide) {
					case 1: strcpy(cNpcName, "CT-Aresden"); break;
					case 2: strcpy(cNpcName, "CT-Elvine"); break;
				}
				break;

			case 88:
				switch (m_pClientList[iClientH]->m_cSide) {
					case 1: strcpy(cNpcName, "Bar-Aresden"); break;
					case 2: strcpy(cNpcName, "Bar-Elvine"); break;
				}
				break;

			case 89:
				switch (m_pClientList[iClientH]->m_cSide) {
					case 1: strcpy(cNpcName, "AGC-Aresden"); break;
					case 2: strcpy(cNpcName, "AGC-Elvine"); break;
				}
				break;
			}
			tX = (int)dX;
			tY = (int)dY;						
			bRet = FALSE;
			switch (cType) {
			case 36:
			case 37:
			case 38:
			case 39:
				if (strcmp(m_pClientList[iClientH]->m_cConstructMapName, m_pClientList[iClientH]->m_cMapName) != 0) bRet = TRUE;
				if (abs(m_pClientList[iClientH]->m_sX - m_pClientList[iClientH]->m_iConstructLocX) > 10) bRet = TRUE;
				if (abs(m_pClientList[iClientH]->m_sY - m_pClientList[iClientH]->m_iConstructLocY) > 10) bRet = TRUE;

				if (bRet == TRUE) 
				{	m_pMapList[ m_pClientList[iClientH]->m_cMapIndex ]->SetNamingValueEmpty(iNamingValue);
					SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_CANNOTCONSTRUCT, 2, NULL, NULL, NULL);
					return;
				}
				for (i = 0; i < DEF_MAXGUILDS; i++) 
				if (m_pGuildTeleportLoc[i].m_iV1 == m_pClientList[iClientH]->m_iGuildGUID) {
					m_pGuildTeleportLoc[i].m_dwTime = dwTime;
					if (m_pGuildTeleportLoc[i].m_iV2 >= DEF_MAXCONSTRUCTNUM) 
					{	m_pMapList[ m_pClientList[iClientH]->m_cMapIndex ]->SetNamingValueEmpty(iNamingValue);
						SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_CANNOTCONSTRUCT, 3, NULL, NULL, NULL);		
						return;
					}else 
					{	m_pGuildTeleportLoc[i].m_iV2++;
						goto RSWU_LOOPBREAK;
					}
				}
				m_pMapList[ m_pClientList[iClientH]->m_cMapIndex ]->SetNamingValueEmpty(iNamingValue);
				SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_CANNOTCONSTRUCT, 3, NULL, NULL, NULL);
				return;	
				break;
			case 43:
			case 44:
			case 45:
			case 46:
			case 47:
			case 51:
				break;

			case 40:
			case 41:
			case 42:
			case 48:
			case 49:
			case 50:
				break;
			}			
RSWU_LOOPBREAK:;
			bRet = FALSE;
			switch (cType) {
			case 36:
			case 37:
				for (ix = tX-2; ix <= tX+2; ix++)
				for (iy = tY-2; iy <= tY+2; iy++) 
				{	m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, ix, iy);
					if ((sOwnerH != NULL) && (cOwnerType == DEF_OWNERTYPE_NPC)) 
					{	switch (m_pNpcList[sOwnerH]->m_sType) {
						case 36:
						case 37:
							bRet = TRUE;
							break;						
				}	}	}
				if ((dY <= 32) || (dY >= 783)) bRet = TRUE;
				break;
			}
			if (bRet == TRUE) 
			{	m_pMapList[ m_pClientList[iClientH]->m_cMapIndex ]->SetNamingValueEmpty(iNamingValue);
				SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_CANNOTCONSTRUCT, 1, NULL, NULL, NULL);
				return;
			}
			if (cMode == NULL) 
			{	bRet = bCreateNewNpc(cNpcName, cName, m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cName, 0, 0, DEF_MOVETYPE_FOLLOW, &tX, &tY, cNpcWayPoint, NULL, NULL, -1, FALSE, FALSE, FALSE, FALSE, m_pClientList[iClientH]->m_iGuildGUID);
				bSetNpcFollowMode(cName, m_pClientList[iClientH]->m_cCharName, DEF_OWNERTYPE_PLAYER);
			}
			else bRet = bCreateNewNpc(cNpcName, cName, m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cName, 0, 0, DEF_MOVETYPE_GUARD, &tX, &tY, cNpcWayPoint, NULL, NULL, -1, FALSE, FALSE, FALSE, FALSE, m_pClientList[iClientH]->m_iGuildGUID);
				
			if (bRet == FALSE) 
			{	m_pMapList[ m_pClientList[iClientH]->m_cMapIndex ]->SetNamingValueEmpty(iNamingValue);
			}else 
			{	m_pClientList[iClientH]->m_iConstructionPoint -= m_iNpcConstructionPoint[cType];
				if (m_pClientList[iClientH]->m_iConstructionPoint < 0) m_pClientList[iClientH]->m_iConstructionPoint = 0;
				SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_CONSTRUCTIONPOINT, m_pClientList[iClientH]->m_iConstructionPoint, m_pClientList[iClientH]->m_iWarContribution, 0, NULL); 
			}
		}
	}
	wsprintf(G_cTxt, "Req. War summon:   PC(%s) Guild(%d-%s) - %s \t%s(%d %d)"
		, m_pClientList[iClientH]->m_cCharName
		, m_pClientList[iClientH]->m_iGuildGUID 
		, m_pClientList[iClientH]->m_cGuildName 
		, cNpcName
		, m_pClientList[iClientH]->m_cMapName
		, dX
		, dY);	
	PutLogList(G_cTxt);
	PutLogEventFileList(G_cTxt);
}
////////////////////////////////////////////////////////////////////////////////////////
//	
////////////////////////////////////////////////////////////////////////////////////////
BOOL CGame::bActionOnWrongCRC(int iClientH, int iReason, int iValue)
{	BOOL bIsHosterTesting = FALSE;
	if (m_iGameServerMode == 1)			// ROUTER mode
	{	if (   (strcmp(m_pClientList[iClientH]->m_cIPaddress, m_cGameServerAddrExternal) == 0)
			|| (strcmp(m_pClientList[iClientH]->m_cIPaddress, m_cGameServerAddrInternal) == 0))
		{	// server & client share same external IP
			bIsHosterTesting = TRUE;
		}
	}else if  ( (m_iGameServerMode == 2)	// INTERNET mode
			&& (strcmp(m_pClientList[iClientH]->m_cIPaddress, m_cGameServerAddr) == 0))
	{	// server & client have exactelly same IP
		bIsHosterTesting = TRUE;
	}
	if (bIsHosterTesting == TRUE)
	{	wsprintf(G_cTxt, "Checksum error (Client:0x%04X%04X Serv:0x%04X%04X) Reason: %d, Code: 0x%04."
			, m_pClientList[iClientH]->m_wSignature1
			, m_pClientList[iClientH]->m_wSignature2
			, m_wServerValidationCRC1
			, m_wServerValidationCRC2
			, iReason
			, iValue);
		ShowClientMsg(iClientH, "AntiHACK", G_cTxt );
		return(FALSE);
	}
	switch (iReason) {
	case 1: // Pas de signature recue, alors qu'on en veut => Hack
		//printf(G_cTxt, "Cn check:  PC(%s) -  Wrong checksum (Client:0x%04X%04X Serv:0x%04X%04X). (Disc.) \tIP(%s)"
		wsprintf(G_cTxt, "Cn check:  PC(%s) -  Missing checksum (Disc.) \tIP(%s)"						
			, m_pClientList[iClientH]->m_cCharName
			, m_pClientList[iClientH]->m_cIPaddress);
		PutHackLogFileList(G_cTxt);	
		PutLogList(G_cTxt);	
		if (m_pClientList[iClientH]->m_bMonitorThisChar) 
		{	PutMonitorLogFileList(G_cTxt);	
			m_pClientList[iClientH]->dwTimeConnectionCheck = 0;
			m_pClientList[iClientH]->m_iConnectionCheck = 0;
			return(FALSE);
		}else 
		{	DeleteClient(iClientH, TRUE, TRUE);	
			return(TRUE);
		}
		break;

	case 2: // 3+ signatures identiques consécutives= hack?
		//printf(G_cTxt, "Cn check:  PC(%s) -  Wrong checksum (Client:0x%04X%04X Serv:0x%04X%04X). (Disc.) \tIP(%s)"
		wsprintf(G_cTxt, "Cn check:  PC(%s) -  Same checksum many times (0x%04X). (Disc.) \tIP(%s)"
			, m_pClientList[iClientH]->m_cCharName
			, iValue
			, m_pClientList[iClientH]->m_cIPaddress);
		PutHackLogFileList(G_cTxt);	
		PutLogList(G_cTxt);	
		if (m_pClientList[iClientH]->m_bMonitorThisChar) 
		{	PutMonitorLogFileList(G_cTxt);	
			m_pClientList[iClientH]->dwTimeConnectionCheck = 0;
			m_pClientList[iClientH]->m_iConnectionCheck = 0;
			return(FALSE);
		}else 
		{	DeleteClient(iClientH, TRUE, TRUE);	
			return(TRUE);
		}
		break;

	case 3: // 3eme signature differente => hack
		//printf(G_cTxt, "Cn check:  PC(%s) -  Wrong checksum (Client:0x%04X%04X Serv:0x%04X%04X). (Disc.) \tIP(%s)"
		wsprintf(G_cTxt, "Cn check:  PC(%s) -  3 different checksums (0x%04X 0x%04X 0x%04X). (Disc.) \tIP(%s)"
			, m_pClientList[iClientH]->m_cCharName
			, (int)m_pClientList[iClientH]->m_wSignature1
			, (int)m_pClientList[iClientH]->m_wSignature2
			, iValue
			, m_pClientList[iClientH]->m_cIPaddress);
		PutHackLogFileList(G_cTxt);	
		PutLogList(G_cTxt);	
		if (m_pClientList[iClientH]->m_bMonitorThisChar) 
		{	PutMonitorLogFileList(G_cTxt);	
			m_pClientList[iClientH]->dwTimeConnectionCheck = 0;
			m_pClientList[iClientH]->m_iConnectionCheck = 0;
			return(FALSE);
		}else 
		{	DeleteClient(iClientH, TRUE, TRUE);	
			return(TRUE);
		}
		break;

	case 4: // Signature recue incorrecte => Hack
		//printf(G_cTxt, "Cn check:  PC(%s) -  Wrong checksum (Client:0x%04X%04X Serv:0x%04X%04X). (Disc.) \tIP(%s)"
		wsprintf(G_cTxt, "Cn check:  PC(%s) -  Wrong checksum (Client:0x%04X Serv:0x%04X 0x%04X). (Disc.) \tIP(%s)"
			, m_pClientList[iClientH]->m_cCharName
			, iValue
			, (int)m_wServerValidationCRC1
			, (int)m_wServerValidationCRC2
			, m_pClientList[iClientH]->m_cIPaddress);
		PutHackLogFileList(G_cTxt);	
		PutLogList(G_cTxt);	
		if (m_pClientList[iClientH]->m_bMonitorThisChar) 
		{	PutMonitorLogFileList(G_cTxt);	
			m_pClientList[iClientH]->dwTimeConnectionCheck = 0;
			m_pClientList[iClientH]->m_iConnectionCheck = 0;
			return(FALSE);
		}else 
		{	DeleteClient(iClientH, TRUE, TRUE);	
			return(TRUE);
		}
		break;
	}
	return(FALSE);
}

void CGame::CheckConnectionHandler(int iClientH, char *pData, char cKey, DWORD dwMsgTime)
{	char * cp;
	WORD * wp, wClientCheckSum;
	DWORD * dwp, dwClientSentTime, dwTimeGapClient, dwTimeGapEvent;
	float fSpeed;
	// Added support forclient sendind a checksum using CCM
	wp  = (WORD *)(pData + DEF_INDEX2_MSGTYPE);
	wClientCheckSum = *wp;
	cp = (char *)(pData + DEF_INDEX2_MSGTYPE + 2);
	dwp = (DWORD *)cp;
	dwClientSentTime = *dwp;
	// This will check Keys as well
	CheckDenialServiceAttack(iClientH, dwClientSentTime, dwMsgTime, cKey);
	if (m_pClientList[iClientH] == NULL) return;

// Pas de signature recue => Hack
	if (wClientCheckSum == 0)
	{	if (m_wServerValidationCRC1 != 0)
		{	// Pas de signature recue, alors qu'on en veut => Hack
			if (bActionOnWrongCRC(iClientH, 1, 0)) return;
		}
	}else
// Stoker les CHECKSUMs envoyées par le client 
	{	if (m_pClientList[iClientH]->m_wSignature1 == 0)
		{	// Reception 1ere signature
			m_pClientList[iClientH]->m_wSignature1 = wClientCheckSum;
			m_pClientList[iClientH]->i_iSignatureCount = -1;		// Negative value when incrementing Sig1
		}else if (m_pClientList[iClientH]->m_wSignature2 == 0)
		{	if (wClientCheckSum == m_pClientList[iClientH]->m_wSignature1)
			{	// 2 fois la même ??? (possible si un msg perdu...)	
				m_pClientList[iClientH]->i_iSignatureCount --;	
				if (m_pClientList[iClientH]->i_iSignatureCount < -3)
				{	// 3 signatures identiques 1 = hack?
					if (bActionOnWrongCRC(iClientH, 2, (int)wClientCheckSum)) return;
				}
			}else
			{	// attarpé la 2eme signature
				m_pClientList[iClientH]->m_wSignature2 = wClientCheckSum;
				m_pClientList[iClientH]->i_iSignatureCount = 1;	
				// remise dans l'ordre ascendant des 2 signatures.
				if (m_pClientList[iClientH]->m_wSignature1 > m_pClientList[iClientH]->m_wSignature2)
				{	WORD wSig = m_pClientList[iClientH]->m_wSignature1;
					m_pClientList[iClientH]->m_wSignature1 = m_pClientList[iClientH]->m_wSignature2;
					m_pClientList[iClientH]->m_wSignature2 = wSig; 
					m_pClientList[iClientH]->i_iSignatureCount = -1 * m_pClientList[iClientH]->i_iSignatureCount;			
			}	}
		}else
// Exploiter les signatures recues
		{	// recu une 3eme signature ??????
			if (   (wClientCheckSum != m_pClientList[iClientH]->m_wSignature1) 
				&& (wClientCheckSum != m_pClientList[iClientH]->m_wSignature2))
			{	// 3eme signature => hack
				if (bActionOnWrongCRC(iClientH, 3, (int)wClientCheckSum)) return;
			}
			// Comptage des signatures
			if (wClientCheckSum == m_pClientList[iClientH]->m_wSignature1) 
			{	m_pClientList[iClientH]->i_iSignatureCount --;		
			}else if (wClientCheckSum == m_pClientList[iClientH]->m_wSignature2)
			{	m_pClientList[iClientH]->i_iSignatureCount ++;		
			}
			if (abs(m_pClientList[iClientH]->i_iSignatureCount) > 4)
			{	// 4+ signatures 1 identiques = hack?	
				if (bActionOnWrongCRC(iClientH, 2, (int)wClientCheckSum)) return;
			}
// Eventuellement comparer les signatures recues a celles prévues
			if (m_wServerValidationCRC1 != 0)
			{	if (   (wClientCheckSum != m_wServerValidationCRC1)
					&& (wClientCheckSum != m_wServerValidationCRC2))
				{	// Signature recue incorrecte => Hack
				if (bActionOnWrongCRC(iClientH, 4, (int)wClientCheckSum)) return;

	}	}	}	}

	if (   (m_pClientList[iClientH]->m_bIsInitComplete == FALSE) 
		|| ((dwMsgTime - m_pClientList[iClientH]->m_dwXPHackCheckTime) < DEF_LOGPROTECTIONTIME) )			
	// Don't compute Speedhacks before the character is connected for good
	{	m_pClientList[iClientH]->dwTimeConnectionCheck		 = dwClientSentTime;	
		m_pClientList[iClientH]->dwEventTimeConnectionCheck  = dwMsgTime;
		m_pClientList[iClientH]->m_iLowServerGapCount = 0;
		m_pClientList[iClientH]->m_iTotalGap = 0;
		m_pClientList[iClientH]->m_iNumberGap = 0;
		m_pClientList[iClientH]->m_iNumberBadGap = 0;	
		m_pClientList[iClientH]->m_iServerSideTotalGap = 0;
		m_pClientList[iClientH]->m_iConnectionCheck = 0;	
		for (register int i = 0; i < 11; i++) m_pClientList[iClientH]->m_cMsgCount[i] = 0;
		return;
	}

//1st PART: Compute gap between 2 last check connection messages
	if (m_pClientList[iClientH]->dwTimeConnectionCheck != 0) 
	{	if (dwClientSentTime > m_pClientList[iClientH]->dwTimeConnectionCheck)
		{	dwTimeGapClient = dwClientSentTime - m_pClientList[iClientH]->dwTimeConnectionCheck;			
			dwTimeGapEvent = dwMsgTime - m_pClientList[iClientH]->dwEventTimeConnectionCheck;
		}else 			
// Negative gap, means stopping a SpeedHack, or seldom the client's PC loosing his timers...
		{	wsprintf(G_cTxt, "Cn check:  PC(%s) -  Negative Client gap, just stopped to SpeedHack. (Disc.) \tIP(%s)"					
				, m_pClientList[iClientH]->m_cCharName
				, m_pClientList[iClientH]->m_cIPaddress);
			PutHackLogFileList(G_cTxt);	
			PutLogList(G_cTxt);	
			if (m_pClientList[iClientH]->m_bMonitorThisChar) 
			{	PutMonitorLogFileList(G_cTxt);	
				m_pClientList[iClientH]->dwTimeConnectionCheck = 0;
				m_pClientList[iClientH]->m_iConnectionCheck = 0;
			}else 	DeleteClient(iClientH, TRUE, TRUE);					
			return;
		}
//Monitoring: Show all connection checks...( huge file !)
		if (m_pClientList[iClientH]->m_bMonitorThisChar)
		{	wsprintf(G_cTxt, "Cn check:  PC(%s) (C:%dms S:%dms) (Pck=%3d) [Key=%4d] \tIP(%s)"				
				, m_pClientList[iClientH]->m_cCharName
				, dwTimeGapClient
				, dwTimeGapEvent
				, m_pClientList[iClientH]->m_iConnectionCheck
				, cKey
				, m_pClientList[iClientH]->m_cIPaddress);
			PutMonitorLogFileList(G_cTxt);
		}

// Very big SpeedHack: The SpeederXP signature ...
//			   Client gap increased by 1000 or more, as server gap is 1/2 the client gap...
		if (   ((dwTimeGapClient+100) > (dwTimeGapEvent * 2)) 
			&& ((int)dwTimeGapClient > (m_iClientConnectionCheckTimeRound +800)))
		{	fSpeed = (float)dwTimeGapClient;
			fSpeed = fSpeed / (float)dwTimeGapEvent;
			fSpeed -= 1; fSpeed *=100;			
			wsprintf(G_cTxt, "Cn check:  PC(%s) (C:%dms S:%dms) - SpeedHack +%d%%.(Delayed) \tIP(%s)"
				, m_pClientList[iClientH]->m_cCharName
				, dwTimeGapClient
				, dwTimeGapEvent
				, (int)fSpeed
				, m_pClientList[iClientH]->m_cIPaddress);
			PutHackLogFileList(G_cTxt);	
			//PutLogList(G_cTxt);	
			if (m_pClientList[iClientH]->m_bMonitorThisChar) 
			{	PutMonitorLogFileList(G_cTxt);	
				m_pClientList[iClientH]->dwTimeConnectionCheck = 0;
				m_pClientList[iClientH]->m_iConnectionCheck = 0;
			}else DelayedDeleteClient(iClientH, TRUE, TRUE);				
			return;	
		}
// Bad client:   This is a quadruple gap...  Edited or wrong client
// or SpeederXp  High SpeederXp type hack (should be detected earlyer...)
// or Lag        Could be enormous lag
		if ((int)dwTimeGapClient > (m_iClientConnectionCheckTimeRound * 4)) // More than 3 missing Gaps
		{	wsprintf(G_cTxt, "Cn check:  PC(%s) (C:%dms S:%dms Exp:%dms) - Big client gap, bad client.(Disc.) \tIP(%s)"
				, m_pClientList[iClientH]->m_cCharName
				, dwTimeGapClient
				, dwTimeGapEvent
				, m_iClientConnectionCheckTimeRound
				, m_pClientList[iClientH]->m_cIPaddress);
			PutHackLogFileList(G_cTxt);	
			//PutLogList(G_cTxt);	
			if (m_pClientList[iClientH]->m_bMonitorThisChar) 
			{	PutMonitorLogFileList(G_cTxt);	
				m_pClientList[iClientH]->dwTimeConnectionCheck = 0;
				m_pClientList[iClientH]->m_iConnectionCheck = 0;
			}else DeleteClient(iClientH, TRUE, TRUE);				
			return;	
		}
		m_pClientList[iClientH]->dwTimeConnectionCheck		 = dwClientSentTime;
		m_pClientList[iClientH]->dwEventTimeConnectionCheck  = dwMsgTime;		
// Adjust gaps if standard client
		if (m_iClientConnectionCheckTime == 8000)
		{	if (dwTimeGapClient < 7901) //Without my patch Client time is sending time & not checked time 
//Client gap low: wrong client
			{	wsprintf(G_cTxt, "Cn check:  PC(%s) (C:%dms Exp:8000ms) - Client gap too low, wrong client.(Disc.) \tIP(%s)"					
					, m_pClientList[iClientH]->m_cCharName
					, (int) dwTimeGapClient
					, m_pClientList[iClientH]->m_cIPaddress);
				PutHackLogFileList(G_cTxt);	
				//PutLogList(G_cTxt);				
				if (m_pClientList[iClientH]->m_bMonitorThisChar) 
				{	PutMonitorLogFileList(G_cTxt);	
					m_pClientList[iClientH]->dwTimeConnectionCheck = 0;
					m_pClientList[iClientH]->m_iConnectionCheck = 0;
				}else 	DeleteClient(iClientH, TRUE, TRUE);	
				return;
			}			
			if (dwTimeGapClient <= 8200)
			{	dwTimeGapClient += 1000;
				dwTimeGapEvent  += 1000;				
			}
		}else // Using my client
		{	if ((int)dwTimeGapClient < m_iClientConnectionCheckTime) 
//Client gap very low: Wrong client prouved
			{	wsprintf(G_cTxt, "Cn check:  PC(%s) (C:%dms Exp:%dms) - Client gap too low, wrong client.(Disc.) \tIP(%s)"					
					, m_pClientList[iClientH]->m_cCharName
					, dwTimeGapClient
					, m_iClientConnectionCheckTime
					, m_pClientList[iClientH]->m_cIPaddress);
				PutHackLogFileList(G_cTxt);	
				//PutLogList(G_cTxt);	
				if (m_pClientList[iClientH]->m_bMonitorThisChar) 
				{	PutMonitorLogFileList(G_cTxt);	
					m_pClientList[iClientH]->dwTimeConnectionCheck = 0;
					m_pClientList[iClientH]->m_iConnectionCheck = 0;
				}else DeleteClient(iClientH, TRUE, TRUE);	
				return;
			}

// Unexpected low Client gap: Between 6150 and +-6900 
//                            Patched client will never send ccm before onTimer event, every 1000 ms...
//                            unless computer is slowed alot (Mainlly on game loading ?)
//                            if serveur gap is near 6000 or near 5000, I'm pretty sure this is a Speedhack (or very very bad luck!)
			int iDecalage = (m_iClientConnectionCheckTimeRound-(int)dwTimeGapEvent)%1000;
			iDecalage -=1000;
			iDecalage = abs(iDecalage); // différence beetwen 5000, 6000, or 7000, and mesured server gap.
			if (   ((int)(dwTimeGapClient+100) < m_iClientConnectionCheckTimeRound) 
				&& (((int)dwTimeGapClient-(int)dwTimeGapEvent) >1000)) 
			{	// Be sure all 15%+ Speedhack are detected..
				fSpeed = (float) dwTimeGapClient;
				fSpeed = fSpeed / (float) dwTimeGapEvent;
				fSpeed -= 1; fSpeed *=100;	
				wsprintf(G_cTxt, "Cn check:  PC(%s) (C:%dms S:%dms Exp:%dms) - SpeedHack +%d%%. (Delayed) \tIP(%s)"					
					, m_pClientList[iClientH]->m_cCharName
					, dwTimeGapClient
					, dwTimeGapEvent
					, m_iClientConnectionCheckTimeRound
					, (int)fSpeed 
					, m_pClientList[iClientH]->m_cIPaddress);
				PutHackLogFileList(G_cTxt);	
				//PutLogList(G_cTxt);	
				if (m_pClientList[iClientH]->m_bMonitorThisChar) 
				{	PutMonitorLogFileList(G_cTxt);	
					m_pClientList[iClientH]->dwTimeConnectionCheck = 0;
					m_pClientList[iClientH]->m_iConnectionCheck = 0;
				}else DelayedDeleteClient(iClientH, TRUE, TRUE);	
				return;
			}else if ( ((int)(dwTimeGapClient+100) < m_iClientConnectionCheckTimeRound) 
					&& (iDecalage < 71) ) // prevent most false alarm is below 15%
			{	// Small SpeedHack detected here. 3%..15% 
				fSpeed = (float) dwTimeGapClient;
				fSpeed = fSpeed / (float) dwTimeGapEvent;
				fSpeed -= 1; fSpeed *=100;	
				if (fSpeed >= 3.0) // Do not detect Speedhack below 3% here...(possible low client gap/lower server gap <6071=
				{	wsprintf(G_cTxt, "Cn check:  PC(%s) (C:%dms S:%dms Exp:%dms) - SpeedHack? +%d%%. (Disc.) \tIP(%s)"					
						, m_pClientList[iClientH]->m_cCharName
						, dwTimeGapClient
						, dwTimeGapEvent
						, m_iClientConnectionCheckTimeRound
						, (int)fSpeed 
						, m_pClientList[iClientH]->m_cIPaddress);
					PutHackLogFileList(G_cTxt);	
					//PutLogList(G_cTxt);	
					if (m_pClientList[iClientH]->m_bMonitorThisChar) 
					{	PutMonitorLogFileList(G_cTxt);	
						m_pClientList[iClientH]->dwTimeConnectionCheck = 0;
						m_pClientList[iClientH]->m_iConnectionCheck = 0;
					}else DeleteClient(iClientH, TRUE, TRUE);	
					return;
				}
			}
// Unexpected high Client gap: Over 7100 and correlated by a low server gap, below 6100
//                             A slow computed (bad Timer) and lag could send false alarm...
			if (   ((int)dwTimeGapClient > (m_iClientConnectionCheckTimeRound + 100)) 
				&& ((int)dwTimeGapEvent  < (m_iClientConnectionCheckTimeRound - 900))) // Prevent detection if lost ccm packet
			{	// SpeedHack detected here: 18%, 42%, 76% but some risk of false alarme dur to lag...
				fSpeed = (float) dwTimeGapClient;
				fSpeed = fSpeed / (float) dwTimeGapEvent;
				fSpeed -= 1; fSpeed *=100;											
				wsprintf(G_cTxt, "Cn check:  PC(%s) (C:%dms S:%dms Exp:%dms) - SpeedHack? +%d%%. (Disc.) \tIP(%s)"					
					, m_pClientList[iClientH]->m_cCharName
					, dwTimeGapClient
					, dwTimeGapEvent
					, m_iClientConnectionCheckTimeRound
					, (int)fSpeed 
					, m_pClientList[iClientH]->m_cIPaddress);
				PutHackLogFileList(G_cTxt);	
				//PutLogList(G_cTxt);	
				if (m_pClientList[iClientH]->m_bMonitorThisChar) 
				{	PutMonitorLogFileList(G_cTxt);	
					m_pClientList[iClientH]->dwTimeConnectionCheck = 0;
					m_pClientList[iClientH]->m_iConnectionCheck = 0;
				}else DeleteClient(iClientH, TRUE, TRUE);	
				return;
			}

// Client gap too far from 7000ms: 6900..6940 and 7060..7100
// and Server gap low +-6000     : below 6100 (as confirmation something wrong)
			if (   (abs((int)dwTimeGapClient - m_iClientConnectionCheckTimeRound) > 60) 
				&& ((m_iClientConnectionCheckTimeRound - (int)dwTimeGapEvent) > 900)
				&& (abs((int)dwTimeGapClient - (int)dwTimeGapEvent) > 950))
			{	// SpeedHack near 20%, 40%, 70% detected here
				fSpeed = (float) dwTimeGapClient;
				fSpeed = fSpeed / (float) dwTimeGapEvent;
				fSpeed -= 1; fSpeed *=100;											
				wsprintf(G_cTxt, "Cn check:  PC(%s) (C:%dms S:%dms Exp:%dms) - SpeedHack? +%d%%. (Disc.) \tIP(%s)"					
					, m_pClientList[iClientH]->m_cCharName
					, dwTimeGapClient
					, dwTimeGapEvent
					, m_iClientConnectionCheckTimeRound
					, (int)fSpeed 
					, m_pClientList[iClientH]->m_cIPaddress);
				PutHackLogFileList(G_cTxt);	
				//PutLogList(G_cTxt);	
				if (m_pClientList[iClientH]->m_bMonitorThisChar) 
				{	PutMonitorLogFileList(G_cTxt);	
					m_pClientList[iClientH]->dwTimeConnectionCheck = 0;
					m_pClientList[iClientH]->m_iConnectionCheck = 0;
				}else 	DeleteClient(iClientH, TRUE, TRUE);	
				return;
			}

// Server gap low: Lag, SpeedHack or Wrong client suspiction
//                 3 times => wrong client or SpeedHack
//				   bigger difference = SPeedHack
//                 Could be caused by a very big lag
			if ((m_iClientConnectionCheckTimeRound - (int)dwTimeGapEvent) > 900) // server gap < 6100ms
			{	if (abs((int)dwTimeGapClient - m_iClientConnectionCheckTimeRound) < 50)
				{	// if client gap is normal, we supose big lag
					m_pClientList[iClientH]->m_iLowServerGapCount += 1000;
				}else
				{	// if client gap is not standard, we supose keep the value
					m_pClientList[iClientH]->m_iLowServerGapCount += (m_iClientConnectionCheckTimeRound - (int)dwTimeGapEvent);
				}
				if (m_pClientList[iClientH]->m_iLowServerGapCount > 2900)
				{	// 3 low server gaps => Big SpeedHacks confirmed here..						
					wsprintf(G_cTxt, "Cn check:  PC(%s) (C:%dms S:%dms Exp:%dms) - Low server gaps. SpeedHack?(Disc.) \tIP(%s)"					
						, m_pClientList[iClientH]->m_cCharName
						, dwTimeGapClient
						, dwTimeGapEvent
						, m_iClientConnectionCheckTimeRound
						, m_pClientList[iClientH]->m_cIPaddress);
					PutHackLogFileList(G_cTxt);	
					//PutLogList(G_cTxt);		
					if (m_pClientList[iClientH]->m_bMonitorThisChar) 
					{	PutMonitorLogFileList(G_cTxt);	
						m_pClientList[iClientH]->dwTimeConnectionCheck = 0;
						m_pClientList[iClientH]->m_iConnectionCheck = 0;
					}else 	DeleteClient(iClientH, TRUE, TRUE);	
					return;	
				}
			}else
			{	m_pClientList[iClientH]->m_iLowServerGapCount = 0;
			}
		}


//2nd PART: Determine Theoric client gap, between 2 client's CCM
//          This is done only once for each client.
		if (m_pClientList[iClientH]->m_iTheoricGap == 0)	// Theoric gap not yet determined
		{	if (m_pClientList[iClientH]->m_iLowerGap == 0)
			{	m_pClientList[iClientH]->m_iLowerGap = (int)dwTimeGapClient;
			}else if (m_pClientList[iClientH]->m_iLowerGap > (int)dwTimeGapClient)	
			{	if (m_pClientList[iClientH]->m_iLowerGap > (int)(dwTimeGapClient + 5)) // don't reset is very small difference 
				{	m_pClientList[iClientH]->m_iLowerGapValidation = 0;		
				}			
				m_pClientList[iClientH]->m_iLowerGap = (int)dwTimeGapClient;				
			}else if ( (int)dwTimeGapClient < m_pClientList[iClientH]->m_iLowerGap + 250)
			{	m_pClientList[iClientH]->m_iLowerGapValidation += 1;
			}			
			if (m_pClientList[iClientH]->m_iLowerGapValidation > m_iCCCNeededForValidation) // 5 if my client else 12
			{	if (m_iClientConnectionCheckTime == 8000)
				{	float fAverage = ((float)m_pClientList[iClientH]->m_iLowerGap + 800.0)/1000.0; 
					m_pClientList[iClientH]->m_iTheoricGap	 = ((int)fAverage) * 1000;
				}else
				{	float fAverage = ((float)m_pClientList[iClientH]->m_iLowerGap + 890.0)/1000.0;
					m_pClientList[iClientH]->m_iTheoricGap	 = ((int)fAverage) * 1000;
				}			
				//Monitoring: Show Theoric gap
				if (m_pClientList[iClientH]->m_bMonitorThisChar)
				{	wsprintf(G_cTxt, "Cn check:  PC(%s) - Theoric gap determination: (Theoric:%dms Lower:%dms) \tIP(%s)"					
						, m_pClientList[iClientH]->m_cCharName
						, m_pClientList[iClientH]->m_iTheoricGap
						, m_pClientList[iClientH]->m_iLowerGap	
						, m_pClientList[iClientH]->m_cIPaddress);
					PutMonitorLogFileList(G_cTxt);	
				}
//Theoric gap check: Client's gap is not as expected.=> Hack: wrong
//                   This would be usefull only if clients has an enlarged gap 
				if (m_pClientList[iClientH]->m_iTheoricGap != m_iClientConnectionCheckTimeRound)
				{	wsprintf(G_cTxt, "Cn check:  PC(%s) (C:%dms Exp:%dms) - Theoric client gap wrong: Wrong client. (Disc.) \tIP(%s)"					
						, m_pClientList[iClientH]->m_cCharName
						, m_pClientList[iClientH]->m_iTheoricGap
						, m_iClientConnectionCheckTimeRound
						, m_pClientList[iClientH]->m_cIPaddress);
					PutHackLogFileList(G_cTxt);
					//PutLogList(G_cTxt);					
					if (m_pClientList[iClientH]->m_bMonitorThisChar) 
					{	PutMonitorLogFileList(G_cTxt);	
						m_pClientList[iClientH]->dwTimeConnectionCheck = 0;
						m_pClientList[iClientH]->m_iConnectionCheck = 0;
					}else 	DeleteClient(iClientH, TRUE, TRUE);	
					return;	
				}
			}
		}				


//3rd PART: Statistics (Average Client Time and server time allow to detect speedhack)			
		if ((int)dwTimeGapClient < (m_iClientConnectionCheckTimeRound * 2))
		{	m_pClientList[iClientH]->m_iTotalGap += (int)dwTimeGapClient;
			m_pClientList[iClientH]->m_iNumberGap += 1;
			m_pClientList[iClientH]->m_iServerSideTotalGap += (int)dwTimeGapEvent;			
		}else 
		{	m_pClientList[iClientH]->m_iNumberBadGap +=1;
		}
		// Over 5, let's reset	
		if (m_pClientList[iClientH]->m_iNumberGap > 5)
		{	if (m_pClientList[iClientH]->m_iNumberBadGap > 15)
//Lag check: Too much bad Gaps.... irrevelant for Speedhack check...
			{	wsprintf(G_cTxt, "Cn check:  PC(%s) (%dms) - %d bad gaps for %d good ones. (Lag?) \tIP(%s)"
					, m_pClientList[iClientH]->m_cCharName
					, dwTimeGapClient
					, m_pClientList[iClientH]->m_iNumberBadGap
					, m_pClientList[iClientH]->m_iNumberGap
					, m_pClientList[iClientH]->m_cIPaddress);
				PutHackLogFileList(G_cTxt);	
				if (m_pClientList[iClientH]->m_bMonitorThisChar) PutMonitorLogFileList(G_cTxt);	
				//PutLogList(G_cTxt);
			}else
			{	//Monitoring: Show each average gap determination	
				if (m_pClientList[iClientH]->m_bMonitorThisChar)
				{	wsprintf(G_cTxt, "Cn check:  PC(%s) (C:%dms S:%dms) - Average gap determination. \tIP(%s)"					
						, m_pClientList[iClientH]->m_cCharName
						, (m_pClientList[iClientH]->m_iTotalGap / m_pClientList[iClientH]->m_iNumberGap)	
						, (m_pClientList[iClientH]->m_iServerSideTotalGap / m_pClientList[iClientH]->m_iNumberGap)
						, m_pClientList[iClientH]->m_cIPaddress);
					PutMonitorLogFileList(G_cTxt);
				}
// Server gap below 8200, => hack (8000..8200- were given +1000)
// SGap <8200     : impossible,               Server	=> Hack prouvé
// SGap 8200..8999: client ralenti					    => Hack si difference notable S/C (en moyenne)	
// SGap +-9000    : normal
// SGap 9000..9199: client un peu ralenti
// SGap 9200+     : Lag ou client très ralenti 

				if (m_iClientConnectionCheckTime == 8000) // Standard client
//SGap <8200     : Impossible!               Server	=> Hack prouvé
//                Means client gap is above 8200 and server gap below 8200
//                Can only happen using speedHack  (on average to cancel Lag effect) 
				{	if (8200 > (m_pClientList[iClientH]->m_iServerSideTotalGap / m_pClientList[iClientH]->m_iNumberGap))
					{	wsprintf(G_cTxt, "Cn check:  PC(%s) (C:%dms S:%dms Max:8200ms) - Server average gap low, SpeedHack. (Disc.) \tIP(%s)"					
							, m_pClientList[iClientH]->m_cCharName
							, (m_pClientList[iClientH]->m_iTotalGap / m_pClientList[iClientH]->m_iNumberGap)
							, (m_pClientList[iClientH]->m_iServerSideTotalGap / m_pClientList[iClientH]->m_iNumberGap)	
							, m_pClientList[iClientH]->m_cIPaddress);
						PutHackLogFileList(G_cTxt);	
						//PutLogList(G_cTxt);				
						if (m_pClientList[iClientH]->m_bMonitorThisChar) 
						{	PutMonitorLogFileList(G_cTxt);	
							m_pClientList[iClientH]->dwTimeConnectionCheck = 0;
							m_pClientList[iClientH]->m_iConnectionCheck = 0;
						}else 	DeleteClient(iClientH, TRUE, TRUE);	
						return;	
					}

//  Cgap <9200 (low gap) & Cgap bigger than Sgp by 500+ >>> SpeedHack !
					if (   (9200 > (m_pClientList[iClientH]->m_iTotalGap / m_pClientList[iClientH]->m_iNumberGap))
						&& ((m_pClientList[iClientH]->m_iTotalGap/m_pClientList[iClientH]->m_iNumberGap) 
							> (500+(m_pClientList[iClientH]->m_iServerSideTotalGap/m_pClientList[iClientH]->m_iNumberGap))))
					{	fSpeed = (float)m_pClientList[iClientH]->m_iTotalGap;
						fSpeed = fSpeed / (float)m_pClientList[iClientH]->m_iServerSideTotalGap;
						fSpeed -= 1; fSpeed *=100;							
						wsprintf(G_cTxt, "Cn check:  PC(%s) (C:%dms S:%dms MaxDif:-500ms) - Average gap difference, %d%% SpeedHack.(Disc.). \tIP(%s)"					
							, m_pClientList[iClientH]->m_cCharName
							, (m_pClientList[iClientH]->m_iTotalGap / m_pClientList[iClientH]->m_iNumberGap)
							, (m_pClientList[iClientH]->m_iServerSideTotalGap / m_pClientList[iClientH]->m_iNumberGap)	
							, (int)fSpeed
							, m_pClientList[iClientH]->m_cIPaddress);
						PutHackLogFileList(G_cTxt);	
						//PutLogList(G_cTxt);				
						if (m_pClientList[iClientH]->m_bMonitorThisChar) 
						{	PutMonitorLogFileList(G_cTxt);	
							m_pClientList[iClientH]->dwTimeConnectionCheck = 0;
							m_pClientList[iClientH]->m_iConnectionCheck = 0;
						}else 	DeleteClient(iClientH, TRUE, TRUE);	
						return;								
					} 
// Cgap >9200 (understand 8200+) & CGap laown than server gap by 250ms >>> NegativeSpeedHack !
					if (   (9200 >= (m_pClientList[iClientH]->m_iTotalGap / m_pClientList[iClientH]->m_iNumberGap))
						&& ((250+(m_pClientList[iClientH]->m_iTotalGap/m_pClientList[iClientH]->m_iNumberGap)) 
							< (m_pClientList[iClientH]->m_iServerSideTotalGap/m_pClientList[iClientH]->m_iNumberGap)))
						// This kind of speedHack should not be possible, meaning slowing the client
						// unless some packet editor send false things
					{	wsprintf(G_cTxt, "Cn check:  PC(%s) (C:%dms S:%dms MaxDif:+250ms) - Average gap, negative SpeedHack or Lag. \tIP(%s)"					
							, m_pClientList[iClientH]->m_cCharName
							, (m_pClientList[iClientH]->m_iTotalGap / m_pClientList[iClientH]->m_iNumberGap)
							, (m_pClientList[iClientH]->m_iServerSideTotalGap / m_pClientList[iClientH]->m_iNumberGap)	
							, m_pClientList[iClientH]->m_cIPaddress);
						PutHackLogFileList(G_cTxt);	
						if (m_pClientList[iClientH]->m_bMonitorThisChar) PutMonitorLogFileList(G_cTxt);	
						//PutLogList(G_cTxt);		
					}
				}else // It's my patched client...
				{	
// Cgap <6150      : Impossible, Wrong client							(checked at gap determination)
// Cgap 6150..6900 : SpeedHack											(checked at gap determination)
// Cgap +-7000     : Normal
// Cgap 7100+      : Client slowed or SpeedHack if serveur gap <=6000	(checked at gap determination) 
// Sgap <= 6000    : Lag or SpeedHack (must be confirmed by Client Gap)	(checked at gap determination)    
					if (500<abs((m_pClientList[iClientH]->m_iTotalGap / m_pClientList[iClientH]->m_iNumberGap)-(m_pClientList[iClientH]->m_iServerSideTotalGap / m_pClientList[iClientH]->m_iNumberGap)))
// Average gap big Client/server difference.
//                  Possible SpeedHack in conjunction with edited client
// This is a counter check because SpeedHack should have been detected on single gap determination with my client.
					{	wsprintf(G_cTxt, "Cn check:  PC(%s) (C:%dms S:%dms MaxDif:+-500ms) - Big Average gap difference. (Disc.) \tIP(%s)"					
							, m_pClientList[iClientH]->m_cCharName
							, (m_pClientList[iClientH]->m_iTotalGap / m_pClientList[iClientH]->m_iNumberGap)
							, (m_pClientList[iClientH]->m_iServerSideTotalGap / m_pClientList[iClientH]->m_iNumberGap)	
							, m_pClientList[iClientH]->m_cIPaddress);
						PutHackLogFileList(G_cTxt);	
						//PutLogList(G_cTxt);					
						if (m_pClientList[iClientH]->m_bMonitorThisChar) 
						{	PutMonitorLogFileList(G_cTxt);	
							m_pClientList[iClientH]->dwTimeConnectionCheck = 0;
							m_pClientList[iClientH]->m_iConnectionCheck = 0;
						}else 	DeleteClient(iClientH, TRUE, TRUE);	
						return;
			}	}	}
			m_pClientList[iClientH]->m_iTotalGap = 0;
			m_pClientList[iClientH]->m_iNumberGap = 0;
			m_pClientList[iClientH]->m_iNumberBadGap = 0;	
			m_pClientList[iClientH]->m_iServerSideTotalGap = 0;
		}


//4th PART: Nbe of packets beetween two last ConnectionCheck messages	
		if (   (m_pClientList[iClientH]->m_iConnectionCheck > m_iClientConnectionCheckMaxNumber) 
			&& ((int)dwTimeGapClient < m_iClientConnectionCheckTimeRound + 1500))
		// Log everytime, if over 33 actions in 8 or 9 seconds...
		{	if (m_pClientList[iClientH]->m_iMaxPackets < m_pClientList[iClientH]->m_iConnectionCheck)
			{	m_pClientList[iClientH]->m_iMaxPackets = m_pClientList[iClientH]->m_iConnectionCheck;			
				wsprintf(G_cTxt, "Cn check:  PC(%s) (C=%4dms) (Pck=%3d) - Too many packets, Packet Editor? \tIP(%s)"				
					, m_pClientList[iClientH]->m_cCharName
					, dwTimeGapClient
					, m_pClientList[iClientH]->m_iConnectionCheck
					, m_pClientList[iClientH]->m_cIPaddress);
				PutHackLogFileList(G_cTxt);
				if (m_pClientList[iClientH]->m_bMonitorThisChar) PutMonitorLogFileList(G_cTxt);
				m_pClientList[iClientH]->m_iMaxPackets = m_pClientList[iClientH]->m_iConnectionCheck;			
				wsprintf(G_cTxt, "Packets: PC(%s) Packets=%3d - Msc:%d Sel:%d Not:%d Cha:%d Obj%d ReI:%d Ite:%d Com:%d Mot:%d ...:%d"				
					, m_pClientList[iClientH]->m_cCharName
					, m_pClientList[iClientH]->m_iConnectionCheck
					, m_pClientList[iClientH]->m_cMsgCount[1]
					, m_pClientList[iClientH]->m_cMsgCount[2]
					, m_pClientList[iClientH]->m_cMsgCount[3]
					, m_pClientList[iClientH]->m_cMsgCount[4]
					, m_pClientList[iClientH]->m_cMsgCount[5]
					, m_pClientList[iClientH]->m_cMsgCount[6]
					, m_pClientList[iClientH]->m_cMsgCount[7]
					, m_pClientList[iClientH]->m_cMsgCount[8]
					, m_pClientList[iClientH]->m_cMsgCount[9]
					, m_pClientList[iClientH]->m_cMsgCount[10]);
				PutHackLogFileList(G_cTxt);				
				if (m_pClientList[iClientH]->m_bMonitorThisChar) PutMonitorLogFileList(G_cTxt);
				//PutLogList(G_cTxt);	
			}
		}
	}else 	
//Recived 1st cn check message: initialize things
	{	m_pClientList[iClientH]->dwTimeConnectionCheck		 = dwClientSentTime;	
		m_pClientList[iClientH]->dwEventTimeConnectionCheck  = dwMsgTime;
		m_pClientList[iClientH]->m_iLowServerGapCount = 0;
		m_pClientList[iClientH]->m_iTotalGap = 0;
		m_pClientList[iClientH]->m_iNumberGap = 0;
		m_pClientList[iClientH]->m_iNumberBadGap = 0;	
		m_pClientList[iClientH]->m_iServerSideTotalGap = 0;
	}
	m_pClientList[iClientH]->m_iConnectionCheck = 0;	
	for (register int i = 0; i < 11; i++) m_pClientList[iClientH]->m_cMsgCount[i] = 0;
}

void CGame::SelectCrusadeDutyHandler(int iClientH, int iDuty)
{	if (m_pClientList[iClientH] == NULL) return;
	if ((m_pClientList[iClientH]->m_iGuildRank != 0) && (iDuty == 3)) return;
	/*if (   (m_iLastCrusadeWinner == m_pClientList[iClientH]->m_cSide) 
		&& (m_pClientList[iClientH]->m_dwCrusadeGUID == 0) && (iDuty == 3)) 
	{		m_pClientList[iClientH]->m_iConstructionPoint = 3000;
	}*/
	// My own system: Advantage given id a side lost many crusades...
	if ((iDuty == 3) && (m_pClientList[iClientH]->m_dwCrusadeGUID ==  m_dwCrusadeGUID))
	{	if (   (m_pClientList[iClientH]->m_cSide == 1)
			&& (m_iCrusadeAdvantage > 0))// Positive value, Elvine won a lot
		{	m_pClientList[iClientH]->m_iConstructionPoint += (1000 * abs(m_iCrusadeAdvantage));
		}else if ( (m_pClientList[iClientH]->m_cSide == 2)
			&& (m_iCrusadeAdvantage < 0))// Negative value, Areden won a lot
		{	m_pClientList[iClientH]->m_iConstructionPoint += (1000 * abs(m_iCrusadeAdvantage));
		}
	}
	m_pClientList[iClientH]->m_iCrusadeDuty = iDuty;
	SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_CRUSADE, (DWORD)m_bIsCrusadeMode, m_pClientList[iClientH]->m_iCrusadeDuty, 0, NULL);
	if (iDuty == 1) 
		_bCrusadeLog(DEF_CRUSADELOG_SELECTDUTY,iClientH,NULL,"Fighter");
	else if (iDuty == 2) 
		_bCrusadeLog(DEF_CRUSADELOG_SELECTDUTY,iClientH,NULL,"Constructor");
	else
		_bCrusadeLog(DEF_CRUSADELOG_SELECTDUTY,iClientH,NULL,"Commander");
}

void CGame::MapStatusHandler(int iClientH, int iMode, char * pMapName)
{register int i;
	if (m_pClientList[iClientH] == NULL) return;
	switch (iMode) {
	case 1: // send Teleport location
		if (m_pClientList[iClientH]->m_iCrusadeDuty == NULL) return;
		for (i = 0; i < DEF_MAXGUILDS; i++) 
		if ((m_pGuildTeleportLoc[i].m_iV1 != NULL) && (m_pGuildTeleportLoc[i].m_iV1 == m_pClientList[iClientH]->m_iGuildGUID)) 
		{	SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_TCLOC, m_pGuildTeleportLoc[i].m_sDestX, m_pGuildTeleportLoc[i].m_sDestY,
				          NULL, m_pGuildTeleportLoc[i].m_cDestMapName, m_pGuildTeleportLoc[i].m_sDestX2, m_pGuildTeleportLoc[i].m_sDestY2,
						  NULL, NULL, NULL, NULL, m_pGuildTeleportLoc[i].m_cDestMapName2);	
			ZeroMemory(m_pClientList[iClientH]->m_cConstructMapName, sizeof(m_pClientList[iClientH]->m_cConstructMapName));
			memcpy(m_pClientList[iClientH]->m_cConstructMapName, m_pGuildTeleportLoc[i].m_cDestMapName2, 10);
			m_pClientList[iClientH]->m_iConstructLocX = m_pGuildTeleportLoc[i].m_sDestX2;
			m_pClientList[iClientH]->m_iConstructLocY = m_pGuildTeleportLoc[i].m_sDestY2;
			return;
		}
		break;

	case 3:	// Send Base & ManaStones
		//if (m_pClientList[iClientH]->m_iCrusadeDuty != 3) return;
		for (i = 0; i < DEF_MAXCRUSADESTRUCTURES; i++) 
		{	m_pClientList[iClientH]->m_stCrusadeStructureInfo[i].cType = NULL;
			m_pClientList[iClientH]->m_stCrusadeStructureInfo[i].cSide = NULL;
			m_pClientList[iClientH]->m_stCrusadeStructureInfo[i].sX = NULL;
			m_pClientList[iClientH]->m_stCrusadeStructureInfo[i].sY = NULL;
		}
		m_pClientList[iClientH]->m_iCSIsendPoint = NULL;
		ZeroMemory(m_pClientList[iClientH]->m_cSendingMapName, sizeof(m_pClientList[iClientH]->m_cSendingMapName));

		if (strcmp(pMapName, m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cName) == 0) 
		{	for (i = 0; i < m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_iTotalCrusadeStructures; i++) 
			{	if ( m_pClientList[iClientH]->m_iCrusadeDuty == 3) 	// Commander 
				{	m_pClientList[iClientH]->m_stCrusadeStructureInfo[i].cType = m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_stCrusadeStructureInfo[i].cType;
					m_pClientList[iClientH]->m_stCrusadeStructureInfo[i].cSide = m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_stCrusadeStructureInfo[i].cSide;
					m_pClientList[iClientH]->m_stCrusadeStructureInfo[i].sX    = m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_stCrusadeStructureInfo[i].sX;
					m_pClientList[iClientH]->m_stCrusadeStructureInfo[i].sY    = m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_stCrusadeStructureInfo[i].sY;
				}else if (m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_stCrusadeStructureInfo[i].cType == 42) 
				{	m_pClientList[iClientH]->m_stCrusadeStructureInfo[i].cType = m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_stCrusadeStructureInfo[i].cType;
					m_pClientList[iClientH]->m_stCrusadeStructureInfo[i].cSide = m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_stCrusadeStructureInfo[i].cSide;
					m_pClientList[iClientH]->m_stCrusadeStructureInfo[i].sX    = m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_stCrusadeStructureInfo[i].sX;
					m_pClientList[iClientH]->m_stCrusadeStructureInfo[i].sY    = m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_stCrusadeStructureInfo[i].sY;
				}
			}
			memcpy(m_pClientList[iClientH]->m_cSendingMapName, m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cName, 10);
		}else 
		{	if (strcmp(pMapName, "middleland") == 0) 
			{	for (i = 0; i < m_iTotalMiddleCrusadeStructures; i++) 
				{	if ( m_pClientList[iClientH]->m_iCrusadeDuty == 3) // Commander
					{	m_pClientList[iClientH]->m_stCrusadeStructureInfo[i].cType = m_stMiddleCrusadeStructureInfo[i].cType;
						m_pClientList[iClientH]->m_stCrusadeStructureInfo[i].cSide = m_stMiddleCrusadeStructureInfo[i].cSide;
						m_pClientList[iClientH]->m_stCrusadeStructureInfo[i].sX    = m_stMiddleCrusadeStructureInfo[i].sX;
						m_pClientList[iClientH]->m_stCrusadeStructureInfo[i].sY    = m_stMiddleCrusadeStructureInfo[i].sY;
					}else if (m_stMiddleCrusadeStructureInfo[i].cType == 42)
					{	m_pClientList[iClientH]->m_stCrusadeStructureInfo[i].cType = m_stMiddleCrusadeStructureInfo[i].cType;
						m_pClientList[iClientH]->m_stCrusadeStructureInfo[i].cSide = m_stMiddleCrusadeStructureInfo[i].cSide;
						m_pClientList[iClientH]->m_stCrusadeStructureInfo[i].sX    = m_stMiddleCrusadeStructureInfo[i].sX;
						m_pClientList[iClientH]->m_stCrusadeStructureInfo[i].sY    = m_stMiddleCrusadeStructureInfo[i].sY;
					}
				}
				strcpy(m_pClientList[iClientH]->m_cSendingMapName, "middleland");
			}else {}
		}	
		_SendMapStatus(iClientH);
		break;
	}
}

void CGame::_SendMapStatus(int iClientH)
{register int i, iDataSize;
 char *cp, cData[DEF_MAXCRUSADESTRUCTURES*6];
 short * sp;
	ZeroMemory(cData, sizeof(cData));
	cp = (char *)(cData);
	memcpy(cp, m_pClientList[iClientH]->m_cSendingMapName, 10);
	cp += 10;	
	sp = (short *)cp;
	*sp = (short)m_pClientList[iClientH]->m_iCSIsendPoint;
	cp += 2;
	cp++;

	if (m_pClientList[iClientH]->m_iCSIsendPoint == NULL)
		m_pClientList[iClientH]->m_bIsSendingMapStatus = TRUE;

	iDataSize = 0;
	for (i = 0 ; i < 100; i++) 
	{	if (m_pClientList[iClientH]->m_iCSIsendPoint >= DEF_MAXCRUSADESTRUCTURES) goto SMS_ENDOFDATA;
		if (m_pClientList[iClientH]->m_stCrusadeStructureInfo[m_pClientList[iClientH]->m_iCSIsendPoint].cType == NULL) goto SMS_ENDOFDATA;
		*cp = m_pClientList[iClientH]->m_stCrusadeStructureInfo[m_pClientList[iClientH]->m_iCSIsendPoint].cType;
		cp++;
		sp = (short *)cp;
		*sp = m_pClientList[iClientH]->m_stCrusadeStructureInfo[m_pClientList[iClientH]->m_iCSIsendPoint].sX;
		cp += 2;
		sp = (short *)cp;
		*sp = m_pClientList[iClientH]->m_stCrusadeStructureInfo[m_pClientList[iClientH]->m_iCSIsendPoint].sY;
		cp += 2;
		*cp = m_pClientList[iClientH]->m_stCrusadeStructureInfo[m_pClientList[iClientH]->m_iCSIsendPoint].cSide;
		cp++;
		iDataSize += 6;
		m_pClientList[iClientH]->m_iCSIsendPoint++;
	}
	cp = (char *)(cData + 12);
	*cp = (iDataSize/6);
	SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_MAPSTATUSNEXT, iDataSize +13, NULL, NULL, cData);
	return;

SMS_ENDOFDATA:;
	cp = (char *)(cData + 12);
	*cp = (iDataSize/6);
	SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_MAPSTATUSLAST, iDataSize +13, NULL, NULL, cData);
	m_pClientList[iClientH]->m_bIsSendingMapStatus = FALSE;
	return;
}

void CGame::RemoveCrusadeStructures()
{register int i;
	for (i = 0 ; i < DEF_MAXNPCS; i++)
	if (m_pNpcList[i] != NULL) {
		switch (m_pNpcList[i]->m_sOriginalType) {
		case 36:
		case 37:
		case 38:
		case 39:
		case 40:
		case 41:
		case 42:
			DeleteNpc(i);
			break;
	}	}
}

void CGame::RequestHelpHandler(int iClientH)
{	register int i;	
	if (m_pClientList[iClientH] == NULL) return;
	if (m_pClientList[iClientH]->m_iGuildRank == -1) return;
	if (m_pClientList[iClientH]->m_iCrusadeDuty != 1) return;
	for (i = 1; i < DEF_MAXCLIENTS; i++)
	if (   (m_pClientList[i] != NULL) && (m_pClientList[i]->m_iGuildRank == 0) 
		&& (m_pClientList[i]->m_iCrusadeDuty == 3) 
		&& (m_pClientList[i]->m_iGuildGUID == m_pClientList[iClientH]->m_iGuildGUID)) 
	{	SendNotifyMsg(NULL, i, DEF_NOTIFY_HELP, m_pClientList[iClientH]->m_sX, m_pClientList[iClientH]->m_sY, m_pClientList[iClientH]->m_iHP, m_pClientList[iClientH]->m_cCharName);
		return;
	}
	SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_HELPFAILED, NULL, NULL, NULL, NULL);
}


BOOL CGame::bStockMsgToGateServer(char *pData, DWORD dwSize)
{
 char * cp;

	//testcode
	//wsprintf(G_cTxt, "StockMsg(%d) Size(%d)", *pData, dwSize);
	//PutLogList(G_cTxt);

	if ((m_iIndexGSS + dwSize) >= DEF_MAXGATESERVERSTOCKMSGSIZE-10) return FALSE;

	cp = (char *)(m_cGateServerStockMsg + m_iIndexGSS);	
	memcpy(cp, pData, dwSize);

	m_iIndexGSS += dwSize;

	return TRUE;
}

void CGame::SendStockMsgToGateServer()
{
 DWORD * dwp;
 WORD * wp;
 char * cp;
	if (m_iIndexGSS > 6) {
		//testcode
		//wsprintf(G_cTxt, "(!) Sending Gate Server Stock Msg(%d)", m_iIndexGSS);
		//PutLogList(G_cTxt);
		SendMsgToGateServer(MSGID_SERVERSTOCKMSG, NULL, m_cGateServerStockMsg);
		ZeroMemory(m_cGateServerStockMsg, sizeof(m_cGateServerStockMsg));
		cp = (char *)m_cGateServerStockMsg;
		dwp = (DWORD *)cp;
		*dwp = MSGID_SERVERSTOCKMSG;
		cp += 4;
		wp = (WORD *)cp;
		*wp = DEF_MSGTYPE_CONFIRM;
		cp += 2;
		m_iIndexGSS = 6;
	}
}

void CGame::ServerStockMsgHandler(char *pData)
{
 char * cp, * cp2, cTemp[120], cLocation[10], cGuildName[20], cName[11], cTemp2[120], cTemp3[120], cMapName[11], cBuffer[256]; short * sp;
 WORD * wp, wServerID, wClientH, wV1, wV2, wV3, wV4, wV5;
 DWORD * dwp;
 BOOL bFlag = FALSE;
 int * ip, i, iTotal, iV1, iV2, iV3 , iV4, iRet;
 short sX, sY;

	iTotal = 0;
	cp = (char *)(pData + 6);
	while (bFlag == FALSE) {
		iTotal++;
		switch (*cp) {
		
		case GSM_REQUEST_SUMMONGUILD:
			cp++;
			ZeroMemory(cGuildName, sizeof(cGuildName));
			memcpy(cGuildName, cp, 20);
			cp += 20;
			ZeroMemory(cTemp, sizeof(cMapName));
			memcpy(cMapName, cp, 10);
			cp += 10;
			cp2 = (char *) cTemp + 10;
			wp = (WORD *)cp;
			wV1 = *wp;
			cp += 2;
			wp = (WORD *)cp;
			wV2 = *wp;
			cp += 2;
			for (i = 0; i < DEF_MAXCLIENTS; i++)
			if ((m_pClientList[i] != NULL) && (strcmp(m_pClientList[i]->m_cGuildName, cGuildName) == 0)) 
			{	wsprintf(G_cTxt,"PC(%s) summoned by Guild(%s) to %s.", m_pClientList[i]->m_cCharName, cGuildName, cMapName);
				PutLogList(G_cTxt);
				RequestTeleportHandler(i, "2   ", cMapName, wV1, wV2);
			}
			break;

		case GSM_REQUEST_SUMMONPLAYER:
			cp++;
			ZeroMemory(cName, sizeof(cName));
			memcpy(cName, cp, 10);
			cp += 10;
			ZeroMemory(cTemp, sizeof(cTemp));
			memcpy(cTemp, cp, 10);
			cp += 10;
			cp2 = (char *) cTemp + 10 ;			
			wp = (WORD *)cp;
			wV1 = *wp;
			cp += 2;
			wp = (WORD *)cp;
			wV2 = *wp;
			cp += 2;			
			for (i = 1; i < DEF_MAXCLIENTS; i++)
				if ((m_pClientList[i] != NULL) && (strcmp(m_pClientList[i]->m_cCharName, cName) == 0)) 
				{	wsprintf(G_cTxt, "GM Order(----------): /summonplayer (%s), cName");
					bSendMsgToLS(MSGID_GAMEMASTERLOG, -1, FALSE, G_cTxt);					
					RequestTeleportHandler(i, "2   ", cTemp ,wV1, wV2);
					break;
				}
			break;
		
		case GSM_REQUEST_SUMMONALL:
			cp++;
			ZeroMemory(cLocation, sizeof(cLocation));
			memcpy(cLocation, cp, 10);
			cp += 10;
			ZeroMemory(cTemp, sizeof(cTemp));
			memcpy(cTemp, cp, 10);
			cp += 10;
			cp2 = (char *) cTemp + 10;			
			wp = (WORD *)cp;
			wV1 = *wp;
			cp += 2;
			wp = (WORD *)cp;
			wV2 = *wp;
			cp += 2;			
			for (i = 0; i < DEF_MAXCLIENTS; i++)
			if ((m_pClientList[i] != NULL) && (strcmp(m_pClientList[i]->m_cLocation, cLocation) == 0)) 
			{	wsprintf(G_cTxt,"PC(%s) summoned by Admin to %s.", m_pClientList[i]->m_cCharName, cMapName);
				PutLogList(G_cTxt);
				RequestTeleportHandler(i, "2   ", cTemp, wV1, wV2);
			}
		break;

		case GSM_CHATMSG:
			cp++;
			ZeroMemory(cTemp, sizeof(cTemp));
			ZeroMemory(cName, sizeof(cName));
			iV1 = *cp;
			cp++;
			ip = (int *)cp;
			iV2 = *ip;
			cp += 4;
			memcpy(cName, cp, 10);
			cp += 10;;
			sp = (short *)cp;
			wV1 = (WORD)*sp;
			cp += 2;
			ChatMsgHandlerGSM(iV1, iV2, cName, cp, wV1);
			cp += wV1;
			break;
		
		case GSM_CONSTRUCTIONPOINT:
			cp++;
			ip = (int *)cp;
			iV1 = *ip;
			cp += 4;
			ip = (int *)cp;
			iV2 = *ip;
			cp += 4;
			GSM_ConstructionPoint(iV1, iV2);
			break;

		case GSM_SETGUILDTELEPORTLOC:
			cp++;
			ip = (int *)cp;
			iV1 = *ip;
			cp += 4;
			ip = (int *)cp;
			iV2 = *ip;
			cp += 4;
			ip = (int *)cp;
			iV3 = *ip;
			cp += 4;
			ZeroMemory(cTemp, sizeof(cTemp));
			memcpy(cTemp, cp, 10);
			cp += 10;
			GSM_SetGuildTeleportLoc(iV1, iV2, iV3, cTemp);
			break;

		case GSM_SETGUILDCONSTRUCTLOC:
			cp++;
			ip = (int *)cp;
			iV1 = *ip;
			cp += 4;
			ip = (int *)cp;
			iV2 = *ip;
			cp += 4;
			ip = (int *)cp;
			iV3 = *ip;
			cp += 4;
			ZeroMemory(cTemp, sizeof(cTemp));
			memcpy(cTemp, cp, 10);
			cp += 10;
			GSM_SetGuildConstructLoc(iV1, iV2, iV3, cTemp);
			break;

		case GSM_REQUEST_SETFORCERECALLTIME:
			cp++;
			wp = (WORD *)cp;
			m_sForceRecallTime = *wp;
			cp += 2;
			wsprintf(G_cTxt,"(!) Game Server Force Recall Time (%d)min",m_sForceRecallTime) ;
			PutLogList(G_cTxt) ;
			break;

		case GSM_MIDDLEMAPSTATUS:
			cp++;
			for (i = 0; i < DEF_MAXCRUSADESTRUCTURES; i++) 
			{	m_stMiddleCrusadeStructureInfo[i].cType = NULL;
				m_stMiddleCrusadeStructureInfo[i].cSide = NULL;
				m_stMiddleCrusadeStructureInfo[i].sX    = NULL;
				m_stMiddleCrusadeStructureInfo[i].sY    = NULL;
			}
			sp = (short *)cp;
			m_iTotalMiddleCrusadeStructures = *sp;
			cp += 2;
			for (i = 0; i < m_iTotalMiddleCrusadeStructures; i++) 
			{	m_stMiddleCrusadeStructureInfo[i].cType = *cp;
				cp++;
				m_stMiddleCrusadeStructureInfo[i].cSide = *cp;
				cp++;
				sp = (short *)cp;
				m_stMiddleCrusadeStructureInfo[i].sX = *sp;
				cp += 2;
				sp = (short *)cp;
				m_stMiddleCrusadeStructureInfo[i].sY = *sp;
				cp += 2;	
			}
			if (m_bEverybodyAdvised == FALSE)
			{	for (i = 1; i < DEF_MAXCLIENTS; i++)
				{	if (   (m_pClientList[i] != NULL) && (m_pClientList[i]->m_bIsInitComplete == TRUE))
					{	MapStatusHandler(i, 3, "middleland");
				}	}
				m_bEverybodyAdvised = TRUE;
			}
			break;
		
		case GSM_BEGINCRUSADE:
			cp++;
			dwp = (DWORD *)cp;
			cp += 4;
			LocalStartCrusadeMode(*dwp);
			break;

		case GSM_BEGINAPOCALYPSE:
			cp++;
			dwp = (DWORD *)cp;
			cp += 4;
			LocalStartApocalypse(*dwp);
			break;

		case GSM_STARTHELDENIAN:
			cp++;
			wp  = (WORD *)cp;
			wV1 = *wp;
			cp += 2;
			wp  = (WORD *)cp;
			wV2 = *wp;
			cp += 2;
			dwp = (DWORD *)cp;
			cp += 4;
			LocalStartHeldenianMode(wV1, wV2, *dwp);
			break;

		case GSM_ENDHELDENIAN:
			cp++;
			dwp = (DWORD *)cp;
			cp += 4;
			ip = (int *)cp;
			iV1 = *ip;
			cp += 4;
			LocalEndHeldenianMode(*dwp ,iV1);
			break;

		case GSM_UPDATECONFIGS:
			cp++;
			LocalUpdateConfigs(*cp);
			cp += 16;
			break;

		case GSM_ENDAPOCALYPSE:
			cp++;
			LocalEndApocalypse();
			break;

		case GSM_ENDCRUSADE:
			cp++;
			LocalEndCrusadeMode(*cp);
			cp += 16;
			break;

		case GSM_COLLECTEDMANA:
			cp++;
			wp  = (WORD *)cp;
			wV1 = *wp;
			cp += 2;

			wp  = (WORD *)cp;
			wV2 = *wp;
			cp += 2;
			CollectedManaHandler(wV1, wV2);
			break;

		case GSM_GRANDMAGICLAUNCH:
			cp++;
			wp  = (WORD *)cp;
			wV1 = *wp;
			cp += 2;
			wp  = (WORD *)cp;
			wV2 = *wp;
			cp += 2;
			switch (wV1) {
			case 1: 
				MeteorStrikeMsgHandler((char)wV2);
				break;
			}
			break;
		
		case  GSM_GRANDMAGICRESULT:
			cp++;
			ZeroMemory(cTemp, sizeof(cTemp));
			memcpy(cTemp, cp, 10);
			cp += 10;
			wp  = (WORD *)cp;
			wV1 = *wp;
			cp += 2;
			wp  = (WORD *)cp;
			wV2 = *wp;
			cp += 2;
			wp  = (WORD *)cp;
			wV3 = *wp;
			cp += 2;
			wp  = (WORD *)cp;
			wV4 = *wp;
			cp += 2;
			wp  = (WORD *)cp;
			wV5 = *wp;
			GrandMagicResultHandler(cTemp, wV1, wV2, wV3, wV4, wV5, cp);
			break;
		
			// v2.15 2002-5-21
		case GSM_REQUEST_SHUTUPPLAYER:
			cp++;
			wp = (WORD *)cp;
			wServerID = *wp;
			cp += 2;
			wp = (WORD *)cp;
			wClientH = *wp;
			cp += 2;
			ZeroMemory(cName, sizeof(cName));
			memcpy(cName, cp, 10);
			cp += 10;
			wp  = (WORD *)cp;
			wV1 = *wp;
			cp += 2;
			ZeroMemory(cTemp, sizeof(cTemp));
			memcpy(cTemp, cp, 10);
			cp += 10;
			GSM_RequestShutupPlayer(cTemp,wServerID,wClientH, wV1, cName);
			break ;

		case GSM_RESPONSE_SHUTUPPLAYER:
			cp++;
			wp = (WORD *)cp;
			wServerID = *wp;
			cp += 2;
			wp = (WORD *)cp;
			wClientH = *wp;
			cp += 2;
			ZeroMemory(cName, sizeof(cName));
			memcpy(cName, cp, 10);
			cp += 10;
			wp  = (WORD *)cp;
			wV1 = *wp;
			cp += 2;
			ZeroMemory(cTemp, sizeof(cTemp));
			memcpy(cTemp, cp, 10);
			cp += 10;
			if (wServerID == m_wServerID_GSS) 
			{	if (   (m_pClientList[wClientH] != NULL) 
					&& (strcmp(m_pClientList[wClientH]->m_cCharName, cName) == 0)
					&& (m_pClientList[wClientH]->m_iAdminUserLevel > 0)) 
				{	SendNotifyMsg(NULL, wClientH, DEF_NOTIFY_PLAYERSHUTUP, wV1*60, NULL, NULL, cTemp);
				}
			}
			break;

		// New 16/05/2004
		case GSM_WHISFERMSG:
			ZeroMemory(cName, sizeof(cName));
			ZeroMemory(cBuffer, sizeof(cBuffer));
			cp++;
			memcpy(cName, cp, 10);
			cp += 10;
			wp = (WORD *)cp;
			wV1 = *wp;
			cp += 2;
			memcpy(cBuffer, cp, wV1);
			cp += wV1;
			for (i = 1; i < DEF_MAXCLIENTS; i++)
				if ((m_pClientList[i] != NULL) && (strcmp(m_pClientList[i]->m_cCharName, cName) == 0)) {
					iRet = m_pClientList[i]->m_pXSock->iSendMsg(cBuffer, wV1);
					if(	m_pClientList[i]->m_iAdminUserLevel > 0) {
						char cTxt[200],cTmpName[12] ;
						ZeroMemory(cTxt,sizeof(cTxt)) ;
						ZeroMemory(cTmpName,sizeof(cTmpName)) ;

						memcpy(cTmpName,cBuffer+10,10) ;
						wsprintf(cTxt,"PC Chat(%s):\"%s\"\tto GM(%s)",cTmpName,cBuffer+21,m_pClientList[i]->m_cCharName) ;
						bSendMsgToLS(MSGID_GAMEMASTERLOG, i, NULL, cTxt);
					}
					break;
				}
		break;

		// New 16/05/2004 Changed
		case GSM_REQUEST_FINDCHARACTER:
			cp++;
			wp = (WORD *)cp;
			wServerID = *wp;
			cp += 2;
			wp = (WORD *)cp;
			wClientH = *wp;
			cp += 2;
			ZeroMemory(cTemp, sizeof(cTemp)); 
			memcpy(cTemp, cp, 10);
			cp += 10;
			ZeroMemory(cTemp2, sizeof(cTemp2));
			memcpy(cTemp2, cp, 10);
			cp += 10;
			GSM_RequestFindCharacter(wServerID, wClientH, cTemp, cTemp2);
			break;

		case GSM_RESPONSE_FINDCHARACTER:
			sX = -1;
			sY = -1;
			cp++;
			wp = (WORD *)cp;
			wServerID = *wp;
			cp += 2;
			wp = (WORD *)cp;
			wClientH = *wp;
			cp += 2;
			ZeroMemory(cTemp, sizeof(cTemp)); // Name of searched character
			memcpy(cTemp, cp, 10);
			cp += 10;
			ZeroMemory(cTemp2, sizeof(cTemp2)); // Name of finder 
			memcpy(cTemp2, cp, 10);
			cp += 10;
			ZeroMemory(cTemp3, sizeof(cTemp3)); // Name of Map + coords
			memcpy(cTemp3, cp, 14);

			if ((wServerID == m_wServerID_GSS) && m_pClientList[wClientH] != NULL) 
			{	if (m_pClientList[wClientH]->m_bIsAdminOrderGoto == TRUE)  // GM command /goto
				{	m_pClientList[wClientH]->m_bIsAdminOrderGoto = FALSE;
					ZeroMemory(cMapName, sizeof(cMapName));
					memcpy(cMapName, cp, 10);
					cp += 10;
					wp = (WORD *)cp;
					sX = *wp;
					cp += 2;
					wp = (WORD *)cp;
					sY = *wp;
					cp += 2;
					if (   (m_pClientList[wClientH]->m_iAdminUserLevel > 0) 
						&& (strcmp(" ~gserver~", cTemp) != 0)) // Snoopy: Exclude an answer to /getactivegservers
					{	if(sX == -1 && sY == -1)
						{	wsprintf(G_cTxt,"GM Order(%-10s): /goto MapName(%s)"
								, m_pClientList[wClientH]->m_cCharName, cMapName);	
						}else
						{	wsprintf(G_cTxt,"GM Order(%-10s): /goto MapName(%s)(%d %d)"
								, m_pClientList[wClientH]->m_cCharName, cMapName, sX, sY);
						}
						bSendMsgToLS(MSGID_GAMEMASTERLOG, wClientH, FALSE, G_cTxt);
						RequestTeleportHandler(wClientH,"2   ", cMapName, sX, sY);
					}
				}else // Whisps
				{	if ((m_pClientList[wClientH]->m_bIsCheckingWhisperPlayer == TRUE) && (strcmp(m_pClientList[wClientH]->m_cWhisperPlayerName, cTemp) == 0)) 
					{	m_pClientList[wClientH]->m_iWhisperPlayerIndex = 10000;
						SendNotifyMsg(NULL, wClientH, DEF_NOTIFY_WHISPERMODEON, NULL, NULL, NULL, m_pClientList[wClientH]->m_cWhisperPlayerName);
					}else // / Command /fi
					{	if (m_pClientList[wClientH]->m_iAdminUserLevel < m_iAdminLevelGoto) 
						{	ZeroMemory(cTemp3, sizeof(cTemp3));
						}
						if (strcmp(" ~gserver~", cTemp) == 0) // Code
						{	ZeroMemory(cMapName, sizeof(cMapName)); // Is really the server's name
							memcpy(cMapName, cp, 10); // Server's name 
							cp += 10;
							wp = (WORD *)cp;
							sX = *wp;
							cp += 2;
							wp = (WORD *)cp;
							sY = *wp;
							cp += 2;
							wsprintf(G_cTxt, "The server %s is running. Players(%d/%d)."
								, cMapName
								, sX
								, sY);	
							if (   (m_pClientList[wClientH]->m_iAdminUserLevel < m_iAdminLevelGoto)
								|| (m_pClientList[wClientH]->m_iAdminUserLevel == 0))// not a GM
									wsprintf(G_cTxt, "The server %s is running.", cMapName);
							SendNotifyMsg(NULL, wClientH, DEF_NOTIFY_IPACCOUNTINFO, NULL, NULL, NULL, G_cTxt);
						}else // Normal /fi command
						{	SendNotifyMsg(NULL, wClientH, DEF_NOTIFY_PLAYERONGAME, NULL, NULL, NULL, cTemp,
								NULL, NULL, NULL, NULL, NULL, NULL, cTemp3);
							if (m_pClientList[wClientH]->m_iAdminUserLevel < m_iAdminLevelGoto) // log for admins
							{	wsprintf(G_cTxt, "GM Order(%-10s): /fi %s", cTemp2, cTemp);
								bSendMsgToLS(MSGID_GAMEMASTERLOG, wClientH, FALSE, G_cTxt);
			}	}	}	}	}
			break;	

		// Avatar	
		case GSM_BEGINAVATAR:
			cp++;
			dwp = (DWORD *)cp;
			cp += 4;
			LocalStartAvatarMode(*dwp);
			break;
		
		// Avatar
		case GSM_ENDAVATAR:
			cp++;
			ip = (int *)cp;
			iV1 = *ip;	// Winner side
			cp += 4;			
			ZeroMemory(cTemp, sizeof(cTemp)); // Name of Messenger
			memcpy(cTemp, cp, 10);
			cp += 10;
			LocalEndAvatarMode(iV1, cp);
			break;

		// Avatar
		case GSM_INFOAVATAR:
			cp++;
			ip = (int *)cp;
			iV1 = *ip;	
			cp += 4;	
			iV2 = *ip;	
			cp += 4;	
			iV3 = *ip;	
			cp += 4;			
			ZeroMemory(cTemp, sizeof(cTemp)); // Name of Messenger
			memcpy(cTemp, cp, 10);
			cp += 10;	
			iV4 = *ip;	
			cp += 4;
			GetGlobalAvatarInfo(iV1, iV2, iV3, cTemp, iV4);
			break;

		default:
			bFlag = TRUE;
			break;	
	}	}
	//wsprintf(G_cTxt, "(!) Total %d GSM Messages.", iTotal-1);
	//PutLogList(G_cTxt);
}

void CGame::GSM_RequestFindCharacter(WORD wReqServerID, WORD wReqClientH, char *pName, char * pFinder)
{char * cp, cTemp[120];
 WORD * wp;
 register int i;

	for (i = 1; i < DEF_MAXCLIENTS; i++)
	if ((m_pClientList[i] != NULL)  && (strcmp(m_pClientList[i]->m_cCharName, pName) == 0)) {
		ZeroMemory(cTemp, sizeof(cTemp));
		cp = (char *)(cTemp);
		*cp = GSM_RESPONSE_FINDCHARACTER;
		cp++;
		wp = (WORD *)cp;
		*wp = wReqServerID;
		cp += 2;
		wp = (WORD *)cp;
		*wp = wReqClientH;
		cp += 2;
		memcpy(cp, pName, 10);
		cp += 10;
		memcpy(cp, pFinder, 10);
		cp += 10;
		memcpy(cp, m_pClientList[i]->m_cMapName, 10);
		cp += 10;
		wp = (WORD *)cp;
		*wp = m_pClientList[i]->m_sX;
		cp += 2;
		wp = (WORD *)cp;
		*wp = m_pClientList[i]->m_sY;
		cp += 2;
		bStockMsgToGateServer(cTemp, 39);
		return;	
	}
	// Snoopy: Added to repond if serveur is up
	if (strlen(pName) == 0) {
		ZeroMemory(cTemp, sizeof(cTemp));
		cp = (char *)(cTemp);
		*cp = GSM_RESPONSE_FINDCHARACTER;
		cp++;
		wp = (WORD *)cp;
		*wp = wReqServerID;
		cp += 2;
		wp = (WORD *)cp;
		*wp = wReqClientH;
		cp += 2;		
		strcpy(cp, " ~gserver~"); // Code instead of searched character name
		cp += 10;
		memcpy(cp, pFinder, 10);
		cp += 10;
		strcpy(cp, m_cServerName); // Name of server
		cp += 10;
		wp = (WORD *)cp;
		*wp = m_iTotalClients;
		cp += 2;
		wp = (WORD *)cp;
		*wp = m_iMaxClients;
		cp += 2;
		bStockMsgToGateServer(cTemp, 39);
		return;	
	}
}

// New 11/05/2004 Changed
void CGame::DoMeteorStrikeDamageHandler(int iMapIndex)
{
 int i, iDamage;
 DWORD dwTime = timeGetTime();

	for (i = 1; i < DEF_MAXCLIENTS; i++)
	if ((m_pClientList[i] != NULL) && (m_pClientList[i]->m_cSide != 0) && (m_pClientList[i]->m_cMapIndex == iMapIndex)) 
	{	/* // Useless, removed !
		if (m_pClientList[i]->m_iLevel < 80) 
			 iDamage = m_pClientList[i]->m_iLevel   +iDice(1,10);
		else iDamage = m_pClientList[i]->m_iLevel*2 +iDice(1,10);*/		
		iDamage = iDice(1, m_pClientList[i]->m_iLevel) + m_pClientList[i]->m_iLevel;
		if (iDamage > 255) iDamage = 255;	
		if (m_pClientList[i]->m_cMagicEffectStatus[ DEF_MAGICTYPE_PROTECT ] == 2)  //magic cut in half
		{	iDamage = (iDamage/2) - 2;
		}
		if (m_pClientList[i]->m_cMagicEffectStatus[ DEF_MAGICTYPE_PROTECT ] == 5)  
		{	iDamage = 0;
		}		
		if (m_pClientList[i]->m_iAdminUserLevel > 0)  // Admins get no damage
		{	iDamage = 0;
		}
		if (m_pClientList[i]->m_bAntiTPLameEK == TRUE)  iDamage = 0;
		m_pClientList[i]->m_iHP -= iDamage;
		if (m_pClientList[i]->m_iHP <= 0) 
		{	ClientKilledHandler(i, NULL, NULL, iDamage);	
			m_stMeteorStrikeResult.iCasualties++;
		}else 
		{	if (iDamage > 0) 
			{	m_pClientList[i]->m_dwLastDamageTime = dwTime;
				SendNotifyMsg(NULL, i, DEF_NOTIFY_HP, NULL, NULL, NULL, NULL);
				SendEventToNearClient_TypeA(i, DEF_OWNERTYPE_PLAYER, MSGID_EVENT_MOTION, DEF_OBJECTDAMAGE, iDamage, NULL, NULL);
				if (m_pClientList[i]->m_bSkillUsingStatus[19] != TRUE) 
				{	m_pMapList[m_pClientList[i]->m_cMapIndex]->ClearOwner(0, i, DEF_OWNERTYPE_PLAYER, m_pClientList[i]->m_sX, m_pClientList[i]->m_sY);
					m_pMapList[m_pClientList[i]->m_cMapIndex]->SetOwner(i, DEF_OWNERTYPE_PLAYER, m_pClientList[i]->m_sX, m_pClientList[i]->m_sY);
				}			
				if (m_pClientList[i]->m_cMagicEffectStatus[ DEF_MAGICTYPE_HOLDOBJECT ] != 0) // 100% unPara
				{	SendNotifyMsg(NULL, i, DEF_NOTIFY_MAGICEFFECTOFF, DEF_MAGICTYPE_HOLDOBJECT, m_pClientList[i]->m_cMagicEffectStatus[ DEF_MAGICTYPE_HOLDOBJECT ], NULL, NULL);
					m_pClientList[i]->m_cMagicEffectStatus[ DEF_MAGICTYPE_HOLDOBJECT ] = NULL;
					bRemoveFromDelayEventList(i, DEF_OWNERTYPE_PLAYER, DEF_MAGICTYPE_HOLDOBJECT);
	}	}	}	}
}
// Sends Manastones and bases to all servers, to be able to distrribute the info to clients...
void CGame::SyncMiddlelandMapInfo()
{int i;
 char * cp;
 short * sp;
	if (m_iMiddlelandMapIndex != -1) 
	{	for (i = 0; i < DEF_MAXCRUSADESTRUCTURES; i++) 
		{	m_stMiddleCrusadeStructureInfo[i].cType = NULL;
			m_stMiddleCrusadeStructureInfo[i].cSide = NULL;
			m_stMiddleCrusadeStructureInfo[i].sX    = NULL;
			m_stMiddleCrusadeStructureInfo[i].sY    = NULL;
		}
		m_iTotalMiddleCrusadeStructures = m_pMapList[m_iMiddlelandMapIndex]->m_iTotalCrusadeStructures;
		if (m_iTotalMiddleCrusadeStructures == 0) return;				
		ZeroMemory(G_cData50000, sizeof(G_cData50000));
		cp = (char *)G_cData50000;
		*cp = GSM_MIDDLEMAPSTATUS;
		cp++;
		sp = (short *)cp;
		*sp = (short)m_iTotalMiddleCrusadeStructures;
		cp += 2;				
		for (i = 0; i < m_iTotalMiddleCrusadeStructures; i++) 
		{	m_stMiddleCrusadeStructureInfo[i].cType = m_pMapList[m_iMiddlelandMapIndex]->m_stCrusadeStructureInfo[i].cType;
			m_stMiddleCrusadeStructureInfo[i].cSide = m_pMapList[m_iMiddlelandMapIndex]->m_stCrusadeStructureInfo[i].cSide;
			m_stMiddleCrusadeStructureInfo[i].sX    = m_pMapList[m_iMiddlelandMapIndex]->m_stCrusadeStructureInfo[i].sX;
			m_stMiddleCrusadeStructureInfo[i].sY    = m_pMapList[m_iMiddlelandMapIndex]->m_stCrusadeStructureInfo[i].sY;			
			*cp = m_stMiddleCrusadeStructureInfo[i].cType;
			cp++;
			*cp = m_stMiddleCrusadeStructureInfo[i].cSide;
			cp++;
			sp = (short *)cp;
			*sp = (short)m_stMiddleCrusadeStructureInfo[i].sX;
			cp += 2;
			sp = (short *)cp;
			*sp = (short)m_stMiddleCrusadeStructureInfo[i].sY;
			cp += 2;
		}		
		if (m_iTotalMiddleCrusadeStructures != 0) 
		{	bStockMsgToGateServer(G_cData50000, 3 + m_iTotalMiddleCrusadeStructures*6);
		}
	}
}

void CGame::GSM_SetGuildConstructLoc(int iGuildGUID, int dX, int dY, char * pMapName)
{int i, iIndex;
 DWORD dwTemp, dwTime;
	dwTime = timeGetTime();
	for (i = 0; i < DEF_MAXGUILDS; i++)
	if (m_pGuildTeleportLoc[i].m_iV1 == iGuildGUID) // changes location
	{	if ((m_pGuildTeleportLoc[i].m_sDestX2 == dX) && (m_pGuildTeleportLoc[i].m_sDestY2 == dY) && (strcmp(m_pGuildTeleportLoc[i].m_cDestMapName2, pMapName) == 0)) {
			m_pGuildTeleportLoc[i].m_dwTime2 = dwTime;
			return;
		}else 
		{	m_pGuildTeleportLoc[i].m_sDestX2 = dX;
			m_pGuildTeleportLoc[i].m_sDestY2 = dY;
			ZeroMemory(m_pGuildTeleportLoc[i].m_cDestMapName2, sizeof(m_pGuildTeleportLoc[i].m_cDestMapName2));
			strcpy(m_pGuildTeleportLoc[i].m_cDestMapName2, pMapName);
			m_pGuildTeleportLoc[i].m_dwTime2 = dwTime;
			wsprintf(G_cTxt, "Construction changed       : %d - %s (%d/%d)"
				, iGuildGUID
				, m_pGuildTeleportLoc[i].m_cDestMapName2
				, dX
				, dY);
			PutLogEventFileList(G_cTxt);
			PutLogList(G_cTxt);
			return;
		}
	}	
	dwTemp = 0;
	iIndex = -1;
	for (i = 0; i < DEF_MAXGUILDS; i++) 
	{	if (m_pGuildTeleportLoc[i].m_iV1 == NULL) // set 1st location
		{	m_pGuildTeleportLoc[i].m_iV1 = iGuildGUID;
			m_pGuildTeleportLoc[i].m_sDestX2 = dX;
			m_pGuildTeleportLoc[i].m_sDestY2 = dY;
			ZeroMemory(m_pGuildTeleportLoc[i].m_cDestMapName2, sizeof(m_pGuildTeleportLoc[i].m_cDestMapName));
			strcpy(m_pGuildTeleportLoc[i].m_cDestMapName2, pMapName);
			m_pGuildTeleportLoc[i].m_dwTime2 = dwTime;
			wsprintf(G_cTxt, "Construction, set          : %d - %s (%d/%d)"
				, iGuildGUID
				, m_pGuildTeleportLoc[i].m_cDestMapName2
				, dX
				, dY);
			PutLogEventFileList(G_cTxt);
			PutLogList(G_cTxt);
			return;
		}else 
		{	if (dwTemp < (dwTime - m_pGuildTeleportLoc[i].m_dwTime2)) {
				dwTemp = (dwTime - m_pGuildTeleportLoc[i].m_dwTime2);
				iIndex = i;
			}
		}
	}
	if (iIndex == -1) return;
	m_pGuildTeleportLoc[i].m_iV1 = iGuildGUID;
	m_pGuildTeleportLoc[i].m_sDestX2 = dX;
	m_pGuildTeleportLoc[i].m_sDestY2 = dY;
	ZeroMemory(m_pGuildTeleportLoc[i].m_cDestMapName2, sizeof(m_pGuildTeleportLoc[i].m_cDestMapName2));
	strcpy(m_pGuildTeleportLoc[i].m_cDestMapName2, pMapName);
	m_pGuildTeleportLoc[i].m_dwTime2 = dwTime;		
	wsprintf(G_cTxt, "Construction, borrowed     : %d - %s (%d/%d)"
		, iGuildGUID
		, m_pGuildTeleportLoc[i].m_cDestMapName2
		, dX
		, dY);
	PutLogEventFileList(G_cTxt);
	PutLogList(G_cTxt);
}

void CGame::CheckCommanderConstructionPoint(int iClientH)
{char * cp, cData[120];
 int  * ip; 
 register int i;
	if (m_pClientList[iClientH] == NULL) return;
	if (m_bIsCrusadeMode == FALSE) return;
	if (m_pClientList[iClientH]->m_iConstructionPoint <= 0) return;

	switch (m_pClientList[iClientH]->m_iCrusadeDuty) {
	case 1: // 
	case 2: // 
		for (i = 0; i < DEF_MAXCLIENTS; i++)
		if (   (m_pClientList[i] != NULL) && (m_pClientList[i]->m_iCrusadeDuty == 3) 
			&& (m_pClientList[i]->m_iGuildGUID == m_pClientList[iClientH]->m_iGuildGUID)) 
		{	m_pClientList[i]->m_iConstructionPoint += m_pClientList[iClientH]->m_iConstructionPoint;
			m_pClientList[i]->m_iWarContribution   += (m_pClientList[iClientH]->m_iConstructionPoint / 10);
			if (m_pClientList[i]->m_iConstructionPoint > DEF_MAXCONSTRUCTIONPOINT) 
				m_pClientList[i]->m_iConstructionPoint = DEF_MAXCONSTRUCTIONPOINT;		
			if (m_pClientList[i]->m_iWarContribution > DEF_MAXWARCONTRIBUTION)
				m_pClientList[i]->m_iWarContribution = DEF_MAXWARCONTRIBUTION;
			if (m_pClientList[i]->m_iWarContribution >= 256*128)
				SendNotifyMsg(NULL, i, DEF_NOTIFY_CONSTRUCTIONPOINT, m_pClientList[i]->m_iConstructionPoint, (m_pClientList[i]->m_iWarContribution %(256*128)), 1, NULL);

			SendNotifyMsg(NULL, i, DEF_NOTIFY_CONSTRUCTIONPOINT, m_pClientList[i]->m_iConstructionPoint, m_pClientList[i]->m_iWarContribution, 0, NULL);
			m_pClientList[iClientH]->m_iConstructionPoint = 0; 
			SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_CONSTRUCTIONPOINT, 0, m_pClientList[iClientH]->m_iWarContribution, 1, NULL);
			return;
		}
		ZeroMemory(cData, sizeof(cData));
		cp = (char *)cData;
		*cp = GSM_CONSTRUCTIONPOINT;
		cp++;
		ip = (int*)cp;
		*ip = m_pClientList[iClientH]->m_iGuildGUID;
		cp += 4;
		ip = (int*)cp;
		*ip = m_pClientList[iClientH]->m_iConstructionPoint;
		cp += 4;
		bStockMsgToGateServer(cData, 9);
		m_pClientList[iClientH]->m_iConstructionPoint = 0; 
		SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_CONSTRUCTIONPOINT, 0, m_pClientList[iClientH]->m_iWarContribution, 1, NULL);
		break;

	case 3: // Commander		
		break;
	}
}

void CGame::GSM_ConstructionPoint(int iGuildGUID, int iPoint)
{ int i;
	for (i = 1; i < DEF_MAXCLIENTS; i++)
	if (   (m_pClientList[i] != NULL) && (m_pClientList[i]->m_iCrusadeDuty == 3) 
		&& (m_pClientList[i]->m_iGuildGUID == iGuildGUID)) 
	{	m_pClientList[i]->m_iConstructionPoint += iPoint;
		m_pClientList[i]->m_iWarContribution   += iPoint/10;		
		if (m_pClientList[i]->m_iConstructionPoint > DEF_MAXCONSTRUCTIONPOINT) 
			m_pClientList[i]->m_iConstructionPoint = DEF_MAXCONSTRUCTIONPOINT;		
		if (m_pClientList[i]->m_iWarContribution > DEF_MAXWARCONTRIBUTION)
			m_pClientList[i]->m_iWarContribution = DEF_MAXWARCONTRIBUTION;				
		if (m_pClientList[i]->m_iWarContribution >= 256*128)
			SendNotifyMsg(NULL, i, DEF_NOTIFY_CONSTRUCTIONPOINT, m_pClientList[i]->m_iConstructionPoint, (m_pClientList[i]->m_iWarContribution %(256*128)), 1, NULL);

		SendNotifyMsg(NULL, i, DEF_NOTIFY_CONSTRUCTIONPOINT, m_pClientList[i]->m_iConstructionPoint, m_pClientList[i]->m_iWarContribution, NULL, NULL);
		wsprintf(G_cTxt, "WarSummon pts by Npc/remote : %d - WarSummon +%d(%d)"
			, iGuildGUID
			, iPoint
			, m_pClientList[i]->m_iConstructionPoint);
		PutLogList(G_cTxt);
		PutLogEventFileList(G_cTxt);
		return;
	}
}

BOOL CGame::bAddClientShortCut(int iClientH)
{ int i; 
	for (i = 0; i < DEF_MAXCLIENTS; i++)
	if (m_iClientShortCut[i] == iClientH) return FALSE;
	for (i = 0; i < DEF_MAXCLIENTS; i++)
	if (m_iClientShortCut[i] == 0) 
	{	m_iClientShortCut[i] = iClientH;
		return TRUE;
	}
	return FALSE;
}

void CGame::RemoveClientShortCut(int iClientH)
{	int i;
	for (i = 0; i < DEF_MAXCLIENTS+1; i++)
	if (m_iClientShortCut[i] == iClientH) 
	{	m_iClientShortCut[i] = 0;
		goto RCSC_LOOPBREAK;
	}
RCSC_LOOPBREAK:;
	//m_iClientShortCut[i] = m_iClientShortCut[m_iTotalClients+1];
	//m_iClientShortCut[m_iTotalClients+1] = 0;
	for (i = 0; i < DEF_MAXCLIENTS; i++)
	if ((m_iClientShortCut[i] == 0) && (m_iClientShortCut[i+1] != 0)) 
	{	m_iClientShortCut[i] = m_iClientShortCut[i+1];
		m_iClientShortCut[i+1] = 0;
	}
}

void CGame::_CreateCrusadeGUID(DWORD dwCrusadeGUID, int iWinnerSide)
{char * cp, cTxt[256], cFn[256], cTemp[1024];	
 FILE * pFile;		
	_mkdir("GameData");
	ZeroMemory(cFn, sizeof(cFn));	
	strcat(cFn,"GameData");
	strcat(cFn,"\\");
	strcat(cFn,"\\");					  
	strcat(cFn,"CrusadeGUID.Txt");		
	pFile = fopen(cFn, "wt");
	if (pFile == NULL) 
	{	wsprintf(cTxt, "(!) Cannot create CrusadeGUID (%d) file. ", dwCrusadeGUID);
		PutLogList(cTxt);
	}else 
	{	ZeroMemory(cTemp, sizeof(cTemp));		
		ZeroMemory(cTxt, sizeof(cTxt));
		wsprintf(cTxt, "CrusadeGUID = %d\n", dwCrusadeGUID);
		strcat(cTemp, cTxt);
		ZeroMemory(cTxt, sizeof(cTxt));
		wsprintf(cTxt, "winner-side = %d\n", iWinnerSide);
		strcat(cTemp, cTxt);
		// SNOOPY: Support for avantaging crusade looser, next time.
		ZeroMemory(cTxt, sizeof(cTxt));
		if (iWinnerSide == 1) m_iCrusadeAdvantage --;
		else if (iWinnerSide == 2) m_iCrusadeAdvantage ++;
		// Negative value means Aresden won a lot
		if ( m_iCrusadeAdvantage > 5  ) m_iCrusadeAdvantage = 5;
		if ( m_iCrusadeAdvantage < -5 ) m_iCrusadeAdvantage = -5;

		wsprintf(cTxt, "advantage-side = %d\n", m_iCrusadeAdvantage);
		strcat(cTemp, cTxt); // m_iCrusadeAdvantage		
		cp = (char *)cTemp;
		fwrite(cp, strlen(cp), 1, pFile);
		switch (iWinnerSide) {
		case 1:	wsprintf(G_cTxt, "(_) CrusadeGUID (%d) file created - Aresden  victory (%d)", dwCrusadeGUID, m_iCrusadeAdvantage);
			break;
		case 2: wsprintf(G_cTxt, "(_) CrusadeGUID (%d) file created - Elvine victory (%d)", dwCrusadeGUID, m_iCrusadeAdvantage);
			break;		
		default:wsprintf(G_cTxt, "(_) CrusadeGUID (%d) file created - Draw (%d)", dwCrusadeGUID, m_iCrusadeAdvantage);
			break;
		}
		PutLogList(G_cTxt);
		PutLogEventFileList(G_cTxt);
	}
	if (pFile != NULL) fclose(pFile);
}

BOOL CGame::bReadCrusadeGUIDFile(char * cFn)
{FILE * pFile;
 HANDLE hFile;
 DWORD  dwFileSize;
 char * cp, * token, cReadMode;
 char seps[] = "= \t\n";
 class CStrTok * pStrTok;
 char cTxt[256];
	ZeroMemory(cTxt, sizeof(cTxt));
	cReadMode = 0;
	hFile = CreateFile(cFn, GENERIC_READ, NULL, NULL, OPEN_EXISTING, NULL, NULL);
	dwFileSize = GetFileSize(hFile, NULL);
	if (hFile != INVALID_HANDLE_VALUE) CloseHandle(hFile);
	pFile = fopen(cFn, "rt");
	if (pFile == NULL) 
	{	PutLogList("(!) Cannot open CrusadeGUID file.");
		return FALSE;
	}else 
	{	PutLogList("(_) Reading CrusadeGUID file...");
		cp = new char[dwFileSize+2];
		ZeroMemory(cp, dwFileSize+2);
		fread(cp, dwFileSize, 1, pFile);
		pStrTok = new class CStrTok(cp, seps);
		token = pStrTok->pGet();
		while( token != NULL )   			
		{	if (cReadMode != 0) 
			{	switch (cReadMode) {
				case 1:
					m_dwCrusadeGUID = _atoi64(token);
					cReadMode = 0;
					break;
				case 2:	
					m_iLastCrusadeWinner = atoi(token);					
					cReadMode = 0;
					break;
				case 3:
					// SNOOPY: to give some advantage to previous looser
					m_iCrusadeAdvantage = atoi(token);
					if ( m_iCrusadeAdvantage > 5  ) m_iCrusadeAdvantage = 5;
					if ( m_iCrusadeAdvantage < -5 ) m_iCrusadeAdvantage = -5;
					if ( m_iCrusadeAdvantage > 0)
					{	// Negative value means Aresden won a lot
						wsprintf(cTxt, "(_) Elvine advantaged = %d times.", abs(m_iCrusadeAdvantage));
					}else
					{	wsprintf(cTxt, "(_) Aresden advantaged = %d times.", m_iCrusadeAdvantage);
					}
					if (m_iCrusadeAdvantage == 0) wsprintf(G_cTxt, "(_) No crusade side is advantaged!");
					cReadMode = 0;
					break;
				}
			}else 
			{	if (memcmp(token, "CrusadeGUID", 11) == 0)		cReadMode = 1;
				if (memcmp(token, "winner-side", 11) == 0)		cReadMode = 2;
				if (memcmp(token, "advantage-side", 14) == 0)	cReadMode = 3;
			}			
			token = pStrTok->pGet();
		}
		delete pStrTok;
		delete cp;
	}
	if (pFile != NULL) fclose(pFile);
	switch (m_iLastCrusadeWinner) {
	case 1:	wsprintf(G_cTxt, "(_) Read CrusadeGUID (%d) file: Last victory for Aresden (%d).", m_dwCrusadeGUID, m_iCrusadeAdvantage);
		break;
	case 2: wsprintf(G_cTxt, "(_) Read CrusadeGUID (%d) file: Last victory for Elvine (%d).", m_dwCrusadeGUID, m_iCrusadeAdvantage);
		break;		
	default:wsprintf(G_cTxt, "(_) Read CrusadeGUID (%d) file: Last crusade was a draw (%d).", m_dwCrusadeGUID, m_iCrusadeAdvantage);
		break;
	}
	PutLogList(G_cTxt);
	if (sizeof(cTxt)>7) PutLogList(cTxt);
	return TRUE;
}

void CGame::ManualEndCrusadeMode(int iWinnerSide)
{char * cp, cData[256];
 WORD * wp;
	if (m_bIsCrusadeMode == FALSE) return;
	LocalEndCrusadeMode(iWinnerSide);
	ZeroMemory(cData, sizeof(cData));
	cp = (char *)(cData);
	*cp =  GSM_ENDCRUSADE;
	cp++;
	*cp = (char)iWinnerSide;
	cp++;
	wp  = (WORD *)cp;
	*wp = NULL;
	cp += 2;
	wp  = (WORD *)cp;
	*wp = NULL;
	cp += 2;
	wp  = (WORD *)cp;
	*wp = NULL;
	cp += 2;		
	cp += 10;
	bStockMsgToGateServer(cData, 18);
	if (iWinnerSide == 2) 
	{	_bCrusadeLog(DEF_CRUSADELOG_ENDCRUSADE, FALSE, FALSE, "Elvine Wictory! (Manual end)");
	}else if (iWinnerSide == 1) 
	{	_bCrusadeLog(DEF_CRUSADELOG_ENDCRUSADE, FALSE, FALSE, "Aresden Wictory! (Manual end)");
	}else
	{	_bCrusadeLog(DEF_CRUSADELOG_ENDCRUSADE, FALSE, FALSE, "Draw! (Manual end)");
	}
}

int CGame::iGetMapLocationForbiddenSide(char *pMapName)
{// SNOOPY: Inverted this function, not used if EQUILIBRIUM map-mode	
 // Returns forbidden side
 // But if Side + ForbidenSide = 3, means map is good side....
	if (strcmp(pMapName, "wrhus_1") == 0)	return 2;
	if (strcmp(pMapName, "wrhus_2") == 0)	return 1;
	if (strcmp(pMapName, "bsmith_1") == 0)	return 2;
	if (strcmp(pMapName, "bsmith_2") == 0)	return 1;
	if (strcmp(pMapName, "gshop_1") == 0)	return 2;
	if (strcmp(pMapName, "gshop_2") == 0)	return 1;
	if (strcmp(pMapName, "arefarm") == 0)	return 2;
	if (strcmp(pMapName, "elvfarm") == 0)	return 1;
	if (strcmp(pMapName, "arewrhus") == 0) return 2;
	if (strcmp(pMapName, "elvwrhus") == 0) return 1;
	if (strcmp(pMapName, "cityhall_1") == 0) return 2;
	if (strcmp(pMapName, "cityhall_2") == 0) return 1;
	if (strcmp(pMapName, "cath_1") == 0)	return 2;
	if (strcmp(pMapName, "cath_2") == 0)	return 1;
	if (strcmp(pMapName, "gldhall_1") == 0) return 2;
	if (strcmp(pMapName, "gldhall_2") == 0) return 1;
	if (strcmp(pMapName, "cmdhall_1") == 0) return 2;
	if (strcmp(pMapName, "Cmdhall_2") == 0) return 1;
	if (strcmp(pMapName, "wzdtwr_1") == 0) return 2;
	if (strcmp(pMapName, "wzdtwr_2") == 0) return 1;
	return -99;
}

BOOL CGame::bCopyItemContents(CItem * pCopy, CItem *pOriginal)
{
	if (pOriginal == NULL) return FALSE;
	if (pCopy == NULL) return FALSE;
	
	pCopy->m_sIDnum = pOriginal->m_sIDnum;					// Â¾Ã†Ã€ÃŒÃ…Ã›Ã€Ã‡ Â°Ã­Ã€Â¯ Â¹Ã¸ÃˆÂ£ 
	pCopy->m_cItemType = pOriginal->m_cItemType;
	pCopy->m_cEquipPos = pOriginal->m_cEquipPos;
	pCopy->m_sItemEffectType = pOriginal->m_sItemEffectType;     
	pCopy->m_sItemEffectValue1 = pOriginal->m_sItemEffectValue1;
	pCopy->m_sItemEffectValue2 = pOriginal->m_sItemEffectValue2;
	pCopy->m_sItemEffectValue3 = pOriginal->m_sItemEffectValue3; 
	pCopy->m_sItemEffectValue4 = pOriginal->m_sItemEffectValue4;
	pCopy->m_sItemEffectValue5 = pOriginal->m_sItemEffectValue5;
	pCopy->m_sItemEffectValue6 = pOriginal->m_sItemEffectValue6; 
	pCopy->m_wMaxLifeSpan = pOriginal->m_wMaxLifeSpan;
	pCopy->m_sSpecialEffect = pOriginal->m_sSpecialEffect;
	
	pCopy->m_sSpecialEffectValue1 = pOriginal->m_sSpecialEffectValue1;
	pCopy->m_sSpecialEffectValue2 = pOriginal->m_sSpecialEffectValue2; 

	pCopy->m_sSprite = pOriginal->m_sSprite;
	pCopy->m_sSpriteFrame = pOriginal->m_sSpriteFrame;

	pCopy->m_cApprValue = pOriginal->m_cApprValue;
	pCopy->m_cSpeed = pOriginal->m_cSpeed;

	pCopy->m_wPrice = pOriginal->m_wPrice; 
	pCopy->m_wWeight = pOriginal->m_wWeight;
	pCopy->m_sLevelLimit = pOriginal->m_sLevelLimit;	
	pCopy->m_cGenderLimit = pOriginal->m_cGenderLimit;

	pCopy->m_sRelatedSkill = pOriginal->m_sRelatedSkill;	
	pCopy->m_cCategory = pOriginal->m_cCategory; // 1..20 normal price for trav, 21..51 1/2 price for travellers, 0 unsellable
	pCopy->m_bIsForSale = pOriginal->m_bIsForSale;
	pCopy->m_dwCount = pOriginal->m_dwCount;
	pCopy->m_sTouchEffectType = pOriginal->m_sTouchEffectType;
	pCopy->m_sTouchEffectValue1 =pOriginal->m_sTouchEffectValue1;
	pCopy->m_sTouchEffectValue2 = pOriginal->m_sTouchEffectValue2;
	pCopy->m_sTouchEffectValue3 = pOriginal->m_sTouchEffectValue3;
	pCopy->m_cItemColor = pOriginal->m_cItemColor;
	pCopy->m_sItemSpecEffectValue1 = pOriginal->m_sItemSpecEffectValue1;
	pCopy->m_sItemSpecEffectValue2 = pOriginal->m_sItemSpecEffectValue2;
	pCopy->m_sItemSpecEffectValue3 = pOriginal->m_sItemSpecEffectValue3;
	pCopy->m_wCurLifeSpan = pOriginal->m_wCurLifeSpan;
	pCopy->m_dwAttribute = pOriginal->m_dwAttribute;	
	return TRUE;
}

void CGame::AdminOrder_SummonStorm(int iClientH, char* pData, DWORD dwMsgSize)
{	char   seps[] = "= \t\n"; 
	char   * token, cBuff[256], cOwnerType;
	int    i; 
	class  CStrTok * pStrTok; 
	short  sOwnerH,sType,sX,sY;
	int    dX1,dY1,iWhetherBonus,iResult = 0,tX,tY,iErr,ix,iy;
	int    iStormCount,iMagicAttr;
	if (m_pClientList[iClientH] == NULL) return; 
	if ((dwMsgSize)   <= 0) return; 
	if (m_pClientList[iClientH]->m_bIsAdminCommandEnabled == FALSE) return;
	if (m_pClientList[iClientH]->m_iAdminUserLevel < m_iAdminLevelStorm)  
	{	SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_ADMINUSERLEVELLOW, NULL, NULL, NULL, NULL); 
		return; 
	} 
	ZeroMemory(cBuff, sizeof(cBuff)); 
	memcpy(cBuff, pData, dwMsgSize); 
	pStrTok = new class CStrTok(cBuff, seps); 
	token = pStrTok->pGet(); 
	token = pStrTok->pGet(); 
	//No Storm Specified
	if (token == NULL)  
	{	delete pStrTok; 
		return; 
	} 	
	sType = atoi(token);
	//Only 100 Magic Spells
	if (sType <= 0)	sType = 1;
	if (sType > 100) sType = 100;
	//No Count Specified
	token = pStrTok->pGet(); 
	if (token == NULL) { 
		delete pStrTok; 
		return; 
	} 
	iStormCount = atoi(token);
	delete pStrTok; 
	if (iStormCount < 0)
		iStormCount = 0;
	if (iStormCount > 30)
		iStormCount = 30;//Original : 30
	DWORD dwTime = timeGetTime();
try{
	//Whether Bouns
	iWhetherBonus = iGetWhetherMagicBonusEffect(sType, m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cWhetherStatus);
	//Magic Attribute
	iMagicAttr = m_pMagicConfigList[sType]->m_iAttribute;
	//Calculate Area Coords
	//Gives Right
	dX1= m_pClientList[iClientH]->m_sX;
	dX1-=10;
	//Gives Top
	dY1= m_pClientList[iClientH]->m_sY;
	dY1-=7;
	sX = m_pClientList[iClientH]->m_sX;
	sY = m_pClientList[iClientH]->m_sY;

	while (iStormCount != 0) 
	{	int randX,randY;
		randX = (rand() % 20) + dX1;
		randY = (rand() % 13) + dY1;
		switch (m_pMagicConfigList[sType]->m_sType) {
			case DEF_MAGICTYPE_DAMAGE_SPOT: // 1
				//Calculate Damage
				m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, randX, randY);
				if (bCheckResistingMagicSuccess(0, sOwnerH, cOwnerType, iResult) == FALSE)
					Effect_Damage_Spot_DamageMove(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, sX, sY, m_pMagicConfigList[sType]->m_sValue4, m_pMagicConfigList[sType]->m_sValue5, m_pMagicConfigList[sType]->m_sValue6 + iWhetherBonus, FALSE, iMagicAttr);
				// On PretendCorpse
				m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetDeadOwner(&sOwnerH, &cOwnerType, randX, randY);
				if (   (cOwnerType == DEF_OWNERTYPE_PLAYER) && (m_pClientList[sOwnerH] != NULL) 
					&& (m_pClientList[sOwnerH]->m_iHP > 0) ) 
				{	if (bCheckResistingMagicSuccess(0, sOwnerH, cOwnerType, iResult) == FALSE)
					Effect_Damage_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue4, m_pMagicConfigList[sType]->m_sValue5, m_pMagicConfigList[sType]->m_sValue6 + iWhetherBonus, FALSE, iMagicAttr);
				}
				//Show effects
				SendEventToNearClient_TypeB(MSGID_EVENT_COMMON, DEF_COMMONTYPE_MAGIC, m_pClientList[iClientH]->m_cMapIndex,
				m_pClientList[iClientH]->m_sX, m_pClientList[iClientH]->m_sY, randX, randY, (sType+100), m_pClientList[iClientH]->m_sType);
			break;

			case DEF_MAGICTYPE_DAMAGE_AREA: // 3 (will fly from spell center point) // removed point damage
				for (iy = randY - m_pMagicConfigList[sType]->m_sValue3; iy <= randY + m_pMagicConfigList[sType]->m_sValue3; iy++)
				for (ix = randX - m_pMagicConfigList[sType]->m_sValue2; ix <= randX + m_pMagicConfigList[sType]->m_sValue2; ix++) 
				{	m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, ix, iy);
					if (bCheckResistingMagicSuccess(0, sOwnerH, cOwnerType, iResult) == FALSE)
						Effect_Damage_Spot_DamageMove(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, randX, randY, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9 + iWhetherBonus, FALSE, iMagicAttr);

					m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetDeadOwner(&sOwnerH, &cOwnerType, ix, iy);
					if (   (cOwnerType == DEF_OWNERTYPE_PLAYER) && (m_pClientList[sOwnerH] != NULL) 
						&& (m_pClientList[sOwnerH]->m_iHP > 0) ) 
					{	if (bCheckResistingMagicSuccess(0, sOwnerH, cOwnerType, iResult) == FALSE)
							Effect_Damage_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9 + iWhetherBonus, FALSE, iMagicAttr);
						}
					}
				//Show effects
				SendEventToNearClient_TypeB(MSGID_EVENT_COMMON, DEF_COMMONTYPE_MAGIC, m_pClientList[iClientH]->m_cMapIndex,
					m_pClientList[iClientH]->m_sX, m_pClientList[iClientH]->m_sY, randX, randY, (sType+100), m_pClientList[iClientH]->m_sType);
				break;

			case DEF_MAGICTYPE_SPDOWN_AREA: //5:  Remove all SP arround
				for (iy = randY - m_pMagicConfigList[sType]->m_sValue3; iy <= randY + m_pMagicConfigList[sType]->m_sValue3; iy++)					
				for (ix = randX - m_pMagicConfigList[sType]->m_sValue2; ix <= randX + m_pMagicConfigList[sType]->m_sValue2; ix++) 
				{	m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, ix, iy);
					Effect_SpDown_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, 1, 4, 800);
				}
				//Show effects
				SendEventToNearClient_TypeB(MSGID_EVENT_COMMON, DEF_COMMONTYPE_MAGIC, m_pClientList[iClientH]->m_cMapIndex,
					m_pClientList[iClientH]->m_sX, m_pClientList[iClientH]->m_sY, randX, randY, (sType+100), m_pClientList[iClientH]->m_sType);
				break;
				
			case DEF_MAGICTYPE_SPUP_AREA: // 7
				for (iy = randY - m_pMagicConfigList[sType]->m_sValue3; iy <= randY + m_pMagicConfigList[sType]->m_sValue3; iy++)
				for (ix = randX - m_pMagicConfigList[sType]->m_sValue2; ix <= randX + m_pMagicConfigList[sType]->m_sValue2; ix++) 
				{	m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, ix, iy);
					Effect_SpUp_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, 1, 4, 800);
				}
				//Show effects
				SendEventToNearClient_TypeB(MSGID_EVENT_COMMON, DEF_COMMONTYPE_MAGIC, m_pClientList[iClientH]->m_cMapIndex,
					m_pClientList[iClientH]->m_sX, m_pClientList[iClientH]->m_sY, randX, randY, (sType+100), m_pClientList[iClientH]->m_sType);
				break;

			case DEF_MAGICTYPE_DAMAGE_LINEAR: // 19
				// LightingBolt- BloodyShockWave
				for (i = 2; i < 10; i++) 
				{	iErr = 0;
					m_Misc.GetPoint2(sX, sY, randX, randY, &tX, &tY, &iErr, i);
					// tx, ty
					m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, tX, tY);
					if (bCheckResistingMagicSuccess(0, sOwnerH, cOwnerType, iResult) == FALSE)
						Effect_Damage_Spot_DamageMove(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, sX, sY, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9 + iWhetherBonus, FALSE, iMagicAttr);
					m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetDeadOwner(&sOwnerH, &cOwnerType, tX, tY);
					if ( (cOwnerType == DEF_OWNERTYPE_PLAYER) && (m_pClientList[sOwnerH] != NULL) && (m_pClientList[sOwnerH]->m_iHP > 0) ) 
					{	if (bCheckResistingMagicSuccess(0, sOwnerH, cOwnerType, iResult) == FALSE)
							Effect_Damage_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9 + iWhetherBonus, FALSE, iMagicAttr);
					}
					// tx-1, ty
					m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, tX-1, tY);
					if (bCheckResistingMagicSuccess(0, sOwnerH, cOwnerType, iResult) == FALSE)
						Effect_Damage_Spot_DamageMove(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, sX, sY, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9 + iWhetherBonus, FALSE, iMagicAttr);
					m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetDeadOwner(&sOwnerH, &cOwnerType, tX-1, tY);
					if ( (cOwnerType == DEF_OWNERTYPE_PLAYER) && (m_pClientList[sOwnerH] != NULL) && (m_pClientList[sOwnerH]->m_iHP > 0) ) 
					{	if (bCheckResistingMagicSuccess(0, sOwnerH, cOwnerType, iResult) == FALSE)
							Effect_Damage_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9 + iWhetherBonus, FALSE, iMagicAttr);
					}

					// tx+1, ty
					m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, tX+1, tY);
					if (bCheckResistingMagicSuccess(0, sOwnerH, cOwnerType, iResult) == FALSE)
						Effect_Damage_Spot_DamageMove(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, sX, sY, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9 + iWhetherBonus, FALSE, iMagicAttr);
						m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetDeadOwner(&sOwnerH, &cOwnerType, tX+1, tY);
					if ( (cOwnerType == DEF_OWNERTYPE_PLAYER) && (m_pClientList[sOwnerH] != NULL) && (m_pClientList[sOwnerH]->m_iHP > 0) ) 
					{	if (bCheckResistingMagicSuccess(0, sOwnerH, cOwnerType, iResult) == FALSE)
							Effect_Damage_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9 + iWhetherBonus, FALSE, iMagicAttr);
					}

					// tx, ty-1
					m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, tX, tY-1);
					if (bCheckResistingMagicSuccess(0, sOwnerH, cOwnerType, iResult) == FALSE)
						Effect_Damage_Spot_DamageMove(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, sX, sY, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9 + iWhetherBonus, FALSE, iMagicAttr);
					m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetDeadOwner(&sOwnerH, &cOwnerType, tX, tY-1);
					if ( (cOwnerType == DEF_OWNERTYPE_PLAYER) && (m_pClientList[sOwnerH] != NULL) && (m_pClientList[sOwnerH]->m_iHP > 0) ) 
					{	if (bCheckResistingMagicSuccess(0, sOwnerH, cOwnerType, iResult) == FALSE)
							Effect_Damage_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9 + iWhetherBonus, FALSE, iMagicAttr);
					}

					// tx, ty+1
					m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, tX, tY+1);
					if (bCheckResistingMagicSuccess(0, sOwnerH, cOwnerType, iResult) == FALSE)
						Effect_Damage_Spot_DamageMove(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, sX, sY, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9 + iWhetherBonus, FALSE, iMagicAttr);
					m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetDeadOwner(&sOwnerH, &cOwnerType, tX, tY+1);
					if ( (cOwnerType == DEF_OWNERTYPE_PLAYER) && (m_pClientList[sOwnerH] != NULL) && (m_pClientList[sOwnerH]->m_iHP > 0) ) 
					{	if (bCheckResistingMagicSuccess(0, sOwnerH, cOwnerType, iResult) == FALSE)
							Effect_Damage_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9 + iWhetherBonus, FALSE, iMagicAttr);
					}								
					if ( (abs(tX - randX) <= 1) && (abs(tY - randY) <= 1)) break;
				}
				// removed Area damage
				// removed dX, dY Target point
				//Show effects
				SendEventToNearClient_TypeB(MSGID_EVENT_COMMON, DEF_COMMONTYPE_MAGIC, m_pClientList[iClientH]->m_cMapIndex,
					m_pClientList[iClientH]->m_sX, m_pClientList[iClientH]->m_sY, randX, randY, (sType+100), m_pClientList[iClientH]->m_sType);
			break;

			case DEF_MAGICTYPE_DAMAGE_AREA_NOSPOT: //21 (fly from caster)
				for (iy = randY - m_pMagicConfigList[sType]->m_sValue3; iy <= randY + m_pMagicConfigList[sType]->m_sValue3; iy++)
				for (ix = randX - m_pMagicConfigList[sType]->m_sValue2; ix <= randX + m_pMagicConfigList[sType]->m_sValue2; ix++) 
				{	m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, ix, iy);
					if (bCheckResistingMagicSuccess(0, sOwnerH, cOwnerType, iResult) == FALSE)
						Effect_Damage_Spot_DamageMove(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, sX, sY, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9 + iWhetherBonus, TRUE, iMagicAttr);
					m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetDeadOwner(&sOwnerH, &cOwnerType, ix, iy);
					if (   (cOwnerType == DEF_OWNERTYPE_PLAYER) && (m_pClientList[sOwnerH] != NULL) 
						&& (m_pClientList[sOwnerH]->m_iHP > 0) ) 
					{	if (bCheckResistingMagicSuccess(0, sOwnerH, cOwnerType, iResult) == FALSE)
							Effect_Damage_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9 + iWhetherBonus, TRUE, iMagicAttr);
					}
				}
				//Show effects
				SendEventToNearClient_TypeB(MSGID_EVENT_COMMON, DEF_COMMONTYPE_MAGIC, m_pClientList[iClientH]->m_cMapIndex,
					m_pClientList[iClientH]->m_sX, m_pClientList[iClientH]->m_sY, randX, randY, (sType+100), m_pClientList[iClientH]->m_sType);
				break;	

			case DEF_MAGICTYPE_TREMOR: // 22 TREMOR is same than DamageArea but will not Fly you // remove point damage
				for (iy = randY - m_pMagicConfigList[sType]->m_sValue3; iy <= randY + m_pMagicConfigList[sType]->m_sValue3; iy++)
				for (ix = randX - m_pMagicConfigList[sType]->m_sValue2; ix <= randX + m_pMagicConfigList[sType]->m_sValue2; ix++) 
				{	m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, ix, iy);
					Effect_Damage_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9 + iWhetherBonus, FALSE, iMagicAttr);
					m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetDeadOwner(&sOwnerH, &cOwnerType, ix, iy);
					if ( (cOwnerType == DEF_OWNERTYPE_PLAYER) && (m_pClientList[sOwnerH] != NULL) &&
						(m_pClientList[sOwnerH]->m_iHP > 0) ) 
					{	Effect_Damage_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9 + iWhetherBonus, FALSE, iMagicAttr);
					}
				}
				//Show effects
				SendEventToNearClient_TypeB(MSGID_EVENT_COMMON, DEF_COMMONTYPE_MAGIC, m_pClientList[iClientH]->m_cMapIndex,
					m_pClientList[iClientH]->m_sX, m_pClientList[iClientH]->m_sY, randX, randY, (sType+100), m_pClientList[iClientH]->m_sType);
				break;

			case DEF_MAGICTYPE_ICE:  //23 (don't fly target)
				for (iy = randY - m_pMagicConfigList[sType]->m_sValue3; iy <= randY + m_pMagicConfigList[sType]->m_sValue3; iy++)
				for (ix = randX - m_pMagicConfigList[sType]->m_sValue2; ix <= randX + m_pMagicConfigList[sType]->m_sValue2; ix++) 
				{	m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, ix, iy);
					if (bCheckResistingMagicSuccess(0, sOwnerH, cOwnerType, iResult) == FALSE) 
						Effect_Damage_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue4, m_pMagicConfigList[sType]->m_sValue5, m_pMagicConfigList[sType]->m_sValue6 + iWhetherBonus, TRUE, iMagicAttr);
					switch (cOwnerType) {
					case DEF_OWNERTYPE_PLAYER:
						if (m_pClientList[sOwnerH] == NULL) continue; // Snoopy: replaced goto MAGIC_NOEFFECT by continue...
						// SNOOPY: No more self icing!
						if (sOwnerH != iClientH) 
						{	if ((m_pClientList[sOwnerH]->m_iHP > 0) && (bCheckResistingIceSuccess(0, sOwnerH, cOwnerType, iResult) == FALSE))
							{	if (m_pClientList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_ICE ] == 0) 
								{	m_pClientList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_ICE ] = 1;
									SetIceFlag(sOwnerH, cOwnerType, TRUE);
									bRegisterDelayEvent(DEF_DELAYEVENTTYPE_MAGICRELEASE, DEF_MAGICTYPE_ICE, dwTime + (m_pMagicConfigList[sType]->m_sValue10*1000), 
										sOwnerH, cOwnerType, NULL, NULL, NULL, 1, NULL, NULL);
									SendNotifyMsg(NULL, sOwnerH, DEF_NOTIFY_MAGICEFFECTON, DEF_MAGICTYPE_ICE, 1, NULL, NULL);
						}	}	}
						break;
					case DEF_OWNERTYPE_NPC:
						if (m_pNpcList[sOwnerH] == NULL) continue; // Snoopy: replaced goto MAGIC_NOEFFECT by continue...
						if ((m_pNpcList[sOwnerH]->m_iHP > 0) && (bCheckResistingIceSuccess(0, sOwnerH, cOwnerType, iResult) == FALSE)) 
						{	if (m_pNpcList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_ICE ] == 0) 
							{	m_pNpcList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_ICE ] = 1;
								SetIceFlag(sOwnerH, cOwnerType, TRUE);
								bRegisterDelayEvent(DEF_DELAYEVENTTYPE_MAGICRELEASE, DEF_MAGICTYPE_ICE, dwTime + (m_pMagicConfigList[sType]->m_sValue10*1000), 
									sOwnerH, cOwnerType, NULL, NULL, NULL, 1, NULL, NULL);
						}	}
						break;
					}
					// Will not ice is not discovered pretencorpse
					m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetDeadOwner(&sOwnerH, &cOwnerType, ix, iy);
					if (   (cOwnerType == DEF_OWNERTYPE_PLAYER) && (m_pClientList[sOwnerH] != NULL)
						&& (m_pClientList[sOwnerH]->m_iHP > 0) ) 
					{	if (bCheckResistingMagicSuccess(0, sOwnerH, cOwnerType, iResult) == FALSE) 
						{	Effect_Damage_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue4, m_pMagicConfigList[sType]->m_sValue5, m_pMagicConfigList[sType]->m_sValue6 + iWhetherBonus, TRUE, iMagicAttr);
							if ((m_pClientList[sOwnerH]->m_iHP > 0) && (bCheckResistingIceSuccess(0, sOwnerH, cOwnerType, iResult) == FALSE)) 
							{	if (m_pClientList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_ICE ] == 0) 
								{	m_pClientList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_ICE ] = 1;
									SetIceFlag(sOwnerH, cOwnerType, TRUE);
										bRegisterDelayEvent(DEF_DELAYEVENTTYPE_MAGICRELEASE, DEF_MAGICTYPE_ICE, dwTime + (m_pMagicConfigList[sType]->m_sValue10*1000), 
										sOwnerH, cOwnerType, NULL, NULL, NULL, 1, NULL, NULL);
									SendNotifyMsg(NULL, sOwnerH, DEF_NOTIFY_MAGICEFFECTON, DEF_MAGICTYPE_ICE, 1, NULL, NULL);
								}
							}
						}
					}
				}
				//Show effects
				SendEventToNearClient_TypeB(MSGID_EVENT_COMMON, DEF_COMMONTYPE_MAGIC, m_pClientList[iClientH]->m_cMapIndex,
					m_pClientList[iClientH]->m_sX, m_pClientList[iClientH]->m_sY, randX, randY, (sType+100), m_pClientList[iClientH]->m_sType);
				break;

			case DEF_MAGICTYPE_DAMAGE_AREA_NOSPOT_SPDOWN: //25 // EWS (will fly in random position)
				for (iy = randY - m_pMagicConfigList[sType]->m_sValue3; iy <= randY + m_pMagicConfigList[sType]->m_sValue3; iy++)
				for (ix = randX - m_pMagicConfigList[sType]->m_sValue2; ix <= randX + m_pMagicConfigList[sType]->m_sValue2; ix++) 
				{	// SNOOPY: Damage is on 456, Special SPdown on 789
					m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, ix, iy);
					if (bCheckResistingMagicSuccess(0, sOwnerH, cOwnerType, iResult) == FALSE) 
					{	// Will fly random direction
						Effect_Damage_Spot_DamageMove(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, ix, iy, m_pMagicConfigList[sType]->m_sValue4, m_pMagicConfigList[sType]->m_sValue5, m_pMagicConfigList[sType]->m_sValue6 + iWhetherBonus, FALSE, iMagicAttr);
						Effect_SpDown_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9);
					}
					m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetDeadOwner(&sOwnerH, &cOwnerType, ix, iy);
					if (    (cOwnerType == DEF_OWNERTYPE_PLAYER) && (m_pClientList[sOwnerH] != NULL) 
							 && (m_pClientList[sOwnerH]->m_iHP > 0) ) 
					{	if (bCheckResistingMagicSuccess(0, sOwnerH, cOwnerType, iResult) == FALSE) 
						{	Effect_Damage_Spot_DamageMove(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, ix, iy, m_pMagicConfigList[sType]->m_sValue4, m_pMagicConfigList[sType]->m_sValue5, 10 + m_pMagicConfigList[sType]->m_sValue6 + iWhetherBonus, FALSE, iMagicAttr);
							Effect_SpDown_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, 10 + m_pMagicConfigList[sType]->m_sValue9);
						}
					}
				}
				//Show effects
				SendEventToNearClient_TypeB(MSGID_EVENT_COMMON, DEF_COMMONTYPE_MAGIC, m_pClientList[iClientH]->m_cMapIndex,
					m_pClientList[iClientH]->m_sX, m_pClientList[iClientH]->m_sY, randX, randY, (sType+100), m_pClientList[iClientH]->m_sType);
				break;

			case DEF_MAGICTYPE_ICE_LINEAR: //26
				// SNOOPY: used iMagicAttr, to send info to damage procedures, not to add bonus for Berzerk Liche Wands
				iMagicAttr +=100;
				for (i = 2; i < 10; i++) 
				{	iErr = 0;
					m_Misc.GetPoint2(sX, sY, randX, randY, &tX, &tY, &iErr, i);
					// tx, ty
					m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, tX, tY);
					if (bCheckResistingMagicSuccess(0, sOwnerH, cOwnerType, iResult) == FALSE) 
					{	Effect_Damage_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue7/2, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9 + iWhetherBonus, FALSE, iMagicAttr);
						switch (cOwnerType) {
						case DEF_OWNERTYPE_PLAYER:
							if (m_pClientList[sOwnerH] == NULL) break;
								if ((m_pClientList[sOwnerH]->m_iHP > 0) && (bCheckResistingIceSuccess(0, sOwnerH, cOwnerType, iResult) == FALSE))
							{	if (m_pClientList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_ICE ] == 0) 
								{	m_pClientList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_ICE ] = 1;
									SetIceFlag(sOwnerH, cOwnerType, TRUE);
									bRegisterDelayEvent(DEF_DELAYEVENTTYPE_MAGICRELEASE, DEF_MAGICTYPE_ICE, dwTime + (m_pMagicConfigList[sType]->m_sValue10*1000), 
										sOwnerH, cOwnerType, NULL, NULL, NULL, 1, NULL, NULL);
									SendNotifyMsg(NULL, sOwnerH, DEF_NOTIFY_MAGICEFFECTON, DEF_MAGICTYPE_ICE, 1, NULL, NULL);
							}	}
							break;
						case DEF_OWNERTYPE_NPC:
							if (m_pNpcList[sOwnerH] == NULL) break;
							if ((m_pNpcList[sOwnerH]->m_iHP > 0) && (bCheckResistingIceSuccess(0, sOwnerH, cOwnerType, iResult) == FALSE)) {
								if (m_pNpcList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_ICE ] == 0) 
								{	m_pNpcList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_ICE ] = 1;
									SetIceFlag(sOwnerH, cOwnerType, TRUE);
									bRegisterDelayEvent(DEF_DELAYEVENTTYPE_MAGICRELEASE, DEF_MAGICTYPE_ICE, dwTime + (m_pMagicConfigList[sType]->m_sValue10*1000), 
										sOwnerH, cOwnerType, NULL, NULL, NULL, 1, NULL, NULL);
							}	}
							break;
					}	} 
					m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetDeadOwner(&sOwnerH, &cOwnerType, tX, tY);
					if ( (cOwnerType == DEF_OWNERTYPE_PLAYER) && (m_pClientList[sOwnerH] != NULL) && (m_pClientList[sOwnerH]->m_iHP > 0) ) 
					{	if (bCheckResistingMagicSuccess(0, sOwnerH, cOwnerType, iResult) == FALSE) 
						{	Effect_Damage_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue7/2, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9 + iWhetherBonus, FALSE, iMagicAttr);
							if ((m_pClientList[sOwnerH]->m_iHP > 0) && (bCheckResistingIceSuccess(0, sOwnerH, cOwnerType, iResult) == FALSE))
							{	if (m_pClientList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_ICE ] == 0)
								{	m_pClientList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_ICE ] = 1;
									SetIceFlag(sOwnerH, cOwnerType, TRUE);
									bRegisterDelayEvent(DEF_DELAYEVENTTYPE_MAGICRELEASE, DEF_MAGICTYPE_ICE, dwTime + (m_pMagicConfigList[sType]->m_sValue10*1000), 
										sOwnerH, cOwnerType, NULL, NULL, NULL, 1, NULL, NULL);
									SendNotifyMsg(NULL, sOwnerH, DEF_NOTIFY_MAGICEFFECTON, DEF_MAGICTYPE_ICE, 1, NULL, NULL);
					}	}	}	}
					// tx-1, ty
					m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, tX-1, tY);
					if (bCheckResistingMagicSuccess(0, sOwnerH, cOwnerType, iResult) == FALSE) 
					{	Effect_Damage_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue7/2, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9 + iWhetherBonus, FALSE, iMagicAttr);
						switch (cOwnerType) {
						case DEF_OWNERTYPE_PLAYER:
							if (m_pClientList[sOwnerH] == NULL) break;
							if ((m_pClientList[sOwnerH]->m_iHP > 0) && (bCheckResistingIceSuccess(0, sOwnerH, cOwnerType, iResult) == FALSE))
							{	if (m_pClientList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_ICE ] == 0) 
								{	m_pClientList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_ICE ] = 1;
									SetIceFlag(sOwnerH, cOwnerType, TRUE);
									bRegisterDelayEvent(DEF_DELAYEVENTTYPE_MAGICRELEASE, DEF_MAGICTYPE_ICE, dwTime + (m_pMagicConfigList[sType]->m_sValue10*1000), 
										sOwnerH, cOwnerType, NULL, NULL, NULL, 1, NULL, NULL);
									SendNotifyMsg(NULL, sOwnerH, DEF_NOTIFY_MAGICEFFECTON, DEF_MAGICTYPE_ICE, 1, NULL, NULL);
							}	}
							break;
						case DEF_OWNERTYPE_NPC:
							if (m_pNpcList[sOwnerH] == NULL) break;
							if ((m_pNpcList[sOwnerH]->m_iHP > 0) && (bCheckResistingIceSuccess(0, sOwnerH, cOwnerType, iResult) == FALSE)) {
								if (m_pNpcList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_ICE ] == 0) 
								{	m_pNpcList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_ICE ] = 1;
									SetIceFlag(sOwnerH, cOwnerType, TRUE);
									bRegisterDelayEvent(DEF_DELAYEVENTTYPE_MAGICRELEASE, DEF_MAGICTYPE_ICE, dwTime + (m_pMagicConfigList[sType]->m_sValue10*1000), 
										sOwnerH, cOwnerType, NULL, NULL, NULL, 1, NULL, NULL);
							}	}
							break;
					}	} 
					m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetDeadOwner(&sOwnerH, &cOwnerType, tX-1, tY);
					if ( (cOwnerType == DEF_OWNERTYPE_PLAYER) && (m_pClientList[sOwnerH] != NULL) && (m_pClientList[sOwnerH]->m_iHP > 0) ) 
					{	if (bCheckResistingMagicSuccess(0, sOwnerH, cOwnerType, iResult) == FALSE) 
						{	Effect_Damage_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue7/2, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9 + iWhetherBonus, FALSE, iMagicAttr);
							if ((m_pClientList[sOwnerH]->m_iHP > 0) && (bCheckResistingIceSuccess(0, sOwnerH, cOwnerType, iResult) == FALSE))
							{	if (m_pClientList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_ICE ] == 0)
								{	m_pClientList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_ICE ] = 1;
									SetIceFlag(sOwnerH, cOwnerType, TRUE);
									bRegisterDelayEvent(DEF_DELAYEVENTTYPE_MAGICRELEASE, DEF_MAGICTYPE_ICE, dwTime + (m_pMagicConfigList[sType]->m_sValue10*1000), 
										sOwnerH, cOwnerType, NULL, NULL, NULL, 1, NULL, NULL);
									SendNotifyMsg(NULL, sOwnerH, DEF_NOTIFY_MAGICEFFECTON, DEF_MAGICTYPE_ICE, 1, NULL, NULL);
					}	}	}	}
					// tx+1, ty
					m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, tX+1, tY);
					if (bCheckResistingMagicSuccess(0, sOwnerH, cOwnerType, iResult) == FALSE) 
					{	Effect_Damage_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue7/2, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9 + iWhetherBonus, FALSE, iMagicAttr);
						switch (cOwnerType) {
						case DEF_OWNERTYPE_PLAYER:
							if (m_pClientList[sOwnerH] == NULL) break;
							if ((m_pClientList[sOwnerH]->m_iHP > 0) && (bCheckResistingIceSuccess(0, sOwnerH, cOwnerType, iResult) == FALSE))
							{	if (m_pClientList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_ICE ] == 0) 
								{	m_pClientList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_ICE ] = 1;
									SetIceFlag(sOwnerH, cOwnerType, TRUE);
									bRegisterDelayEvent(DEF_DELAYEVENTTYPE_MAGICRELEASE, DEF_MAGICTYPE_ICE, dwTime + (m_pMagicConfigList[sType]->m_sValue10*1000), 
										sOwnerH, cOwnerType, NULL, NULL, NULL, 1, NULL, NULL);
									SendNotifyMsg(NULL, sOwnerH, DEF_NOTIFY_MAGICEFFECTON, DEF_MAGICTYPE_ICE, 1, NULL, NULL);
							}	}
							break;
						case DEF_OWNERTYPE_NPC:
							if (m_pNpcList[sOwnerH] == NULL) break;
							if ((m_pNpcList[sOwnerH]->m_iHP > 0) && (bCheckResistingIceSuccess(0, sOwnerH, cOwnerType, iResult) == FALSE)) {
								if (m_pNpcList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_ICE ] == 0) 
								{	m_pNpcList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_ICE ] = 1;
									SetIceFlag(sOwnerH, cOwnerType, TRUE);
									bRegisterDelayEvent(DEF_DELAYEVENTTYPE_MAGICRELEASE, DEF_MAGICTYPE_ICE, dwTime + (m_pMagicConfigList[sType]->m_sValue10*1000), 
										sOwnerH, cOwnerType, NULL, NULL, NULL, 1, NULL, NULL);
							}	}
							break;
					}	} 
					m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetDeadOwner(&sOwnerH, &cOwnerType, tX+1, tY);
					if ( (cOwnerType == DEF_OWNERTYPE_PLAYER) && (m_pClientList[sOwnerH] != NULL) && (m_pClientList[sOwnerH]->m_iHP > 0) ) 
					{	if (bCheckResistingMagicSuccess(0, sOwnerH, cOwnerType, iResult) == FALSE) 
						{	Effect_Damage_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue7/2, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9 + iWhetherBonus, FALSE, iMagicAttr);
							if ((m_pClientList[sOwnerH]->m_iHP > 0) && (bCheckResistingIceSuccess(0, sOwnerH, cOwnerType, iResult) == FALSE))
							{	if (m_pClientList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_ICE ] == 0)
								{	m_pClientList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_ICE ] = 1;
									SetIceFlag(sOwnerH, cOwnerType, TRUE);
									bRegisterDelayEvent(DEF_DELAYEVENTTYPE_MAGICRELEASE, DEF_MAGICTYPE_ICE, dwTime + (m_pMagicConfigList[sType]->m_sValue10*1000), 
										sOwnerH, cOwnerType, NULL, NULL, NULL, 1, NULL, NULL);
									SendNotifyMsg(NULL, sOwnerH, DEF_NOTIFY_MAGICEFFECTON, DEF_MAGICTYPE_ICE, 1, NULL, NULL);
					}	}	}	}
					// tx, ty-1
					m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, tX, tY-1);
					if (bCheckResistingMagicSuccess(0, sOwnerH, cOwnerType, iResult) == FALSE) 
					{	Effect_Damage_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue7/2, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9 + iWhetherBonus, FALSE, iMagicAttr);
						switch (cOwnerType) {
						case DEF_OWNERTYPE_PLAYER:
							if (m_pClientList[sOwnerH] == NULL) break;
							if ((m_pClientList[sOwnerH]->m_iHP > 0) && (bCheckResistingIceSuccess(0, sOwnerH, cOwnerType, iResult) == FALSE))
							{	if (m_pClientList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_ICE ] == 0) 
								{	m_pClientList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_ICE ] = 1;
									SetIceFlag(sOwnerH, cOwnerType, TRUE);
									bRegisterDelayEvent(DEF_DELAYEVENTTYPE_MAGICRELEASE, DEF_MAGICTYPE_ICE, dwTime + (m_pMagicConfigList[sType]->m_sValue10*1000), 
										sOwnerH, cOwnerType, NULL, NULL, NULL, 1, NULL, NULL);
									SendNotifyMsg(NULL, sOwnerH, DEF_NOTIFY_MAGICEFFECTON, DEF_MAGICTYPE_ICE, 1, NULL, NULL);
							}	}
							break;
						case DEF_OWNERTYPE_NPC:
							if (m_pNpcList[sOwnerH] == NULL) break;
							if ((m_pNpcList[sOwnerH]->m_iHP > 0) && (bCheckResistingIceSuccess(0, sOwnerH, cOwnerType, iResult) == FALSE)) {
								if (m_pNpcList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_ICE ] == 0) 
								{	m_pNpcList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_ICE ] = 1;
									SetIceFlag(sOwnerH, cOwnerType, TRUE);
									bRegisterDelayEvent(DEF_DELAYEVENTTYPE_MAGICRELEASE, DEF_MAGICTYPE_ICE, dwTime + (m_pMagicConfigList[sType]->m_sValue10*1000), 
										sOwnerH, cOwnerType, NULL, NULL, NULL, 1, NULL, NULL);
							}	}
							break;
					}	} 
					m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetDeadOwner(&sOwnerH, &cOwnerType, tX, tY-1);
					if ( (cOwnerType == DEF_OWNERTYPE_PLAYER) && (m_pClientList[sOwnerH] != NULL) && (m_pClientList[sOwnerH]->m_iHP > 0) ) 
					{	if (bCheckResistingMagicSuccess(0, sOwnerH, cOwnerType, iResult) == FALSE) 
						{	Effect_Damage_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue7/2, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9 + iWhetherBonus, FALSE, iMagicAttr);
							if ((m_pClientList[sOwnerH]->m_iHP > 0) && (bCheckResistingIceSuccess(0, sOwnerH, cOwnerType, iResult) == FALSE))
							{	if (m_pClientList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_ICE ] == 0)
								{	m_pClientList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_ICE ] = 1;
									SetIceFlag(sOwnerH, cOwnerType, TRUE);
									bRegisterDelayEvent(DEF_DELAYEVENTTYPE_MAGICRELEASE, DEF_MAGICTYPE_ICE, dwTime + (m_pMagicConfigList[sType]->m_sValue10*1000), 
										sOwnerH, cOwnerType, NULL, NULL, NULL, 1, NULL, NULL);
									SendNotifyMsg(NULL, sOwnerH, DEF_NOTIFY_MAGICEFFECTON, DEF_MAGICTYPE_ICE, 1, NULL, NULL);
					}	}	}	}
					// tx, ty+1
					m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, tX, tY+1);
					if (bCheckResistingMagicSuccess(0, sOwnerH, cOwnerType, iResult) == FALSE) 
					{	Effect_Damage_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue7/2, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9 + iWhetherBonus, FALSE, iMagicAttr);
						switch (cOwnerType) {
						case DEF_OWNERTYPE_PLAYER:
							if (m_pClientList[sOwnerH] == NULL) break;
							if ((m_pClientList[sOwnerH]->m_iHP > 0) && (bCheckResistingIceSuccess(0, sOwnerH, cOwnerType, iResult) == FALSE))
							{	if (m_pClientList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_ICE ] == 0) 
								{	m_pClientList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_ICE ] = 1;
									SetIceFlag(sOwnerH, cOwnerType, TRUE);
									bRegisterDelayEvent(DEF_DELAYEVENTTYPE_MAGICRELEASE, DEF_MAGICTYPE_ICE, dwTime + (m_pMagicConfigList[sType]->m_sValue10*1000), 
										sOwnerH, cOwnerType, NULL, NULL, NULL, 1, NULL, NULL);
									SendNotifyMsg(NULL, sOwnerH, DEF_NOTIFY_MAGICEFFECTON, DEF_MAGICTYPE_ICE, 1, NULL, NULL);
							}	}
							break;
						case DEF_OWNERTYPE_NPC:
							if (m_pNpcList[sOwnerH] == NULL) break;
							if ((m_pNpcList[sOwnerH]->m_iHP > 0) && (bCheckResistingIceSuccess(0, sOwnerH, cOwnerType, iResult) == FALSE)) {
								if (m_pNpcList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_ICE ] == 0) 
								{	m_pNpcList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_ICE ] = 1;
									SetIceFlag(sOwnerH, cOwnerType, TRUE);
									bRegisterDelayEvent(DEF_DELAYEVENTTYPE_MAGICRELEASE, DEF_MAGICTYPE_ICE, dwTime + (m_pMagicConfigList[sType]->m_sValue10*1000), 
										sOwnerH, cOwnerType, NULL, NULL, NULL, 1, NULL, NULL);
							}	}
							break;
					}	} 
					m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetDeadOwner(&sOwnerH, &cOwnerType, tX, tY+1);
					if ( (cOwnerType == DEF_OWNERTYPE_PLAYER) && (m_pClientList[sOwnerH] != NULL) && (m_pClientList[sOwnerH]->m_iHP > 0) ) 
					{	if (bCheckResistingMagicSuccess(0, sOwnerH, cOwnerType, iResult) == FALSE) 
						{	Effect_Damage_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue7/2, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9 + iWhetherBonus, FALSE, iMagicAttr);
							if ((m_pClientList[sOwnerH]->m_iHP > 0) && (bCheckResistingIceSuccess(0, sOwnerH, cOwnerType, iResult) == FALSE))
							{	if (m_pClientList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_ICE ] == 0)
								{	m_pClientList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_ICE ] = 1;
									SetIceFlag(sOwnerH, cOwnerType, TRUE);
									bRegisterDelayEvent(DEF_DELAYEVENTTYPE_MAGICRELEASE, DEF_MAGICTYPE_ICE, dwTime + (m_pMagicConfigList[sType]->m_sValue10*1000), 
										sOwnerH, cOwnerType, NULL, NULL, NULL, 1, NULL, NULL);
									SendNotifyMsg(NULL, sOwnerH, DEF_NOTIFY_MAGICEFFECTON, DEF_MAGICTYPE_ICE, 1, NULL, NULL);
					}	}	}	}				
					// Exit if reaching the Target
					if ( (abs(tX - randX) <= 1) && (abs(tY - randY) <= 1)) break;
				}
				// removed Area damage: depends on X/Y settings in the spell and m_sValue789, same as linear damge
				// removed Target Damage: depends on m_sValue456
				//Show effects
				SendEventToNearClient_TypeB(MSGID_EVENT_COMMON, DEF_COMMONTYPE_MAGIC, m_pClientList[iClientH]->m_cMapIndex,
					m_pClientList[iClientH]->m_sX, m_pClientList[iClientH]->m_sY, randX, randY, (sType+100), m_pClientList[iClientH]->m_sType);
				break;



			case DEF_MAGICTYPE_DAMAGE_AREA_ARMOR_BREAK: //28 m_sValue10 is used for armor decrement
				for (iy = randY - m_pMagicConfigList[sType]->m_sValue3; iy <= randY + m_pMagicConfigList[sType]->m_sValue3; iy++)
				for (ix = randX - m_pMagicConfigList[sType]->m_sValue2; ix <= randX + m_pMagicConfigList[sType]->m_sValue2; ix++) 
				{	m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, ix, iy);
					if (bCheckResistingMagicSuccess(0, sOwnerH, cOwnerType, iResult) == FALSE) 
					{	Effect_Damage_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9 + iWhetherBonus, FALSE, iMagicAttr);
					} // No chance to resist Armor life decrement...	
					ArmorLifeDecrement(iClientH,sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue10);					

					m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetDeadOwner(&sOwnerH, &cOwnerType, ix, iy);
					if (   (cOwnerType == DEF_OWNERTYPE_PLAYER) && (m_pClientList[sOwnerH] != NULL) 
						&& (m_pClientList[sOwnerH]->m_iHP > 0) ) 
					{	if (bCheckResistingMagicSuccess(0, sOwnerH, cOwnerType, iResult) == FALSE) 
						{	Effect_Damage_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9 + iWhetherBonus, FALSE, iMagicAttr);
						}	
					ArmorLifeDecrement(iClientH,sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue10);
						
					}
				}
				//Show effects
				SendEventToNearClient_TypeB(MSGID_EVENT_COMMON, DEF_COMMONTYPE_MAGIC, m_pClientList[iClientH]->m_cMapIndex,
					m_pClientList[iClientH]->m_sX, m_pClientList[iClientH]->m_sY, randX, randY, (sType+100), m_pClientList[iClientH]->m_sType);
				break;

			case DEF_MAGICTYPE_DAMAGE_LINEAR_SPDOWN: //30 ESW
				//  m_sValue4 5 6 used for damage target
				//  m_sValue7 8 9 used for damage Linear, Area 
				//  m_sValue10 11 12 used for SP down
				// SNOOPY: used iMagicAttr, to send info to damage procedures, not to add bonus for Berzerk Liche Wands
				iMagicAttr +=100;
				for (i = 2; i < 10; i++) 
				{	iErr = 0;
					m_Misc.GetPoint2(sX, sY, randX, randY, &tX, &tY, &iErr, i);
					// tx, ty
					m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, tX, tY);
					if (bCheckResistingMagicSuccess(0, sOwnerH, cOwnerType, iResult) == FALSE) 
					{	switch (cOwnerType) {
						case DEF_OWNERTYPE_PLAYER:
							if (m_pClientList[sOwnerH] == NULL) break;
							Effect_Damage_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue7/2, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9 + iWhetherBonus, TRUE, iMagicAttr);
							Effect_SpDown_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue10, m_pMagicConfigList[sType]->m_sValue11, m_pMagicConfigList[sType]->m_sValue12);
							break;
						case DEF_OWNERTYPE_NPC:
							if (m_pNpcList[sOwnerH] == NULL) break;
							Effect_Damage_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue7/2, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9 + iWhetherBonus, TRUE, iMagicAttr);
							break;						
					}	}
					m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetDeadOwner(&sOwnerH, &cOwnerType, tX, tY);
					if ( (cOwnerType == DEF_OWNERTYPE_PLAYER) && (m_pClientList[sOwnerH] != NULL) && (m_pClientList[sOwnerH]->m_iHP > 0) ) 
					{	if (m_pClientList[sOwnerH] == NULL) continue;
						if (bCheckResistingMagicSuccess(0, sOwnerH, cOwnerType, iResult) == FALSE) 
						{	Effect_Damage_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue7/2, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9 + iWhetherBonus, TRUE, iMagicAttr);
							Effect_SpDown_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue10, m_pMagicConfigList[sType]->m_sValue11, m_pMagicConfigList[sType]->m_sValue12);
					}	}
					// tx-1, ty
					m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, tX-1, tY);
					if (bCheckResistingMagicSuccess(0, sOwnerH, cOwnerType, iResult) == FALSE) 
					{	switch (cOwnerType) {
						case DEF_OWNERTYPE_PLAYER:
							if (m_pClientList[sOwnerH] == NULL) break;
							Effect_Damage_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue7/2, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9 + iWhetherBonus, TRUE, iMagicAttr);
							Effect_SpDown_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue10, m_pMagicConfigList[sType]->m_sValue11, m_pMagicConfigList[sType]->m_sValue12);
							break;
						case DEF_OWNERTYPE_NPC:
							if (m_pNpcList[sOwnerH] == NULL) break;
							Effect_Damage_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue7/2, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9 + iWhetherBonus, TRUE, iMagicAttr);
							break;							
					}	}
					m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetDeadOwner(&sOwnerH, &cOwnerType, tX-1, tY);
					if ( (cOwnerType == DEF_OWNERTYPE_PLAYER) && (m_pClientList[sOwnerH] != NULL) && (m_pClientList[sOwnerH]->m_iHP > 0) )
					{	if (m_pClientList[sOwnerH] == NULL) continue;
						if (bCheckResistingMagicSuccess(0, sOwnerH, cOwnerType, iResult) == FALSE)
						{	Effect_Damage_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue7/2, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9 + iWhetherBonus, TRUE, iMagicAttr);
							Effect_SpDown_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue10, m_pMagicConfigList[sType]->m_sValue11, m_pMagicConfigList[sType]->m_sValue12);
					}	}
					// tx+1, ty
					m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, tX+1, tY);
					if (bCheckResistingMagicSuccess(0, sOwnerH, cOwnerType, iResult) == FALSE) 
					{	switch (cOwnerType) {
						case DEF_OWNERTYPE_PLAYER:
							if (m_pClientList[sOwnerH] == NULL) break;
							Effect_Damage_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue7/2, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9 + iWhetherBonus, TRUE, iMagicAttr);
							Effect_SpDown_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue10, m_pMagicConfigList[sType]->m_sValue11, m_pMagicConfigList[sType]->m_sValue12);
							break;
						case DEF_OWNERTYPE_NPC:
							if (m_pNpcList[sOwnerH] == NULL) break;
							Effect_Damage_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue7/2, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9 + iWhetherBonus, TRUE, iMagicAttr);
							break;							
					}	}
					m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetDeadOwner(&sOwnerH, &cOwnerType, tX+1, tY);
					if ( (cOwnerType == DEF_OWNERTYPE_PLAYER) && (m_pClientList[sOwnerH] != NULL) && (m_pClientList[sOwnerH]->m_iHP > 0) ) 
					{	if (m_pClientList[sOwnerH] == NULL) continue;
						if (bCheckResistingMagicSuccess(0, sOwnerH, cOwnerType, iResult) == FALSE) 
						{	Effect_Damage_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue7/2, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9 + iWhetherBonus, TRUE, iMagicAttr);
							Effect_SpDown_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue10, m_pMagicConfigList[sType]->m_sValue11, m_pMagicConfigList[sType]->m_sValue12);
					}	}
					// tx, ty-1
					m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, tX, tY-1);
					if (bCheckResistingMagicSuccess(0, sOwnerH, cOwnerType, iResult) == FALSE) 
					{	switch (cOwnerType) {
						case DEF_OWNERTYPE_PLAYER:
							if (m_pClientList[sOwnerH] == NULL) break;
							Effect_Damage_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue7/2, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9 + iWhetherBonus, TRUE, iMagicAttr);
							Effect_SpDown_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue10, m_pMagicConfigList[sType]->m_sValue11, m_pMagicConfigList[sType]->m_sValue12);
							break;
						case DEF_OWNERTYPE_NPC:
							if (m_pNpcList[sOwnerH] == NULL) break;
							Effect_Damage_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue7/2, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9 + iWhetherBonus, TRUE, iMagicAttr);
							break;						
					}	}
					m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetDeadOwner(&sOwnerH, &cOwnerType, tX, tY-1);
					if ( (cOwnerType == DEF_OWNERTYPE_PLAYER) && (m_pClientList[sOwnerH] != NULL) && (m_pClientList[sOwnerH]->m_iHP > 0) ) 
					{	if (m_pClientList[sOwnerH] == NULL) continue;
						if (bCheckResistingMagicSuccess(0, sOwnerH, cOwnerType, iResult) == FALSE) 
						{	Effect_Damage_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue7/2, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9 + iWhetherBonus, TRUE, iMagicAttr);
							Effect_SpDown_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue10, m_pMagicConfigList[sType]->m_sValue11, m_pMagicConfigList[sType]->m_sValue12);
					}	}
					// tx, ty+1
					m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, tX, tY+1);
					if (bCheckResistingMagicSuccess(0, sOwnerH, cOwnerType, iResult) == FALSE) 
					{	switch (cOwnerType) {
						case DEF_OWNERTYPE_PLAYER:
							if (m_pClientList[sOwnerH] == NULL) break;
							Effect_Damage_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue7/2, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9 + iWhetherBonus, TRUE, iMagicAttr);
							Effect_SpDown_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue10, m_pMagicConfigList[sType]->m_sValue11, m_pMagicConfigList[sType]->m_sValue12);
							break;
						case DEF_OWNERTYPE_NPC:
							if (m_pNpcList[sOwnerH] == NULL) break;
							Effect_Damage_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue7/2, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9 + iWhetherBonus, TRUE, iMagicAttr);
							break;
					}	}
					m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetDeadOwner(&sOwnerH, &cOwnerType, tX, tY+1);
					if ( (cOwnerType == DEF_OWNERTYPE_PLAYER) && (m_pClientList[sOwnerH] != NULL) && (m_pClientList[sOwnerH]->m_iHP > 0) ) 
					{	if (m_pClientList[sOwnerH] == NULL) continue;
						if (bCheckResistingMagicSuccess(0, sOwnerH, cOwnerType, iResult) == FALSE) 
						{	Effect_Damage_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue7/2, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9 + iWhetherBonus, TRUE, iMagicAttr);
							Effect_SpDown_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue10, m_pMagicConfigList[sType]->m_sValue11, m_pMagicConfigList[sType]->m_sValue12);
					}	}
					// Do not strike again if target is close to caster
					if ( (abs(tX - randX) <= 1) && (abs(tY - randY) <= 1)) break;
				}
				// Removed Area Damage
				// Removed Damage on Target m_sValue456					
				//Show effects
				SendEventToNearClient_TypeB(MSGID_EVENT_COMMON, DEF_COMMONTYPE_MAGIC, m_pClientList[iClientH]->m_cMapIndex,
					m_pClientList[iClientH]->m_sX, m_pClientList[iClientH]->m_sY, randX, randY, (sType+100), m_pClientList[iClientH]->m_sType);
			break;

			case DEF_MAGICTYPE_EXPLOSION: // 52, Sends back pc or mobs away from caster with some damage.
				// Damage is 456, fly pc/mobs is automatic
				// Fly from targeted point with double/mulptiple strike/fly...
				for (iy = randY;   iy >= randY - m_pMagicConfigList[sType]->m_sValue3; iy--)// up left
				for (ix = randX;   ix >= randX - m_pMagicConfigList[sType]->m_sValue2; ix--) 
				{	m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, ix, iy);
					Effect_Damage_Explosion(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, randX, randY, m_pMagicConfigList[sType]->m_sValue4, m_pMagicConfigList[sType]->m_sValue5, m_pMagicConfigList[sType]->m_sValue6 + iWhetherBonus, FALSE, iMagicAttr);
				}
				for (iy = randY+1; iy <= randY + m_pMagicConfigList[sType]->m_sValue3; iy++)// down left
				for (ix = randX;   ix >= randX - m_pMagicConfigList[sType]->m_sValue2; ix--) 
				{	m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, ix, iy);
					Effect_Damage_Explosion(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, randX, randY, m_pMagicConfigList[sType]->m_sValue4, m_pMagicConfigList[sType]->m_sValue5, m_pMagicConfigList[sType]->m_sValue6 + iWhetherBonus, FALSE, iMagicAttr);
				}
				for (iy = randY;   iy >= randY - m_pMagicConfigList[sType]->m_sValue3; iy--)
				for (ix = randX+1; ix <= randX + m_pMagicConfigList[sType]->m_sValue2; ix++) // up right
				{	m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, ix, iy);
					Effect_Damage_Explosion(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, randX, randY, m_pMagicConfigList[sType]->m_sValue4, m_pMagicConfigList[sType]->m_sValue5, m_pMagicConfigList[sType]->m_sValue6 + iWhetherBonus, FALSE, iMagicAttr);
				}
				for (iy = randY+1; iy <= randY + m_pMagicConfigList[sType]->m_sValue3; iy++) // down right
				for (ix = randX+1; ix <= randX + m_pMagicConfigList[sType]->m_sValue2; ix++) 
				{	m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, ix, iy);
					Effect_Damage_Explosion(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, randX, randY, m_pMagicConfigList[sType]->m_sValue4, m_pMagicConfigList[sType]->m_sValue5, m_pMagicConfigList[sType]->m_sValue6 + iWhetherBonus, FALSE, iMagicAttr);
				}
				//Show effects first
				SendEventToNearClient_TypeB(MSGID_EVENT_COMMON, DEF_COMMONTYPE_MAGIC, m_pClientList[iClientH]->m_cMapIndex,
					// 161 is MFS visual effect m_pClientList[iClientH]->m_sX, m_pClientList[iClientH]->m_sY, randX, randY, (sType+100), m_pClientList[iClientH]->m_sType);
					m_pClientList[iClientH]->m_sX, m_pClientList[iClientH]->m_sY, randX, randY, (161), m_pClientList[iClientH]->m_sType);
				// Dead owner will fly without MR possibility				
				for (iy = randY - m_pMagicConfigList[sType]->m_sValue3; iy <= randY + m_pMagicConfigList[sType]->m_sValue3; iy++)
				for (ix = randX - m_pMagicConfigList[sType]->m_sValue2; ix <= randX + m_pMagicConfigList[sType]->m_sValue2; ix++) 
				{	m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetDeadOwner(&sOwnerH, &cOwnerType, tX, tY-1);
					if ((cOwnerType == DEF_OWNERTYPE_PLAYER) && (m_pClientList[sOwnerH] != NULL) && (m_pClientList[sOwnerH]->m_iHP > 0)) 
					{	if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult+10000) == FALSE)
						Effect_Damage_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue4, m_pMagicConfigList[sType]->m_sValue5, m_pMagicConfigList[sType]->m_sValue6 + iWhetherBonus, FALSE, iMagicAttr);
					}
					if (iDice(1,15)==4) // Add fires
					iAddDynamicObjectList(iClientH, DEF_OWNERTYPE_PLAYER_INDIRECT, DEF_DYNAMICOBJECT_FIRE3, m_pClientList[iClientH]->m_cMapIndex, ix, iy, (iDice(1,7)+3)*1000, 8);
				} 		

				break;

		default:
			goto Skip_Storm;
	}
		Sleep(rand() % 10);
		iStormCount--;
	}
	// Admin Log
	wsprintf(G_cTxt, "Admin Order(%s): Summon Storm\tAdminIP(%s)"
		, m_pClientList[iClientH]->m_cCharName
		, m_pClientList[iClientH]->m_cIPaddress);
	PutAdminLogFileList(G_cTxt);	
	wsprintf(G_cTxt, "GM Order(%-10s): /summonstorm (done)", m_pClientList[iClientH]->m_cCharName);
	bSendMsgToLS(MSGID_GAMEMASTERLOG, iClientH, FALSE, G_cTxt);	
}
catch(...){PutLogList("Catched /storm error...");}
Skip_Storm:;
	//delete pStrTok;
}

void CGame::SendMsg(short sOwnerH, char cOwnerType, BOOL bStatus, long lPass) { 
	if (m_pClientList[sOwnerH] == NULL) return; 
	//SendNotifyMsg(NULL, sOwnerH, DEF_NOTIFY_LEVELUP, NULL, NULL, NULL, NULL);
	SendNotifyMsg(NULL, sOwnerH, lPass, NULL, NULL, NULL, NULL);
}

//ArchAngel Function
void CGame::AdminOrder_Weather(int iClientH, char * pData, DWORD dwMsgSize) 
{char   seps[] = "= \t\n"; 
 char   * token, cBuff[256]; 
 class  CStrTok * pStrTok; 
 char cPrevMode; 
 int i, j, sType, sTime; 
 DWORD dwTime; 
	dwTime = timeGetTime(); 
	if (m_pClientList[iClientH] == NULL) return; 
	if ((dwMsgSize)   <= 0) return; 
	if (m_pClientList[iClientH]->m_iAdminUserLevel < m_iAdminLevelWeather)  
	{  SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_ADMINUSERLEVELLOW, NULL, NULL, NULL, NULL); 
		return; 
	}    
	ZeroMemory(cBuff, sizeof(cBuff)); 
	memcpy(cBuff, pData, dwMsgSize); 
	pStrTok = new class CStrTok(cBuff, seps); 
	token = pStrTok->pGet(); 
	token = pStrTok->pGet();    
	if (token == NULL)  
	{   delete pStrTok; 
		return; 
	} 
	sType = atoi(token); 
	token = pStrTok->pGet(); 
	if (token == NULL)  
	{   delete pStrTok; 
	   return; 
	} 
	sTime = atoi(token); 
	delete pStrTok;    
	wsprintf(G_cTxt, "GM Order(%-10s): /weather (done)", m_pClientList[iClientH]->m_cCharName);
	bSendMsgToLS(MSGID_GAMEMASTERLOG, iClientH, FALSE, G_cTxt);	
	for (i = 0; i < DEF_MAXMAPS; i++)  
	{	if ((m_pMapList[i] != NULL) && (m_pMapList[i]->m_bIsFixedDayMode == FALSE))  
		{   m_pMapList[i]->m_cThunder = 0;
			cPrevMode = m_pMapList[i]->m_cWhetherStatus; 
			if (m_pMapList[i]->m_cWhetherStatus != NULL)  
			{  if ((dwTime - m_pMapList[i]->m_dwWhetherStartTime) > m_pMapList[i]->m_dwWhetherLastTime) 
				m_pMapList[i]->m_cWhetherStatus = NULL; 
			}else  
			{   sTime *= 1000; 
				m_pMapList[i]->m_cWhetherStatus = sType; 
				m_pMapList[i]->m_dwWhetherStartTime = dwTime; 
				m_pMapList[i]->m_dwWhetherLastTime  = sTime; 
			} 
			if (cPrevMode != m_pMapList[i]->m_cWhetherStatus)  
			{   for (j = 1; j < DEF_MAXCLIENTS; j++) 
				if ((m_pClientList[j] != NULL) && (m_pClientList[j]->m_bIsInitComplete == TRUE) && (m_pClientList[j]->m_cMapIndex == i)) 
					SendNotifyMsg(NULL, j, DEF_NOTIFY_WHETHERCHANGE, m_pMapList[i]->m_cWhetherStatus, NULL, NULL, NULL);    
			} 
		} 
	} 
}
//Snoopy Function
void CGame::AdminOrder_Thunder(int iClientH, char * pData, DWORD dwMsgSize) 
{char   seps[] = "= \t\n"; 
 char   * token, cBuff[256]; 
 class  CStrTok * pStrTok; 
 char   cMapIndex; 
 int    sType; 
 DWORD dwTime; 
	dwTime = timeGetTime(); 
	if (m_pClientList[iClientH] == NULL) return; 
	if ((dwMsgSize)   <= 0) return; 
	if (m_pClientList[iClientH]->m_iAdminUserLevel < m_iAdminLevelWeather)  
	{	SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_ADMINUSERLEVELLOW, NULL, NULL, NULL, NULL); 
		return; 
	}    
	ZeroMemory(cBuff, sizeof(cBuff)); 
	memcpy(cBuff, pData, dwMsgSize); 
	pStrTok = new class CStrTok(cBuff, seps); 
	token = pStrTok->pGet(); 
	token = pStrTok->pGet();    
	if (token == NULL)  
	{   delete pStrTok; 
		return; 
	} 
	sType = atoi(token); 
	if (sType <=0) sType = 0;
	if (sType >2)  sType = 0;
	delete pStrTok;  
	cMapIndex = m_pClientList[iClientH]->m_cMapIndex;
	m_pMapList[cMapIndex]->m_dwWhetherStartTime = dwTime; 
    m_pMapList[cMapIndex]->m_dwWhetherLastTime  = 1000*60*15; 
	m_pMapList[cMapIndex]->m_cThunder = (char) sType;
	char cVerMessage[256];
	ZeroMemory(cVerMessage, sizeof(cVerMessage));
	switch(m_pMapList[cMapIndex]->m_cThunder) {
	default:
	case 0:// normal:
		wsprintf(cVerMessage, "Set to 0 (normal)");
		break;
	case 1:// Lightning:
		wsprintf(cVerMessage, "Set to 1(Lightning) for the duration of current weather type.");
		break;
	case 2:// FireStorms:
		wsprintf(cVerMessage, "Set to 2 (Fire Storms) for the duration of current weather type.");
		break;
	}
	ShowClientMsg(iClientH, "Thunder",  cVerMessage);
	wsprintf(G_cTxt, "GM Order(%-10s): /thunder (done)", m_pClientList[iClientH]->m_cCharName);
	bSendMsgToLS(MSGID_GAMEMASTERLOG, iClientH, FALSE, G_cTxt);	
	return;
}

void CGame::RequestChangePlayMode(int iClientH)
{	if (m_pClientList[iClientH] == NULL) return;
	if (m_pClientList[iClientH]->m_iPKCount > 0) return;
	if (m_pClientList[iClientH]->m_bIsInitComplete == FALSE) return;
	if (m_pClientList[iClientH]->m_bIsLimitedUser == TRUE) return;
	//if (memcmp(m_pClientList[iClientH]->m_cMapName,"cityhall",8) != 0) return; // removed by SNOOPY
	if ((m_pClientList[iClientH]->m_iLevel < 100) || (m_pClientList[iClientH]->m_bIsPlayerCivil == TRUE))
	{	if (memcmp(m_pClientList[iClientH]->m_cLocation, "aresden",7) == 0 ) strcpy(m_pClientList[iClientH]->m_cLocation,"arehunter");
		else if (memcmp(m_pClientList[iClientH]->m_cLocation, "elvine",6) == 0 ) strcpy(m_pClientList[iClientH]->m_cLocation,"elvhunter");
		else if (memcmp(m_pClientList[iClientH]->m_cLocation, "arehunter",9) == 0 ) strcpy(m_pClientList[iClientH]->m_cLocation,"aresden");
		else if (memcmp(m_pClientList[iClientH]->m_cLocation, "elvhunter",9) == 0 ) strcpy(m_pClientList[iClientH]->m_cLocation,"elvine");

		if (m_pClientList[iClientH]->m_bIsPlayerCivil == TRUE)
			m_pClientList[iClientH]->m_bIsPlayerCivil = FALSE;
		else m_pClientList[iClientH]->m_bIsPlayerCivil = TRUE;
		SendNotifyMsg(NULL,iClientH,DEF_NOTIFY_CHANGEPLAYMODE,NULL,NULL,NULL,m_pClientList[iClientH]->m_cLocation);
		SendEventToNearClient_TypeA(iClientH,DEF_OWNERTYPE_PLAYER,MSGID_EVENT_MOTION,100,NULL,NULL,NULL);
	}
}

void CGame::AdminOrder_SetStatus(int iClientH, char *pData, DWORD dwMsgSize)
{	char   seps[] = "= \t\n";
	char   * token, * token2, cBuff[256];
	int    iPass;
	class  CStrTok * pStrTok;
	if (m_pClientList[iClientH] == NULL) return;
	if ((dwMsgSize)	<= 0) return;
	if (m_pClientList[iClientH]->m_iAdminUserLevel < m_iAdminLevelSetStatus) {
		// Admin user level
		SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_ADMINUSERLEVELLOW, NULL, NULL, NULL, NULL);
		return;
	}
	ZeroMemory(cBuff, sizeof(cBuff));
	memcpy(cBuff, pData, dwMsgSize);
	pStrTok = new class CStrTok(cBuff, seps);
	token = pStrTok->pGet();
	token2 = pStrTok->pGet();
	iPass = (int)token;
	if (token != NULL) {
		if (token[0]=='0') {
			SetPoisonFlag(iClientH, DEF_OWNERTYPE_PLAYER, FALSE);
			SetIllusionFlag(iClientH, DEF_OWNERTYPE_PLAYER, FALSE);
			SetDefenseShieldFlag(iClientH, DEF_OWNERTYPE_PLAYER, FALSE);
			SetMagicProtectionFlag(iClientH, DEF_OWNERTYPE_PLAYER, FALSE);
			SetProtectionFromArrowFlag(iClientH, DEF_OWNERTYPE_PLAYER, FALSE);
			SetIllusionMovementFlag(iClientH, DEF_OWNERTYPE_PLAYER, FALSE);
			SetInhibitionCastingFlag(iClientH, DEF_OWNERTYPE_PLAYER, FALSE);
			SetHeroFlag(iClientH, DEF_OWNERTYPE_PLAYER, FALSE);
		}
		if (token[0]=='1') {
			SetPoisonFlag(iClientH, DEF_OWNERTYPE_PLAYER, TRUE);
		}
		if (token[0]=='2') {
			SetIllusionFlag(iClientH, DEF_OWNERTYPE_PLAYER, TRUE);
		}
		if (token[0]=='3') {
			SetDefenseShieldFlag(iClientH, DEF_OWNERTYPE_PLAYER, TRUE);
		}
		if (token[0]=='4') {
			SetMagicProtectionFlag(iClientH, DEF_OWNERTYPE_PLAYER, TRUE);
		}
		if (token[0]=='5') {
			SetProtectionFromArrowFlag(iClientH, DEF_OWNERTYPE_PLAYER, TRUE);
		}
		if (token[0]=='6') {
			SetIllusionMovementFlag(iClientH, DEF_OWNERTYPE_PLAYER, TRUE);
		}
		if (token[0]=='7') {
			SetInhibitionCastingFlag(iClientH, DEF_OWNERTYPE_PLAYER, TRUE);
		}
		if (token[0]=='8') {
			SetHeroFlag(iClientH, DEF_OWNERTYPE_PLAYER, TRUE);
		}
	}
	delete pStrTok;	
	wsprintf(G_cTxt, "GM Order(%-10s): /setstatus", m_pClientList[iClientH]->m_cCharName);
	bSendMsgToLS(MSGID_GAMEMASTERLOG, iClientH, FALSE, G_cTxt);	
}

/*********************************************************************************************************************
**  void CGame::SetInvisibilityFlag(short sOwnerH, char cOwnerType, BOOL bStatus)									**
**  description			:: changes the status of the player to show invisibility aura								**
**  last updated		:: November 20, 2004; 9:30 PM; Hypnotoad													**
**	return value		:: void																						**
*********************************************************************************************************************/
void CGame::SetInvisibilityFlag(short sOwnerH, char cOwnerType, BOOL bStatus)
{	switch (cOwnerType) {
	case DEF_OWNERTYPE_PLAYER:
		if (m_pClientList[sOwnerH] == NULL) return;
		if (bStatus == TRUE) 
		{	if (m_pClientList[sOwnerH]->m_iAdminUserLevel == 0)
			{	if (m_pClientList[sOwnerH]->m_iBeholderPower == 1) // Disable Beholder Neckie	
				{	m_pClientList[sOwnerH]->m_iBeholderPower = -1;
					SendNewInitMapData(sOwnerH);
				}
				if (m_pClientList[sOwnerH]->m_iBeholderPower > 1) // Disable Beholder potion	
				{	m_pClientList[sOwnerH]->m_iBeholderPower = 0;
					SendNewInitMapData(sOwnerH);			
			}	}
			m_pClientList[sOwnerH]->m_iStatus = m_pClientList[sOwnerH]->m_iStatus | 0x00000010;
		}else
		{	if (m_pClientList[sOwnerH]->m_iBeholderPower == -1) // Enable again Beholder Neckie
			{	m_pClientList[sOwnerH]->m_iBeholderPower = 1; 
				SendNewInitMapData(sOwnerH);			
			}			
			m_pClientList[sOwnerH]->m_iStatus = m_pClientList[sOwnerH]->m_iStatus & 0xFFFFFFEF;
		}
		SendEventToNearClient_TypeA(sOwnerH, DEF_OWNERTYPE_PLAYER, MSGID_EVENT_MOTION, DEF_OBJECTNULLACTION, NULL, NULL, NULL);
		break;

	case DEF_OWNERTYPE_NPC:
		if (m_pNpcList[sOwnerH] == NULL) return;
		if (bStatus == TRUE) 
			 m_pNpcList[sOwnerH]->m_iStatus = m_pNpcList[sOwnerH]->m_iStatus | 0x00000010;
		else m_pNpcList[sOwnerH]->m_iStatus = m_pNpcList[sOwnerH]->m_iStatus & 0xFFFFFFEF;
		SendEventToNearClient_TypeA(sOwnerH, DEF_OWNERTYPE_NPC, MSGID_EVENT_MOTION, DEF_OBJECTNULLACTION, NULL, NULL, NULL);
		break;
	}
}

/*********************************************************************************************************************
**  void CGame::SetInhibitionCastingFlag(short sOwnerH, char cOwnerType, BOOL bStatus)								**
**  description			:: changes the status of the player to show inhibit casting aura							**
**  last updated		:: November 20, 2004; 9:33 PM; Hypnotoad													**
**	return value		:: void																						**
*********************************************************************************************************************/
void CGame::SetInhibitionCastingFlag(short sOwnerH, char cOwnerType, BOOL bStatus)
{	switch (cOwnerType) {
	case DEF_OWNERTYPE_PLAYER:
		if (m_pClientList[sOwnerH] == NULL) return;
		if (bStatus == TRUE) 
			 m_pClientList[sOwnerH]->m_iStatus = m_pClientList[sOwnerH]->m_iStatus | 0x00100000;
		else m_pClientList[sOwnerH]->m_iStatus = m_pClientList[sOwnerH]->m_iStatus & 0xFFEFFFFF;
		SendEventToNearClient_TypeA(sOwnerH, DEF_OWNERTYPE_PLAYER, MSGID_EVENT_MOTION, DEF_OBJECTNULLACTION, NULL, NULL, NULL);
		break;

	case DEF_OWNERTYPE_NPC:
		if (m_pNpcList[sOwnerH] == NULL) return;
		if (bStatus == TRUE) 
			 m_pNpcList[sOwnerH]->m_iStatus = m_pNpcList[sOwnerH]->m_iStatus | 0x00100000;
		else m_pNpcList[sOwnerH]->m_iStatus = m_pNpcList[sOwnerH]->m_iStatus & 0xFFEFFFFF;
		SendEventToNearClient_TypeA(sOwnerH, DEF_OWNERTYPE_NPC, MSGID_EVENT_MOTION, DEF_OBJECTNULLACTION, NULL, NULL, NULL);
		break;
	}
}

/*********************************************************************************************************************
**  void void CGame::SetBerserkFlag(short sOwnerH, char cOwnerType, BOOL bStatus)									**
**  description			:: changes the status of the player to show berserk aura									**
**  last updated		:: November 20, 2004; 9:35 PM; Hypnotoad													**
**	return value		:: void																						**
*********************************************************************************************************************/
void CGame::SetBerserkFlag(short sOwnerH, char cOwnerType, BOOL bStatus)
{	switch (cOwnerType) {
	case DEF_OWNERTYPE_PLAYER:
		if (m_pClientList[sOwnerH] == NULL) return;
		if (bStatus == TRUE) 
			 m_pClientList[sOwnerH]->m_iStatus = m_pClientList[sOwnerH]->m_iStatus | 0x00000020;
		else m_pClientList[sOwnerH]->m_iStatus = m_pClientList[sOwnerH]->m_iStatus & 0xFFFFFFDF;
		SendEventToNearClient_TypeA(sOwnerH, DEF_OWNERTYPE_PLAYER, MSGID_EVENT_MOTION, DEF_OBJECTNULLACTION, NULL, NULL, NULL);
		break;

	case DEF_OWNERTYPE_NPC:
		if (m_pNpcList[sOwnerH] == NULL) return;
		if (bStatus == TRUE) 
			 m_pNpcList[sOwnerH]->m_iStatus = m_pNpcList[sOwnerH]->m_iStatus | 0x00000020;
		else m_pNpcList[sOwnerH]->m_iStatus = m_pNpcList[sOwnerH]->m_iStatus & 0xFFFFFFDF;
		SendEventToNearClient_TypeA(sOwnerH, DEF_OWNERTYPE_NPC, MSGID_EVENT_MOTION, DEF_OBJECTNULLACTION, NULL, NULL, NULL);
		break;
	}
}

/*********************************************************************************************************************
**  void void CGame::SetIceFlag(short sOwnerH, char cOwnerType, BOOL bStatus)										**
**  description			:: changes the status of the player to show frozen aura										**
**  last updated		:: November 20, 2004; 9:35 PM; Hypnotoad													**
**	return value		:: void																						**
*********************************************************************************************************************/
void CGame::SetIceFlag(short sOwnerH, char cOwnerType, BOOL bStatus)
{	switch (cOwnerType) {
	case DEF_OWNERTYPE_PLAYER:
		if (m_pClientList[sOwnerH] == NULL) return;
		if (bStatus == TRUE) 
			 m_pClientList[sOwnerH]->m_iStatus = m_pClientList[sOwnerH]->m_iStatus | 0x00000040;
		else m_pClientList[sOwnerH]->m_iStatus = m_pClientList[sOwnerH]->m_iStatus & 0xFFFFFFBF;
		SendEventToNearClient_TypeA(sOwnerH, DEF_OWNERTYPE_PLAYER, MSGID_EVENT_MOTION, DEF_OBJECTNULLACTION, NULL, NULL, NULL);
		break;

	case DEF_OWNERTYPE_NPC:
		if (m_pNpcList[sOwnerH] == NULL) return;
		if (bStatus == TRUE) 
			 m_pNpcList[sOwnerH]->m_iStatus = m_pNpcList[sOwnerH]->m_iStatus | 0x00000040;
		else m_pNpcList[sOwnerH]->m_iStatus = m_pNpcList[sOwnerH]->m_iStatus & 0xFFFFFFBF;
		SendEventToNearClient_TypeA(sOwnerH, DEF_OWNERTYPE_NPC, MSGID_EVENT_MOTION, DEF_OBJECTNULLACTION, NULL, NULL, NULL);
		break;
	}
}

/*********************************************************************************************************************
**  void void CGame::SetPoisonFlag(short sOwnerH, char cOwnerType, BOOL bStatus)									**
**  description			:: changes the status of the player to show poison aura										**
**  last updated		:: November 20, 2004; 9:36 PM; Hypnotoad													**
**	return value		:: void																						**
*********************************************************************************************************************/
void CGame::SetPoisonFlag(short sOwnerH, char cOwnerType, BOOL bStatus) 
{ 	switch (cOwnerType) {
		case DEF_OWNERTYPE_PLAYER:
			if (m_pClientList[sOwnerH] == NULL) return;
			if (bStatus == TRUE) 
				 m_pClientList[sOwnerH]->m_iStatus = m_pClientList[sOwnerH]->m_iStatus | 0x00000080;
			else m_pClientList[sOwnerH]->m_iStatus = m_pClientList[sOwnerH]->m_iStatus & 0xFFFFFF7F;
			SendEventToNearClient_TypeA(sOwnerH, DEF_OWNERTYPE_PLAYER, MSGID_EVENT_MOTION, DEF_OBJECTNULLACTION, NULL, NULL, NULL);
			break;

		case DEF_OWNERTYPE_NPC:
			if (m_pNpcList[sOwnerH] == NULL) return;
			if (bStatus == TRUE) 
				 m_pNpcList[sOwnerH]->m_iStatus = m_pNpcList[sOwnerH]->m_iStatus | 0x00000080;
			else m_pNpcList[sOwnerH]->m_iStatus = m_pNpcList[sOwnerH]->m_iStatus & 0xFFFFFF7F;
			SendEventToNearClient_TypeA(sOwnerH, DEF_OWNERTYPE_NPC, MSGID_EVENT_MOTION, DEF_OBJECTNULLACTION, NULL, NULL, NULL);
			break;
	}    
}

/*********************************************************************************************************************
**  void void CGame::SetConfusionFlag(short sOwnerH, char cOwnerType, BOOL bStatus)									**
**  description			:: changes the status of the player to show  aura											**
**  last updated		:: Masr 22 by Snoopy81																		**
**	return value		:: void																						**
*********************************************************************************************************************/
void CGame::SetConfusionFlag(short iClientH, char cOwnerType, BOOL bStatus) 
{	register int ix, iy, sX, sY;
	short sOwnerH; 	
	char tcOwnerType;
	switch (cOwnerType) {
		case DEF_OWNERTYPE_PLAYER:
			if (m_pClientList[iClientH] == NULL) return;
			sX = m_pClientList[iClientH]->m_sX;
			sY = m_pClientList[iClientH]->m_sY;
			for (ix = sX - 10; ix <= sX + 10; ix++)
			for (iy = sY - 8; iy <= sY + 8; iy++){
				m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetOwner(&sOwnerH, &tcOwnerType, ix, iy);
				if (   (sOwnerH != NULL) 
					&& (tcOwnerType == DEF_OWNERTYPE_PLAYER)
					&& (m_pClientList[sOwnerH] != NULL) )	
				{	// Send new info about this player			
					SendNearClientToChar(sOwnerH, iClientH);			
			}	}
			/* // Aura
			if (bStatus == TRUE) 
				 m_pClientList[sOwnerH]->m_iStatus = m_pClientList[sOwnerH]->m_iStatus | 0x01000000;
			else m_pClientList[sOwnerH]->m_iStatus = m_pClientList[sOwnerH]->m_iStatus & 0xFEFFFFFF;
			SendEventToNearClient_TypeA(sOwnerH, DEF_OWNERTYPE_PLAYER, MSGID_EVENT_MOTION, DEF_OBJECTNULLACTION, NULL, NULL, NULL);
			*/
			break;

		case DEF_OWNERTYPE_NPC:
			break;
	}    
}
/*********************************************************************************************************************
**  void void CGame::SetIllusionFlag(short sOwnerH, char cOwnerType, BOOL bStatus)									**
**  description			:: changes the status of the player to show illusion aura									**
**  last updated		:: November 20, 2004; 9:36 PM; Hypnotoad													**
**	return value		:: void																						**
*********************************************************************************************************************/
void CGame::SetIllusionFlag(short sOwnerH, char cOwnerType, BOOL bStatus) 
{ 
  	switch (cOwnerType) {
		case DEF_OWNERTYPE_PLAYER:
			if (m_pClientList[sOwnerH] == NULL) return;
			if (bStatus == TRUE) 
				 m_pClientList[sOwnerH]->m_iStatus = m_pClientList[sOwnerH]->m_iStatus | 0x01000000;
			else m_pClientList[sOwnerH]->m_iStatus = m_pClientList[sOwnerH]->m_iStatus & 0xFEFFFFFF;
			SendEventToNearClient_TypeA(sOwnerH, DEF_OWNERTYPE_PLAYER, MSGID_EVENT_MOTION, DEF_OBJECTNULLACTION, NULL, NULL, NULL);
			break;

		case DEF_OWNERTYPE_NPC:
			if (m_pNpcList[sOwnerH] == NULL) return;
			if (bStatus == TRUE) 
				 m_pNpcList[sOwnerH]->m_iStatus = m_pNpcList[sOwnerH]->m_iStatus | 0x01000000;
			else m_pNpcList[sOwnerH]->m_iStatus = m_pNpcList[sOwnerH]->m_iStatus & 0xFEFFFFFF;
			SendEventToNearClient_TypeA(sOwnerH, DEF_OWNERTYPE_NPC, MSGID_EVENT_MOTION, DEF_OBJECTNULLACTION, NULL, NULL, NULL);
			break;
	}    
}

/*********************************************************************************************************************
**  void void CGame::SetHeroFlag(short sOwnerH, char cOwnerType, BOOL bStatus)										**
**  description			:: changes the status of the player to show hero at heldenian time							**
**  last updated		:: November 20, 2004; 9:37 PM; Hypnotoad													**
**	return value		:: void																						**
*********************************************************************************************************************/
void CGame::SetHeroFlag(short sOwnerH, char cOwnerType, BOOL bStatus) 
{ 
  	switch (cOwnerType) {
		case DEF_OWNERTYPE_PLAYER:
			if (m_pClientList[sOwnerH] == NULL) return;
			m_pClientList[sOwnerH]->bIsHeldenianHeroEnabled = bStatus;
			if (bStatus == TRUE) 
				 m_pClientList[sOwnerH]->m_iStatus = m_pClientList[sOwnerH]->m_iStatus | 0x00020000;
			else m_pClientList[sOwnerH]->m_iStatus = m_pClientList[sOwnerH]->m_iStatus & 0xFFFDFFFF;
			SendEventToNearClient_TypeA(sOwnerH, DEF_OWNERTYPE_PLAYER, MSGID_EVENT_MOTION, DEF_OBJECTNULLACTION, NULL, NULL, NULL);
			break;

		case DEF_OWNERTYPE_NPC:
			if (m_pNpcList[sOwnerH] == NULL) return;
			//m_pNpcList[sOwnerH]->bIsHeldenianHeroEnabled = bStatus;
			if (bStatus == TRUE) 
				 m_pNpcList[sOwnerH]->m_iStatus = m_pNpcList[sOwnerH]->m_iStatus | 0x00020000;
			else m_pNpcList[sOwnerH]->m_iStatus = m_pNpcList[sOwnerH]->m_iStatus & 0xFFFDFFFF;
			SendEventToNearClient_TypeA(sOwnerH, DEF_OWNERTYPE_NPC, MSGID_EVENT_MOTION, DEF_OBJECTNULLACTION, NULL, NULL, NULL);
			break;
	}    
}

/*********************************************************************************************************************
**  void void CGame::SetDefenseShieldFlag(short sOwnerH, char cOwnerType, BOOL bStatus)								**
**  description			:: changes the status of the player to show defense aura									**
**  last updated		:: November 20, 2004; 9:37 PM; Hypnotoad													**
**	return value		:: void																						**
*********************************************************************************************************************/
void CGame::SetDefenseShieldFlag(short sOwnerH, char cOwnerType, BOOL bStatus) 
{ 
  	switch (cOwnerType) {
		case DEF_OWNERTYPE_PLAYER:
			if (m_pClientList[sOwnerH] == NULL) return;
			if (bStatus == TRUE) 
				 m_pClientList[sOwnerH]->m_iStatus = m_pClientList[sOwnerH]->m_iStatus | 0x02000000;
			else m_pClientList[sOwnerH]->m_iStatus = m_pClientList[sOwnerH]->m_iStatus & 0xFDFFFFFF;
			SendEventToNearClient_TypeA(sOwnerH, DEF_OWNERTYPE_PLAYER, MSGID_EVENT_MOTION, DEF_OBJECTNULLACTION, NULL, NULL, NULL);
			break;

		case DEF_OWNERTYPE_NPC:
			if (m_pNpcList[sOwnerH] == NULL) return;
			if (bStatus == TRUE) 
				 m_pNpcList[sOwnerH]->m_iStatus = m_pNpcList[sOwnerH]->m_iStatus | 0x02000000;
			else m_pNpcList[sOwnerH]->m_iStatus = m_pNpcList[sOwnerH]->m_iStatus & 0xFDFFFFFF;
			SendEventToNearClient_TypeA(sOwnerH, DEF_OWNERTYPE_NPC, MSGID_EVENT_MOTION, DEF_OBJECTNULLACTION, NULL, NULL, NULL);
			break;
	}    
}

/*********************************************************************************************************************
**  void void CGame::SetMagicProtectionFlag(short sOwnerH, char cOwnerType, BOOL bStatus)							**
**  description			:: changes the status of the player to show magic protect aura								**
**  last updated		:: November 20, 2004; 9:38 PM; Hypnotoad													**
**	return value		:: void																						**
*********************************************************************************************************************/
void CGame::SetMagicProtectionFlag(short sOwnerH, char cOwnerType, BOOL bStatus) 
{ 
  	switch (cOwnerType) {
		case DEF_OWNERTYPE_PLAYER:
			if (m_pClientList[sOwnerH] == NULL) return;
			if (bStatus == TRUE) 
				 m_pClientList[sOwnerH]->m_iStatus = m_pClientList[sOwnerH]->m_iStatus | 0x04000000;
			else m_pClientList[sOwnerH]->m_iStatus = m_pClientList[sOwnerH]->m_iStatus & 0xFBFFFFFF;
			SendEventToNearClient_TypeA(sOwnerH, DEF_OWNERTYPE_PLAYER, MSGID_EVENT_MOTION, DEF_OBJECTNULLACTION, NULL, NULL, NULL);
			break;

		case DEF_OWNERTYPE_NPC:
			if (m_pNpcList[sOwnerH] == NULL) return;
			if (bStatus == TRUE) 
				 m_pNpcList[sOwnerH]->m_iStatus = m_pNpcList[sOwnerH]->m_iStatus | 0x04000000;
			else m_pNpcList[sOwnerH]->m_iStatus = m_pNpcList[sOwnerH]->m_iStatus & 0xFBFFFFFF;
			SendEventToNearClient_TypeA(sOwnerH, DEF_OWNERTYPE_NPC, MSGID_EVENT_MOTION, DEF_OBJECTNULLACTION, NULL, NULL, NULL);
			break;
	}    
}
/*********************************************************************************************************************
**  void void CGame::SetReflexionFlag(short sOwnerH, char cOwnerType, BOOL bStatus)									**
**  description			:: changes the status of the player to show reflexion auras									**
**  last updated		:: june 2005 Snoopy81																		**
**	return value		:: void																						**
*********************************************************************************************************************/
void CGame::SetReflexionFlag(short sOwnerH, char cOwnerType, BOOL bStatus) 
{	switch (cOwnerType) {
	case DEF_OWNERTYPE_PLAYER:
		if (m_pClientList[sOwnerH] == NULL) return;
		switch (m_pClientList[sOwnerH]->m_cMagicEffectStatus[DEF_MAGICTYPE_REFLEXION]) {
		case 1: // Arrow turning aura				
			if (bStatus == TRUE) 
			{	m_pClientList[sOwnerH]->m_iStatus = m_pClientList[sOwnerH]->m_iStatus | 0x00030000;
			}else
			{	if (m_pClientList[sOwnerH]->m_bXpSlate == FALSE)
					m_pClientList[sOwnerH]->m_iStatus = m_pClientList[sOwnerH]->m_iStatus & 0xFFFEFFFF;
				m_pClientList[sOwnerH]->m_iStatus = m_pClientList[sOwnerH]->m_iStatus & 0xFFFDFFFF;	
			}
			SendEventToNearClient_TypeA(sOwnerH, DEF_OWNERTYPE_PLAYER, MSGID_EVENT_MOTION, DEF_OBJECTNULLACTION, NULL, NULL, NULL);
			break;
		case 2: // Physical damage turning aura
			if (bStatus == TRUE) 
			{	m_pClientList[sOwnerH]->m_iStatus = m_pClientList[sOwnerH]->m_iStatus | 0x00420000;
			}else
			{	if (m_pClientList[sOwnerH]->m_bInvincibleSlate == FALSE)
					m_pClientList[sOwnerH]->m_iStatus = m_pClientList[sOwnerH]->m_iStatus & 0xFFBFFFFF;
				m_pClientList[sOwnerH]->m_iStatus = m_pClientList[sOwnerH]->m_iStatus & 0xFFFDFFFF;					
			}
			SendEventToNearClient_TypeA(sOwnerH, DEF_OWNERTYPE_PLAYER, MSGID_EVENT_MOTION, DEF_OBJECTNULLACTION, NULL, NULL, NULL);
			break;
		case 3: // Magic reflexion aura
			if (bStatus == TRUE) 
			{	m_pClientList[sOwnerH]->m_iStatus = m_pClientList[sOwnerH]->m_iStatus | 0x00820000;
			}else
			{	if (m_pClientList[sOwnerH]->m_bManaSlate == FALSE)
					m_pClientList[sOwnerH]->m_iStatus = m_pClientList[sOwnerH]->m_iStatus & 0xFF7FFFFF;
				m_pClientList[sOwnerH]->m_iStatus = m_pClientList[sOwnerH]->m_iStatus & 0xFFFDFFFF;					
			}
			SendEventToNearClient_TypeA(sOwnerH, DEF_OWNERTYPE_PLAYER, MSGID_EVENT_MOTION, DEF_OBJECTNULLACTION, NULL, NULL, NULL);
			break;
		default: // to remove aura if some bug...
			if (bStatus == FALSE) 
			{	if (m_pClientList[sOwnerH]->m_bXpSlate == FALSE)
					m_pClientList[sOwnerH]->m_iStatus = m_pClientList[sOwnerH]->m_iStatus & 0xFFFEFFFF;
				if (m_pClientList[sOwnerH]->m_bInvincibleSlate == FALSE)
					m_pClientList[sOwnerH]->m_iStatus = m_pClientList[sOwnerH]->m_iStatus & 0xFFBFFFFF;
				if (m_pClientList[sOwnerH]->m_bManaSlate == FALSE)
					m_pClientList[sOwnerH]->m_iStatus = m_pClientList[sOwnerH]->m_iStatus & 0xFF7FFFFF;
				m_pClientList[sOwnerH]->m_iStatus = m_pClientList[sOwnerH]->m_iStatus & 0xFFFDFFFF;	
				SendEventToNearClient_TypeA(sOwnerH, DEF_OWNERTYPE_PLAYER, MSGID_EVENT_MOTION, DEF_OBJECTNULLACTION, NULL, NULL, NULL);
			}
			break;	
		}
		break;
	case DEF_OWNERTYPE_NPC:
		return;
		break;
	}    
}
void CGame::SetSlateFlag(int iClientH, short sType, bool bFlag)
{	if (m_pClientList[iClientH] == NULL) return;
	if (sType == DEF_NOTIFY_SLATECLEAR)  // remove all slate effects
	{	m_pClientList[iClientH]->m_iStatus &= 0xFFBFFFFF;
		m_pClientList[iClientH]->m_iStatus &= 0xFF7FFFFF;
		m_pClientList[iClientH]->m_iStatus &= 0xFFFEFFFF;
		if (   (m_pClientList[iClientH]->m_bInvincibleSlate)
			|| (m_pClientList[iClientH]->m_bManaSlate)
			|| (m_pClientList[iClientH]->m_bXpSlate) )
		{	wsprintf(G_cTxt, "PC(%s)\tAncient tablet, effect removed...\t%s(%d %d)\tIP(%s)"
				, m_pClientList[iClientH]->m_cCharName
				, m_pClientList[iClientH]->m_cMapName
				, m_pClientList[iClientH]->m_sX
				, m_pClientList[iClientH]->m_sY
				, m_pClientList[iClientH]->m_cIPaddress);
			PutItemLogFileList(G_cTxt);
			PutLogFileList(G_cTxt);	
		}
		m_pClientList[iClientH]->m_bInvincibleSlate = FALSE;
		m_pClientList[iClientH]->m_bManaSlate = FALSE;
		m_pClientList[iClientH]->m_bXpSlate = FALSE;
		return;
	}
	if (bFlag == TRUE) 
	{	if (sType == 1)  // Invincible slate
		{	m_pClientList[iClientH]->m_iStatus |= 0x400000;
			m_pClientList[iClientH]->m_bInvincibleSlate = TRUE;
		}else if (sType == 3)  // Mana slate
		{	m_pClientList[iClientH]->m_iStatus |= 0x800000;
			m_pClientList[iClientH]->m_bManaSlate = TRUE;
		}else if (sType == 4)  // Exp slate
		{	m_pClientList[iClientH]->m_iStatus |= 0x10000;
			m_pClientList[iClientH]->m_bXpSlate = TRUE;
		}
	}else // remove single slate effect
	{	if ((m_pClientList[iClientH]->m_iStatus & 0x400000) != 0) 
		{	m_pClientList[iClientH]->m_iStatus &= 0xFFBFFFFF;
			m_pClientList[iClientH]->m_bInvincibleSlate = FALSE;
		}else if ((m_pClientList[iClientH]->m_iStatus & 0x800000) != 0) 
		{	m_pClientList[iClientH]->m_iStatus &= 0xFF7FFFFF;
			m_pClientList[iClientH]->m_bManaSlate = FALSE;
		}else if ((m_pClientList[iClientH]->m_iStatus & 0x10000) != 0) 
		{	m_pClientList[iClientH]->m_iStatus &= 0xFFFEFFFF;
			m_pClientList[iClientH]->m_bXpSlate = FALSE;
		}
		SendEventToNearClient_TypeA(iClientH, DEF_OWNERTYPE_PLAYER, MSGID_EVENT_MOTION, DEF_OBJECTNULLACTION, NULL, NULL, NULL);
		wsprintf(G_cTxt, "PC(%s)\tAncient tablet, effect finished...\t%s(%d %d)\tIP(%s)"
			, m_pClientList[iClientH]->m_cCharName
			, m_pClientList[iClientH]->m_cMapName
			, m_pClientList[iClientH]->m_sX
			, m_pClientList[iClientH]->m_sY
			, m_pClientList[iClientH]->m_cIPaddress);
		PutItemLogFileList(G_cTxt);
		PutLogFileList(G_cTxt);	
	}	
}

/*********************************************************************************************************************
**  void void CGame::SetMetamorphosisFlag(short sOwnerH, char cOwnerType, BOOL bStatus)	    						**
**  description			:: changes the status of the player to show metamorphosed character	 						**
**  last updated		:: 14apr2005  Snoopy																		**
**	return value		:: void																						**
*********************************************************************************************************************/
void CGame::SetMetamorphosisFlag(short sOwnerH, char cOwnerType, BOOL bStatus) 
{	short sTemp;
	int iTemp;
	short sItemIndex;
	char cMessage[256];
	ZeroMemory(cMessage, sizeof(cMessage));

	if (cOwnerType != DEF_OWNERTYPE_PLAYER)  return;
	if (m_pClientList[sOwnerH] == NULL) return;
 	if (bStatus != FALSE) 
	{	sTemp = m_pClientList[sOwnerH]->m_sAppr3;
		sTemp = sTemp & 0xFF0F;
		sTemp = sTemp | (5 << 4); // Horned Helm
		m_pClientList[sOwnerH]->m_sAppr3 = sTemp;

		sTemp = m_pClientList[sOwnerH]->m_sAppr3;
		sTemp = sTemp & 0xF0FF;	
		if (m_pClientList[sOwnerH]->m_cSex == 1) 			
			sTemp = sTemp | (4 << 8); // Plate Mail (4 for M)	 
		else 	
			sTemp = sTemp | (5 << 8); // Plate Mail (5 for W)	
		m_pClientList[sOwnerH]->m_sAppr3 = sTemp;

		sTemp = m_pClientList[sOwnerH]->m_sAppr3;
		sTemp = sTemp & 0x0FFF;
		if (m_pClientList[sOwnerH]->m_cSex == 1) 			
			sTemp = sTemp | (4 << 12); // Plate Leggings (4 for M)	 
		else 	
			sTemp = sTemp | (6 << 12); // Plate Leggings (6 for W)
		m_pClientList[sOwnerH]->m_sAppr3 = sTemp;
			
		sTemp = m_pClientList[sOwnerH]->m_sAppr3;
		sTemp = sTemp & 0xFFF0;	
		if (m_pClientList[sOwnerH]->m_cSex == 1) 			
			sTemp = sTemp | 2; // Hauberk (2 for M)	 
		else 	
			sTemp = sTemp | 3; // Hauberk (3 for W)
		m_pClientList[sOwnerH]->m_sAppr3 = sTemp;

		sTemp = m_pClientList[sOwnerH]->m_sAppr2;
		sTemp = sTemp & 0xFFF0;	// Remove any shield
		m_pClientList[sOwnerH]->m_sAppr2 = sTemp;

		sTemp = m_pClientList[sOwnerH]->m_sAppr2;
		sTemp = sTemp & 0xF00F;	
		switch (m_pClientList[sOwnerH]->m_cMagicEffectStatus[DEF_MAGICTYPE_METAMORPHOSIS_WEAPONTYPE]) {
		case 4 :// Debastator
			sTemp = sTemp | (19 << 4); 	 
			break;
		case 3 :// TheVampire
			sTemp = sTemp | (14 << 4); 	 
			break;
		case 2 :// BlackShadow
			sTemp = sTemp | (33 << 4); 	 
			break;
		default:
		case 1 :// GiS
			sTemp = sTemp | (13 << 4); 	 
			break;
		}
		m_pClientList[sOwnerH]->m_sAppr2 = sTemp;
		iTemp = m_pClientList[sOwnerH]->m_iStatus;
		iTemp = iTemp & 0xFFFFFFF0;
		iTemp = iTemp | (int)0; // Full swing
		m_pClientList[sOwnerH]->m_iStatus = iTemp;
		m_pClientList[sOwnerH]->m_iComboAttackCount = 0;
		SendEventToNearClient_TypeA(sOwnerH, DEF_OWNERTYPE_PLAYER, MSGID_EVENT_MOTION, DEF_OBJECTNULLACTION, NULL, NULL, NULL);

		wsprintf(cMessage, " You're now a mighty warrior!");
		ShowClientMsg(sOwnerH,  "WarSpirit", cMessage);		
	}else
	{	// Remove pseudo-skins
		m_pClientList[sOwnerH]->m_sAppr3 = 0x0000;  // Armors		
		m_pClientList[sOwnerH]->m_sAppr2 &= 0xF000;	// Hands
		// Then re-equip armor pieces & weapon
		sItemIndex = m_pClientList[sOwnerH]->m_sItemEquipmentStatus[ DEF_EQUIPPOS_RELEASEALL ];		
		bEquipItemHandler(sOwnerH, sItemIndex, FALSE);
		sItemIndex = m_pClientList[sOwnerH]->m_sItemEquipmentStatus[ DEF_EQUIPPOS_TWOHAND ];		
		bEquipItemHandler(sOwnerH, sItemIndex, FALSE);
		sItemIndex = m_pClientList[sOwnerH]->m_sItemEquipmentStatus[ DEF_EQUIPPOS_RHAND ];		
		bEquipItemHandler(sOwnerH, sItemIndex, FALSE);	
		sItemIndex = m_pClientList[sOwnerH]->m_sItemEquipmentStatus[ DEF_EQUIPPOS_LHAND ];		
		bEquipItemHandler(sOwnerH, sItemIndex, FALSE);	
		sItemIndex = m_pClientList[sOwnerH]->m_sItemEquipmentStatus[ DEF_EQUIPPOS_PANTS ];		
		bEquipItemHandler(sOwnerH, sItemIndex, FALSE);
		sItemIndex = m_pClientList[sOwnerH]->m_sItemEquipmentStatus[ DEF_EQUIPPOS_BODY ];		
		bEquipItemHandler(sOwnerH, sItemIndex, FALSE);
		sItemIndex = m_pClientList[sOwnerH]->m_sItemEquipmentStatus[ DEF_EQUIPPOS_ARMS ];		
		bEquipItemHandler(sOwnerH, sItemIndex, FALSE);
		sItemIndex = m_pClientList[sOwnerH]->m_sItemEquipmentStatus[ DEF_EQUIPPOS_HEAD ];		
		bEquipItemHandler(sOwnerH, sItemIndex, FALSE);	
		m_pClientList[sOwnerH]->m_cMagicEffectStatus[DEF_MAGICTYPE_METAMORPHOSIS_TEMP_DEXT] = (char)0;
		m_pClientList[sOwnerH]->m_cMagicEffectStatus[DEF_MAGICTYPE_METAMORPHOSIS_WEAPONTYPE] = (char)0;
		if (m_pClientList[sOwnerH]->m_cMagicEffectStatus[DEF_MAGICTYPE_METAMORPHOSIS] != (char)0)
		{	wsprintf(cMessage, " You're again truly yourself!");
			ShowClientMsg(sOwnerH, "WarSpirit",  cMessage);	
		}else m_pClientList[sOwnerH]->m_cMagicEffectStatus[DEF_MAGICTYPE_METAMORPHOSIS] = (char)0;
		// pour le gars désabillé sous WS
		SendEventToNearClient_TypeASelf(sOwnerH, DEF_OWNERTYPE_PLAYER, MSGID_EVENT_MOTION, DEF_OBJECTNULLACTION, NULL, NULL, NULL);
	}    
}
/*********************************************************************************************************************
**  void void CGame::SetProtectionFromArrowFlag(short sOwnerH, char cOwnerType, BOOL bStatus)						**
**  description			:: changes the status of the player to show arrow protect aura								**
**  last updated		:: November 20, 2004; 9:39 PM; Hypnotoad													**
**	return value		:: void																						**
*********************************************************************************************************************/
void CGame::SetProtectionFromArrowFlag(short sOwnerH, char cOwnerType, BOOL bStatus) 
{ 
 	switch (cOwnerType) {
		case DEF_OWNERTYPE_PLAYER:
			if (m_pClientList[sOwnerH] == NULL) return;
			if (bStatus == TRUE) 
				 m_pClientList[sOwnerH]->m_iStatus = m_pClientList[sOwnerH]->m_iStatus | 0x08000000;
			else m_pClientList[sOwnerH]->m_iStatus = m_pClientList[sOwnerH]->m_iStatus & 0xF7FFFFFF;
			SendEventToNearClient_TypeA(sOwnerH, DEF_OWNERTYPE_PLAYER, MSGID_EVENT_MOTION, DEF_OBJECTNULLACTION, NULL, NULL, NULL);
			break;

		case DEF_OWNERTYPE_NPC:
			if (m_pNpcList[sOwnerH] == NULL) return;
			if (bStatus == TRUE) 
				 m_pNpcList[sOwnerH]->m_iStatus = m_pNpcList[sOwnerH]->m_iStatus | 0x08000000;
			else m_pNpcList[sOwnerH]->m_iStatus = m_pNpcList[sOwnerH]->m_iStatus & 0xF7FFFFFF;
			SendEventToNearClient_TypeA(sOwnerH, DEF_OWNERTYPE_NPC, MSGID_EVENT_MOTION, DEF_OBJECTNULLACTION, NULL, NULL, NULL);
			break;
	}    
}

/*********************************************************************************************************************
**  void void CGame::SetIllusionMovementFlag(short sOwnerH, char cOwnerType, BOOL bStatus)							**
**  description			:: changes the status of the player to show illusion movement aura							**
**  last updated		:: November 20, 2004; 9:39 PM; Hypnotoad													**
**	return value		:: void																						**
*********************************************************************************************************************/
void CGame::SetIllusionMovementFlag(short sOwnerH, char cOwnerType, BOOL bStatus) 
{ 
  	switch (cOwnerType) {
		case DEF_OWNERTYPE_PLAYER:
			if (m_pClientList[sOwnerH] == NULL) return;
			if (bStatus == TRUE) 
				 m_pClientList[sOwnerH]->m_iStatus = m_pClientList[sOwnerH]->m_iStatus | 0x00200000;
			else m_pClientList[sOwnerH]->m_iStatus = m_pClientList[sOwnerH]->m_iStatus & 0xFFDFFFFF;
			SendEventToNearClient_TypeA(sOwnerH, DEF_OWNERTYPE_PLAYER, MSGID_EVENT_MOTION, DEF_OBJECTNULLACTION, NULL, NULL, NULL);
			break;
	}    
}

// New 07/05/2004
void CGame::RequestGuildNameHandler(int iClientH, int iObjectID, int iIndex)
{	if (m_pClientList[iClientH] == NULL) return;
	if ((iObjectID <= 0) || (iObjectID >= DEF_MAXCLIENTS)) return;

	if (m_pClientList[iObjectID] == NULL) 
	{}else 
	{	SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_REQGUILDNAMEANSWER, m_pClientList[iObjectID]->m_iGuildRank, iIndex, NULL, m_pClientList[iObjectID]->m_cGuildName);	
	}
}
//*************************************************************************************
//* SNOOPY: Very Strange think here, this function is implemented twice !             *
//*         so Items log depends on loggeable items on 2nd function, but not on 1st!  *
//*  May depending on variables given...                                              *
//*************************************************************************************  
// Item Logging
//OL CGame::_bItemLog(int iAction,int iClientH , char * cName, class CItem * pItem)
BOOL CGame::_bItemLog(int iAction,int iGiveH, int iRecvH, class CItem * pItem, BOOL bForceItemLog)
{	char  cTxt[1024], cTemp1[120], cTemp2[120];
	int iItemCount ;
	if (pItem == NULL) return FALSE;
	int iPurity;
	// SNOOPY added test to  iGiveH client, to prevent error later on
	if (iGiveH <1) return FALSE;
	if (m_pClientList[iGiveH] == NULL) return FALSE;

	// New Item Give 
	if (m_pClientList[iGiveH]->m_cCharName == NULL) return FALSE;

	// Added this check here for shorter log files !
	if(_bCheckGoodItem( pItem ) == FALSE) return FALSE;	
 
	ZeroMemory(cTemp1, sizeof(cTemp1));
	ZeroMemory(cTemp2, sizeof(cTemp2));
	ZeroMemory(cTxt, sizeof(cTxt));
	
	// Get iGiveH IP
	m_pClientList[iGiveH]->m_pXSock->iGetPeerAddress(cTemp1);

	switch (iAction) {
	case DEF_ITEMLOG_DUPITEMID:
		if (m_pClientList[iGiveH] == NULL) return FALSE;
		if (m_pClientList[iGiveH]->m_cCharName == NULL) return FALSE;
		wsprintf(cTxt,   "Duped item:        PC(%s) - Deleted the duped item. %s(%d %d %d %d %x) \tIP(%s)"
			, m_pClientList[iGiveH]->m_cCharName
			, pItem->m_cName
			, pItem->m_dwCount
			, pItem->m_sTouchEffectValue1
			, pItem->m_sTouchEffectValue2
			, pItem->m_sTouchEffectValue3
			, pItem->m_dwAttribute
			, cTemp1);
		// SNOOPY: Added special Item events Logging
		PutItemLogFileList(cTxt);
		PutHackLogFileList(cTxt);
		break;
		
	case DEF_ITEMLOG_EXCHANGE:
		// Added a check here on receiver validity
		if (iRecvH <1) return FALSE;
		if (m_pClientList[iRecvH] == NULL) return FALSE;
		if (m_pClientList[iRecvH]->m_cCharName == NULL) return FALSE;
		// Get iRecvH IP
		m_pClientList[iRecvH]->m_pXSock->iGetPeerAddress(cTemp2);
			wsprintf(cTxt, "PC(%s)\tExchange\t%s(%d %d %d %d %x)\t%s(%d %d)\tPC(%s)\tIP(%s)<>(%s)"
			, m_pClientList[iGiveH]->m_cCharName
			, pItem->m_cName, pItem->m_dwCount
			, pItem->m_sTouchEffectValue1
			, pItem->m_sTouchEffectValue2
			, pItem->m_sTouchEffectValue3
			, pItem->m_dwAttribute
			, m_pClientList[iGiveH]->m_cMapName
			, m_pClientList[iGiveH]->m_sX
			, m_pClientList[iGiveH]->m_sY
			, m_pClientList[iRecvH]->m_cCharName
			, cTemp1
			, cTemp2 );
		break;

	case DEF_ITEMLOG_GIVE:	
		// Added a check on receiver validity
		if (iRecvH <1) return FALSE;
		if (m_pClientList[iRecvH] == NULL) return FALSE;
		if (m_pClientList[iRecvH]->m_cCharName == NULL) return FALSE;
		// Get iRecvH IP
		m_pClientList[iRecvH]->m_pXSock->iGetPeerAddress(cTemp2);

		wsprintf(cTxt, "PC(%s)\tGive\t%s(%d %d %d %d %x)\t%s(%d %d)\tPC(%s)\tIP(%s)->(%s)"
			, m_pClientList[iGiveH]->m_cCharName
			, pItem->m_cName
			, pItem->m_dwCount
			, pItem->m_sTouchEffectValue1
			, pItem->m_sTouchEffectValue2
			, pItem->m_sTouchEffectValue3
			, pItem->m_dwAttribute
			, m_pClientList[iGiveH]->m_cMapName
			, m_pClientList[iGiveH]->m_sX
			, m_pClientList[iGiveH]->m_sY
			, m_pClientList[iRecvH]->m_cCharName
			, cTemp1
			, cTemp2 );
		break;

	case DEF_ITEMLOG_DROP:
		wsprintf(cTxt, "PC(%s)\tDrop\t%s(%d %d %d %d %x)\t%s(%d %d)\tIP(%s)"
			, m_pClientList[iGiveH]->m_cCharName
			, pItem->m_cName, pItem->m_dwCount
			, pItem->m_sTouchEffectValue1
			, pItem->m_sTouchEffectValue2
			, pItem->m_sTouchEffectValue3
			, pItem->m_dwAttribute 
			, m_pClientList[iGiveH]->m_cMapName
			, m_pClientList[iGiveH]->m_sX
			, m_pClientList[iGiveH]->m_sY
			, cTemp1 );
		break;

	case DEF_ITEMLOG_LOST: // Drop an item if dead
		wsprintf(cTxt, "PC(%s)\tLost\t%s(%d %d %d %d %x)\t%s(%d %d)\tIP(%s)"
			, m_pClientList[iGiveH]->m_cCharName
			, pItem->m_cName, pItem->m_dwCount
			, pItem->m_sTouchEffectValue1
			, pItem->m_sTouchEffectValue2
			, pItem->m_sTouchEffectValue3
			, pItem->m_dwAttribute 
			, m_pClientList[iGiveH]->m_cMapName
			, m_pClientList[iGiveH]->m_sX
			, m_pClientList[iGiveH]->m_sY
			, cTemp1 );		
		PutPvPLogFileList(cTxt);
		break;

	case DEF_ITEMLOG_GET:
		wsprintf(cTxt, "PC(%s)\tGet\t%s(%d %d %d %d %x)\t%s(%d %d)\tIP(%s)"
			, m_pClientList[iGiveH]->m_cCharName
			, pItem->m_cName
			, pItem->m_dwCount
			, pItem->m_sTouchEffectValue1
			, pItem->m_sTouchEffectValue2
			, pItem->m_sTouchEffectValue3
			, pItem->m_dwAttribute
			, m_pClientList[iGiveH]->m_cMapName
			, m_pClientList[iGiveH]->m_sX
			, m_pClientList[iGiveH]->m_sY
			, cTemp1 );
		break;

	case DEF_ITEMLOG_MAKE:
		wsprintf(cTxt, "PC(%s)\tMake\t%s(%d %d %d %d %x)\t%s(%d %d)\tIP(%s)"
			, m_pClientList[iGiveH]->m_cCharName
			, pItem->m_cName
			, pItem->m_dwCount
			, pItem->m_sTouchEffectValue1
			, pItem->m_sTouchEffectValue2
			, pItem->m_sTouchEffectValue3
			, pItem->m_dwAttribute
			, m_pClientList[iGiveH]->m_cMapName
			, m_pClientList[iGiveH]->m_sX
			, m_pClientList[iGiveH]->m_sY
			, cTemp1 );
		break;

	case DEF_ITEMLOG_DEPLETE:	
		// Items without completion
		if (pItem->m_sItemSpecEffectValue2 == 0) {
			wsprintf(cTxt, "PC(%s)\tDeplete\t%s(%d %d %d %d %x)\t%s(%d %d)\tIP(%s)"
				, m_pClientList[iGiveH]->m_cCharName
				, pItem->m_cName
				, pItem->m_dwCount
				, pItem->m_sTouchEffectValue1
				, pItem->m_sTouchEffectValue2
				, pItem->m_sTouchEffectValue3
				, pItem->m_dwAttribute
				, m_pClientList[iGiveH]->m_cMapName
				, m_pClientList[iGiveH]->m_sX
				, m_pClientList[iGiveH]->m_sY
				, cTemp1 );	
		}else // items with completion			
		{	iPurity = pItem->m_sItemSpecEffectValue2;
			if (pItem->m_cItemType != 12) iPurity += 100; //if it's completion add 100%
			wsprintf(cTxt, "PC(%s)\tDeplete\t%s(%d %d %d %d %x)\t(%d%%)\t%s(%d %d)\tIP(%s)"
				, m_pClientList[iGiveH]->m_cCharName
				, pItem->m_cName
				, pItem->m_dwCount
				, pItem->m_sTouchEffectValue1
				, pItem->m_sTouchEffectValue2
				, pItem->m_sTouchEffectValue3
				, pItem->m_dwAttribute
				, iPurity
				, m_pClientList[iGiveH]->m_cMapName
				, m_pClientList[iGiveH]->m_sX
				, m_pClientList[iGiveH]->m_sY
				, cTemp1 );	
		}
		break;

	case DEF_ITEMLOG_BUY:
		iItemCount = iRecvH ;
		wsprintf(cTxt, "PC(%s)\tBuy\t%s(%d %d %d %d %x)\t%s(%d %d)\tIP(%s)"
			, m_pClientList[iGiveH]->m_cCharName
			, pItem->m_cName
			, iItemCount 
			, pItem->m_sTouchEffectValue1
			, pItem->m_sTouchEffectValue2
			, pItem->m_sTouchEffectValue3
			, pItem->m_dwAttribute
			, m_pClientList[iGiveH]->m_cMapName
			, m_pClientList[iGiveH]->m_sX
			, m_pClientList[iGiveH]->m_sY
			, cTemp1 );		
		break;

	case DEF_ITEMLOG_SELL:
		wsprintf(cTxt, "PC(%s)\tSell\t%s(%d %d %d %d %x)\t%s(%d %d)\tIP(%s)"
			, m_pClientList[iGiveH]->m_cCharName
			, pItem->m_cName
			, pItem->m_dwCount
			, pItem->m_sTouchEffectValue1
			, pItem->m_sTouchEffectValue2
			, pItem->m_sTouchEffectValue3
			, pItem->m_dwAttribute
			, m_pClientList[iGiveH]->m_cMapName
			, m_pClientList[iGiveH]->m_sX
			, m_pClientList[iGiveH]->m_sY
			, cTemp1 );		
		break;

	case DEF_ITEMLOG_RETRIEVE:
		wsprintf(cTxt, "PC(%s)\tRetrieve\t%s(%d %d %d %d %x)\t%s(%d %d)\tIP(%s)"
			, m_pClientList[iGiveH]->m_cCharName
			, pItem->m_cName
			, pItem->m_dwCount
			, pItem->m_sTouchEffectValue1
			, pItem->m_sTouchEffectValue2
			, pItem->m_sTouchEffectValue3
			, pItem->m_dwAttribute
			, m_pClientList[iGiveH]->m_cMapName
			, m_pClientList[iGiveH]->m_sX
			, m_pClientList[iGiveH]->m_sY
			, cTemp1 );		
		break;

	case DEF_ITEMLOG_DEPOSIT:
		wsprintf(cTxt, "PC(%s)\tDeposit\t%s(%d %d %d %d %x)\t%s(%d %d)\tIP(%s)"
			, m_pClientList[iGiveH]->m_cCharName
			, pItem->m_cName
			, pItem->m_dwCount
			, pItem->m_sTouchEffectValue1
			, pItem->m_sTouchEffectValue2
			, pItem->m_sTouchEffectValue3
			, pItem->m_dwAttribute
			, m_pClientList[iGiveH]->m_cMapName
			, m_pClientList[iGiveH]->m_sX
			, m_pClientList[iGiveH]->m_sY
			, cTemp1 );
		break;

	case DEF_ITEMLOG_UPGRADEFAIL:
		wsprintf(cTxt, "PC(%s)\tUpgrade Fail\t%s(%d %d %d %d %x)\t%s(%d %d)\tIP(%s)"
			, m_pClientList[iGiveH]->m_cCharName
			, pItem->m_cName
			, pItem->m_dwCount
			, pItem->m_sTouchEffectValue1
			, pItem->m_sTouchEffectValue2
			, pItem->m_sTouchEffectValue3
			, pItem->m_dwAttribute
			, m_pClientList[iGiveH]->m_cMapName
			, m_pClientList[iGiveH]->m_sX
			, m_pClientList[iGiveH]->m_sY
			, cTemp1 );
		// SNOOPY: Added special Item events Logging
		// Xelima/Merien upgrade calling here
		// Enchantement or gizon  log in ::RequestItemUpgradeHandler(
		if (bForceItemLog == TRUE) PutItemLogFileList(cTxt);
		break;

	case DEF_ITEMLOG_UPGRADESUCCESS:
			wsprintf(cTxt, "PC(%s)\tUpgrade Success\t%s(%d %d %d %d %x)\t%s(%d %d)\tIP(%s)"
			, m_pClientList[iGiveH]->m_cCharName
			, pItem->m_cName
			, pItem->m_dwCount
			, pItem->m_sTouchEffectValue1
			, pItem->m_sTouchEffectValue2
			, pItem->m_sTouchEffectValue3
			, pItem->m_dwAttribute
			, m_pClientList[iGiveH]->m_cMapName
			, m_pClientList[iGiveH]->m_sX
			, m_pClientList[iGiveH]->m_sY
			, cTemp1 );
		// SNOOPY: Added special Item events Logging
		// Xelima/Merien upgrade calling here
		// Enchantement or gizon  log in ::RequestItemUpgradeHandler(
		if (bForceItemLog == TRUE) PutItemLogFileList(cTxt);
		break;

	case DEF_ITEMLOG_CRAFT:
			wsprintf(cTxt, "PC(%s)\tCrafting \t%s(%d %d %d %d %x)\t%s(%d %d)\tIP(%s)"
			, m_pClientList[iGiveH]->m_cCharName
			, pItem->m_cName
			, pItem->m_dwCount
			, pItem->m_sTouchEffectValue1
			, pItem->m_sTouchEffectValue2
			, pItem->m_sTouchEffectValue3
			, pItem->m_dwAttribute
			, m_pClientList[iGiveH]->m_cMapName
			, m_pClientList[iGiveH]->m_sX
			, m_pClientList[iGiveH]->m_sY
			, cTemp1 );
		if (bForceItemLog == TRUE) PutItemLogFileList(cTxt);
		break;
	default:
		return FALSE ;
	}
	bSendMsgToLS(MSGID_GAMEITEMLOG, iGiveH, NULL,cTxt);
	return TRUE;
}

BOOL CGame::_bItemLog(int iAction,int iClientH , char * cName, class CItem * pItem)
{	// SNOOPY: Summon monster don't give item pointer
	char  cTxt[1024], cTemp1[120];
	// SNOOPY: Useless feature  re-implemented here
	// and before everything else because of possible empty pointers in this case
	if (iAction == DEF_ITEMLOG_SUMMONMONSTER)  // Was useless ? Used by SNOOPY
	{	// Added a check on client validity
		if (iClientH < 1) return FALSE;
		if (m_pClientList[iClientH] == NULL) return FALSE;
		if (m_pClientList[iClientH]->m_cCharName == NULL) return FALSE;

		// Testing presence of npc name
		if (cName == NULL) return FALSE;	
		
		// Get iClientH IP
		m_pClientList[iClientH]->m_pXSock->iGetPeerAddress(cTemp1);

		wsprintf(cTxt,"PC(%s)\tSummon(%s)\t%s(%d %d)\tIP(%s)"
			, m_pClientList[iClientH]->m_cCharName
			, cName
			, m_pClientList[iClientH]->m_cMapName
			, m_pClientList[iClientH]->m_sX
			, m_pClientList[iClientH]->m_sY
			, cTemp1);
		bSendMsgToLS(MSGID_GAMEITEMLOG, iClientH, NULL,cTxt);
		
		// SNOOPY: Added special Item events Logging
		if  (memcmp(cName, "Ogre" , 4) == 0)			PutItemLogFileList(cTxt);
		if  (memcmp(cName, "WereWolf" , 8) == 0)		PutItemLogFileList(cTxt);
		if  (memcmp(cName, "Demon" , 5) == 0)			PutItemLogFileList(cTxt);
		if  (memcmp(cName, "Unicorn" , 7) == 0)			PutItemLogFileList(cTxt);
		if  (memcmp(cName, "BG" , 2) == 0)				PutItemLogFileList(cTxt);
		if  (memcmp(cName, "Sor-Aresden" , 11) == 0)	PutItemLogFileList(cTxt);
		if  (memcmp(cName, "Sor-Elvine" , 10) == 0)		PutItemLogFileList(cTxt);
		if  (memcmp(cName, "Evil-Sorceress" , 14) == 0) PutItemLogFileList(cTxt);
		if  (memcmp(cName, "ATK-Aresden" , 11) == 0)	PutItemLogFileList(cTxt);
		if  (memcmp(cName, "ATK-Elvine" , 10) == 0)		PutItemLogFileList(cTxt);
		if  (memcmp(cName, "Evil-ATK" , 8) == 0)		PutItemLogFileList(cTxt);
		if  (memcmp(cName, "Elf-Aresden" , 11) == 0)	PutItemLogFileList(cTxt);
		if  (memcmp(cName, "Elf-Elvine" , 10) == 0)		PutItemLogFileList(cTxt);
		if  (memcmp(cName, "Evil-Elf" , 8) == 0)		PutItemLogFileList(cTxt);
		if  (memcmp(cName, "DSK-Aresden" , 11) == 0)	PutItemLogFileList(cTxt);
		if  (memcmp(cName, "DSK-Elvine" , 10) == 0)		PutItemLogFileList(cTxt);
		if  (memcmp(cName, "Evil-DSK" , 8) == 0)		PutItemLogFileList(cTxt);
		if  (memcmp(cName, "HBT-Aresden" , 11) == 0)	PutItemLogFileList(cTxt);
		if  (memcmp(cName, "HBT-Elvine" , 10) == 0)		PutItemLogFileList(cTxt);
		if  (memcmp(cName, "Bar-Aresden" , 11) == 0)	PutItemLogFileList(cTxt);
		if  (memcmp(cName, "Bar-Elvine" , 10) == 0)		PutItemLogFileList(cTxt);
		if  (memcmp(cName, "Evil-Barbarian" , 14) == 0) PutItemLogFileList(cTxt);
	
		return TRUE ;
	} // End of DEF_ITEMLOG_SUMMONMONSTER	

	// Check for item validity
	// All next cases need a valid Item
	if(pItem == NULL) return FALSE;
	if(_bCheckGoodItem( pItem ) == FALSE) return FALSE;	
	
	// SNOOPY: isolated this case because of no iClientH information
	if (iAction == DEF_ITEMLOG_NEWGENDROP) 
	{	wsprintf(cTxt, "NPC(%s)\tDrop\t%s(%d %d %d %d %x)"
			, cName
			, pItem->m_cName
			, pItem->m_dwCount
			, pItem->m_sTouchEffectValue1
			, pItem->m_sTouchEffectValue2
			, pItem->m_sTouchEffectValue3
			, pItem->m_dwAttribute);		
		bSendMsgToLS(MSGID_GAMEITEMLOG, iClientH, NULL,cTxt);
		return TRUE ;
	}	
	// SNOOPY: isolated this case because of no iClientH information
	if (iAction == DEF_ITEMLOG_ITEMEVENT) 
	{	wsprintf(cTxt, "NPC(%s)\tItemEvent\t%s(%d %d %d %d %x)"
			, cName
			, pItem->m_cName
			, pItem->m_dwCount
			, pItem->m_sTouchEffectValue1
			, pItem->m_sTouchEffectValue2
			, pItem->m_sTouchEffectValue3
			, pItem->m_dwAttribute);		
		bSendMsgToLS(MSGID_GAMEITEMLOG, iClientH, NULL,cTxt);
		return TRUE ;
	}
	// Now all other cases
	// Resseting 
	ZeroMemory(cTxt, sizeof(cTxt));
	ZeroMemory(cTemp1, sizeof(cTemp1));

	// Added a check on client validity
	if (iClientH < 1) return FALSE;
	if (m_pClientList[iClientH] == NULL) return FALSE;
	if (m_pClientList[iClientH]->m_cCharName == NULL) return FALSE;

	// Get iClientH IP
	m_pClientList[iClientH]->m_pXSock->iGetPeerAddress(cTemp1);


	switch (iAction) {
	case DEF_ITEMLOG_SKILLLEARN: 
	case DEF_ITEMLOG_MAGICLEARN: 
		// SNOOPY Added calling this from ::UseItemHandler
		// Testing the presence of Spell or Skill Name
		if (cName == NULL) return FALSE; 
		if (m_pClientList[iClientH] == NULL) return FALSE;
		wsprintf(cTxt, "PC(%s)\tLearn(%s)\tusing(%s)\t%s(%d %d)\tIP(%s)"
			, m_pClientList[iClientH]->m_cCharName
			, cName
			, pItem->m_cName
			, m_pClientList[iClientH]->m_cMapName
			, m_pClientList[iClientH]->m_sX
			, m_pClientList[iClientH]->m_sY
			, cTemp1);
			// SNOOPY: Added special Item events Logging
			if (iAction == DEF_ITEMLOG_MAGICLEARN) PutItemLogFileList(cTxt);
		break; 

	case DEF_ITEMLOG_POISONED: // Useless? (depends on TAIWANLOG global constant)
		wsprintf(cTxt,"PC(%s)\tBe Poisoned\t%s(%d %d)\tIP(%s)"
			, m_pClientList[iClientH]->m_cCharName
			, m_pClientList[iClientH]->m_cMapName
			, m_pClientList[iClientH]->m_sX
			, m_pClientList[iClientH]->m_sY
			, cTemp1);
		break; 

	case DEF_ITEMLOG_REPAIR: // Useless ?
		// Testing the presence of item name
		if (cName == NULL) return FALSE;

		wsprintf(cTxt,"PC(%s)\tRepair(%s)\t%s(%d %d)\tIP(%s)"
			, m_pClientList[iClientH]->m_cCharName
			, cName
			, m_pClientList[iClientH]->m_cMapName
			, m_pClientList[iClientH]->m_sX
			, m_pClientList[iClientH]->m_sY
			, cTemp1);
		break; 

	default:
		return FALSE;
	}
	bSendMsgToLS(MSGID_GAMEITEMLOG, iClientH, NULL,cTxt);
	return TRUE ;
}

BOOL CGame::_bCheckGoodItem( class CItem * pItem )
{	if( pItem == NULL ) return FALSE;

	if( pItem->m_sIDnum == 90 )
	{	if( pItem->m_dwCount > 5000 ) return TRUE; 
		else return FALSE;
	}
	switch (pItem->m_sIDnum) {
	case 6:   // Eldiniel Hand
	case 7:	  // Aresien Hand
	case 20:  // Excalibur
	case 74 : // GoldenAxe
	case 84:  // Master Shield
	case 86:  // Knight Shield
	case 73:  // WarAxe+2
	case 56:  // Flam+2
	case 52:  // GS+2
	case 101: // Red Fish
	case 102: // Green Fish
	case 103: // Yellow Fish
	case 113: // Magic Resist Manual
	case 125: // WarriorSpirit Manual
	case 126: // Bloody Mantle Manual
	case 245: // Flags
	case 246: // Flags
	case 247: // Flags
	case 248: // Flags
	case 259: // Wand MShield
 // Et ++++
		return TRUE;  // Log those in all cases..
		break;
	case 91:  // Potions
	case 92:  // 
	case 93:  // 
	case 94:  // 
	case 95:  // 
	case 96:  // 
	case 98:  // Baguette 
	case 99:  // Meat
	case 100: // Fish
	case 104: // Map 
	case 114: // RecallScroll
	case 115: // InvisibilityScroll 
	case 116: // DetectInviScroll
	case 117: // BleedingIsleTicket 
	case 355: // Coal
	case 357: // IronOre
	case 358: // Crystal 
	case 500: // IronBar
	case 501: // Supercoal 
	case 548: // WereWolf parts 
	case 549: //  
	case 550: //  
	case 551: //  
	case 552: //  
	case 553: //  
	case 554: //  
		return FALSE;  // Never Log those items..
		break;
	default:
		// Don't Log common Alchim parts
		if ((pItem->m_sIDnum > 187) && (pItem->m_sIDnum<226)) return FALSE;
		// Log all items above 259 
		if ( pItem->m_sIDnum > 259 ) return TRUE;  
		// And all stated items below 259
		//else if ((pItem->m_dwAttribute & 0xF0F0F001) == NULL) return FALSE; 
		if (( pItem->m_sIDnum <= 259 ) && (pItem->m_dwAttribute == 0)) return FALSE; 		
		return TRUE; 	
	}
	return TRUE; 
}

// SNOOPY: Fixed XP Party Bug
void CGame::GetExp(int iClientH, int iExp, BOOL bIsAttackerOwn)
{
	double dV1, dV2, dV3, dV4;
	int i, iH, iUnitValue;
	DWORD dwTime = timeGetTime();
	int iPrensentPartyMembers;

	if (m_pClientList[iClientH] == NULL) return;
	if (iExp <= 0) return;
	// m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_iXPRate
	if (m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_iXPRate != 100)
	{	dV1 = (double) iExp;
		dV2 = dV1 * m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_iXPRate;
		dV3 = dV2 / 100;
		iExp = (int)dV3;	
	}
	if (m_iXPBonusType < 2) {
		// HB or USA modes standards bonus 80- and farms
		// Formulas to compute extra XP lvl80-, bonus in farms
		//
		if ((m_pClientList[iClientH]->m_iLevel <= 80) && (m_iXPBonusType == 0)) 
			// XP increase for levels 1..80 (2.5% bonus per level below 80)
		{	dV1 = (double)(80 - m_pClientList[iClientH]->m_iLevel);
			dV2 = dV1 * 0.025f;
			dV3 = (double)iExp;
			dV1 = (dV2 + 1.025f)*dV3;
			iExp = (int)dV1;
		}else  //Lower exp
		{	if ((m_pClientList[iClientH]->m_iLevel >= 100) &&((strcmp(m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cName, "arefarm") == 0) 
				|| (strcmp(m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cName, "elvfarm") == 0))) {
					// Level 100+ get -90% XP at farms
					iExp = (iExp/10) ;
				}
			else if ((strcmp(m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cName, "arefarm") == 0) 
				|| (strcmp(m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cName, "elvfarm") == 0)) {
				// Level 80..99 get -75% XP at farms
					iExp = (iExp*1/4) ;
				}
		}
	} // Snoopy: My special XP bonusses will be computed at the end for each player AFTER Party XP
	//Check for party status, else give exp to player
	if (	(m_pClientList[iClientH]->m_iPartyID != NULL) 
		 && (m_pClientList[iClientH]->m_iPartyStatus == DEF_PARTYSTATUS_CONFIRM))
	{	//Only divide exp if > 1 person and exp > 10
		if(iExp >= 10 && m_stPartyInfo[m_pClientList[iClientH]->m_iPartyID].iTotalMembers > 0)
		{	// Calc total ppl in party
			
			// found a bug! iPrensentPartyMembers is total nb on map not in all party!
			iPrensentPartyMembers = 0;
			for(i = 0; i < m_stPartyInfo[m_pClientList[iClientH]->m_iPartyID].iTotalMembers; i++)
			{	iH = m_stPartyInfo[m_pClientList[iClientH]->m_iPartyID].iIndex[i];
				if (   (iH > 0)	// added due to a strange bug, on 1st Apoc test.(issue with gate ????)
					&& (m_pClientList[iH] != NULL) 
					&& (m_pClientList[iH]->m_bSkillUsingStatus[19] != 1) // Pretend corpse
					//&& (m_pClientList[iH]->m_iHP > 0)	
					&& (m_pClientList[iH]->m_bIsKilled == FALSE)
					// Snoopy: Added some more checks to prevent earning XP 
					//         in case of corrupted parties
					&& (m_pClientList[iH]->m_iPartyID != NULL)
					&& (m_pClientList[iH]->m_iPartyID == m_pClientList[iClientH]->m_iPartyID) ) 
				{	// Dead characters cannot divide XP
					//Newly added, Only players on same map get exp 
					//if(m_pClientList[iH]->m_cMapIndex == m_pClientList[iClientH]->m_cMapIndex)
					// Snoopy suspect this was changed this due to possible same m_cMapIndex but on different servers ?!?!
					if ((strlen(m_pMapList[m_pClientList[iH]->m_cMapIndex]->m_cName)) == (strlen(m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cName))) {
						if(memcmp(m_pMapList[m_pClientList[iH]->m_cMapIndex]->m_cName, 
								  m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cName, 
								  strlen(m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cName)) == 0){
							iPrensentPartyMembers++;
						}
					}
				}
			}

			//Check for party bug
			if(iPrensentPartyMembers > 8){
				wsprintf(G_cTxt, "(X) Party Bug !! partyMember %d XXXXXXXXXX", iPrensentPartyMembers);
				PutLogList(G_cTxt);
				PutLogFileList(G_cTxt);
				iPrensentPartyMembers = 8;
			}
			//Figure out how much exp a player gets
			dV1 = (double)iExp;

			switch(iPrensentPartyMembers){
			case 1:
				dV2 = dV1;
				break;
			case 2: // +10%
				dV2 = (dV1 + (dV1 * 1.0e-1)) / 2.0;
				break;
			case 3:
				dV2 = (dV1 + (dV1 * 1.0e-1)) / 3.0;
				break;
			case 4: // +15%
				dV2 = (dV1 + (dV1 * 1.5e-1)) / 4.0;
				break;
			case 5:
				dV2 = (dV1 + (dV1 * 1.5e-1)) / 5.0;
				break;
			case 6: // + 20%
				dV2 = (dV1 + (dV1 * 2.0e-1)) / 6.0;
				break;
			case 7:
				dV2 = (dV1 + (dV1 * 2.0e-1)) / 7.0;
				break;
			case 8:
				dV2 = (dV1 + (dV1 * 2.0e-1)) / 8.0;
				break;
			}

			dV4 = dV2 + 5.0e-1;
			iUnitValue = (int)dV4;
/*
//	HBx replaced routine
				//Divide exp among party members
				for(i = 0; i < iTotalPartyMembers; i++){
					iH = m_stPartyInfo[m_pClientList[iClientH]->m_iPartyID].iIndex[i];
						if (	(m_pClientList[iH] != NULL) 
							 && (m_pClientList[iH]->m_bSkillUsingStatus[19] != 1) // Pretend corpse
							 && (m_pClientList[iH]->m_iHP > 0)) { // Is player alive ??
							//Exp gain x3 if XP Ancient Slate used
							if((m_pClientList[iH]->m_iStatus & 0x10000) != 0)
								iUnitValue *= 3;
							m_pClientList[iH]->m_iExpStock += iUnitValue;
							// Restore "normal" XP for other in Party.
							iUnitValue = (int)dV3;
						}
					}*/
			// Divide exp among party members (by SNOOPY)
			// Searching all party members in case one is not on the map...
			for(i = 0; i < m_stPartyInfo[m_pClientList[iClientH]->m_iPartyID].iTotalMembers; i++)
			{	iH = m_stPartyInfo[m_pClientList[iClientH]->m_iPartyID].iIndex[i];
				if ( (iH > 0 )
					 &&	(m_pClientList[iH] != NULL) 
					 && (m_pClientList[iH]->m_bSkillUsingStatus[19] != 1)	// Pretend corpse
					 //&& (m_pClientList[iH]->m_iHP > 0)		
				     && (m_pClientList[iH]->m_bIsKilled == FALSE)				// Is player alive ??
					// Snoopy: Added some more checks to prevent earning XP 
					//         in case of corrupted parties
					&& ((dwTime - m_pClientList[iH]->m_dwLastActionTime) < 1000*60*3) // No XP if more than 3 minutes passive.
					&& (m_pClientList[iH]->m_iPartyID != NULL)
					&& (m_pClientList[iH]->m_iPartyID == m_pClientList[iClientH]->m_iPartyID)
					) 
				{	if ((strlen(m_pMapList[m_pClientList[iH]->m_cMapIndex]->m_cName)) == (strlen(m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cName))) 
					{	if(memcmp(m_pMapList[m_pClientList[iH]->m_cMapIndex]->m_cName, 
							m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cName, // on same map?
							strlen(m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cName)) == 0)
						{	// Get XP only if on same map...
						  	//Exp gain x3 if XP Ancient Slate used
							if(m_pClientList[iH]->m_bXpSlate)
								iUnitValue *= 3;
							// XP increase in USA mode
							if ( m_iXPBonusType == 1) 
							{	if (m_pClientList[iH]->m_iLevel >= 1 && m_pClientList[iH]->m_iLevel < 20)
									iUnitValue *= (int)3.5;
								else if (m_pClientList[iH]->m_iLevel >= 20  && m_pClientList[iH]->m_iLevel < 121)
									iUnitValue *= 3;
								else if (m_pClientList[iH]->m_iLevel >= 120 && m_pClientList[iH]->m_iLevel < 161)
									iUnitValue *= 2;
								else if (m_pClientList[iH]->m_iLevel >= 160 && m_pClientList[iH]->m_iLevel < 180)
									iUnitValue *= (int)1.5;
							}
							// XP increase for levels 1..120 (2.0% bonus per level below 120)
							if (   ( m_iXPBonusType == 2) 
								&& (m_pClientList[iH]->m_iLevel <= 120)) 
							{	dV1 = (double)(120 - m_pClientList[iH]->m_iLevel);
								dV2 = dV1 * 0.02f;
								dV3 = (double)iUnitValue;
								dV1 = (dV2 + 1.020f)*dV3;
								iUnitValue = (int)dV1;
							}
							// XP lowered for levels 140+ (2.0% malus per level above 140)
							if (   ( m_iXPBonusType == 2) 
								&& (m_pClientList[iH]->m_iLevel > (m_iPlayerMaxLevel-10))) 
							{	dV1 = (double)(m_pClientList[iH]->m_iLevel - (m_iPlayerMaxLevel-10));
								dV2 = dV1 * 0.02f;
								dV3 = (double)iUnitValue;
								dV1 = (1.0f - dV2)*dV3;
								iUnitValue = (int)dV1;
							}
								
							// Add here bonus for XP20% Weapons
							if (   (m_pClientList[iH]->m_iAddExp > 0) 
								&& (m_pClientList[iH]->m_iLevel < m_iPlayerMaxLevel)
								&& ( m_iXPBonusType == 2))  
							{	dV1 = (double)m_pClientList[iH]->m_iAddExp;
								dV2 = (double)iUnitValue;
								dV3 = (dV1/100.0f)*dV2;
								iUnitValue += (int)dV3;
							}
							//Add exp to player ( Party case )
							m_pClientList[iH]->m_iExpStock += iUnitValue;
							// Restore "normal" XP for other in Party.
							// for next FOR loop ...
							iUnitValue = (int)dV4;								
						}
					}
				}
			}
		}
		else{ // Single in party case
			//Exp gain x3 if XP Ancient Slate used
			if(m_pClientList[iClientH]->m_bXpSlate)
				iExp *= 3;
			// XP increase in USA mode
			if ( m_iXPBonusType == 1) 
			{	if (m_pClientList[iClientH]->m_iLevel >= 1 && m_pClientList[iClientH]->m_iLevel < 20)
					iExp *= (int)3.5;
				else if (m_pClientList[iClientH]->m_iLevel >= 20 && m_pClientList[iClientH]->m_iLevel < 121)
					iExp *= 3;
				else if (m_pClientList[iClientH]->m_iLevel >= 120 && m_pClientList[iClientH]->m_iLevel < 161)
					iExp *= 2;
				else if (m_pClientList[iClientH]->m_iLevel >= 160 && m_pClientList[iClientH]->m_iLevel < 180)
					iExp *= (int)1.5;
			}
			
			// XP increase for levels 1..120 (2.0% bonus per level below 120)
			if (   ( m_iXPBonusType == 2) 
				&& (m_pClientList[iClientH]->m_iLevel <= 120)) 
			{	dV1 = (double)(120 - m_pClientList[iClientH]->m_iLevel);
				dV2 = dV1 * 0.02f;
				dV3 = (double)iExp;
				dV1 = (dV2 + 1.020f)*dV3;
				iExp = (int)dV1;
			}
			// XP lowered for levels 140+ (2.0% malus per level above 140)
			if (   ( m_iXPBonusType == 2) 
				&& (m_pClientList[iClientH]->m_iLevel > (m_iPlayerMaxLevel-10))) 
			{	dV1 = (double)(m_pClientList[iClientH]->m_iLevel - (m_iPlayerMaxLevel-10));
				dV2 = dV1 * 0.02f;
				dV3 = (double)iExp;
				dV1 = (1.0f - dV2)*dV3;
				iExp = (int)dV1;
			}
			// Add here bonus for XP20% Weapons
			if (   (m_pClientList[iClientH]->m_iAddExp > 0) 
				&& (m_pClientList[iClientH]->m_iLevel < m_iPlayerMaxLevel)
				&& ( m_iXPBonusType == 2))  
			{	dV1 = (double)m_pClientList[iClientH]->m_iAddExp;
				dV2 = (double)iExp;
				dV3 = (dV1/100.0f)*dV2;
				iExp += (int)dV3;
			}
			//Add exp to player
			m_pClientList[iClientH]->m_iExpStock += iExp;
		}
	}else
	{ // Not in a party case
		//Exp gain x3 if XP Ancient Slate used
		if(m_pClientList[iClientH]->m_bXpSlate)
			iExp *= 3;
	
		// XP increase in USA mode
		if ( m_iXPBonusType == 1) 
		{	if (m_pClientList[iClientH]->m_iLevel >= 1 && m_pClientList[iClientH]->m_iLevel < 20)
				iExp *= (int)3.5;
			else if (m_pClientList[iClientH]->m_iLevel >= 20 &&  m_pClientList[iClientH]->m_iLevel < 121)
				iExp *= 3;
			else if (m_pClientList[iClientH]->m_iLevel >= 120 && m_pClientList[iClientH]->m_iLevel < 161)
				iExp *= 2;
			else if (m_pClientList[iClientH]->m_iLevel >= 160 && m_pClientList[iClientH]->m_iLevel < 180)
				iExp *= (int)1.5;
		}

		// XP increase for levels 1..120 (2.0% bonus per level below 120)
		if (   ( m_iXPBonusType == 2)
			&& (m_pClientList[iClientH]->m_iLevel <= 120)) 
		{	dV1 = (double)(120 - m_pClientList[iClientH]->m_iLevel);
			dV2 = dV1 * 0.02f;
			dV3 = (double)iExp;
			dV1 = (dV2 + 1.020f)*dV3;
			iExp = (int)dV1;
		}
		// XP lowered for levels 140+ (2.0% malus per level above 140)
		if (   ( m_iXPBonusType == 2)
			&& (m_pClientList[iClientH]->m_iLevel > (m_iPlayerMaxLevel-10))) 
		{	dV1 = (double)(m_pClientList[iClientH]->m_iLevel - (m_iPlayerMaxLevel-10));
			dV2 = dV1 * 0.02f;
			dV3 = (double)iExp;
			dV1 = (1.0f - dV2)*dV3;
			iExp = (int)dV1;
		}
		// Add here bonus for XP20% Weapons
			if (   (m_pClientList[iClientH]->m_iAddExp > 0) 
				&& (m_pClientList[iClientH]->m_iLevel < m_iPlayerMaxLevel)
				&& ( m_iXPBonusType == 2))  
		{	dV1 = (double)m_pClientList[iClientH]->m_iAddExp;
			dV2 = (double)iExp;
			dV3 = (dV1/100.0f)*dV2;
			iExp += (int)dV3;
		}
		//Add exp to player
		m_pClientList[iClientH]->m_iExpStock += iExp;
	}
}
BOOL CGame::bCheckAndConvertPlusWeaponItem(int iClientH, int iItemIndex)
{	// SNOOPY: Useless function.....
	// +1, +2  Attribute 
	if (m_pClientList[iClientH] == NULL) return FALSE;
	if (m_pClientList[iClientH]->m_pItemList[iItemIndex] == NULL) return FALSE;

	switch (m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sIDnum) {
	case 4:  // Dagger +1
	case 9:  // Short Sword +1
	case 13: // Main Gauge +1
	case 16: // Gradius +1
	case 18: // Long Sword +1
	case 19: // Long Sword +2
	case 21: // Excaliber +1
	case 24: // Sabre +1
	case 26: // Scimitar +1
	case 27: // Scimitar +2
	case 29: // Falchoin +1
	case 30: // Falchion +2
	case 32: // Esterk +1
	case 33: // Esterk +2
	case 35: // Rapier +1
	case 36: // Rapier +2
	case 39: // Broad Sword +1
	case 40: // Broad Sword +2
	case 43: // Bastad Sword +1
	case 44: // Bastad Sword +2
	case 47: // Claymore +1
	case 48: // Claymore +2
	case 51: // Great Sword +1
	case 52: // Great Sword +2
	case 55: // Flameberge +1
	case 56: // Flameberge +2
	case 60: // Light Axe +1
	case 61: // Light Axe +2
	case 63: // Tomahoc +1
	case 64: // Tomohoc +2
	case 66: // Sexon Axe +1
	case 67: // Sexon Axe +2
	case 69: // Double Axe +1
	case 70: // Double Axe +2
	case 72: // War Axe +1
	case 73: // War Axe +2

	case 580: // Battle Axe +1
	case 581: // Battle Axe +2
	case 582: // Sabre +2
		return TRUE;
		break;
	}
	return FALSE;
}

void CGame::ArmorLifeDecrement(int iAttackerH, int iTargetH, char cOwnerType, int iValue)
{	int iTemp;

	if (m_pClientList[iAttackerH] == NULL) return ;
	switch (cOwnerType) {
	case DEF_OWNERTYPE_PLAYER:
		if (m_pClientList[iTargetH] == NULL) return;
		break;

	case DEF_OWNERTYPE_NPC:	return;
	default: return;
	}

	if (m_pClientList[iAttackerH]->m_cSide == m_pClientList[iTargetH]->m_cSide) return ;

	int iHammerChance;

	// Snoopy: added Strip the armor piece

	iTemp = m_pClientList[iTargetH]->m_sItemEquipmentStatus[DEF_EQUIPPOS_BODY];
	if ((iTemp != -1) && (m_pClientList[iTargetH]->m_pItemList[iTemp] != NULL)) 
	{	if ((m_pClientList[iTargetH]->m_cSide != 0) && (m_pClientList[iTargetH]->m_pItemList[iTemp]->m_wCurLifeSpan > 0))	
			m_pClientList[iTargetH]->m_pItemList[iTemp]->m_wCurLifeSpan -= iValue;
		if (m_pClientList[iTargetH]->m_pItemList[iTemp]->m_wCurLifeSpan <= 0) 
		{	m_pClientList[iTargetH]->m_pItemList[iTemp]->m_wCurLifeSpan = 0;
			SendNotifyMsg(NULL, iTargetH, DEF_NOTIFY_ITEMLIFESPANEND, m_pClientList[iTargetH]->m_pItemList[iTemp]->m_cEquipPos, iTemp, NULL, NULL);
			ReleaseItemHandler(iTargetH, iTemp, TRUE);
		}else
		{	iHammerChance = iDice(1, 2*(m_pClientList[iTargetH]->m_pItemList[iTemp]->m_wMaxLifeSpan - m_pClientList[iTargetH]->m_pItemList[iTemp]->m_wCurLifeSpan));
			if (   (m_pClientList[iTargetH]->m_pItemList[iTemp]->m_sIDnum == 622) 
				|| (m_pClientList[iTargetH]->m_pItemList[iTemp]->m_sIDnum == 621)) 
			{	iHammerChance = 0; // Never unequip Merien plates !
			}			
			if (   (m_pClientList[iTargetH]->m_pItemList[iTemp]->m_wCurLifeSpan < iHammerChance) 
				&& (iDice(1,10) <= 5))
			{	ReleaseItemHandler(iTargetH, iTemp, TRUE);
				SendNotifyMsg(NULL, iTargetH, DEF_NOTIFY_ITEMRELEASED, m_pClientList[iTargetH]->m_pItemList[iTemp]->m_cEquipPos, iTemp, NULL, NULL);
	}	}	}

	iTemp = m_pClientList[iTargetH]->m_sItemEquipmentStatus[DEF_EQUIPPOS_PANTS];
	if ((iTemp != -1) && (m_pClientList[iTargetH]->m_pItemList[iTemp] != NULL)) 
	{	if ((m_pClientList[iTargetH]->m_cSide != 0) && (m_pClientList[iTargetH]->m_pItemList[iTemp]->m_wCurLifeSpan > 0))	
			m_pClientList[iTargetH]->m_pItemList[iTemp]->m_wCurLifeSpan -= iValue;
		if (m_pClientList[iTargetH]->m_pItemList[iTemp]->m_wCurLifeSpan <= 0) 
		{	m_pClientList[iTargetH]->m_pItemList[iTemp]->m_wCurLifeSpan = 0;
			SendNotifyMsg(NULL, iTargetH, DEF_NOTIFY_ITEMLIFESPANEND, m_pClientList[iTargetH]->m_pItemList[iTemp]->m_cEquipPos, iTemp, NULL, NULL);
			ReleaseItemHandler(iTargetH, iTemp, TRUE);	
		}else
		{	iHammerChance = iDice(1, 2*(m_pClientList[iTargetH]->m_pItemList[iTemp]->m_wMaxLifeSpan - m_pClientList[iTargetH]->m_pItemList[iTemp]->m_wCurLifeSpan));
			if (   (m_pClientList[iTargetH]->m_pItemList[iTemp]->m_wCurLifeSpan < iHammerChance) 
				&& (iDice(1,10) <= 3))
			{	ReleaseItemHandler(iTargetH, iTemp, TRUE);
				SendNotifyMsg(NULL, iTargetH, DEF_NOTIFY_ITEMRELEASED, m_pClientList[iTargetH]->m_pItemList[iTemp]->m_cEquipPos, iTemp, NULL, NULL);
	}	}	}

	iTemp = m_pClientList[iTargetH]->m_sItemEquipmentStatus[DEF_EQUIPPOS_FOOT];
	if ((iTemp != -1) && (m_pClientList[iTargetH]->m_pItemList[iTemp] != NULL)) 
	{	if ((m_pClientList[iTargetH]->m_cSide != 0) && (m_pClientList[iTargetH]->m_pItemList[iTemp]->m_wCurLifeSpan > 0))	
			m_pClientList[iTargetH]->m_pItemList[iTemp]->m_wCurLifeSpan -= iValue;
		if (m_pClientList[iTargetH]->m_pItemList[iTemp]->m_wCurLifeSpan <= 0) 
		{	m_pClientList[iTargetH]->m_pItemList[iTemp]->m_wCurLifeSpan = 0;
			SendNotifyMsg(NULL, iTargetH, DEF_NOTIFY_ITEMLIFESPANEND, m_pClientList[iTargetH]->m_pItemList[iTemp]->m_cEquipPos, iTemp, NULL, NULL);
			ReleaseItemHandler(iTargetH, iTemp, TRUE);	
		}else
		{	iHammerChance = iDice(1, 2*(m_pClientList[iTargetH]->m_pItemList[iTemp]->m_wMaxLifeSpan - m_pClientList[iTargetH]->m_pItemList[iTemp]->m_wCurLifeSpan));
			if (   (m_pClientList[iTargetH]->m_pItemList[iTemp]->m_wCurLifeSpan < iHammerChance) 
				&& (iDice(1,10) <= 2))
			{	ReleaseItemHandler(iTargetH, iTemp, TRUE);
				SendNotifyMsg(NULL, iTargetH, DEF_NOTIFY_ITEMRELEASED, m_pClientList[iTargetH]->m_pItemList[iTemp]->m_cEquipPos, iTemp, NULL, NULL);
	}	}	}

	iTemp = m_pClientList[iTargetH]->m_sItemEquipmentStatus[DEF_EQUIPPOS_ARMS];
	if ((iTemp != -1) && (m_pClientList[iTargetH]->m_pItemList[iTemp] != NULL)) 
	{	if ((m_pClientList[iTargetH]->m_cSide != 0) && (m_pClientList[iTargetH]->m_pItemList[iTemp]->m_wCurLifeSpan > 0))	
			m_pClientList[iTargetH]->m_pItemList[iTemp]->m_wCurLifeSpan -= iValue;

		if (m_pClientList[iTargetH]->m_pItemList[iTemp]->m_wCurLifeSpan <= 0) 
		{	m_pClientList[iTargetH]->m_pItemList[iTemp]->m_wCurLifeSpan = 0;
			SendNotifyMsg(NULL, iTargetH, DEF_NOTIFY_ITEMLIFESPANEND, m_pClientList[iTargetH]->m_pItemList[iTemp]->m_cEquipPos, iTemp, NULL, NULL);
			ReleaseItemHandler(iTargetH, iTemp, TRUE);
		}else
		{	iHammerChance = iDice(1, 2*(m_pClientList[iTargetH]->m_pItemList[iTemp]->m_wMaxLifeSpan - m_pClientList[iTargetH]->m_pItemList[iTemp]->m_wCurLifeSpan));
			if (   (m_pClientList[iTargetH]->m_pItemList[iTemp]->m_wCurLifeSpan < iHammerChance) 
				&& (iDice(1,10) <= 2))
			{	ReleaseItemHandler(iTargetH, iTemp, TRUE);
				SendNotifyMsg(NULL, iTargetH, DEF_NOTIFY_ITEMRELEASED, m_pClientList[iTargetH]->m_pItemList[iTemp]->m_cEquipPos, iTemp, NULL, NULL);
	}	}	}

	iTemp = m_pClientList[iTargetH]->m_sItemEquipmentStatus[DEF_EQUIPPOS_HEAD];
	if ((iTemp != -1) && (m_pClientList[iTargetH]->m_pItemList[iTemp] != NULL)) 
	{	if ((m_pClientList[iTargetH]->m_cSide != 0) && (m_pClientList[iTargetH]->m_pItemList[iTemp]->m_wCurLifeSpan > 0))	
			m_pClientList[iTargetH]->m_pItemList[iTemp]->m_wCurLifeSpan -= iValue;
		if (m_pClientList[iTargetH]->m_pItemList[iTemp]->m_wCurLifeSpan <= 0) 
		{	m_pClientList[iTargetH]->m_pItemList[iTemp]->m_wCurLifeSpan = 0;
			SendNotifyMsg(NULL, iTargetH, DEF_NOTIFY_ITEMLIFESPANEND, m_pClientList[iTargetH]->m_pItemList[iTemp]->m_cEquipPos, iTemp, NULL, NULL);
			ReleaseItemHandler(iTargetH, iTemp, TRUE);
		}else
		{	iHammerChance = iDice(1, 2*(m_pClientList[iTargetH]->m_pItemList[iTemp]->m_wMaxLifeSpan - m_pClientList[iTargetH]->m_pItemList[iTemp]->m_wCurLifeSpan));
			if (   (m_pClientList[iTargetH]->m_pItemList[iTemp]->m_wCurLifeSpan < iHammerChance) 
				&& (iDice(1,10) <= 2))
			{	ReleaseItemHandler(iTargetH, iTemp, TRUE);
				SendNotifyMsg(NULL, iTargetH, DEF_NOTIFY_ITEMRELEASED, m_pClientList[iTargetH]->m_pItemList[iTemp]->m_cEquipPos, iTemp, NULL, NULL);
	}	}	}
			
}

void CGame::AdminOrder_GoTo(int iClientH, char* pData, DWORD dwMsgSize)
{	char   seps[] = "= \t\n";
	char   * token, cBuff[256], cPlayerName[11],cMapName[32];
	class  CStrTok * pStrTok;
	char *cp;
	WORD *wp;
	if (m_pClientList[iClientH] == NULL) return;
	if ((dwMsgSize)	<= 0) return;
	if (m_pClientList[iClientH]->m_iAdminUserLevel < m_iAdminLevelGoto) 
	{	SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_ADMINUSERLEVELLOW, NULL, NULL, NULL, NULL);
		return;
	}
	ZeroMemory(cPlayerName, sizeof(cPlayerName));
	ZeroMemory(cBuff, sizeof(cBuff));
	memcpy(cBuff, pData, dwMsgSize);
	pStrTok = new class CStrTok(cBuff, seps);
	token = pStrTok->pGet();
	token = pStrTok->pGet();
	if (token == NULL) {
		delete pStrTok;
		return;
	}
	if (strlen(token) > 10) 
	{	memcpy(cPlayerName,token,10);
	}else
	{	memcpy(cPlayerName,token,strlen(token));
	}
	for(int i = 1; i < DEF_MAXCLIENTS; i++){
		if (m_pClientList[i] != NULL) {
			if (memcmp(cPlayerName,m_pClientList[i]->m_cCharName, 10) == 0) {
				if (m_pClientList[iClientH]->m_iAdminUserLevel > 0) {
					if(m_pClientList[i]->m_sX == -1 && m_pClientList[i]->m_sX == -1)
					{	wsprintf(cBuff,"GM Order(%-10s): /goto MapName(%s)"
							, m_pClientList[iClientH]->m_cCharName, m_pClientList[i]->m_cMapName);
					}else
					{	wsprintf(cBuff,"GM Order(%-10s): /goto MapName(%s)(%d %d)", m_pClientList[iClientH]->m_cCharName
							, m_pClientList[i]->m_cMapName, m_pClientList[i]->m_sX, m_pClientList[i]->m_sY);
					}
					bSendMsgToLS(MSGID_GAMEMASTERLOG,iClientH,FALSE,cBuff);
					ZeroMemory(cMapName,sizeof(cMapName));
					strcpy(cMapName, m_pClientList[i]->m_cMapName);
					RequestTeleportHandler(iClientH,"2   ", cMapName, m_pClientList[i]->m_sX, m_pClientList[i]->m_sY);
				}
				delete pStrTok;
				return;
	}	}	}
	m_pClientList[iClientH]->m_bIsAdminOrderGoto = TRUE;
	ZeroMemory(cBuff,sizeof(cBuff));	
	cp = (char *)cBuff;
	*cp = GSM_REQUEST_FINDCHARACTER;
	cp++;
	wp = (WORD *)cp;
	*wp = m_wServerID_GSS;
	cp += 2;
	wp = (WORD *)cp;
	*wp = iClientH;
	cp += 2;
	memcpy(cp,cPlayerName,10);
	cp += 10;
	memcpy(cp,m_pClientList[iClientH]->m_cCharName,10);
	cp += 10;
	bStockMsgToGateServer(cBuff,25);

	delete pStrTok;
}

void CGame::AdminOrder_MonsterCount(int iClientH, char* pData, DWORD dwMsgSize)
{	int iMonsterCount;
	if (m_pClientList[iClientH] == NULL) return;
	if ((dwMsgSize)	<= 0) return;
	if (m_pClientList[iClientH]->m_iAdminUserLevel < m_iAdminLevelMonsterCount) 
	{	SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_ADMINUSERLEVELLOW, NULL, NULL, NULL, NULL);
		return;
	}
	iMonsterCount = m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_iTotalActiveObject;
	SendNotifyMsg(0,iClientH, DEF_NOTIFY_MONSTERCOUNT, iMonsterCount,NULL,NULL,NULL);
	wsprintf(G_cTxt, "GM Order(%-10s): /monstercount (%d)", m_pClientList[iClientH]->m_cCharName, iMonsterCount);
	bSendMsgToLS(MSGID_GAMEMASTERLOG, iClientH, FALSE, G_cTxt);	
}

void CGame::AdminOrder_SetForceRecallTime(int iClientH, char *pData, DWORD dwMsgSize)
{ class  CStrTok * pStrTok;
 char   seps[] = "= \t\n";
 char   * token, cBuff[256],* cp; 
 WORD * wp ;
 int    iTime;
	if (m_pClientList[iClientH] == NULL) return;
	if ((dwMsgSize)	<= 0) return;
	if (m_pClientList[iClientH]->m_iAdminUserLevel < m_iAdminLevelSetRecallTime) 
	{	SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_ADMINUSERLEVELLOW, NULL, NULL, NULL, NULL);
		return;
	}
	ZeroMemory(cBuff, sizeof(cBuff));
	memcpy(cBuff, pData, dwMsgSize);
	pStrTok = new class CStrTok(cBuff, seps);
	token = pStrTok->pGet();
	token = pStrTok->pGet();   	
	if (token != NULL) {
		if (token == NULL) 
			 iTime = 0;
		else iTime = atoi(token);	
		if (iTime < 0) iTime = 0;	 	
		m_sForceRecallTime = iTime ;
		ZeroMemory(cBuff, sizeof(cBuff));
		cp = (char *)cBuff;
		*cp = GSM_REQUEST_SETFORCERECALLTIME;
		cp++;	
		wp = (WORD *)cp;
		*wp = iTime ;
		cp += 2;
		bStockMsgToGateServer(cBuff, 3);
		wsprintf(G_cTxt,"(!) Game Server Force Recall Time (%d)min",m_sForceRecallTime) ;
		PutLogList(G_cTxt) ;
		// Admin Log
		wsprintf(G_cTxt, "Admin Order(%s): Game Server Force Recall Time (%d)min\tAdminIP(%s)"
			, m_pClientList[iClientH]->m_cCharName
			, m_sForceRecallTime
			, m_pClientList[iClientH]->m_cIPaddress);
		PutAdminLogFileList(G_cTxt);		
		wsprintf(G_cTxt, "GM Order(%-10s): /setforcerecalltime (%d min)", m_pClientList[iClientH]->m_cCharName, m_sForceRecallTime);
		bSendMsgToLS(MSGID_GAMEMASTERLOG, iClientH, FALSE, G_cTxt);	
	}
	delete pStrTok;
	return ;
}

void CGame::AdminOrder_UnsummonBoss(int iClientH)
{	if (m_pClientList[iClientH] == NULL) return;
	if (m_pClientList[iClientH]->m_iAdminUserLevel < m_iAdminLevelUnsummonBoss) 
	{	SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_ADMINUSERLEVELLOW, NULL, NULL, NULL, NULL);
		return;
	}
	for(int i = 1; i < DEF_MAXNPCS; i++)
	{	if (m_pNpcList[i] != NULL && m_pNpcList[i]->m_bIsSummoned == FALSE) 
		{	switch(m_pNpcList[i]->m_sType) {
			case 31: //Demon
			case 49: //Hellclaw
			case 45: //GHKABS
			case 47: //BG
			case 50: //Tigerworm
			case 52: //Gagoyle
			case 81: //Abaddon
			case 66: //Wyvern
			case 73: //Fire-Wyvern	 	    
			// SNOOPY: Added here all npc non killable by single player
			case 71: // Centaurus
			case 75: // Claw-Lizard
			case 77: // MasterMage-Orc
			case 78: // Minautors
			case 79: // Nizie
				m_pNpcList[i]->m_bIsUnsummoned = TRUE;
				NpcKilledHandler(iClientH, DEF_OWNERTYPE_PLAYER, i, 0);
				DeleteNpc(i);
				break;
			default: // boss mob case...
				if (m_pNpcList[i]->m_iNpcBossType == 1)
				{	m_pNpcList[i]->m_bIsUnsummoned = TRUE;
					NpcKilledHandler(iClientH, DEF_OWNERTYPE_PLAYER, i, 0);
					DeleteNpc(i);
				}
				break;	
	}	}	}
	wsprintf(G_cTxt, "Admin Order(%s): Unsummon Boss\tAdminIP(%s)"
		, m_pClientList[iClientH]->m_cCharName
		, m_pClientList[iClientH]->m_cIPaddress);
	PutAdminLogFileList(G_cTxt);
	PutLogEventFileList(G_cTxt);
	wsprintf(G_cTxt, "GM Order(%-10s): /unsummonboss ", m_pClientList[iClientH]->m_cCharName);
	bSendMsgToLS(MSGID_GAMEMASTERLOG, iClientH, FALSE, G_cTxt);	
}

void CGame::AdminOrder_ClearNpc(int iClientH)
{	if (m_pClientList[iClientH] == NULL) return;
	if (m_pClientList[iClientH]->m_iAdminUserLevel < m_iAdminLevelClearNpc) 
	{	SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_ADMINUSERLEVELLOW, NULL, NULL, NULL, NULL);
		return;
	}
	for(int i = 1; i < DEF_MAXNPCS; i++)
	{	if (   (m_pNpcList[i] != NULL) && (m_pNpcList[i]->m_bIsSummoned == FALSE) ) 
		{	switch(m_pNpcList[i]->m_sType) {
			case 15: // ShopKeeper-W
			case 19: // Gandlf
			case 20: // Howard
			case 24: // Tom
			case 25: // William
			case 26: // Kennedy
			case 67: // McGaffin
			case 68: // Perry
			case 69: // Devlin
			case 90: // Gail
			case 91: // Gates....
				break;
			default:
				if (m_pNpcList[i]->m_cMapIndex == m_pClientList[iClientH]->m_cMapIndex)
				{	m_pNpcList[i]->m_bIsUnsummoned = TRUE;
					NpcKilledHandler(iClientH, DEF_OWNERTYPE_PLAYER, i, 0);
					DeleteNpc(i);
				}
				break;
	}	}	}			
	// Admin Log
	wsprintf(G_cTxt, "Admin Order(%s): Clear npc\tAdminIP(%s)"
		, m_pClientList[iClientH]->m_cCharName
		, m_pClientList[iClientH]->m_cIPaddress);
	PutAdminLogFileList(G_cTxt);
	PutLogEventFileList(G_cTxt);
	wsprintf(G_cTxt, "GM Order(%-10s): /clearnpc (done)", m_pClientList[iClientH]->m_cCharName);
	bSendMsgToLS(MSGID_GAMEMASTERLOG, iClientH, FALSE, G_cTxt);	
}

// New 12/05/2004
void CGame::RemoveCrusadeNpcs(void)
{	for(int i = 0; i < DEF_MAXNPCS; i++)
	{	if (m_pNpcList[i] != NULL) 
		{	if ((m_pNpcList[i]->m_sOriginalType >= 43 && m_pNpcList[i]->m_sOriginalType <= 47) || m_pNpcList[i]->m_sOriginalType == 51) 
			{	NpcKilledHandler(NULL, NULL, i, NULL);
	}	}	}
}

void CGame::RemoveCrusadeRecallTime(void)
{	for(int i = 1; i < DEF_MAXCLIENTS; i++)
	{	if (m_pClientList[i] != NULL) 
		{	if (m_pClientList[i]->m_bIsWarLocation == TRUE &&
				m_pClientList[i]->m_bIsPlayerCivil == TRUE &&
				m_pClientList[i]->m_bIsInitComplete == TRUE) 
			{	m_pClientList[i]->m_iTimeLeft_ForceRecall = 0;
				m_pClientList[i]->m_bIsWarLocation = FALSE;
	}	}	}
}
// This function has been revamped by Snoopy (Msg ID was wrong..)
BOOL CGame::_bCrusadeLog(int iAction,int iClientH,int iData, char * cName)
{	char  cTxt[200];  
	ZeroMemory(cTxt, sizeof(cTxt));
	switch (iAction) {
		case DEF_CRUSADELOG_ENDCRUSADE:
			if (cName == NULL) return FALSE;
			wsprintf(cTxt,"Crusade:    End Crusade %s",cName);
			break;
		case DEF_CRUSADELOG_SELECTDUTY :
			if (cName == NULL) return FALSE;
			if (m_pClientList[iClientH] == NULL) return FALSE;
			wsprintf(cTxt,"Crusade:    PC(%-10s)\tSelect Duty\t(%s)\t \t(%s)", m_pClientList[iClientH]->m_cCharName,cName,m_pClientList[iClientH]->m_cGuildName);
			break ;
		case DEF_CRUSADELOG_GETEXP :
			if (m_pClientList[iClientH] == NULL) return FALSE;
			wsprintf(cTxt,"Crusade:    PC(%-10s)\tGet Crusade Exp\t(%d)\t \t(%s)", m_pClientList[iClientH]->m_cCharName, iData, m_pClientList[iClientH]->m_cGuildName);
			break ;
		case DEF_CRUSADELOG_STARTCRUSADE:
			wsprintf(cTxt,"Crusade:    Start Crusade");
			break ;
		case DEF_CRUSADELOG_ENDHELDENIAN:
			wsprintf(cTxt,"Heldenian:  End Heldenian type %d, %s",cName);
			break ;
		case DEF_CRUSADELOG_STARTHELDENIAN:
			wsprintf(cTxt,"Heldenian:  Start Heldenian type %d, %s owns BattleField.", iData, cName);
			break ;
		case DEF_CRUSADELOG_GETHELDENIANEXP:
			if (m_pClientList[iClientH] == NULL) return FALSE;
			wsprintf(cTxt,"Heldenian:  PC(%-10s)\tGet Heldenian Exp\t(%d)", m_pClientList[iClientH]->m_cCharName, iData);
			break ;
		case DEF_CRUSADELOG_HELDENIANVICTORY:
			wsprintf(cTxt,"Heldenian:  Heldenian type %d, victory before allowed time, %s.", iData, cName);
			break ;
		case DEF_CRUSADELOG_HELDENIANWARNOW:
			wsprintf(cTxt,"Heldenian:  Heldenian fighting starting now...");
			break ;
		case DEF_CRUSADELOG_APOCALYPSE:
			wsprintf(cTxt,"Apocalypse: %s", cName);
			break ;
		case DEF_CRUSADELOG_EK_LOG:
			wsprintf(cTxt,"EK: %s",cName);
			break ;
		case DEF_CRUSADELOG_TEST:
			wsprintf(cTxt,"Testing CRUSADELOG");
			break ;
		case DEF_CRUSADELOG_BEGINAVATAR:
			wsprintf(cTxt,"Avatar:	   Start Avatar event");
			break ;
		case DEF_CRUSADELOG_ENDAVATAR:
			wsprintf(cTxt,"Crusade:    End AVATAR event %s",cName);
			break ;

		default:
			return FALSE;
	}
	bSendMsgToLS(MSGID_GAMECRUSADELOG, iClientH, NULL,cTxt);
	return TRUE ;
}

// Testcode, found reference to it in 3.51, InitPlayerData and RequestTeleportHandler
int CGame::iGetPlayerABSStatus(int iClientH)
{	int iRet;
	// 1: isCivilian bit
	// 2: isAres bit (Elvine if absent)
	// 4: isNotNeutral bit
	// 8: isCriminal bit (or Evil side)
	if (m_pClientList[iClientH] == NULL) return 0;
	iRet = 0;
	if (m_pClientList[iClientH]->m_iPKCount != 0) 
	{	iRet = 8;		
		if (m_pClientList[iClientH]->m_iAdminUserLevel != 0) iRet = 0;// GMs not shown as criminals
	}
	// SNOOPY: New routine (for evil side (4)
	switch (m_pClientList[iClientH]->m_cSide) {
	case 0: 
		iRet = 3; // se voir en vert
		break;
	case 1: 
		iRet = iRet | 6; // isAres isNotNeutral
		if (m_pClientList[iClientH]->m_bIsPlayerCivil == TRUE)	iRet = iRet | 1;
		break;
	case 2: 
		iRet = iRet | 4; // isNotNeutral
		if (m_pClientList[iClientH]->m_bIsPlayerCivil == TRUE)	iRet = iRet | 1;
		break;
	case 4:		// Exec/Exec, mais le client recode ca en fonction de la ville et ca fera un Traveller.
		iRet = 2;	
		break;
	default: 
		iRet = iRet = 8;
		break;
	}
	return iRet;
}

//Init item based in its name
BOOL CGame::_bInitItemAttr(class CItem * pItem, char * pItemName)
{register int i;
 char cTmpName[21];
	ZeroMemory(cTmpName, sizeof(cTmpName));
	strcpy(cTmpName, pItemName);
	for (i = 0; i < DEF_MAXITEMTYPES; i++) 
	if (m_pItemConfigList[i] != NULL) 
	{	if (memcmp(cTmpName, m_pItemConfigList[i]->m_cName, 20) == 0) 
		{	ZeroMemory(pItem->m_cName, sizeof(pItem->m_cName));
			strcpy(pItem->m_cName, m_pItemConfigList[i]->m_cName);
			pItem->m_cItemType         = m_pItemConfigList[i]->m_cItemType;
			pItem->m_cEquipPos         = m_pItemConfigList[i]->m_cEquipPos;
			pItem->m_sItemEffectType   = m_pItemConfigList[i]->m_sItemEffectType;
			pItem->m_sItemEffectValue1 = m_pItemConfigList[i]->m_sItemEffectValue1;
			pItem->m_sItemEffectValue2 = m_pItemConfigList[i]->m_sItemEffectValue2;
			pItem->m_sItemEffectValue3 = m_pItemConfigList[i]->m_sItemEffectValue3;
			pItem->m_sItemEffectValue4 = m_pItemConfigList[i]->m_sItemEffectValue4;
			pItem->m_sItemEffectValue5 = m_pItemConfigList[i]->m_sItemEffectValue5;
			pItem->m_sItemEffectValue6 = m_pItemConfigList[i]->m_sItemEffectValue6;
			pItem->m_wMaxLifeSpan      = m_pItemConfigList[i]->m_wMaxLifeSpan;
			pItem->m_wCurLifeSpan	   = pItem->m_wMaxLifeSpan;					// 
			pItem->m_sSpecialEffect    = m_pItemConfigList[i]->m_sSpecialEffect;			
			pItem->m_sSprite           = m_pItemConfigList[i]->m_sSprite;
			pItem->m_sSpriteFrame      = m_pItemConfigList[i]->m_sSpriteFrame;
			pItem->m_wPrice            = m_pItemConfigList[i]->m_wPrice;
			pItem->m_wWeight           = m_pItemConfigList[i]->m_wWeight;
			pItem->m_cApprValue        = m_pItemConfigList[i]->m_cApprValue;
			pItem->m_cSpeed            = m_pItemConfigList[i]->m_cSpeed;
			pItem->m_sLevelLimit       = m_pItemConfigList[i]->m_sLevelLimit;
			pItem->m_cGenderLimit      = m_pItemConfigList[i]->m_cGenderLimit;			
			pItem->m_sSpecialEffectValue1 = m_pItemConfigList[i]->m_sSpecialEffectValue1;
			pItem->m_sSpecialEffectValue2 = m_pItemConfigList[i]->m_sSpecialEffectValue2;
			pItem->m_sRelatedSkill     = m_pItemConfigList[i]->m_sRelatedSkill;
			pItem->m_cCategory         = m_pItemConfigList[i]->m_cCategory;
			pItem->m_sIDnum			   = m_pItemConfigList[i]->m_sIDnum;
			pItem->m_bIsForSale	       = m_pItemConfigList[i]->m_bIsForSale;
			pItem->m_cItemColor        = m_pItemConfigList[i]->m_cItemColor;	
			return TRUE;
		}
	}
 	return FALSE;
}
//Init item based in its ID
BOOL CGame::_bInitItemAttr(class CItem * pItem, int iItemID)
{register int i;
for (i = 0; i < DEF_MAXITEMTYPES; i++) 
	if (m_pItemConfigList[i] != NULL) 
	{	if (m_pItemConfigList[i]->m_sIDnum == iItemID) 
		{	ZeroMemory(pItem->m_cName, sizeof(pItem->m_cName));
			strcpy(pItem->m_cName, m_pItemConfigList[i]->m_cName);
			pItem->m_cItemType         = m_pItemConfigList[i]->m_cItemType;
			pItem->m_cEquipPos         = m_pItemConfigList[i]->m_cEquipPos;
			pItem->m_sItemEffectType   = m_pItemConfigList[i]->m_sItemEffectType;
			pItem->m_sItemEffectValue1 = m_pItemConfigList[i]->m_sItemEffectValue1;
			pItem->m_sItemEffectValue2 = m_pItemConfigList[i]->m_sItemEffectValue2;
			pItem->m_sItemEffectValue3 = m_pItemConfigList[i]->m_sItemEffectValue3;
			pItem->m_sItemEffectValue4 = m_pItemConfigList[i]->m_sItemEffectValue4;
			pItem->m_sItemEffectValue5 = m_pItemConfigList[i]->m_sItemEffectValue5;
			pItem->m_sItemEffectValue6 = m_pItemConfigList[i]->m_sItemEffectValue6;
			pItem->m_wMaxLifeSpan      = m_pItemConfigList[i]->m_wMaxLifeSpan;
			pItem->m_wCurLifeSpan	   = pItem->m_wMaxLifeSpan;
			pItem->m_sSpecialEffect    = m_pItemConfigList[i]->m_sSpecialEffect;
			pItem->m_sSprite           = m_pItemConfigList[i]->m_sSprite;
			pItem->m_sSpriteFrame      = m_pItemConfigList[i]->m_sSpriteFrame;
			pItem->m_wPrice            = m_pItemConfigList[i]->m_wPrice;
			pItem->m_wWeight           = m_pItemConfigList[i]->m_wWeight;
			pItem->m_cApprValue        = m_pItemConfigList[i]->m_cApprValue;
			pItem->m_cSpeed            = m_pItemConfigList[i]->m_cSpeed;
			pItem->m_sLevelLimit       = m_pItemConfigList[i]->m_sLevelLimit;
			pItem->m_cGenderLimit      = m_pItemConfigList[i]->m_cGenderLimit;
			pItem->m_sSpecialEffectValue1 = m_pItemConfigList[i]->m_sSpecialEffectValue1;
			pItem->m_sSpecialEffectValue2 = m_pItemConfigList[i]->m_sSpecialEffectValue2;
			pItem->m_sRelatedSkill     = m_pItemConfigList[i]->m_sRelatedSkill;
			pItem->m_cCategory         = m_pItemConfigList[i]->m_cCategory;
			pItem->m_sIDnum			   = m_pItemConfigList[i]->m_sIDnum;
			pItem->m_bIsForSale	       = m_pItemConfigList[i]->m_bIsForSale;
			pItem->m_cItemColor        = m_pItemConfigList[i]->m_cItemColor;
			return TRUE;
	}	}
	return FALSE;
}

void CGame::ReqCreateSlateHandler(int iClientH, char* pData)
{int i, iRet;
 short *sp;
 char cItemID[4], ctr[4];
 char *cp, cSlateColour, cData[120];
 BOOL bIsSlatePresent = FALSE;
 BOOL bCreateFailed = FALSE;
 CItem * pItem;
 int iSlateType, iEraseReq;
 DWORD *dwp;
 WORD *wp;
	if (m_pClientList[iClientH] == NULL) return;
	if (m_pClientList[iClientH]->m_bIsOnWaitingProcess == TRUE) return;
	for(i = 0; i < 4; i++)
	{	cItemID[i] = 0;
		ctr[i] = 0;
	}
	cp = (char *)pData;
	cp += 11;
	// 14% chance of creating slates
	if (iDice(1,100) < m_sSlateSuccessRate) bIsSlatePresent = TRUE;
	else bCreateFailed = TRUE;
    try // make sure slates really exist
	{	for(i = 0; i < 4; i++)
		{	cItemID[i] = *cp;
			cp++;
			if(m_pClientList[iClientH]->m_pItemList[cItemID[i]] == NULL || cItemID[i] >DEF_MAXITEMS)
			{ 	bIsSlatePresent = FALSE;
				SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_SLATE_CREATEFAIL, NULL, NULL, NULL, NULL);  			
				return; 
			}//No duping
			if (m_pClientList[iClientH]->m_pItemList[cItemID[i]]->m_sIDnum == 868) // LU
				ctr[0] = 1;
			else if (m_pClientList[iClientH]->m_pItemList[cItemID[i]]->m_sIDnum == 869) // LD
				ctr[1] = 1;
			else if (m_pClientList[iClientH]->m_pItemList[cItemID[i]]->m_sIDnum == 870) // RU
				ctr[2] = 1;
			else if (m_pClientList[iClientH]->m_pItemList[cItemID[i]]->m_sIDnum == 871) // RD
				ctr[3] = 1;
		}	}
    catch(...)//Crash Hacker Caught		
	{	bIsSlatePresent = FALSE;
		SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_SLATE_CREATEFAIL, NULL, NULL, NULL, NULL);  
		wsprintf(G_cTxt, "TSearch SlateHack: PC(%s) - Creating slates without correct item.(Delayed). \tIP(%s)"
			, m_pClientList[iClientH]->m_cCharName
			, m_pClientList[iClientH]->m_cIPaddress);	
		PutHackLogFileList(G_cTxt);
		DelayedDeleteClient(iClientH, TRUE, TRUE);
		return;
    }
	// Are all 4 slates present ??
	if (ctr[0] != 1 || ctr[1] != 1 || ctr[2] != 1 || ctr[3] != 1) 
	{	bIsSlatePresent = FALSE;
		return; 
	}
	if (m_pClientList[iClientH]->m_iAdminUserLevel >= 3) bIsSlatePresent = TRUE;
	// if we failed, kill everything
	if ((!bIsSlatePresent) && (bCreateFailed == FALSE))
	{	for(i = 0; i < 4; i++) 
		{	if(m_pClientList[iClientH]->m_pItemList[cItemID[i]] != NULL) 
			{	ItemDepleteHandler(iClientH,cItemID[i], FALSE);
		} 	}
		SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_SLATE_CREATEFAIL, NULL, NULL, NULL, NULL); 
		return; 
	}
	// make the slates
	for(i = 0; i < 4; i++)
	{	if(m_pClientList[iClientH]->m_pItemList[cItemID[i]] != NULL) 
		{	ItemDepleteHandler(iClientH,cItemID[i], FALSE);	
	}	}
	// Colours: 0: incolore, 3:Yellow, 5:Green, 18: red, 36:Blue, 54:Black, 21: Pink, 34: Violet
	pItem = new class CItem;
	i = iDice(1,1000);
	if (i < 50)  // Hp slate
	{	iSlateType = 1;
		cSlateColour = 18;// red slate (18 or 32)
	}else if (i < 250)  // Bezerk slate
	{	iSlateType = 2;
		cSlateColour = 3; // yellow
	}else if (i < 750)  // Exp slate
	{	iSlateType = 4;
		cSlateColour = 5; // green (5 better than 7)
	}else if (i < 950)  // Mana slate
	{	iSlateType = 3;
		cSlateColour = 36; // Blue slate (36 better than 37)
	}else if (i <  1001)  // Hp slate
	{	iSlateType = 1;
		cSlateColour = 18; // red slate
	}
	if (bCreateFailed == TRUE)
	{	iSlateType = 5;
		cSlateColour = -10; // black slate, for people failing creating a real Slate
	}
	// Notify client
	SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_SLATE_CREATESUCCESS, iSlateType, NULL, NULL, NULL);
	ZeroMemory(cData,sizeof(cData));
	// Create slates
	if (_bInitItemAttr(pItem, 867) == FALSE) 
	{	delete pItem;
		return;
	}else
	{	pItem->m_sTouchEffectType   = DEF_ITET_ID;
		pItem->m_sTouchEffectValue1 = iDice(1,100000);
		pItem->m_sTouchEffectValue2 = iDice(1,100000);	
		SYSTEMTIME SysTime;
		char cTemp[256];
		GetLocalTime(&SysTime);
		ZeroMemory(cTemp, sizeof(cTemp));
		wsprintf(cTemp, "%d%2d",  (short)SysTime.wMonth, (short)SysTime.wDay);
		pItem->m_sTouchEffectValue3 = atoi(cTemp);
		_bItemLog(DEF_ITEMLOG_GET, iClientH, -1, pItem);
		wsprintf(G_cTxt, "PC(%s)\tCreated an Ancient tablet.\t%s(%d %d)\tIP(%s)"
			, m_pClientList[iClientH]->m_cCharName
			, m_pClientList[iClientH]->m_cMapName
			, m_pClientList[iClientH]->m_sX
			, m_pClientList[iClientH]->m_sY
			, m_pClientList[iClientH]->m_cIPaddress);
		PutItemLogFileList(G_cTxt);
		PutLogFileList(G_cTxt);	
		pItem->m_sItemSpecEffectValue2 = iSlateType;
		pItem->m_cItemColor = cSlateColour;
		if(_bAddClientItemList(iClientH, pItem, &iEraseReq) == TRUE)
		{	ZeroMemory(cData,sizeof(cData));
			dwp  = (DWORD *)(cData + DEF_INDEX4_MSGID);
			*dwp = MSGID_NOTIFY;
			wp   = (WORD *)(cData + DEF_INDEX2_MSGTYPE);
			*wp  = DEF_NOTIFY_ITEMOBTAINED;
			cp = (char *)(cData + DEF_INDEX2_MSGTYPE + 2);
			*cp = 1;
			cp++;
			memcpy(cp, pItem->m_cName, 20);
			cp += 20;
			dwp  = (DWORD *)cp;
			*dwp = pItem->m_dwCount;
			cp += 4;
			*cp = pItem->m_cItemType;
			cp++;
			*cp = pItem->m_cEquipPos;
			cp++;
			*cp = (char)0;
			cp++;
			sp  = (short *)cp;
			*sp = pItem->m_sLevelLimit;
			cp += 2;
			*cp = pItem->m_cGenderLimit;
			cp++;
			wp = (WORD *)cp;
			*wp = pItem->m_wCurLifeSpan;
			cp += 2;
			wp = (WORD *)cp;
			*wp = pItem->m_wWeight;
			cp += 2;
			sp  = (short *)cp;
			*sp = pItem->m_sSprite;
			cp += 2;
			sp  = (short *)cp;
			*sp = pItem->m_sSpriteFrame;
			cp += 2;
			*cp = pItem->m_cItemColor;
			cp++;
			*cp = (char)pItem->m_sItemSpecEffectValue2;
			cp ++;
			dwp  = (DWORD *)cp;
			*dwp = pItem->m_dwAttribute;
			cp += 4;
			if (iEraseReq == 1) delete pItem;
			iRet = m_pClientList[iClientH]->m_pXSock->iSendMsg(cData, 53);
			switch (iRet) {
			case DEF_XSOCKEVENT_QUENEFULL:
			case DEF_XSOCKEVENT_SOCKETERROR:
			case DEF_XSOCKEVENT_CRITICALERROR:
			case DEF_XSOCKEVENT_SOCKETCLOSED:
				DeleteClient(iClientH, TRUE, TRUE);
				return;
			}
		}else
		{	m_pMapList[ m_pClientList[iClientH]->m_cMapIndex ]->bSetItem(m_pClientList[iClientH]->m_sX, m_pClientList[iClientH]->m_sY, pItem);
			SendEventToNearClient_TypeB(MSGID_EVENT_COMMON, DEF_COMMONTYPE_ITEMDROP, m_pClientList[iClientH]->m_cMapIndex,
										m_pClientList[iClientH]->m_sX, m_pClientList[iClientH]->m_sY, pItem->m_sSprite, pItem->m_sSpriteFrame,
										pItem->m_cItemColor);
			dwp  = (DWORD *)(cData + DEF_INDEX4_MSGID);
			*dwp = MSGID_NOTIFY;
			wp   = (WORD *)(cData + DEF_INDEX2_MSGTYPE);
			*wp  = DEF_NOTIFY_CANNOTCARRYMOREITEM;
			iRet = m_pClientList[iClientH]->m_pXSock->iSendMsg(cData, 6);
			switch (iRet) {
			case DEF_XSOCKEVENT_QUENEFULL:
			case DEF_XSOCKEVENT_SOCKETERROR:
			case DEF_XSOCKEVENT_CRITICALERROR:
			case DEF_XSOCKEVENT_SOCKETCLOSED:
				DeleteClient(iClientH, TRUE, TRUE);
				break;
			}
		}
	}
	return;
}

// New 18/05/2004
void CGame::SetPlayingStatus(int iClientH)
{char cMapName[11], cLocation[11];
	if (m_pClientList[iClientH] == NULL) return;
	ZeroMemory(cMapName, sizeof(cMapName));
	ZeroMemory(cLocation, sizeof(cLocation));
	strcpy(cLocation, m_pClientList[iClientH]->m_cLocation);
	strcpy(cMapName, m_pMapList[ m_pClientList[iClientH]->m_cMapIndex]->m_cName);
	m_pClientList[iClientH]->m_cSide = 0;
	m_pClientList[iClientH]->m_bIsOwnLocation = FALSE;
	m_pClientList[iClientH]->m_bIsPlayerCivil = FALSE;

// Sobame patch replaced this by map setting PK-mode = 0,1,2
	if (memcmp(cLocation, cMapName, 3) == 0) 
	{	m_pClientList[iClientH]->m_bIsOwnLocation = TRUE;
	}
// SNOOPY: Revamped this to include Side 4 for non Ares/Elvine/Travellers
	if (memcmp(cLocation, "are", 3) == 0) 
	{	m_pClientList[iClientH]->m_cSide = 1;
	}else if (memcmp(cLocation, "elv", 3) == 0) 
	{		m_pClientList[iClientH]->m_cSide = 2;
	}else   // Travellers are OwnLocation in cities
	{	if (memcmp(cLocation, "NONE", 4) == 0) 
		{	if (strcmp(cMapName, "elvine") == 0 || strcmp(cMapName, "aresden") == 0) 
			{	m_pClientList[iClientH]->m_bIsOwnLocation = TRUE;
			}			
			m_pClientList[iClientH]->m_bIsNeutral = TRUE;
			m_pClientList[iClientH]->m_cSide = 0;
		}else 
		{	m_pClientList[iClientH]->m_cSide = 4;//Evil side is anything not "NONE" or citizens
			m_pClientList[iClientH]->m_iRating = -500; // Max Evil reputation for executors
			AdjustClientDropRate(iClientH);
		}
	}
	if (memcmp(cLocation, "arehunter", 9) == 0 || memcmp(cLocation, "elvhunter", 9) == 0) 
	{	m_pClientList[iClientH]->m_bIsPlayerCivil = TRUE;
	}
	if (memcmp(m_pClientList[iClientH]->m_cMapName, "bisle", 5) == 0) 
	{	m_pClientList[iClientH]->m_bIsPlayerCivil = FALSE;
	}

	if (memcmp(m_pClientList[iClientH]->m_cMapName, "bsmith", 6) == 0 ||
		memcmp(m_pClientList[iClientH]->m_cMapName, "gldhall", 7) == 0 ||
		memcmp(m_pClientList[iClientH]->m_cMapName, "gshop", 5) == 0)
		m_pClientList[iClientH]->m_pIsProcessingAllowed = TRUE;
	else
		m_pClientList[iClientH]->m_pIsProcessingAllowed = FALSE;

	if (memcmp(m_pClientList[iClientH]->m_cMapName, "wrhus", 5) == 0 ||
		memcmp(m_pClientList[iClientH]->m_cMapName, "arewrhus", 8) == 0 ||
		memcmp(m_pClientList[iClientH]->m_cMapName, "elvwrhus", 8) == 0)
		m_pClientList[iClientH]->m_bIsInsideWarehouse = TRUE;
	else
		m_pClientList[iClientH]->m_bIsInsideWarehouse = FALSE;

	if (memcmp(m_pClientList[iClientH]->m_cMapName, "wzdtwr", 6) == 0)
		m_pClientList[iClientH]->m_bIsInsideWizardTower = TRUE;
	else
		m_pClientList[iClientH]->m_bIsInsideWizardTower = FALSE;
}

void CGame::ForceChangePlayMode(int iClientH, bool bNotify)
{
	if(m_pClientList[iClientH] == NULL) return;

	if (memcmp(m_pClientList[iClientH]->m_cLocation, "arehunter", 9) == 0)
		strcpy(m_pClientList[iClientH]->m_cLocation, "aresden");
	else if (memcmp(m_pClientList[iClientH]->m_cLocation, "elvhunter", 9) == 0)
		strcpy(m_pClientList[iClientH]->m_cLocation, "elvine");

	if (m_pClientList[iClientH]->m_bIsPlayerCivil == TRUE)
		m_pClientList[iClientH]->m_bIsPlayerCivil = FALSE;

	if (bNotify) {
		SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_CHANGEPLAYMODE, NULL, NULL, NULL, m_pClientList[iClientH]->m_cLocation);
		SendEventToNearClient_TypeA(iClientH, DEF_OWNERTYPE_PLAYER, MSGID_EVENT_MOTION, DEF_OBJECTNULLACTION, NULL, NULL, NULL);
	}
}

void CGame::ShowVersion(int iClientH)
{   char cVerMessage[256];
	ZeroMemory(cVerMessage, sizeof(cVerMessage));
	wsprintf(cVerMessage, " Helbreath %s.%s - Equilibrium Project by Snoopy81", DEF_UPPERVERSION, DEF_LOWERVERSION);
	ShowClientMsg(iClientH, "HGserver",  cVerMessage);
}

// v2.15 2002-5-21
void CGame::GSM_RequestShutupPlayer(char * pGMName,WORD wReqServerID, WORD wReqClientH, WORD wTime,char * pPlayer )
{	char * cp, cTemp[120];
	WORD * wp;
	register int i;
	for (i = 1; i < DEF_MAXCLIENTS; i++)
		if ((m_pClientList[i] != NULL) && (strcmp(m_pClientList[i]->m_cCharName, pPlayer) == 0)) {
			ZeroMemory(cTemp, sizeof(cTemp));
			cp = (char *)(cTemp);
			*cp = GSM_RESPONSE_SHUTUPPLAYER;
			cp++;
			wp = (WORD *)cp;
			*wp = wReqServerID;
			cp += 2;
			wp = (WORD *)cp;
			*wp = wReqClientH;
			cp += 2;
			memcpy(cp, pGMName, 10);
			cp += 10;
			wp = (WORD *)cp;
			*wp = (WORD) wTime;
			cp += 2;
			memcpy(cp, pPlayer, 10);
			cp += 10;
			m_pClientList[i]->m_iTimeLeft_ShutUp = wTime*20;
			SendNotifyMsg(NULL, i, DEF_NOTIFY_PLAYERSHUTUP, wTime*60, NULL, NULL, pPlayer);			
			wsprintf(G_cTxt, "GM Order(----------): /shutup (done)");
			bSendMsgToLS(MSGID_GAMEMASTERLOG, -1, FALSE, G_cTxt);
			bStockMsgToGateServer(cTemp, 27);
			return;	
		}
}
//_bPKLog(DEF_PKLOG_BYNPC,iClientH,NULL,cAttackerName) ;
// v2.14 05/22/2004 - Hypnotoad - adds pk log
// SNOOPY: Changed the log to be more readable (as in v2.191...) 
BOOL CGame::_bPKLog(int iAction,int iAttackerH , int iVictumH, char * pNPC)
{	char  cTxt[1024];
	ZeroMemory(cTxt, sizeof(cTxt));
	if ( m_pClientList[iVictumH] == NULL) return FALSE ;
	switch (iAction) {
		case DEF_PKLOG_REDUCECRIMINAL: 
			wsprintf(cTxt, "PC(%s(%d))\tReduced PKCount(%d)\t%s(%d %d)\tIP(%s)"
				, m_pClientList[iVictumH]->m_cCharName
				, m_pClientList[iVictumH]->m_iLevel
				, m_pClientList[iVictumH]->m_iPKCount
				, m_pClientList[iVictumH]->m_cMapName
				, m_pClientList[iVictumH]->m_sX
				, m_pClientList[iVictumH]->m_sY
				, m_pClientList[iVictumH]->m_cIPaddress);
			break; 
		case DEF_PKLOG_BYPLAYER: // Crim killed
			if ( m_pClientList[iAttackerH] == NULL) return FALSE; 
			wsprintf(cTxt, "PC(%s(%d))\tCriminal killed by PC(%s(%d))\t%s(%d %d)\tIP(%s)by(%s)"
				, m_pClientList[iVictumH]->m_cCharName
				, m_pClientList[iVictumH]->m_iLevel
				, m_pClientList[iAttackerH]->m_cCharName
				, m_pClientList[iAttackerH]->m_iLevel
				, m_pClientList[iVictumH]->m_cMapName
				, m_pClientList[iVictumH]->m_sX
				, m_pClientList[iVictumH]->m_sY
				, m_pClientList[iVictumH]->m_cIPaddress
				, m_pClientList[iAttackerH]->m_cIPaddress);
			break;
		case DEF_PKLOG_BYENEMY:
			if ( m_pClientList[iAttackerH] == NULL) return FALSE ;
			wsprintf(cTxt, "PC(%s(%d))\tKilled by Enemy(%s(%d))EKCount(%d)\t%s(%d %d)\tIP(%s)by(%s)"
				, m_pClientList[iVictumH]->m_cCharName
				, m_pClientList[iVictumH]->m_iLevel
				, m_pClientList[iAttackerH]->m_cCharName
				, m_pClientList[iAttackerH]->m_iLevel
				, m_pClientList[iAttackerH]->m_iEnemyKillCount
				, m_pClientList[iVictumH]->m_cMapName
				, m_pClientList[iVictumH]->m_sX
				, m_pClientList[iVictumH]->m_sY
				, m_pClientList[iVictumH]->m_cIPaddress
				, m_pClientList[iAttackerH]->m_cIPaddress);
			break; 
		case DEF_PKLOG_BYENEMY_SAME_IP:
			if ( m_pClientList[iAttackerH] == NULL) return FALSE; 
			wsprintf(cTxt, "PC(%s(%d))\tKilled by Enemy with same IP - PC(%s(%d))\t%s(%d %d)\tIP(%s)"
				, m_pClientList[iVictumH]->m_cCharName
				, m_pClientList[iVictumH]->m_iLevel
				, m_pClientList[iAttackerH]->m_cCharName
				, m_pClientList[iAttackerH]->m_iLevel
				, m_pClientList[iVictumH]->m_cMapName
				, m_pClientList[iVictumH]->m_sX
				, m_pClientList[iVictumH]->m_sY
				, m_pClientList[iVictumH]->m_cIPaddress);
			PutHackLogFileList(cTxt);
			break;
		case DEF_PKLOG_BYPK:
			if ( m_pClientList[iAttackerH] == NULL) return FALSE ;
			wsprintf(cTxt, "PC(%s(%d))\tKilled by PK(%s(%d))PKCount(%d)\t%s(%d %d)\tIP(%s)by(%s)"
				, m_pClientList[iVictumH]->m_cCharName
				, m_pClientList[iVictumH]->m_iLevel
				, m_pClientList[iAttackerH]->m_cCharName
				, m_pClientList[iAttackerH]->m_iLevel
				, m_pClientList[iAttackerH]->m_iPKCount
				, m_pClientList[iVictumH]->m_cMapName
				, m_pClientList[iVictumH]->m_sX
				, m_pClientList[iVictumH]->m_sY
				, m_pClientList[iVictumH]->m_cIPaddress
				, m_pClientList[iAttackerH]->m_cIPaddress);
			break; 
		case DEF_PKLOG_BYNPC:
			if ( pNPC == NULL ) return FALSE ;
			wsprintf(cTxt, "PC(%s(%d))\tKilled by NPC(%s)\t%s(%d %d)\tIP(%s)"
				, m_pClientList[iVictumH]->m_cCharName
				, m_pClientList[iVictumH]->m_iLevel
				, pNPC
				, m_pClientList[iVictumH]->m_cMapName
				, m_pClientList[iVictumH]->m_sX
				, m_pClientList[iVictumH]->m_sY
				, m_pClientList[iVictumH]->m_cIPaddress);
			break; 
		case DEF_PKLOG_BYOTHER:
			wsprintf(cTxt, "PC(%s)\tKilled by Other\t%s(%d %d)\tIP(%s)"
				, m_pClientList[iVictumH]->m_cCharName
				, m_pClientList[iVictumH]->m_iLevel
				, m_pClientList[iVictumH]->m_cMapName
				, m_pClientList[iVictumH]->m_sX
				, m_pClientList[iVictumH]->m_sY
				, m_pClientList[iVictumH]->m_cIPaddress);
			break; 			
		// Added by Snoopy
		case DEF_PKLOG_RESURRECTION: 
			wsprintf(cTxt, "PC(%s(%d))\tResurrected \t%s(%d %d)\tIP(%s)"
				, m_pClientList[iVictumH]->m_cCharName
				, m_pClientList[iVictumH]->m_iLevel
				, m_pClientList[iVictumH]->m_cMapName
				, m_pClientList[iVictumH]->m_sX
				, m_pClientList[iVictumH]->m_sY
				, m_pClientList[iVictumH]->m_cIPaddress);
			break; 				
		// Added by Snoopy
		case DEF_PKLOG_BYSELF: 
			wsprintf(cTxt, "PC(%s(%d))\tPerformed suicide \t%s(%d %d)\tIP(%s)"
				, m_pClientList[iVictumH]->m_cCharName
				, m_pClientList[iVictumH]->m_iLevel
				, m_pClientList[iVictumH]->m_cMapName
				, m_pClientList[iVictumH]->m_sX
				, m_pClientList[iVictumH]->m_sY
				, m_pClientList[iVictumH]->m_cIPaddress);
			break; 
		// Added by Snoopy
		case DEF_PKLOG_SAFEMAP: 
			if ( m_pClientList[iAttackerH] == NULL) return FALSE ;
			wsprintf(cTxt, "PC(%s(%d))\tKilled by Enemy(%s(%d)) on a no penalty/reward map. \t%s(%d %d)\tIP(%s)by(%s)"
				, m_pClientList[iVictumH]->m_cCharName
				, m_pClientList[iVictumH]->m_iLevel
				, m_pClientList[iAttackerH]->m_cCharName
				, m_pClientList[iAttackerH]->m_iLevel
				, m_pClientList[iVictumH]->m_cMapName
				, m_pClientList[iVictumH]->m_sX
				, m_pClientList[iVictumH]->m_sY
				, m_pClientList[iVictumH]->m_cIPaddress
				, m_pClientList[iAttackerH]->m_cIPaddress);
			break; 
		// Added by Snoopy
		case DEF_PKLOG_PLRAIDER: 
			wsprintf(cTxt, "PC(%s(%d))\tChoose to limit his level to %d. \t%s(%d %d)\tIP(%s)"			
				, m_pClientList[iVictumH]->m_cCharName
				, m_pClientList[iVictumH]->m_iLevel
				, DEF_PLRAIDER_LEVELLIMIT
				, m_pClientList[iVictumH]->m_cMapName
				, m_pClientList[iVictumH]->m_sX
				, m_pClientList[iVictumH]->m_sY
				, m_pClientList[iVictumH]->m_cIPaddress);
			break; 
		default:
			return FALSE;
	}
	PutPvPLogFileList(cTxt);
	return TRUE ;
}

void CGame::RequestResurrectPlayer(int iClientH, bool bResurrect)
{	short sX, sY;
	char buff[100];
	if (m_pClientList[iClientH] == NULL) return;
	sX = m_pClientList[iClientH]->m_sX;
	sY = m_pClientList[iClientH]->m_sY;
	if (bResurrect == FALSE) 
	{	m_pClientList[iClientH]->m_bIsBeingResurrected = FALSE;
		return;
	}
	if (m_pClientList[iClientH]->m_bIsBeingResurrected == FALSE) 
	{	wsprintf(buff,   "Resurrection hack: PC(%s) - Tried to use resurrection hack.(Delayed). \tIP(%s)"
			, m_pClientList[iClientH]->m_cCharName
			, m_pClientList[iClientH]->m_cIPaddress);
		PutHackLogFileList(G_cTxt);
		DelayedDeleteClient(iClientH, TRUE, TRUE, TRUE, TRUE);
		return;
	}
	wsprintf(buff, "(*) Resurrect Player! %s", m_pClientList[iClientH]->m_cCharName);
	PutLogList(buff);

	// SNOOPY: Log this on PKlog	DEF_PKLOG_RESURRECTION
 	_bPKLog(DEF_PKLOG_RESURRECTION,NULL,iClientH,NULL) ;
	m_pClientList[iClientH]->m_bIsKilled = FALSE;
	m_pClientList[iClientH]->m_bKilledByPlayerKiller = FALSE;
	// Player's HP becomes half of the Max HP. 
	m_pClientList[iClientH]->m_iHP = iGetMaxHP(iClientH, FALSE)/2; 
	// Player's MP
	m_pClientList[iClientH]->m_iMP = iGetMaxMP(iClientH)/2;
	// Player's SP
	m_pClientList[iClientH]->m_iSP = iGetMaxSP(iClientH)/2;
	// Player's Hunger
	m_pClientList[iClientH]->m_iHungerStatus = 100;
	m_pClientList[iClientH]->m_bIsBeingResurrected = FALSE;
	RequestTeleportHandler(iClientH, "2   ", m_pClientList[iClientH]->m_cMapName, m_pClientList[iClientH]->m_sX, m_pClientList[iClientH]->m_sY);
}

///////////////////////////////////////////////////////////////////////////////////////
// SpeedHack detection rewriten by Snoopy81
//			Return value:	TRUE  Too fast, block the move!.., 
//							FALSE Don't block
/////////////////////////////////////////////////////////////////////////////////////// 
BOOL CGame::bCheckClientDashFrequency(int iClientH, DWORD dwClientTime, DWORD dwMsgTime)
{	// dwMsgTime is not used here (using only client side time)
	if (m_pClientList[iClientH] == NULL) return FALSE;
	m_pClientList[iClientH]->m_iWalkCount = 0;
	m_pClientList[iClientH]->m_iRunCount = 0;
	m_pClientList[iClientH]->m_iAttackCount = 0;
	if (dwClientTime == 0)
	{	wsprintf(G_cTxt, "Swing Speeder:     PC(%s) - Attack time missing (Hack?).(Disc.) \tIP(%s)"
			, m_pClientList[iClientH]->m_cCharName
			, m_pClientList[iClientH]->m_cIPaddress);
		PutHackLogFileList(G_cTxt);
		DeleteClient(iClientH, TRUE, TRUE);
		return TRUE;
	}
	// Detect Swinging with low strength....
	int iSpeed = 0;
	short sItemIndex = m_pClientList[iClientH]->m_sItemEquipmentStatus[DEF_EQUIPPOS_RHAND];
	if ((sItemIndex != -1) && (m_pClientList[iClientH]->m_pItemList[sItemIndex] != NULL)) 
	{	iSpeed = (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cSpeed); // Already includes Agile weapons effect
	}
	sItemIndex = m_pClientList[iClientH]->m_sItemEquipmentStatus[DEF_EQUIPPOS_TWOHAND];
	if ((sItemIndex != -1) && (m_pClientList[iClientH]->m_pItemList[sItemIndex] != NULL)) 
	{	iSpeed = (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cSpeed); // Already includes Agile weapons effect		
	}
	iSpeed -= ((m_pClientList[iClientH]->m_iStr + m_pClientList[iClientH]->m_iAngelicStr) / 13);
	if (iSpeed < 0) iSpeed = 0;

	// If just changed Peace/Dash mode,, we reset average
	if (m_pClientList[iClientH]->m_bIsAttackModeChange == TRUE) // reset
	{	m_pClientList[iClientH]->m_bIsAttackModeChange = FALSE;
		m_pClientList[iClientH]->m_iDashCount = 0;
		return FALSE;
	}
	
	// detect dashing with low skill
	short sSkillUsed = m_pClientList[iClientH]->m_sUsingWeaponSkill;	
	WORD wWeaponType = ((m_pClientList[iClientH]->m_sAppr2 & 0x0FF0) >> 4);
	if (   (m_pClientList[iClientH]->m_cSkillMastery[sSkillUsed] != 100) 
		&& (wWeaponType != 25) // PickAxe
		&& (wWeaponType != 27) // Hoe
		&& ((m_pClientList[iClientH]->m_sAppr2 & 0xF000) != 0) // Not peace mode
		&& (m_pClientList[iClientH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_METAMORPHOSIS ] == 0) ) 
	{	wsprintf(G_cTxt, "Fullswing Hack:    PC(%s) - Dashing with only (%d) weapon skill.(Disc.) \tIP(%s)"
				, m_pClientList[iClientH]->m_cCharName
				, m_pClientList[iClientH]->m_cSkillMastery[sSkillUsed]
				, m_pClientList[iClientH]->m_cIPaddress);
		PutHackLogFileList(G_cTxt);
		DeleteClient(iClientH, TRUE, TRUE);
		return TRUE;
	}

	int iGapAvr;	
	if (m_pClientList[iClientH]->m_iDashCount == 0)
	{	m_pClientList[iClientH]->m_dwDashLAT   = dwClientTime;
		m_pClientList[iClientH]->m_iDashTotal  = 0;	
		m_pClientList[iClientH]->m_iDashCount  = 1;
	}else
	{	if ((dwClientTime - m_pClientList[iClientH]->m_dwDashLAT) > 3000)
		{	// Stopped Dashing
			m_pClientList[iClientH]->m_iDashCount  = 0;	
			return FALSE;
		}
		m_pClientList[iClientH]->m_iDashTotal  += (dwClientTime - m_pClientList[iClientH]->m_dwDashLAT);
		iGapAvr  = m_pClientList[iClientH]->m_iDashTotal / m_pClientList[iClientH]->m_iDashCount;	
		if (m_pClientList[iClientH]->m_bMonitorThisChar)
		{	wsprintf(G_cTxt, "Dash  Speed:  PC(%s) (C:%dms) (Speed:%d)"				
				, m_pClientList[iClientH]->m_cCharName
				, (dwClientTime - m_pClientList[iClientH]->m_dwDashLAT)
				, iSpeed);
			PutMonitorLogFileList(G_cTxt);
		}
		// Client average gap is too short
		if (iGapAvr < 720 + ( 30 * m_pClientList[iClientH]->m_iDashCount)) // Dash too fast (average 100ms)
		{	// 750 to 900 mini average Dash speed (normal is 1sec
			wsprintf(G_cTxt, "Hack (Dash):  PC(%s) - Client dash gap low.(C:%dms)(%d mesures) \tIP(%s)"
				, m_pClientList[iClientH]->m_cCharName
				, iGapAvr
				, m_pClientList[iClientH]->m_iDashCount
				, m_pClientList[iClientH]->m_cIPaddress);
			PutHackLogFileList(G_cTxt);	
			m_pClientList[iClientH]->m_iDashCount  = 0;
			if (m_pClientList[iClientH]->m_bMonitorThisChar) PutMonitorLogFileList(G_cTxt);	
			else return TRUE;
		}
		m_pClientList[iClientH]->m_dwDashLAT   = dwClientTime;
		m_pClientList[iClientH]->m_iDashCount  +=1;
		if (m_pClientList[iClientH]->m_iDashCount > 6)
		{	m_pClientList[iClientH]->m_iDashCount = 0;
		}
	}
	return FALSE;
}
///////////////////////////////////////////////////////////////////////////////////////
// SpeedHack detection rewriten by Snoopy81
//			Return value:	TRUE  Too fast, block the move!.., 
//							FALSE Don't block
/////////////////////////////////////////////////////////////////////////////////////// 
BOOL CGame::bCheckClientAttackFrequency(int iClientH, DWORD dwClientTime, DWORD dwMsgTime)
{	if (m_pClientList[iClientH] == NULL) return FALSE;
	m_pClientList[iClientH]->m_iWalkCount = 0;
	m_pClientList[iClientH]->m_iRunCount  = 0;
	m_pClientList[iClientH]->m_iDashCount = 0;
	if (dwClientTime == 0)
	{	wsprintf(G_cTxt, "Swing Speeder:     PC(%s) - Attack time missing (Hack?).(Disc.) \tIP(%s)"
			, m_pClientList[iClientH]->m_cCharName
			, m_pClientList[iClientH]->m_cIPaddress);
		PutHackLogFileList(G_cTxt);
		DeleteClient(iClientH, TRUE, TRUE);
		return TRUE;
	}
	// Detect Swinging with low strength....
	int iSpeed = 0;
	short sItemIndex = m_pClientList[iClientH]->m_sItemEquipmentStatus[DEF_EQUIPPOS_RHAND];
	if ((sItemIndex != -1) && (m_pClientList[iClientH]->m_pItemList[sItemIndex] != NULL)) 
	{	iSpeed = (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cSpeed); // Already includes Agile weapons effect
	}
	sItemIndex = m_pClientList[iClientH]->m_sItemEquipmentStatus[DEF_EQUIPPOS_TWOHAND];
	if ((sItemIndex != -1) && (m_pClientList[iClientH]->m_pItemList[sItemIndex] != NULL)) 
	{	iSpeed = (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cSpeed); // Already includes Agile weapons effect		
	}
	iSpeed -= ((m_pClientList[iClientH]->m_iStr + m_pClientList[iClientH]->m_iAngelicStr) / 13);
	if (iSpeed < 0) iSpeed = 0;
	if (m_pClientList[iClientH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_METAMORPHOSIS ] != 0) iSpeed = 0;

	// If just changed Peace/Attack mode,, we reset average
	if (m_pClientList[iClientH]->m_bIsAttackModeChange == TRUE) // reset
	{	m_pClientList[iClientH]->m_bIsAttackModeChange = FALSE;
		m_pClientList[iClientH]->m_iAttackCount = 0;
		return FALSE;
	}
	int iGapAvr, iGapAvrS;
	switch (m_pClientList[iClientH]->m_iAttackCount) {
	case 0: // 1st Attack message
		m_pClientList[iClientH]->m_dwAttackLAT   = dwClientTime;
		m_pClientList[iClientH]->m_dwAttackLATS  = dwMsgTime;	
		m_pClientList[iClientH]->m_iAttackTotal  = 0;		
		m_pClientList[iClientH]->m_iAttackTotalS = 0;	
		m_pClientList[iClientH]->m_iAttackCount  = 1;
		break;
	case 1: // 2nd Attack msg, 1st gap calculation
	case 2: // 2..4 gaps computed
	case 3:
	case 4: // Standard Attacking speed is +- 545 ms
	case 5: 
		// Hum.... last msg sent before previous one!				
		if (dwClientTime <= m_pClientList[iClientH]->m_dwAttackLAT)
		{	if (dwMsgTime > m_pClientList[iClientH]->m_dwAttackLATS +400)
			{	// But server side seems normal: Big Lag effect or SpeedHack!
				wsprintf(G_cTxt, "Swing Speed:  PC(%s) - Negative Client gap, just stopped to SpeedHack. (Disc.) \tIP(%s)"					
					, m_pClientList[iClientH]->m_cCharName
					, m_pClientList[iClientH]->m_cIPaddress);
				PutHackLogFileList(G_cTxt);	
				PutLogList(G_cTxt);						
				m_pClientList[iClientH]->m_iAttackCount  = 0; // Sure of reset if Delete client commented
				if (m_pClientList[iClientH]->m_bMonitorThisChar) PutMonitorLogFileList(G_cTxt);	
				else DeleteClient(iClientH, TRUE, TRUE);
				return FALSE;	
			}
		}			
		// Stopped Swinging ....restart mesures from this msg			
		if (   ((dwClientTime - m_pClientList[iClientH]->m_dwAttackLAT) > 1500)
			&& ((dwMsgTime - m_pClientList[iClientH]->m_dwAttackLATS) > 1200))
		{	// Do not count this time.
			if (m_pClientList[iClientH]->m_bMonitorThisChar)
			{	wsprintf(G_cTxt, "Swing Speed:  PC(%s) (C:%dms S:%dms) - Stopped Attacking."				
					, m_pClientList[iClientH]->m_cCharName
					, (dwClientTime - m_pClientList[iClientH]->m_dwAttackLAT)
					, (dwMsgTime - m_pClientList[iClientH]->m_dwAttackLATS));
				PutMonitorLogFileList(G_cTxt);
			}
			m_pClientList[iClientH]->m_dwAttackLAT   = dwClientTime;
			m_pClientList[iClientH]->m_dwAttackLATS  = dwMsgTime;
			m_pClientList[iClientH]->m_iAttackTotal  = 0;		
			m_pClientList[iClientH]->m_iAttackTotalS = 0;	
			m_pClientList[iClientH]->m_iAttackCount  = 1;	
			break;
		}
		m_pClientList[iClientH]->m_iAttackTotal  += (dwClientTime - m_pClientList[iClientH]->m_dwAttackLAT);
		m_pClientList[iClientH]->m_iAttackTotalS += (dwMsgTime - m_pClientList[iClientH]->m_dwAttackLATS);
		iGapAvr  = m_pClientList[iClientH]->m_iAttackTotal / m_pClientList[iClientH]->m_iAttackCount;
		iGapAvrS = m_pClientList[iClientH]->m_iAttackTotalS/ m_pClientList[iClientH]->m_iAttackCount;
		if (m_pClientList[iClientH]->m_bMonitorThisChar)
		{	wsprintf(G_cTxt, "Swing Speed:  PC(%s) (C:%dms S:%dms)(Speed:%d)"				
				, m_pClientList[iClientH]->m_cCharName
				, (dwClientTime - m_pClientList[iClientH]->m_dwAttackLAT)
				, (dwMsgTime - m_pClientList[iClientH]->m_dwAttackLATS)
				, iSpeed);
			PutMonitorLogFileList(G_cTxt);
		}
		// Client gap is too short (FullSwing Hack?)(standard is +-600)
		if (dwClientTime - m_pClientList[iClientH]->m_dwAttackLAT < 490 + ( 10 * m_pClientList[iClientH]->m_iAttackCount) + (80 * iSpeed)) // Attack too fast
		{	m_pClientList[iClientH]->m_iAttackCountBad +=1;//  0;m_iAttackCountOK = 
		}else if (iGapAvr < 990 + ( 10 * m_pClientList[iClientH]->m_iAttackCount) + (80 * iSpeed))
		{	m_pClientList[iClientH]->m_iAttackCountOK += 1;
		}

		// Client average gap is too short (standard is +-600)
		// If using a slow weapon, the gap increase is not mandatory because of been hurt....
		if (iGapAvr < 500) // Attack too fast
		{	// 500 to 550 mini average Swing speed Don't mesure speed here because could not delay some swings (when been hurt)
		    wsprintf(G_cTxt, "Swing Speed:  PC(%s) (C:%dms S:%dms)(Speed:%d) - Client swing gap low.(%d mesures) \tIP(%s)"
				, m_pClientList[iClientH]->m_cCharName
				, iGapAvr
				, iGapAvrS
				, m_pClientList[iClientH]->m_iAttackCount
				, iSpeed
				, m_pClientList[iClientH]->m_cIPaddress);
			PutHackLogFileList(G_cTxt);	
			m_pClientList[iClientH]->m_iAttackCount  = 0;
			if (m_pClientList[iClientH]->m_bMonitorThisChar) PutMonitorLogFileList(G_cTxt);	
			else return TRUE;
			return FALSE;
		}
		m_pClientList[iClientH]->m_dwAttackLAT   = dwClientTime;
		m_pClientList[iClientH]->m_dwAttackLATS  = dwMsgTime;	
		m_pClientList[iClientH]->m_iAttackCount  +=1;
		break;
	case 6: // last determination	
		// Hum.... last msg sent before previous one!				
		if (dwClientTime <= m_pClientList[iClientH]->m_dwAttackLAT)
		{	if (dwMsgTime > m_pClientList[iClientH]->m_dwAttackLATS +400)
			{	// But server side seems normal: Big Lag effect or SpeedHack!	
				wsprintf(G_cTxt, "Swing Speed:  PC(%s) - Negative Client gap, just stopped to SpeedHack. (Disc.) \tIP(%s)"					
					, m_pClientList[iClientH]->m_cCharName
					, m_pClientList[iClientH]->m_cIPaddress);
				PutHackLogFileList(G_cTxt);	
				PutLogList(G_cTxt);						
				m_pClientList[iClientH]->m_iAttackCount  = 0; // reset
				if (m_pClientList[iClientH]->m_bMonitorThisChar) PutMonitorLogFileList(G_cTxt);	
				else DeleteClient(iClientH, TRUE, TRUE);	
				return FALSE;	
			}
		}			
		// Stopped Attacking ..		restart mesures from this msg	
		if (   ((dwClientTime - m_pClientList[iClientH]->m_dwAttackLAT) > 1500)
			&& ((dwMsgTime - m_pClientList[iClientH]->m_dwAttackLATS) > 1200))
		{	if (m_pClientList[iClientH]->m_bMonitorThisChar)
			{	wsprintf(G_cTxt, "Swing Speed:  PC(%s) (C:%dms S:%dms) - Stopped attacking."				
					, m_pClientList[iClientH]->m_cCharName
					, (dwClientTime - m_pClientList[iClientH]->m_dwAttackLAT)
					, (dwMsgTime - m_pClientList[iClientH]->m_dwAttackLATS));			
				PutMonitorLogFileList(G_cTxt);					
			}
			m_pClientList[iClientH]->m_dwAttackLAT   = dwClientTime;
			m_pClientList[iClientH]->m_dwAttackLATS  = dwMsgTime;
			m_pClientList[iClientH]->m_iAttackTotal  = 0;
			m_pClientList[iClientH]->m_iAttackTotalS = 0;
			m_pClientList[iClientH]->m_iAttackCount  = 1;						
			break;
		}
		m_pClientList[iClientH]->m_iAttackTotal += (dwClientTime - m_pClientList[iClientH]->m_dwAttackLAT);
		m_pClientList[iClientH]->m_iAttackTotalS += (dwMsgTime - m_pClientList[iClientH]->m_dwAttackLATS);
		iGapAvr = m_pClientList[iClientH]->m_iAttackTotal  / m_pClientList[iClientH]->m_iAttackCount;
		iGapAvrS = m_pClientList[iClientH]->m_iAttackTotalS/ m_pClientList[iClientH]->m_iAttackCount;
		if (m_pClientList[iClientH]->m_bMonitorThisChar)
		{	wsprintf(G_cTxt, "Swing Speed:  PC(%s) (C:%dms S:%dms)(Speed:%d)"				
				, m_pClientList[iClientH]->m_cCharName
				, (dwClientTime - m_pClientList[iClientH]->m_dwAttackLAT)
				, (dwMsgTime - m_pClientList[iClientH]->m_dwAttackLATS)
				, iSpeed);
			PutMonitorLogFileList(G_cTxt);			
			wsprintf(G_cTxt, "Swing Speed:  PC(%s) (#:%dms #:%dms)"				
				, m_pClientList[iClientH]->m_cCharName
				, iGapAvr
				, iGapAvrS);
			PutMonitorLogFileList(G_cTxt);	
		}
		// Client average gap is too short (FullSwing Hack?)(standard is +-600)
		if (dwClientTime - m_pClientList[iClientH]->m_dwAttackLAT < 490 + ( 10 * m_pClientList[iClientH]->m_iAttackCount) + (80 * iSpeed)) // Attack too fast
		{	m_pClientList[iClientH]->m_iAttackCountBad +=1;//  0;m_iAttackCountOK 
		}else if (iGapAvr < 990 + ( 10 * m_pClientList[iClientH]->m_iAttackCount) + (80 * iSpeed))
		{	m_pClientList[iClientH]->m_iAttackCountOK += 1;
		}
		if (m_pClientList[iClientH]->m_iAttackCountBad > m_pClientList[iClientH]->m_iAttackCountOK)
		{	//printf(G_cTxt, "Swing Speed:  PC(%s) (C:%dms S:%dms)(Speed:%d)"	
			wsprintf(G_cTxt, "Swing Speed:  PC(%s) (C:%dms S:%dms)(Speed:%d) - Many short gaps. (Bad:%d OK:%d) FullSwing hack. (Disc.) \tIP(%s)"
				, m_pClientList[iClientH]->m_cCharName
				, iGapAvr
				, iGapAvrS
				, m_pClientList[iClientH]->m_iAttackCountBad
				, m_pClientList[iClientH]->m_iAttackCountOK
				, iSpeed
				, m_pClientList[iClientH]->m_cIPaddress);
			PutHackLogFileList(G_cTxt);
			m_pClientList[iClientH]->m_iAttackCount  = 0; // reset
			if (m_pClientList[iClientH]->m_bMonitorThisChar) PutMonitorLogFileList(G_cTxt);		
			else DeleteClient(iClientH, TRUE, TRUE);
				return TRUE;
		}else if (m_pClientList[iClientH]->m_iAttackCountBad < (m_pClientList[iClientH]->m_iAttackCountOK*2))
		{	m_pClientList[iClientH]->m_iAttackCountOK = m_pClientList[iClientH]->m_iAttackCountBad = 0;
		
		}
		// Client average gap is too short (standard is +-600)
		if (iGapAvr < 520) // Attack too fast
		{	wsprintf(G_cTxt, "Swing Speed:  PC(%s) (C:%dms S:%dms)(Speed:%d) - Client swing gap low.(6 mesures) \tIP(%s)"
				, m_pClientList[iClientH]->m_cCharName
				, iGapAvr
				, iGapAvrS
				, iSpeed
				, m_pClientList[iClientH]->m_cIPaddress);
			PutHackLogFileList(G_cTxt);
			m_pClientList[iClientH]->m_iAttackCount  = 0; // reset
			if (m_pClientList[iClientH]->m_bMonitorThisChar) PutMonitorLogFileList(G_cTxt);	
			else return TRUE;
		}
		// On 6th check Mesure as well server average...
		if (iGapAvrS < 450 + (80 * iSpeed)) // Attack too fast, server time , (Siementec uses 500ms)
		{	wsprintf(G_cTxt, "Swing Speed:  PC(%s) (C:%dms S:%dms)(Speed:%d) - Server swing gap low.(6 mesures) \tIP(%s)"
				, m_pClientList[iClientH]->m_cCharName
				, iGapAvr
				, iGapAvrS
				, iSpeed
				, m_pClientList[iClientH]->m_cIPaddress);
			PutHackLogFileList(G_cTxt);
			m_pClientList[iClientH]->m_iAttackCount  = 0; // reset
			if (m_pClientList[iClientH]->m_bMonitorThisChar) PutMonitorLogFileList(G_cTxt);	
			else return TRUE;
		}
		// If average is computed on more gaps,=> less tolerance
		if (   (iGapAvr  > (iGapAvrS + 100))	// Fast client: possible SpeedHack
			|| (iGapAvrS > (iGapAvr  + 200)))	// Slow client: big lag ?
		{	// +-300ms ServerGap is possible once
			//printf(G_cTxt, "Swing Speed:  PC(%s) (C:%dms S:%dms)(Speed:%d)"	
			wsprintf(G_cTxt, "Swing Speed:  PC(%s) (C:%dms S:%dms)(Speed:%d) - Attack gap difference (6 mesures)  \tIP(%s)"
				, m_pClientList[iClientH]->m_cCharName
				, iGapAvr
				, iGapAvrS
				, iSpeed
				, m_pClientList[iClientH]->m_cIPaddress);
			PutHackLogFileList(G_cTxt);
			m_pClientList[iClientH]->m_iAttackCount  = 0; // reset
			if (m_pClientList[iClientH]->m_bMonitorThisChar) PutMonitorLogFileList(G_cTxt);	
			else return TRUE;
		}
		m_pClientList[iClientH]->m_dwAttackLAT   = dwClientTime;
		m_pClientList[iClientH]->m_dwAttackLATS  = dwMsgTime;
		m_pClientList[iClientH]->m_iAttackTotal  = 0;
		m_pClientList[iClientH]->m_iAttackTotalS = 0;
		if (m_pClientList[iClientH]->m_iAttackCount != 0) m_pClientList[iClientH]->m_iAttackCount  = 1;
		break;
	}
	return FALSE;
}

///////////////////////////////////////////////////////////////////////////////////////
// SpeedHack detection rewriten by Snoopy81
//			Return value:	TRUE  Too fast, block the move!.., 
//							FALSE Don't block
/////////////////////////////////////////////////////////////////////////////////////// 
BOOL CGame::bCheckClientMoveFrequency(int iClientH, DWORD dwClientTime, DWORD dwMsgTime, int iMoveType) //1=run, 2=walk, 0= Stop, 7:Fly
{	if (m_pClientList[iClientH] == NULL) return FALSE;
	//if (m_pClientList[iClientH]->m_iAdminUserLevel > 0) return TRUE;
	m_pClientList[iClientH]->m_iAttackCount  = 0;
	m_pClientList[iClientH]->m_iDashCount    = 0;
	if (dwClientTime == 0)
	{	wsprintf(G_cTxt, "Move Speeder:      PC(%s) - Move time missing (Hack?).(Disc.) \tIP(%s)"
			, m_pClientList[iClientH]->m_cCharName
			, m_pClientList[iClientH]->m_cIPaddress);
		PutHackLogFileList(G_cTxt);
		DeleteClient(iClientH, TRUE, TRUE);
		return FALSE;
	}
	// If move was latelly bloqued, we reset Average 
	if (m_pClientList[iClientH]->m_bIsMoveBlocked == TRUE)		// reset
	{	m_pClientList[iClientH]->m_bIsMoveBlocked = FALSE;
		m_pClientList[iClientH]->m_iWalkCount = 0;
		m_pClientList[iClientH]->m_iRunCount = 0;
		return FALSE;
	}
	// If just changed Peace/Attack mode,, we reset average
	if (m_pClientList[iClientH]->m_bIsAttackModeChange == TRUE) // reset
	{	m_pClientList[iClientH]->m_bIsAttackModeChange = FALSE;
		m_pClientList[iClientH]->m_iWalkCount = 0;
		m_pClientList[iClientH]->m_iRunCount = 0;
		return FALSE;
	}
	int iGapAvr, iGapAvrS; //, iRunDiff;		
	//DWORD dwServerTime = timeGetTime();
	switch (iMoveType){
	case 7: // DEF_OBJECTDAMAGEMOVE reset counters		
		m_pClientList[iClientH]->m_dwDamageMoveCounter --;
		if (m_pClientList[iClientH]->m_iLastDamage != 0)
		{	if (   (dwMsgTime >(m_pClientList[iClientH]->m_dwLastDamageMoveTime + 3500))		
				&& (m_pClientList[iClientH]->m_dwDamageMoveCounter == 0))
			{	// Not asked client to DamageMove in 3 last seconds => Tsearch Hack		
				// But if client hold his bg, the DAMAGEMOVE is not sent by client until he releases it.
				// So I need to add a counter too.
				wsprintf(G_cTxt, "Tsearch Fly Hack:  PC(%s) -  Sends DamageMove, but was not flawn! (Disc.) \tIP(%s)"					
					, m_pClientList[iClientH]->m_cCharName
					, m_pClientList[iClientH]->m_cIPaddress);
				PutHackLogFileList(G_cTxt);	
				PutLogList(G_cTxt);						
				if (m_pClientList[iClientH]->m_bMonitorThisChar) PutMonitorLogFileList(G_cTxt);	
				else DeleteClient(iClientH, TRUE, TRUE);
				return TRUE;	
			}
		}
		// Message sent from server to show on client, but clients sends back.
		m_pClientList[iClientH]->m_iRunCount  = 0;
		m_pClientList[iClientH]->m_iWalkCount  = 0;
		if (m_pClientList[iClientH]->m_bMonitorThisChar)
		{	wsprintf(G_cTxt, "Damage Move msg:   PC(%s)"				
				, m_pClientList[iClientH]->m_cCharName);
			PutMonitorLogFileList(G_cTxt);
		}
		break;
	case 0: // DEF_OBJECTSTOP: reset counters
		m_pClientList[iClientH]->m_iRunCount  = 0;
		m_pClientList[iClientH]->m_iWalkCount  = 0;
		if (m_pClientList[iClientH]->m_bMonitorThisChar)
		{	wsprintf(G_cTxt, "Stop message:      PC(%s)"				
				, m_pClientList[iClientH]->m_cCharName);
			PutMonitorLogFileList(G_cTxt);
		}
		break;
	case 2: //walk: reset run counters
		m_pClientList[iClientH]->m_iRunCount  = 0;
		switch (m_pClientList[iClientH]->m_iWalkCount) {
		case 0: // 1st walk message
			m_pClientList[iClientH]->m_dwWalkLAT   = dwClientTime;	
			m_pClientList[iClientH]->m_dwWalkLATS  = dwMsgTime;	
			m_pClientList[iClientH]->m_iWalkTotal  = 0;	
			m_pClientList[iClientH]->m_iWalkTotalS = 0;	
			m_pClientList[iClientH]->m_iWalkCount  = 1;
			break;
		case 1: // 2nd walk msg, 1st gap calculation
		case 2: // 2..4 gaps computed
		case 3:
		case 4: // Standard walking speed is +- 545 ms
		case 5: 
			// Hum.... last msg sent before previous one!				
			if (dwClientTime <= m_pClientList[iClientH]->m_dwWalkLAT)
			{	if (dwMsgTime > m_pClientList[iClientH]->m_dwWalkLATS +400)
				{	// But server side seems normal: Big Lag effect or SpeedHack!
					wsprintf(G_cTxt, "Walking Speed:     PC(%s) -  Negative Client gap, just stopped to SpeedHack. (Disc.) \tIP(%s)"					
						, m_pClientList[iClientH]->m_cCharName
						, m_pClientList[iClientH]->m_cIPaddress);
					PutHackLogFileList(G_cTxt);	
					PutLogList(G_cTxt);						
					m_pClientList[iClientH]->m_iWalkCount  = 0; // Reset
					if (m_pClientList[iClientH]->m_bMonitorThisChar) PutMonitorLogFileList(G_cTxt);	
					else DeleteClient(iClientH, TRUE, TRUE);
					return TRUE;	
				}
			}			
			// Stopped walking...restart mesures from this msg		
			if (   ((dwClientTime - m_pClientList[iClientH]->m_dwWalkLAT) > 1000)
				&& ((dwMsgTime - m_pClientList[iClientH]->m_dwWalkLATS) > 700))
			{	if (m_pClientList[iClientH]->m_bMonitorThisChar)
				{	wsprintf(G_cTxt, "Walking Speed:     PC(%s) (C:%dms S:%dms) - Stopped walking."				
						, m_pClientList[iClientH]->m_cCharName
						, (dwClientTime - m_pClientList[iClientH]->m_dwWalkLAT)
						, (dwMsgTime - m_pClientList[iClientH]->m_dwWalkLATS));
					PutMonitorLogFileList(G_cTxt);
				}
				m_pClientList[iClientH]->m_dwWalkLAT   = dwClientTime;
				m_pClientList[iClientH]->m_dwWalkLATS  = dwMsgTime;
				m_pClientList[iClientH]->m_iWalkTotal  = 0;
				m_pClientList[iClientH]->m_iWalkTotalS = 0;
				m_pClientList[iClientH]->m_iWalkCount  = 1;				
				break;
			}
			m_pClientList[iClientH]->m_iWalkTotal  += (dwClientTime - m_pClientList[iClientH]->m_dwWalkLAT);
			m_pClientList[iClientH]->m_iWalkTotalS += (dwMsgTime - m_pClientList[iClientH]->m_dwWalkLATS);
			iGapAvr  = m_pClientList[iClientH]->m_iWalkTotal / m_pClientList[iClientH]->m_iWalkCount;
			iGapAvrS = m_pClientList[iClientH]->m_iWalkTotalS/ m_pClientList[iClientH]->m_iWalkCount;
			if (m_pClientList[iClientH]->m_bMonitorThisChar)
			{	wsprintf(G_cTxt, "Walking Speed:     PC(%s) (C:%dms S:%dms)"				
					, m_pClientList[iClientH]->m_cCharName
					, (dwClientTime - m_pClientList[iClientH]->m_dwWalkLAT)
					, (dwMsgTime - m_pClientList[iClientH]->m_dwWalkLATS));
				PutMonitorLogFileList(G_cTxt);
			}
			// Client average gap is too short (standard is +- 545)
			if (iGapAvr < 435 + ( 5 * m_pClientList[iClientH]->m_iWalkCount)) // Walk too fast
			{	// 440 to 460 mini average walking speed
				wsprintf(G_cTxt, "Speed Hack (Walk): PC(%s) - Client walk gap low.(C:%dms S:%dms)(%d mesures) \tIP(%s)"
					, m_pClientList[iClientH]->m_cCharName
					, iGapAvr
					, iGapAvrS
					, m_pClientList[iClientH]->m_iWalkCount
					, m_pClientList[iClientH]->m_cIPaddress);
				PutHackLogFileList(G_cTxt);
				m_pClientList[iClientH]->m_iWalkCount  = 0;
				if (m_pClientList[iClientH]->m_bMonitorThisChar) PutMonitorLogFileList(G_cTxt);	
				else return TRUE;
			}
			// Difference beetween Client/Server average gap
		/*	iRunDiff = 460 - (10*m_pClientList[iClientH]->m_iRunCount); //Allows lag 150 140 130 120 110ms
			if (m_pClientList[iClientH]->m_iWalkTotal > (iRunDiff + m_pClientList[iClientH]->m_iWalkTotalS)) // Walks too fast
			{	// +-300ms ServerGap is possible once
				wsprintf(G_cTxt, "Speed Hack (Walk): PC(%s) - Walk gap difference (TotalC;%dms TotalS;%dms)(%d mesures) \tIP(%s)"
					, m_pClientList[iClientH]->m_cCharName
					, m_pClientList[iClientH]->m_iWalkTotal
					, m_pClientList[iClientH]->m_iWalkTotalS
					, m_pClientList[iClientH]->m_iWalkCount
					, m_pClientList[iClientH]->m_cIPaddress);
				PutHackLogFileList(G_cTxt);
				m_pClientList[iClientH]->m_iWalkCount  = 0;
				if (m_pClientList[iClientH]->m_bMonitorThisChar) PutMonitorLogFileList(G_cTxt);	
				else return TRUE;
			}*/
			m_pClientList[iClientH]->m_dwWalkLAT   = dwClientTime;
			m_pClientList[iClientH]->m_dwWalkLATS  = dwMsgTime;	
			m_pClientList[iClientH]->m_iWalkCount  +=1;
			break;
		case 6: // last determination	
			// Hum.... last msg sent before previous one!				
			if (dwClientTime <= m_pClientList[iClientH]->m_dwWalkLAT)
			{	if (dwMsgTime > m_pClientList[iClientH]->m_dwWalkLATS +400)
				{	// But server side seems normal: Big Lag effect or SpeedHack!
					wsprintf(G_cTxt, "Walking Speed:     PC(%s) -  Negative Client gap, just stopped to SpeedHack. (Disc.) \tIP(%s)"					
						, m_pClientList[iClientH]->m_cCharName
						, m_pClientList[iClientH]->m_cIPaddress);
					PutHackLogFileList(G_cTxt);	
					PutLogList(G_cTxt);						
					m_pClientList[iClientH]->m_iWalkCount  = 0; // reset
					if (m_pClientList[iClientH]->m_bMonitorThisChar) PutMonitorLogFileList(G_cTxt);	
					else DeleteClient(iClientH, TRUE, TRUE);	
					return TRUE;	
				}
			}			
			// Stopped walking ....	restart mesures from this msg
			if (   ((dwClientTime - m_pClientList[iClientH]->m_dwWalkLAT) > 1000)
				&& ((dwMsgTime - m_pClientList[iClientH]->m_dwWalkLATS) > 700))
			{	// Do not count this time.
				if (m_pClientList[iClientH]->m_bMonitorThisChar)
				{	wsprintf(G_cTxt, "Walking Speed:     PC(%s) (C:%dms S:%dms) - Stopped walking."				
						, m_pClientList[iClientH]->m_cCharName
						, (dwClientTime - m_pClientList[iClientH]->m_dwWalkLAT)
						, (dwMsgTime - m_pClientList[iClientH]->m_dwWalkLATS));
					PutMonitorLogFileList(G_cTxt);					
				}
				m_pClientList[iClientH]->m_dwWalkLAT   = dwClientTime;
				m_pClientList[iClientH]->m_dwWalkLATS  = dwMsgTime;	
				m_pClientList[iClientH]->m_iWalkTotal  = 0;
				m_pClientList[iClientH]->m_iWalkTotalS = 0;
				m_pClientList[iClientH]->m_iWalkCount  = 1;				
				break;
			}
			m_pClientList[iClientH]->m_iWalkTotal += (dwClientTime - m_pClientList[iClientH]->m_dwWalkLAT);
			m_pClientList[iClientH]->m_iWalkTotalS += (dwMsgTime - m_pClientList[iClientH]->m_dwWalkLATS);
			iGapAvr = m_pClientList[iClientH]->m_iWalkTotal  / m_pClientList[iClientH]->m_iWalkCount;
			iGapAvrS = m_pClientList[iClientH]->m_iWalkTotalS/ m_pClientList[iClientH]->m_iWalkCount;
			if (m_pClientList[iClientH]->m_bMonitorThisChar)		
			{	wsprintf(G_cTxt, "Walking Speed:     PC(%s) (C:%dms S:%dms)"	
					, m_pClientList[iClientH]->m_cCharName
					, (dwClientTime - m_pClientList[iClientH]->m_dwWalkLAT)
					, (dwMsgTime - m_pClientList[iClientH]->m_dwWalkLATS));
				PutMonitorLogFileList(G_cTxt);		
				wsprintf(G_cTxt, "Average Walk:      PC(%s) (#:%dms #:%dms)"				
					, m_pClientList[iClientH]->m_cCharName
					, iGapAvr
					, iGapAvrS);
				PutMonitorLogFileList(G_cTxt);	
			}
			// Client average gap is too short
			if (iGapAvr < 465) // Walk too fast, client time
			{	wsprintf(G_cTxt, "Speed Hack (Walk): PC(%s) - Client walk gap low.(C:%dms S:%dms)(6 mesures)  \tIP(%s)"
					, m_pClientList[iClientH]->m_cCharName
					, iGapAvr
					, iGapAvrS
					, m_pClientList[iClientH]->m_cIPaddress);
				PutHackLogFileList(G_cTxt);
				m_pClientList[iClientH]->m_iWalkCount  = 0; // reset
				if (m_pClientList[iClientH]->m_bMonitorThisChar) PutMonitorLogFileList(G_cTxt);	
				else return TRUE;
			}
			// On 6th check Mesure as well server average...
/*			if (iGapAvrS < 465) // Walk too fast, server time
			{	wsprintf(G_cTxt, "Speed Hack (Walk): PC(%s) - Server walk gap low.(C:%dms S:%dms)(6 mesures)  \tIP(%s)"
					, m_pClientList[iClientH]->m_cCharName
					, iGapAvr
					, iGapAvrS
					, m_pClientList[iClientH]->m_cIPaddress);
				PutHackLogFileList(G_cTxt);
				m_pClientList[iClientH]->m_iWalkCount  = 0; // reset
				if (m_pClientList[iClientH]->m_bMonitorThisChar) PutMonitorLogFileList(G_cTxt);	
				else return TRUE;
			}
			// Difference beetween Client/Server average gap
			if (650 < abs(m_pClientList[iClientH]->m_iWalkTotal - m_pClientList[iClientH]->m_iWalkTotalS)) // Walk too fast
			{	// +-300ms ServerGap is possible once
				wsprintf(G_cTxt, "Speed Hack (Walk): PC(%s) - Walk gap difference (TotalC:%dms TotalS:%dms)(6 mesures) \tIP(%s)"
					, m_pClientList[iClientH]->m_cCharName
					, m_pClientList[iClientH]->m_iWalkTotal
					, m_pClientList[iClientH]->m_iWalkTotalS
					, m_pClientList[iClientH]->m_cIPaddress);
				PutHackLogFileList(G_cTxt);
				m_pClientList[iClientH]->m_iWalkCount  = 0; // reset
				if (m_pClientList[iClientH]->m_bMonitorThisChar) PutMonitorLogFileList(G_cTxt);	
				else return TRUE;
			}*/
			m_pClientList[iClientH]->m_dwWalkLAT   = dwClientTime;
			m_pClientList[iClientH]->m_dwWalkLATS  = dwMsgTime;
			m_pClientList[iClientH]->m_iWalkTotal  = 0;
			m_pClientList[iClientH]->m_iWalkTotalS = 0;
			m_pClientList[iClientH]->m_iWalkCount  = 1;
			break;
		}
		break;
	case 1: //running ...reset walk counters
		m_pClientList[iClientH]->m_iWalkCount  = 0;
		switch (m_pClientList[iClientH]->m_iRunCount) {
		case 0: // 1st Run message
			m_pClientList[iClientH]->m_dwRunLAT   = dwClientTime;
			m_pClientList[iClientH]->m_dwRunLATS  = dwMsgTime;		
			m_pClientList[iClientH]->m_iRunTotal  = 0;	
			m_pClientList[iClientH]->m_iRunTotalS = 0;	
			m_pClientList[iClientH]->m_iRunCount  = 1;
			break;
		case 1: // 2nd Run msg, 1st gap calculation
		case 2: // 2..4 gaps computed
		case 3:
		case 4: // Standard Running speed is +- 345 ms
		case 5: 
			// Hum.... last msg sent before previous one!				
			if (dwClientTime <= m_pClientList[iClientH]->m_dwRunLAT)
			{	if (dwMsgTime > m_pClientList[iClientH]->m_dwRunLATS +200)
				{	// But server side seems normal: Big Lag effect or SpeedHack!
					wsprintf(G_cTxt, "Running Speed:     PC(%s) -  Negative Client gap, just stopped to SpeedHack. (Disc.) \tIP(%s)"					
						, m_pClientList[iClientH]->m_cCharName
						, m_pClientList[iClientH]->m_cIPaddress);
					PutHackLogFileList(G_cTxt);	
					PutLogList(G_cTxt);						
					m_pClientList[iClientH]->m_iRunCount  = 0; // Reset
					if (m_pClientList[iClientH]->m_bMonitorThisChar) PutMonitorLogFileList(G_cTxt);	
					else DeleteClient(iClientH, TRUE, TRUE);	
					return TRUE;	
				}
			}		
			// Stopped runing... restart mesures from this msg			
			if (   ((dwClientTime - m_pClientList[iClientH]->m_dwRunLAT) > 1000)
				&& ((dwMsgTime - m_pClientList[iClientH]->m_dwRunLATS) > 700))
			{	if (m_pClientList[iClientH]->m_bMonitorThisChar)
				{	wsprintf(G_cTxt, "Running Speed:     PC(%s) (C:%dms S:%dms) - Stopped running."				
						, m_pClientList[iClientH]->m_cCharName
						, (dwClientTime - m_pClientList[iClientH]->m_dwRunLAT)
						, (dwMsgTime - m_pClientList[iClientH]->m_dwRunLATS));
					PutMonitorLogFileList(G_cTxt);
				}
				m_pClientList[iClientH]->m_dwRunLAT   = dwClientTime;
				m_pClientList[iClientH]->m_dwRunLATS  = dwMsgTime;
				m_pClientList[iClientH]->m_iRunTotal  = 0;
				m_pClientList[iClientH]->m_iRunTotalS = 0;
				m_pClientList[iClientH]->m_iRunCount  = 1;	
				break;		
			}
			m_pClientList[iClientH]->m_iRunTotal  += (dwClientTime - m_pClientList[iClientH]->m_dwRunLAT);
			m_pClientList[iClientH]->m_iRunTotalS += (dwMsgTime - m_pClientList[iClientH]->m_dwRunLATS);
			iGapAvr  = m_pClientList[iClientH]->m_iRunTotal / m_pClientList[iClientH]->m_iRunCount;
			iGapAvrS = m_pClientList[iClientH]->m_iRunTotalS/ m_pClientList[iClientH]->m_iRunCount;
			if (m_pClientList[iClientH]->m_bMonitorThisChar)
			{	wsprintf(G_cTxt, "Running Speed:     PC(%s) (C:%dms S:%dms)"				
					, m_pClientList[iClientH]->m_cCharName
					, (dwClientTime - m_pClientList[iClientH]->m_dwRunLAT)
					, (dwMsgTime - m_pClientList[iClientH]->m_dwRunLATS));
				PutMonitorLogFileList(G_cTxt);
			}
			// Client average gap is too short
			if (iGapAvr < 235 + ( 5 * m_pClientList[iClientH]->m_iRunCount)) // Run too fast
			{	// 240 to 260 - 300 is theoric low limit (could be less if running with: DBLclick) 
				wsprintf(G_cTxt, "Speed Hack (Run):  PC(%s) - Client run gap low.(C:%dms S:%dms)(%d mesures) \tIP(%s)"
					, m_pClientList[iClientH]->m_cCharName
					, iGapAvr
					, iGapAvrS
					, m_pClientList[iClientH]->m_iRunCount
					, m_pClientList[iClientH]->m_cIPaddress);
				PutHackLogFileList(G_cTxt);
				m_pClientList[iClientH]->m_iRunCount  = 0;
				if (m_pClientList[iClientH]->m_bMonitorThisChar) PutMonitorLogFileList(G_cTxt);	
				else return TRUE;
			}
			// Difference beetween Client/Server average gap
		/*	iRunDiff = 460 - (10*m_pClientList[iClientH]->m_iRunCount); //Allows lag 150 140 130 120 110ms
			if (m_pClientList[iClientH]->m_iRunTotal > (iRunDiff + m_pClientList[iClientH]->m_iRunTotalS)) // Run too fast
			{	// +-0ms ServerGap is possible once
				wsprintf(G_cTxt, "Speed Hack (Run):  PC(%s) - Run gap difference (TotalC;%dms TotalS;%dms)(%d mesures) \tIP(%s)"
					, m_pClientList[iClientH]->m_cCharName
					, m_pClientList[iClientH]->m_iRunTotal
					, m_pClientList[iClientH]->m_iRunTotalS
					, m_pClientList[iClientH]->m_iRunCount
					, m_pClientList[iClientH]->m_cIPaddress);
				PutHackLogFileList(G_cTxt);
				m_pClientList[iClientH]->m_iRunCount  = 0;
				if (m_pClientList[iClientH]->m_bMonitorThisChar) PutMonitorLogFileList(G_cTxt);	
				else return TRUE;
			}*/
			m_pClientList[iClientH]->m_dwRunLAT   = dwClientTime;
			m_pClientList[iClientH]->m_dwRunLATS  = dwMsgTime;	
			m_pClientList[iClientH]->m_iRunCount  +=1;
			break;
		case 6: // last determination 
			// Hum.... last msg sent before previous one!				
			if (dwClientTime <= m_pClientList[iClientH]->m_dwRunLAT)
			{	if (dwMsgTime > m_pClientList[iClientH]->m_dwRunLATS +200)
				{	// But server side seems normal: Big Lag effect or SpeedHack!
					wsprintf(G_cTxt, "Running Speed:     PC(%s) -  Negative Client gap, just stopped to SpeedHack. (Disc.) \tIP(%s)"					
						, m_pClientList[iClientH]->m_cCharName
						, m_pClientList[iClientH]->m_cIPaddress);
					PutHackLogFileList(G_cTxt);	
					PutLogList(G_cTxt);						
					m_pClientList[iClientH]->m_iRunCount  = 0; // reset
					if (m_pClientList[iClientH]->m_bMonitorThisChar) PutMonitorLogFileList(G_cTxt);	
					else DeleteClient(iClientH, TRUE, TRUE);	
					return TRUE;	
				}
			}		
			// Stopped runing 1 time....		
			if (   ((dwClientTime - m_pClientList[iClientH]->m_dwRunLAT) > 1000)
				&& ((dwMsgTime - m_pClientList[iClientH]->m_dwRunLATS) > 700))
			{	// Do not count this time.
				if (m_pClientList[iClientH]->m_bMonitorThisChar)
				{	wsprintf(G_cTxt, "Running Speed:     PC(%s) (C:%dms S:%dms) - Stopped running."				
						, m_pClientList[iClientH]->m_cCharName
						, (dwClientTime - m_pClientList[iClientH]->m_dwRunLAT)
						, (dwMsgTime - m_pClientList[iClientH]->m_dwRunLATS));
					PutMonitorLogFileList(G_cTxt);
				}
				m_pClientList[iClientH]->m_dwRunLAT   = dwClientTime;
				m_pClientList[iClientH]->m_dwRunLATS  = dwMsgTime;
				m_pClientList[iClientH]->m_iRunTotal  = 0;
				m_pClientList[iClientH]->m_iRunTotalS = 0;
				m_pClientList[iClientH]->m_iRunCount  = 1;		
				break;	
			}
			m_pClientList[iClientH]->m_iRunTotal += (dwClientTime - m_pClientList[iClientH]->m_dwRunLAT);
			m_pClientList[iClientH]->m_iRunTotalS += (dwMsgTime - m_pClientList[iClientH]->m_dwRunLATS);
			iGapAvr = m_pClientList[iClientH]->m_iRunTotal  / m_pClientList[iClientH]->m_iRunCount;
			iGapAvrS = m_pClientList[iClientH]->m_iRunTotalS/ m_pClientList[iClientH]->m_iRunCount;
			if (m_pClientList[iClientH]->m_bMonitorThisChar)
			{	wsprintf(G_cTxt, "Running Speed:     PC(%s) (C:%dms S:%dms)"				
					, m_pClientList[iClientH]->m_cCharName
					, (dwClientTime - m_pClientList[iClientH]->m_dwRunLAT)
					, (dwMsgTime - m_pClientList[iClientH]->m_dwRunLATS));
				PutMonitorLogFileList(G_cTxt);	
				wsprintf(G_cTxt, "Average Run:       PC(%s) (#:%dms #:%dms)"				
					, m_pClientList[iClientH]->m_cCharName
					, iGapAvr
					, iGapAvrS);
				PutMonitorLogFileList(G_cTxt);	
			}
			// Client average gap is too short
			if (iGapAvr < 265) // Run too fast, client time
			{	wsprintf(G_cTxt, "Speed Hack (Run):  PC(%s) - Client run gap low.(C:%dms S:%dms)(%d mesures) \tIP(%s)"
					, m_pClientList[iClientH]->m_cCharName
					, iGapAvr
					, iGapAvrS
					, m_pClientList[iClientH]->m_iRunCount
					, m_pClientList[iClientH]->m_cIPaddress);
				PutHackLogFileList(G_cTxt);
				m_pClientList[iClientH]->m_iRunCount  = 0; // reset
				if (m_pClientList[iClientH]->m_bMonitorThisChar) PutMonitorLogFileList(G_cTxt);	
				else return TRUE;
			}
/*			// On 6th check Mesure as well server average...
			if (iGapAvrS < 275) // Run too fast, server time (275*6)-300 = 225 * 6
			{	//printf(G_cTxt, "Cn check:  PC(%s) (Client:%dms Server:%dms) (Pck=%3d) [Key=%4d] \tIP(%s)"				
				wsprintf(G_cTxt, "Speed Hack (Run):  PC(%s) - Server run gap low.(C:%dms S:%dms)(%d mesures)  \tIP(%s)"
					, m_pClientList[iClientH]->m_cCharName
					, iGapAvr
					, iGapAvrS
					, m_pClientList[iClientH]->m_iRunCount
					, m_pClientList[iClientH]->m_cIPaddress);
				PutHackLogFileList(G_cTxt);
				if (m_pClientList[iClientH]->m_bMonitorThisChar) PutMonitorLogFileList(G_cTxt);	
				return TRUE;
			}
			// Difference beetween Client/Server average gap ( 1 pck décalé (300ms) +100ms lag.
			if (650 < abs(m_pClientList[iClientH]->m_iRunTotal - m_pClientList[iClientH]->m_iRunTotalS)) // Run too fast
			{	// +-0ms ServerGap is possible once
				wsprintf(G_cTxt, "Speed Hack (Run):  PC(%s) - Run gap difference (TotalC:%dms TotalS:%dms)(%d mesures) \tIP(%s)"
					, m_pClientList[iClientH]->m_cCharName
					, m_pClientList[iClientH]->m_iRunTotal
					, m_pClientList[iClientH]->m_iRunTotalS
					, m_pClientList[iClientH]->m_iRunCount
					, m_pClientList[iClientH]->m_cIPaddress);
				PutHackLogFileList(G_cTxt);
				m_pClientList[iClientH]->m_iRunCount  = 0; // reset
				if (m_pClientList[iClientH]->m_bMonitorThisChar) PutMonitorLogFileList(G_cTxt);	
				return TRUE;
			}*/
			m_pClientList[iClientH]->m_dwRunLAT   = dwClientTime;
			m_pClientList[iClientH]->m_dwRunLATS  = dwMsgTime;
			m_pClientList[iClientH]->m_iRunTotal  = 0;
			m_pClientList[iClientH]->m_iRunTotalS = 0;
			m_pClientList[iClientH]->m_iRunCount  = 1;
			break;
		}
		break;	
	}
	return FALSE; // Don't block
}
/*
BOOL CGame::bCheckClientInvisibility(short iClientH)
{
	BOOL bFlag;
	int iShortCutIndex;
	int i;
	short sRange;
	if(m_pClientList[iClientH] == NULL) return FALSE;
	if (m_pClientList[iClientH]->m_iAdminUserLevel > 0) return FALSE;
	bFlag = TRUE;
	iShortCutIndex = 0;
		while(bFlag){
Raven-HBRND(www.hbrnd.com) says:
what i suggest
is .. if its requesting
to see the other side whyle invsie
check the bag
for the neckie
			i = m_iClientShortCut[iShortCutIndex];
			iShortCutIndex++;
			if (i == 0) bFlag = FALSE;

			if ((bFlag == TRUE) && (m_pClientList[i] != NULL) && (m_pClientList[i]->m_bIsInitComplete == TRUE)) {
				if ( (m_pClientList[i]->m_cMapIndex == m_pClientList[iClientH]->m_cMapIndex) &&
				     (m_pClientList[i]->m_sX >= m_pClientList[iClientH]->m_sX - 10 - sRange) &&
				 	 (m_pClientList[i]->m_sX <= m_pClientList[iClientH]->m_sX + 10 + sRange) &&
				 	 (m_pClientList[i]->m_sY >= m_pClientList[iClientH]->m_sY - 8 - sRange) &&
					 (m_pClientList[i]->m_sY <= m_pClientList[iClientH]->m_sY + 8 + sRange) ) {
			// iClient = center screen character
			// i = visable characters on screen
					if ( (m_pClientList[iClientH]->m_cSide != m_pClientList[i]->m_cSide) 
								&& (i != iClientH) 
								&& (m_pClientList[iClientH]->m_sAppr4 == m_pClientList[iClientH]->m_sAppr4 & 0x0001)
								) {
						//wsprintf(G_cTxt, "(!) Invisibility Hack Suspect: (%s)", m_pClientList[iClientH]->m_cCharName);
						//PutLogList(G_cTxt);
						//DeleteClient(iClientH, TRUE, TRUE);
						}
					}
			}
		}
	return FALSE;
}*/

void CGame::CrusadeWarStarter()
{
 SYSTEMTIME SysTime;
 int i;

	if (m_bIsCrusadeMode == TRUE) return;
	if (m_bIsCrusadeWarStarter == FALSE) return;
	GetLocalTime(&SysTime);	
	for (i = 0; i < DEF_MAXSCHEDULE; i++)
	if	((m_stCrusadeWarSchedule[i].iDay == SysTime.wDayOfWeek) && 
		(m_stCrusadeWarSchedule[i].iHour == SysTime.wHour) && 
		(m_stCrusadeWarSchedule[i].iMinute == SysTime.wMinute)) {
			PutLogList("(!) Automated crusade is being initiated!");
			PutLogEventFileList("(!) Automated crusade is being initiated!");
			GlobalStartCrusadeMode();
			return;
	}
}

void CGame::OnTimer(char cType)
{	DWORD dwTime = timeGetTime();
	GameProcess();
	//m_dwGameTime1 = dwTime; 
	if ((dwTime - m_dwGameTime2) > 3000) 
	{	CheckClientResponseTime();
		SendMsgToGateServer(MSGID_GAMESERVERALIVE, NULL);
		CheckDayOrNightMode();
		InvalidateRect(G_hWnd, NULL, TRUE);
		m_dwGameTime2 = dwTime;
		_CheckGateSockConnection();	
		// v1.41
		if (   (m_bIsGameStarted == FALSE)		&& (m_bIsItemAvailable == TRUE)      
			&& (m_bIsNpcAvailable == TRUE)		&& (m_bIsGateSockAvailable == TRUE)  
			&& (m_bIsLogSockAvailable == TRUE)	&& (m_bIsMagicAvailable == TRUE)     
			&& (m_bIsSkillAvailable == TRUE)	&& (m_bIsPortionAvailable == TRUE)   
			&& (m_bIsQuestAvailable == TRUE)	&& (m_bIsBuildItemAvailable == TRUE) 
			&& (m_iSubLogSockActiveCount == DEF_MAXSUBLOGSOCK)) 
		{	PutLogList("Sending start message...");
			SendMessage(m_hWnd, WM_USER_STARTGAMESIGNAL, NULL, NULL);
			m_bIsGameStarted = TRUE;
		}else if (m_bIsLogSockAvailable == FALSE)
		{	PutLogList("(!!!W) Game Server registration to WorldServer, no response!");
			PutLogList("       Please check MSGID_REQUEST_REGISTERGAMESERVER!");
	}	}
	if ((dwTime - m_dwGameTime6) > 1000) 
	{	DelayEventProcessor();
		SendStockMsgToGateServer();
		m_dwGameTime6 = dwTime;
		// Avatar reaches Statue?
		if ((m_bIsAvatarMode == TRUE) && (m_iPLmapIndex != -1)) CheckRelicGoal();

		if (m_iFinalShutdownCount != 0) 
		{	m_iFinalShutdownCount--;
			wsprintf(G_cTxt, "Final Shutdown...%d", m_iFinalShutdownCount);
			PutLogList(G_cTxt);
			if (m_iFinalShutdownCount <= 1) 
			{	SendMessage(m_hWnd, WM_CLOSE, NULL, NULL);
				return;	
	}	}	}

	if ((dwTime - m_dwGameTime3) > 3000) 
	{	SyncMiddlelandMapInfo();
		CheckDynamicObjectList();
		DynamicObjectEffectProcessor();
		NoticeHandler();
		SpecialEventHandler();
		//SNOOPY:Check if Apocalypse Gate nedd to be closed
		OpenCloseApocalypseGate();
		m_dwGameTime3 = dwTime;
	}

	if ((dwTime - m_dwGameTime4) > 600) 
	{	MobGenerator();
		if (m_iSubLogSockInitIndex < DEF_MAXSUBLOGSOCK) // v1.432-3 Sub-Log-Socket	 
		{	m_pSubLogSock[m_iSubLogSockInitIndex] = new class XSocket(m_hWnd, DEF_SERVERSOCKETBLOCKLIMIT);
			m_bIsSubLogSockInitialPointer[m_iSubLogSockInitIndex] = (int) m_pSubLogSock[m_iSubLogSockInitIndex];
			m_pSubLogSock[m_iSubLogSockInitIndex]->bConnect(m_cLogServerAddr, m_iLogServerPort, (WM_ONLOGSOCKETEVENT + m_iSubLogSockInitIndex + 1));
			//wsprintf(G_cTxt, "(...W) Try to connect sub-log-socket(%d)   Addr:%s  Port:%d", m_iSubLogSockInitIndex, m_cLogServerAddr, m_iLogServerPort);
			//PutLogList(G_cTxt);				
			m_pSubLogSock[m_iSubLogSockInitIndex]->bInitBufferSize(DEF_MSGBUFFERSIZE);
			// Snoopy
			//wsprintf(G_cTxt,"Opening Socket(%d) (OnTimer) Pointer: %d,", m_iSubLogSockInitIndex,m_pSubLogSock[m_iSubLogSockInitIndex]);
			//PutLogList(G_cTxt);
			m_iSubLogSockInitIndex++;
		}
		m_dwGameTime4 = dwTime;
	}

	if ((dwTime - m_dwGameTime5) > 1000*60*3)  // 3 minutes		
	{	m_dwGameTime5 = dwTime;
		srand( (unsigned)time( NULL ) );   	
		MagicSMG();	// SNOOPY check/change SMG type -1...( Magic pits)
	}

	if ((dwTime - m_dwFishTime) > 4000) 
	{	FishProcessor();
		FishGenerator();
		SendCollectedMana();
		CrusadeWarStarter();
		//ApocalypseStarter();
		ApocalypseEnder();
		m_dwFishTime = dwTime;
		AFKChecker(); // Sends ZzZz to AFKs ....
	}
	
	if ((dwTime - m_dwWhetherTime) > 1000*20) // 20secs
	{	WhetherProcessor();
		m_dwWhetherTime = dwTime;
		if (m_bIsApocalypseMode == TRUE) DoAbaddonThunderDamageHandler(-1); // -1 only affects Abaddon map
		//SNOOPY: check if Heldenian war must be started or finished.
		if (m_bIsHeldenianMode == TRUE)		  
		{	HeldenianStartWarNow();
			HeldenianEndWarNow();
	}	}
	
	// v1.4311-3  1000*60*60*2 = 7200000 = 2hours
	if ((dwTime - m_dwCanFightzoneReserveTime) > 7200000) 
	{	FightzoneReserveProcessor();
		m_dwCanFightzoneReserveTime = dwTime;
	}

	if ((m_bIsServerShutdowned == FALSE) && (m_bOnExitProcess == TRUE) && ((dwTime - m_dwExitProcessTime) > 1000*2)) 
	{	if (_iForcePlayerDisconect(15) == 0) 
		{	PutLogList("(!) GAME SERVER SHUTDOWN PROCESS COMPLETED! All players are disconnected.");
			m_bIsServerShutdowned = TRUE;
			if ((m_cShutDownCode == 3) || (m_cShutDownCode == 4)) 
			{	PutLogList("(!!!) AUTO-SERVER-REBOOTING!");
				PutLogFileList("(!!!) AUTO-SERVER-REBOOTING!");
				bInit();
				m_iAutoRebootingCount++;
			}else 
			{	if (m_iFinalShutdownCount == 0)	m_iFinalShutdownCount = 20;
			}
		}
		m_dwExitProcessTime = dwTime;
	}

	if ((dwTime - m_dwMapSectorInfoTime) > 1000*10) // 10secs
	{	m_dwMapSectorInfoTime = dwTime;
		UpdateMapSectorInfo();
		MineralGenerator();
		m_iMapSectorInfoUpdateCount++;
		if (m_iMapSectorInfoUpdateCount >= 5) 
		{	AgingMapSectorInfo();
			m_iMapSectorInfoUpdateCount = 0;
		}
	}
}

BOOL CGame::bReadScheduleConfigFile(char *pFn)
{
 FILE * pFile;
 HANDLE hFile;
 DWORD  dwFileSize;
 char * cp, * token, cReadModeA, cReadModeB;
 char seps[] = "= \t\n";
 class CStrTok * pStrTok;
 int   iIndex;

	cReadModeA = 0;
	cReadModeB = 0;
	iIndex = 0;

	hFile = CreateFile(pFn, GENERIC_READ, NULL, NULL, OPEN_EXISTING, NULL, NULL);
	dwFileSize = GetFileSize(hFile, NULL);
	if (hFile != INVALID_HANDLE_VALUE) CloseHandle(hFile);

	pFile = fopen(pFn, "rt");
	if (pFile == NULL) {
		// °ÔÀÓ¼­¹öÀÇ ÃÊ±âÈ­ ÆÄÀÏÀ» ÀÐÀ» ¼ö ¾ø´Ù.
		PutLogList("(!) Cannot open Schedule file.");
		return FALSE;
	}
	else {
		PutLogList("(!) Reading Schedule file...");
		cp = new char[dwFileSize+2];
		ZeroMemory(cp, dwFileSize+2);
		fread(cp, dwFileSize, 1, pFile);

		pStrTok = new class CStrTok(cp, seps);
		token = pStrTok->pGet();

		while( token != NULL )   {
			
			if (cReadModeA != 0) {
				switch (cReadModeA) {
				case 1:
					if (strcmp(m_cServerName, token) == 0) {
						PutLogList("(!) Success: This server will schedule crusade total war.");
						m_bIsCrusadeWarStarter = TRUE;
					}
					cReadModeA = 0;
					break;

				case 2:
					if (strcmp(m_cServerName, token) == 0) {
						PutLogList("(!) Success: This server will schedule apocalypse.");
						m_bIsApocalypseStarter = TRUE;
					}
					cReadModeA = 0;
					break;

				case 3:
					switch (cReadModeB) {
					case 1:
						if (iIndex >= DEF_MAXSCHEDULE) {
							PutLogList("(!) WARNING! Too many crusade war schedule!"); 
							delete pStrTok;
							delete cp;
							return TRUE;
						}
						m_stCrusadeWarSchedule[iIndex].iDay = atoi(token);
						cReadModeB = 2;
						break;
					case 2:
						m_stCrusadeWarSchedule[iIndex].iHour = atoi(token);
						cReadModeB = 3;
						break;
					case 3:
						m_stCrusadeWarSchedule[iIndex].iMinute = atoi(token);
						iIndex++;
						cReadModeA = 0;
						cReadModeB = 0;
						break;
					}
					break;

				case 4:
					switch (cReadModeB) {
					case 1:
						if (iIndex >= DEF_MAXAPOCALYPSE) {
							PutLogList("(!) WARNING! Too many Apocalypse schedule!"); 
							delete pStrTok;
							delete cp;
							return TRUE;
						}
						m_stApocalypseScheduleStart[iIndex].iDay = atoi(token);
						cReadModeB = 2;
						break;
					case 2:
						m_stApocalypseScheduleStart[iIndex].iHour = atoi(token);
						cReadModeB = 3;
						break;
					case 3:
						m_stApocalypseScheduleStart[iIndex].iMinute = atoi(token);
						iIndex++;
						cReadModeA = 0;
						cReadModeB = 0;
						break;
					}
					break;

				case 5:
					switch (cReadModeB) {
					case 1:
						if (iIndex >= DEF_MAXAPOCALYPSE) {
							PutLogList("(!) WARNING! Too many Apocalypse schedule!"); 
							delete pStrTok;
							delete cp;
							return TRUE;
						}
						m_stApocalypseScheduleEnd[iIndex].iDay = atoi(token);
						cReadModeB = 2;
						break;
					case 2:
						m_stApocalypseScheduleEnd[iIndex].iHour = atoi(token);
						cReadModeB = 3;
						break;
					case 3:
						m_stApocalypseScheduleEnd[iIndex].iMinute = atoi(token);
						iIndex++;
						cReadModeA = 0;
						cReadModeB = 0;
						break;
					}
					break;

				case 6:
					switch (cReadModeB) {
					case 1:
						if (iIndex >= DEF_MAXHELDENIAN) {
							PutLogList("(!) WARNING! Too many Heldenians scheduled!"); 
							delete pStrTok;
							delete cp;
							return TRUE;
						}
						m_stHeldenianSchedule[iIndex].iDay = atoi(token);
						cReadModeB = 2;
						break;
					case 2:
						m_stHeldenianSchedule[iIndex].StartiHour = atoi(token);
						cReadModeB = 3;
						break;
					case 3:
						m_stHeldenianSchedule[iIndex].StartiMinute = atoi(token);
						cReadModeB = 4;
						break;
					case 4:
						m_stHeldenianSchedule[iIndex].EndiHour = atoi(token);
						cReadModeB = 5;
						break;
					case 5:
						m_stHeldenianSchedule[iIndex].EndiMinute = atoi(token);
						iIndex++;
						cReadModeA = 0;
						cReadModeB = 0;
						break;

					}
					break;
				}
			}
			else {
				if (memcmp(token, "crusade-server-name", 19) == 0) {
					cReadModeA = 1;
					cReadModeB = 1;
				}
				if (memcmp(token, "apocalypse-server-name", 22) == 0) {
					cReadModeA = 2;
					cReadModeB = 1;
				}
				if (memcmp(token, "crusade-schedule", 16) == 0) {
					cReadModeA = 3;
					cReadModeB = 1;
				}
				if (memcmp(token, "apocalypse-schedule-start", 25) == 0) {
					cReadModeA = 4;
					cReadModeB = 1;
				}
				if (memcmp(token, "apocalypse-schedule-end", 23) == 0) {
					cReadModeA = 5;
					cReadModeB = 1;
				}
				if (memcmp(token, "Heldenian-schedule", 18) == 0) {
					cReadModeA = 6;
					cReadModeB = 1;
				}
			}
			
			token = pStrTok->pGet();
		}
		delete pStrTok;
		delete cp;
	}
	if (pFile != NULL) fclose(pFile);
	return TRUE;
}

void CGame::GlobalStartCrusadeMode()
{char * cp, cData[120];
 DWORD * dwp, dwCrusadeGUID;
 	
	if (m_bIsAvatarMode == TRUE) return;
	if (m_bIsApocalypseMode == TRUE) return;
	if (m_bIsHeldenianMode == TRUE) return;
/* SYSTEMTIME SysTime;
	GetLocalTime(&SysTime);
	if (m_iLatestCrusadeDayOfWeek != -1) // Prevents running Crusade twice from same server....
	{	if (m_iLatestCrusadeDayOfWeek == SysTime.wDayOfWeek) return;
	}
	else m_iLatestCrusadeDayOfWeek = SysTime.wDayOfWeek;*/
	dwCrusadeGUID = timeGetTime();
	ZeroMemory(cData, sizeof(cData));
	cp = (char *)cData;
	*cp = GSM_BEGINCRUSADE;
	cp++;
	dwp = (DWORD *)cp;
	*dwp = dwCrusadeGUID;
	cp += 4;
	bStockMsgToGateServer(cData, 5);
	LocalStartCrusadeMode(dwCrusadeGUID);
	_bCrusadeLog(DEF_CRUSADELOG_STARTCRUSADE, NULL, NULL, NULL);
}

void CGame::OnStartGameSignal()
{ int i;	
	for (i = 0; i < DEF_MAXMAPS; i++)
	if (m_pMapList[i] != NULL) 	_bReadMapInfoFiles(i);
	
	bReadCrusadeStructureConfigFile("..\\GameConfigs\\Crusade.cfg");
	//Avatar
	bReadAvatarStructureConfigFile("..\\GameConfigs\\Avatar.cfg");
	_LinkStrikePointMapIndex();
	bReadScheduleConfigFile("..\\GameConfigs\\Schedule.cfg");
	bReadCrusadeGUIDFile("GameData\\CrusadeGUID.txt");
	bReadApocalypseGUIDFile("GameData\\ApocalypseGUID.txt");
	bReadHeldenianGUIDFile("GameData\\HeldenianGUID.txt");	
	bReadAvatarGUIDFile("GameData\\AvatarGUID.txt");
	PutLogList("");
	PutLogList("(!) Game Server Activated.");
}

void CGame::RequestGuildTeleportHandler(int iClientH)
{register int i;
 char cMapName[11];	
	if (m_pClientList[iClientH] == NULL) return;
	if (m_pClientList[iClientH]->m_iLockedMapTime != NULL) 
	{	SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_LOCKEDMAP, m_pClientList[iClientH]->m_iLockedMapTime, NULL, NULL, m_pClientList[iClientH]->m_cLockedMapName);
		return;
	}
	// if a guild teleport is set when its not a crusade, log the hacker
	if (!m_bIsCrusadeMode) 
	{	wsprintf(G_cTxt, "Crusade TP Hack:   PC(%s) - Setting teleport location when crusade is disabled.(Delayed) \tIP(%s)"
			, m_pClientList[iClientH]->m_cCharName
			, m_pClientList[iClientH]->m_cIPaddress);
		PutHackLogFileList(G_cTxt);
		DelayedDeleteClient(iClientH, TRUE, TRUE);
		return;
	}
	// if a player is using guild teleport and he is not in a guild, log the hacker
	if (m_pClientList[iClientH]->m_iCrusadeDuty == 0) 
	{	wsprintf(G_cTxt, "Crusade GuildHack: PC(%s) - Teleporting when not in a guild.(Disc.) \tIP(%s)"
			, m_pClientList[iClientH]->m_cCharName
			, m_pClientList[iClientH]->m_cIPaddress);
		PutHackLogFileList(G_cTxt);
		DeleteClient(iClientH, TRUE, TRUE);
		return;
	}
	// Prevent use from inside ML
	if ((m_pClientList[iClientH]->m_cMapIndex == m_iMiddlelandMapIndex) &&	(m_iMiddlelandMapIndex != -1))
		return;
	for (i = 0; i < DEF_MAXGUILDS; i++) 
	if (m_pGuildTeleportLoc[i].m_iV1 == m_pClientList[iClientH]->m_iGuildGUID) 
	{	ZeroMemory(cMapName, sizeof(cMapName));
		strcpy(cMapName, m_pGuildTeleportLoc[i].m_cDestMapName);
		wsprintf(G_cTxt, "Using guild TP:    PC(%s) Guild(%d-%s) - TP to %s (%d/%d). \tIP(%s)"
			, m_pClientList[iClientH]->m_cCharName
			, m_pClientList[iClientH]->m_iGuildGUID 
			, m_pClientList[iClientH]->m_cGuildName 
			, cMapName
			, m_pGuildTeleportLoc[i].m_sDestX
			, m_pGuildTeleportLoc[i].m_sDestY
			, m_pClientList[iClientH]->m_cIPaddress);	
		PutLogEventFileList(G_cTxt);			
		PutLogList(G_cTxt);
		RequestTeleportHandler(iClientH, "3   ", cMapName, m_pGuildTeleportLoc[i].m_sDestX, m_pGuildTeleportLoc[i].m_sDestY);
		return;
	}	
	switch (m_pClientList[iClientH]->m_cSide) {
	case 1: // 
		break;
	case 2: // 
		break;
	}
}


void CGame::GSM_SetGuildTeleportLoc(int iGuildGUID, int dX, int dY, char * pMapName)
{	int i, iIndex;
	DWORD dwTemp, dwTime;	
	dwTime = timeGetTime();
	for (i = 0; i < DEF_MAXGUILDS; i++)
	if (m_pGuildTeleportLoc[i].m_iV1 == iGuildGUID) 
	{	if ((m_pGuildTeleportLoc[i].m_sDestX == dX) && (m_pGuildTeleportLoc[i].m_sDestY == dY) && (strcmp(m_pGuildTeleportLoc[i].m_cDestMapName, pMapName) == 0)) 
		{	m_pGuildTeleportLoc[i].m_dwTime = dwTime;
			return;
		}else 
		{	m_pGuildTeleportLoc[i].m_sDestX = dX;
			m_pGuildTeleportLoc[i].m_sDestY = dY;
			ZeroMemory(m_pGuildTeleportLoc[i].m_cDestMapName, sizeof(m_pGuildTeleportLoc[i].m_cDestMapName));
			strcpy(m_pGuildTeleportLoc[i].m_cDestMapName, pMapName);
			m_pGuildTeleportLoc[i].m_dwTime = dwTime;
			wsprintf(G_cTxt, "GuildTeleport changed          : %d - %s (%d/%d)"
				, iGuildGUID
				, m_pGuildTeleportLoc[i].m_cDestMapName
				, dX
				, dY);
			PutLogEventFileList(G_cTxt);
			PutLogList(G_cTxt);
			return;
		}
	}	
	dwTemp = 0;
	iIndex = -1;
	for (i = 0; i < DEF_MAXGUILDS; i++) 
	{	if (m_pGuildTeleportLoc[i].m_iV1 == NULL) 
		{	m_pGuildTeleportLoc[i].m_iV1 = iGuildGUID;
			m_pGuildTeleportLoc[i].m_sDestX = dX;
			m_pGuildTeleportLoc[i].m_sDestY = dY;
			ZeroMemory(m_pGuildTeleportLoc[i].m_cDestMapName, sizeof(m_pGuildTeleportLoc[i].m_cDestMapName));
			strcpy(m_pGuildTeleportLoc[i].m_cDestMapName, pMapName);
			m_pGuildTeleportLoc[i].m_dwTime = dwTime;
			m_pGuildTeleportLoc[i].m_dwTime = dwTime;
			wsprintf(G_cTxt, "GuildTeleport set          : %d - %s (%d/%d)"
				, iGuildGUID
				, m_pGuildTeleportLoc[i].m_cDestMapName
				, dX
				, dY);
			PutLogEventFileList(G_cTxt);
			PutLogList(G_cTxt);
			return;
		}else 
		{	if (dwTemp < (dwTime - m_pGuildTeleportLoc[i].m_dwTime)) 
			{	dwTemp = (dwTime - m_pGuildTeleportLoc[i].m_dwTime);
				iIndex = i;
			}
		}
	}
	if (iIndex == -1) return;
	m_pGuildTeleportLoc[i].m_iV1 = iGuildGUID;
	m_pGuildTeleportLoc[i].m_sDestX = dX;
	m_pGuildTeleportLoc[i].m_sDestY = dY;
	ZeroMemory(m_pGuildTeleportLoc[i].m_cDestMapName, sizeof(m_pGuildTeleportLoc[i].m_cDestMapName));
	strcpy(m_pGuildTeleportLoc[i].m_cDestMapName, pMapName);
	m_pGuildTeleportLoc[i].m_dwTime = dwTime;
	wsprintf(G_cTxt, "GuildTeleport borrowed     : %d - %s (%d/%d)"
		, iGuildGUID
		, m_pGuildTeleportLoc[i].m_cDestMapName
		, dX
		, dY);
	PutLogEventFileList(G_cTxt);
	PutLogList(G_cTxt);
}

// If receiving a character packet
void CGame::RequestSetGuildTeleportLocHandler(int iClientH, int dX, int dY, int iGuildGUID, char * pMapName)
{char * cp, cData[120];
 register int i;
 int *ip, iIndex;
 DWORD dwTemp, dwTime;
	if (m_pClientList[iClientH] == NULL) return;
	if (m_pClientList[iClientH]->m_bIsOnWaitingProcess == TRUE) return;
	// if a player is setting TP and its not a crusade, log the hacker
	if (m_bIsCrusadeMode == FALSE) 		
	{	wsprintf(G_cTxt, "Crusade TP Hack:    PC(%s) - Setting point when not a crusade.(Disc.)\tIP(%s)"
			, m_pClientList[iClientH]->m_cCharName
			, m_pClientList[iClientH]->m_cIPaddress);
		PutHackLogFileList(G_cTxt);
		DeleteClient(iClientH, TRUE, TRUE);
		return;
	}	
	// if a player is setting TP and its not a gm, log the hacker
	if (m_pClientList[iClientH]->m_iCrusadeDuty != 3) 
	{	wsprintf(G_cTxt, "Crusade TP Hack:    PC(%s) - Setting point when not a Guild Master.(Delayed)\tIP(%s)"
			, m_pClientList[iClientH]->m_cCharName
			, m_pClientList[iClientH]->m_cIPaddress);
		PutHackLogFileList(G_cTxt);
		DelayedDeleteClient(iClientH, TRUE, TRUE);
		return;
	}
	// SNOOPY: removed y <100 limite and tweack TP for X and Y // ML map size = 524x524
	if (dY < 25) dY = 25;
	if (dY > 499) dY = 499;
	if (dX < 25) dX = 25;
	if (dX > 499) dX = 499;
	ZeroMemory(cData, sizeof(cData));
	cp = (char *)cData;
	*cp = GSM_SETGUILDTELEPORTLOC;
	cp++;
	ip = (int *)cp;
	*ip = iGuildGUID;
	cp += 4;
	ip = (int *)cp;
	*ip = dX;
	cp += 4;
	ip = (int *)cp;
	*ip = dY;
	cp += 4;	
	memcpy(cp, pMapName, 10);
	cp += 10;
	dwTime = timeGetTime();

	for (i = 0; i < DEF_MAXGUILDS; i++)
	if (m_pGuildTeleportLoc[i].m_iV1 == iGuildGUID) // changes location
	{	if ((m_pGuildTeleportLoc[i].m_sDestX == dX) && (m_pGuildTeleportLoc[i].m_sDestY == dY) && (strcmp(m_pGuildTeleportLoc[i].m_cDestMapName, pMapName) == 0)) 
		{	m_pGuildTeleportLoc[i].m_dwTime = dwTime;
			return;
		}else 
		{	m_pGuildTeleportLoc[i].m_sDestX = dX;
			m_pGuildTeleportLoc[i].m_sDestY = dY;
			ZeroMemory(m_pGuildTeleportLoc[i].m_cDestMapName, sizeof(m_pGuildTeleportLoc[i].m_cDestMapName));
			strcpy(m_pGuildTeleportLoc[i].m_cDestMapName, pMapName);
			m_pGuildTeleportLoc[i].m_dwTime = dwTime;
			wsprintf(G_cTxt, "GuildTeleport change req.  : %d - %s (%d/%d) - %s"
				, iGuildGUID
				, pMapName
				, dX
				, dY
				, m_pClientList[iClientH]->m_cGuildName);
			PutLogEventFileList(G_cTxt);
			PutLogList(G_cTxt);
			bStockMsgToGateServer(cData, 23);
			return;
		}
	}
	dwTemp = 0;
	iIndex = -1;
	for (i = 0; i < DEF_MAXGUILDS; i++) 
	{	if (m_pGuildTeleportLoc[i].m_iV1 == NULL)  // set location (1st time)
		{	m_pGuildTeleportLoc[i].m_iV1 = iGuildGUID;
			m_pGuildTeleportLoc[i].m_sDestX = dX;
			m_pGuildTeleportLoc[i].m_sDestY = dY;
			ZeroMemory(m_pGuildTeleportLoc[i].m_cDestMapName, sizeof(m_pGuildTeleportLoc[i].m_cDestMapName));
			strcpy(m_pGuildTeleportLoc[i].m_cDestMapName, pMapName);
			m_pGuildTeleportLoc[i].m_dwTime = dwTime;			
			wsprintf(G_cTxt, "GuildTeleport set req.     : %d - %s (%d/%d) - %s"
				, iGuildGUID
				, pMapName
				, dX
				, dY
				, m_pClientList[iClientH]->m_cGuildName);
			PutLogEventFileList(G_cTxt);
			PutLogList(G_cTxt);
			bStockMsgToGateServer(cData, 23);
			return;
		}else // if too much guild TP, replace the older one....
		{	if (dwTemp < (dwTime - m_pGuildTeleportLoc[i].m_dwTime)) 
			{	dwTemp = (dwTime - m_pGuildTeleportLoc[i].m_dwTime);
				iIndex = i;
			}
		}
	}
	if (iIndex == -1) return;
	m_pGuildTeleportLoc[i].m_iV1 = iGuildGUID;
	m_pGuildTeleportLoc[i].m_sDestX = dX;
	m_pGuildTeleportLoc[i].m_sDestY = dY;
	ZeroMemory(m_pGuildTeleportLoc[i].m_cDestMapName, sizeof(m_pGuildTeleportLoc[i].m_cDestMapName));
	strcpy(m_pGuildTeleportLoc[i].m_cDestMapName, pMapName);
	m_pGuildTeleportLoc[i].m_dwTime = dwTime;	
	wsprintf(G_cTxt, "GuildTeleport borrow req.  : %d - %s (%d/%d) - %s"
		, iGuildGUID
		, pMapName
		, dX
		, dY
		, m_pClientList[iClientH]->m_cGuildName);
	PutLogEventFileList(G_cTxt);
	PutLogList(G_cTxt);
	bStockMsgToGateServer(cData, 23);
}

// New 12/05/2004 Changed
void CGame::MeteorStrikeHandler(int iMapIndex)
{
 int i, ix, iy, dX, dY, iIndex, iTargetIndex, iTotalESG, iEffect;
 int iTargetArray[DEF_MAXSTRIKEPOINTS];
 short sOwnerH;
 char  cOwnerType;
 DWORD dwTime = timeGetTime();
	
	PutLogList("(!) Beginning Meteor Strike Procedure...");
	if (iMapIndex == -1) 
	{	PutLogList("(X) MeteorStrikeHandler Error! MapIndex -1!");
		return;
	}	
	if (m_pMapList[iMapIndex] == NULL) 
	{	PutLogList("(X) MeteorStrikeHandler Error! NULL Map!");
		return;
	}	
	if (m_pMapList[iMapIndex]->m_iTotalStrikePoints == 0) 
	{	PutLogList("(X) MeteorStrikeHandler Error! No Strike Points!");
		return;
	}	
	for (i = 0; i < DEF_MAXSTRIKEPOINTS; i++) iTargetArray[i] = -1;

	iIndex = 0;
	for (i = 1; i <= m_pMapList[iMapIndex]->m_iTotalStrikePoints; i++) 
	{	if (m_pMapList[iMapIndex]->m_stStrikePoint[i].iHP > 0) 
		{	iTargetArray[iIndex] = i; 
			iIndex++;
		}
	}
	//testcode
	wsprintf(G_cTxt, "(!) Map(%s) has %d available strike points", m_pMapList[iMapIndex]->m_cName, iIndex);
	PutLogList(G_cTxt);

	m_stMeteorStrikeResult.iCasualties            = 0;
	m_stMeteorStrikeResult.iCrashedStructureNum   = 0;
	m_stMeteorStrikeResult.iStructureDamageAmount = 0;

	if (iIndex == 0) 
	{	PutLogList("(!) No strike points!");
		bRegisterDelayEvent(DEF_DELAYEVENTTYPE_CALCMETEORSTRIKEEFFECT, NULL, dwTime + 6000, NULL, NULL, iMapIndex, NULL, NULL, NULL, NULL, NULL);
	}else 
	{	for (i = 1; i < DEF_MAXCLIENTS; i++)
		{	if ((m_pClientList[i] != NULL) && (m_pClientList[i]->m_bIsInitComplete == TRUE) && (m_pClientList[i]->m_cMapIndex == iMapIndex)) 
			{	SendNotifyMsg(NULL, i, DEF_NOTIFY_METEORSTRIKEHIT, NULL, NULL, NULL, NULL);
			}
		}
		for (i = 0; i < iIndex; i++) 
		{	iTargetIndex = iTargetArray[i];
			if (iTargetIndex == -1) 
			{	PutLogList("(X) Strike Point MapIndex: -1!");
				goto MSH_SKIP_STRIKE;
			}
			dX = m_pMapList[iMapIndex]->m_stStrikePoint[iTargetIndex].dX;
			dY = m_pMapList[iMapIndex]->m_stStrikePoint[iTargetIndex].dY;
			// dX, dY Energy Shield Generator
			// NPC
			iTotalESG = 0;
			for (ix = dX-10; ix <= dX+10; ix++) 
			for (iy = dY-10; iy <= dY+10; iy++) 
			{	m_pMapList[iMapIndex]->GetOwner(&sOwnerH, &cOwnerType, ix, iy);
				if ((cOwnerType == DEF_OWNERTYPE_NPC) && (m_pNpcList[sOwnerH] != NULL) && (m_pNpcList[sOwnerH]->m_sType == 40)) 
				{	iTotalESG++;
				}
			}			
			// testcode
			wsprintf(G_cTxt, "(!) Meteor Strike Target(%d, %d) ESG(%d)", dX, dY, iTotalESG);
			PutLogList(G_cTxt);

			if (iTotalESG < 2) 
			{	m_pMapList[iMapIndex]->m_stStrikePoint[iTargetIndex].iHP -= (2 - iTotalESG);
				if (m_pMapList[iMapIndex]->m_stStrikePoint[iTargetIndex].iHP <= 0) 
				{	m_pMapList[iMapIndex]->m_stStrikePoint[iTargetIndex].iHP = 0;
					// Should have been a way to prevent people to go in destructed building, never implemented
					//m_pMapList[m_pMapList[iMapIndex]->m_stStrikePoint[iTargetIndex].iMapIndex]->m_bIsDisabled = TRUE;
					m_stMeteorStrikeResult.iCrashedStructureNum++;
				}else 
				{	m_stMeteorStrikeResult.iStructureDamageAmount += (2 - iTotalESG);
					iEffect = iDice(1,5)-1;
					iAddDynamicObjectList(NULL, NULL, DEF_DYNAMICOBJECT_FIRE2, iMapIndex, 
					                  m_pMapList[iMapIndex]->m_stStrikePoint[iTargetIndex].iEffectX[iEffect] +(iDice(1,3) -2), 
									  m_pMapList[iMapIndex]->m_stStrikePoint[iTargetIndex].iEffectY[iEffect] +(iDice(1,3) -2), 60*1000*50);
				}
			}
MSH_SKIP_STRIKE:;
		}
		bRegisterDelayEvent(DEF_DELAYEVENTTYPE_DOMETEORSTRIKEDAMAGE, NULL, dwTime + 1000, NULL, NULL, iMapIndex, NULL, NULL, NULL, NULL, NULL);
		bRegisterDelayEvent(DEF_DELAYEVENTTYPE_DOMETEORSTRIKEDAMAGE, NULL, dwTime + 4000, NULL, NULL, iMapIndex, NULL, NULL, NULL, NULL, NULL);
		bRegisterDelayEvent(DEF_DELAYEVENTTYPE_CALCMETEORSTRIKEEFFECT, NULL, dwTime + 6000, NULL, NULL, iMapIndex, NULL, NULL, NULL, NULL, NULL);
	}
}

void CGame::_ClearExchangeStatus(int iToH)
{	if ((iToH <= 0) || (iToH >= DEF_MAXCLIENTS)) return;
	if (m_pClientList[iToH] == NULL) return;
	if (m_pClientList[iToH]->m_cExchangeName != FALSE) 
		SendNotifyMsg(NULL, iToH, DEF_NOTIFY_CANCELEXCHANGEITEM, NULL, NULL, NULL, NULL, NULL, NULL,
						NULL, NULL, NULL, NULL, NULL);	
	// m_pClientList[iToH]->m_cExchangeName    = FALSE;
	// Needed here ??? has Exchange any effect on Connection check messages?
	m_pClientList[iToH]->dwTimeConnectionCheck = 0;
	//m_pClientList[iToH]->m_iAlterItemDropIndex = -1;
	//m_pClientList[iToH]->m_iEventItemDropIndex = -1;
	//m_pClientList[iToH]->m_cExchangeItemIndex = -1;
	m_pClientList[iToH]->m_iExchangeH = NULL;
	m_pClientList[iToH]->m_bIsExchangeMode = FALSE;
	m_pClientList[iToH]->m_bIsExchangeConfirm = FALSE;// snoopy if 2 consecutive trade this value seemed not reset to FALSE
	ZeroMemory(m_pClientList[iToH]->m_cExchangeName, sizeof(m_pClientList[iToH]->m_cExchangeName));
}

void CGame::CancelExchangeItem(int iClientH)
{
 int iExH;
	iExH = m_pClientList[iClientH]->m_iExchangeH;
	_ClearExchangeStatus(iExH);
	_ClearExchangeStatus(iClientH);
}

// v2.17 2002-7-15
void CGame::SetForceRecallTime(int iClientH)
{	int iTL_ = 0 ;
	SYSTEMTIME SysTime;
	if (m_pClientList[iClientH] == NULL) return ;
	if (m_pClientList[iClientH]->m_iTimeLeft_ForceRecall == 0) 
	{	if (m_sForceRecallTime > 0 ) 
		{	m_pClientList[iClientH]->m_iTimeLeft_ForceRecall = 20*m_sForceRecallTime ;
		}else 
		{	GetLocalTime(&SysTime);
			switch (SysTime.wDayOfWeek) {
			case 1:	m_pClientList[iClientH]->m_iTimeLeft_ForceRecall = 20*m_sRaidTimeMonday; break;  //¿ù¿äÀÏ  3ºÐ 2002-09-10 #1
			case 2:	m_pClientList[iClientH]->m_iTimeLeft_ForceRecall = 20*m_sRaidTimeTuesday; break;  //È­¿äÀÏ  3ºÐ 
			case 3:	m_pClientList[iClientH]->m_iTimeLeft_ForceRecall = 20*m_sRaidTimeWednesday; break;  //¼ö¿äÀÏ  3ºÐ 
			case 4:	m_pClientList[iClientH]->m_iTimeLeft_ForceRecall = 20*m_sRaidTimeThursday; break;  //¸ñ¿äÀÏ  3ºÐ 
			case 5:	m_pClientList[iClientH]->m_iTimeLeft_ForceRecall = 20*m_sRaidTimeFriday; break; //±Ý¿äÀÏ 15ºÐ
			case 6:	m_pClientList[iClientH]->m_iTimeLeft_ForceRecall = 20*m_sRaidTimeSaturday; break; //Åä¿äÀÏ 45ºÐ 
			case 0:	m_pClientList[iClientH]->m_iTimeLeft_ForceRecall = 20*m_sRaidTimeSunday; break; //ÀÏ¿äÀÏ 60ºÐ
			}
		}
	}else  // if (m_pClientList[iClientH]->m_iTimeLeft_ForceRecall == 0) 
	{	if (m_sForceRecallTime > 0 ) 
		{	iTL_ =  20*m_sForceRecallTime ;
		}else 
		{	GetLocalTime(&SysTime);
			switch (SysTime.wDayOfWeek) {
			case 1:	iTL_ = 20*m_sRaidTimeMonday; break;  //¿ù¿äÀÏ  3ºÐ 2002-09-10 #1
			case 2:	iTL_ = 20*m_sRaidTimeTuesday; break;  //È­¿äÀÏ  3ºÐ
			case 3:	iTL_ = 20*m_sRaidTimeWednesday; break;  //¼ö¿äÀÏ  3ºÐ
			case 4:	iTL_ = 20*m_sRaidTimeThursday; break;  //¸ñ¿äÀÏ  3ºÐ
			case 5:	iTL_ = 20*m_sRaidTimeFriday; break; //±Ý¿äÀÏ 15ºÐ
			case 6:	iTL_ = 20*m_sRaidTimeSaturday; break; //Åä¿äÀÏ 45ºÐ 
			case 0:	iTL_ = 20*m_sRaidTimeSunday; break; //ÀÏ¿äÀÏ 60ºÐ
			}
		}
		if (m_pClientList[iClientH]->m_iTimeLeft_ForceRecall > iTL_) 
			m_pClientList[iClientH]->m_iTimeLeft_ForceRecall = iTL_;
	}
	return ;
}

void CGame::CheckForceRecallTime(int iClientH)
{SYSTEMTIME SysTime;
 int iTL_;
	if(m_pClientList[iClientH] == NULL) return;
	if (m_pClientList[iClientH]->m_iAdminUserLevel > 0) return;
	if (m_pClientList[iClientH]->m_iTimeLeft_ForceRecall == 0) 
	{	// has admin set a recall time ??
		if (m_sForceRecallTime > 0) {
			m_pClientList[iClientH]->m_iTimeLeft_ForceRecall = m_sForceRecallTime * 20;
		}else // use standard recall time calculations
		{	GetLocalTime(&SysTime);	
			switch(SysTime.wDayOfWeek) {
			case 1:	m_pClientList[iClientH]->m_iTimeLeft_ForceRecall = 20*m_sRaidTimeMonday; break;  //¿ù¿äÀÏ  3ºÐ 2002-09-10 #1
			case 2:	m_pClientList[iClientH]->m_iTimeLeft_ForceRecall = 20*m_sRaidTimeTuesday; break;  //È­¿äÀÏ  3ºÐ 
			case 3:	m_pClientList[iClientH]->m_iTimeLeft_ForceRecall = 20*m_sRaidTimeWednesday; break;  //¼ö¿äÀÏ  3ºÐ 
			case 4:	m_pClientList[iClientH]->m_iTimeLeft_ForceRecall = 20*m_sRaidTimeThursday; break;  //¸ñ¿äÀÏ  3ºÐ 
			case 5:	m_pClientList[iClientH]->m_iTimeLeft_ForceRecall = 20*m_sRaidTimeFriday; break; //±Ý¿äÀÏ 15ºÐ
			case 6:	m_pClientList[iClientH]->m_iTimeLeft_ForceRecall = 20*m_sRaidTimeSaturday; break; //Åä¿äÀÏ 45ºÐ 
			case 0:	m_pClientList[iClientH]->m_iTimeLeft_ForceRecall = 20*m_sRaidTimeSunday; break; //ÀÏ¿äÀÏ 60ºÐ
			}
		}
	}else// has admin set a recall time ??
	{	if (m_sForceRecallTime > 0) 
		{	iTL_ = m_sForceRecallTime * 20;
		}else // use standard recall time calculations		
		{	GetLocalTime(&SysTime);
			switch(SysTime.wDayOfWeek) {
			case 1:	m_pClientList[iClientH]->m_iTimeLeft_ForceRecall = 20*m_sRaidTimeMonday; break;  //¿ù¿äÀÏ  3ºÐ 2002-09-10 #1
			case 2:	m_pClientList[iClientH]->m_iTimeLeft_ForceRecall = 20*m_sRaidTimeTuesday; break;  //È­¿äÀÏ  3ºÐ 
			case 3:	m_pClientList[iClientH]->m_iTimeLeft_ForceRecall = 20*m_sRaidTimeWednesday; break;  //¼ö¿äÀÏ  3ºÐ 
			case 4:	m_pClientList[iClientH]->m_iTimeLeft_ForceRecall = 20*m_sRaidTimeThursday; break;  //¸ñ¿äÀÏ  3ºÐ 
			case 5:	m_pClientList[iClientH]->m_iTimeLeft_ForceRecall = 20*m_sRaidTimeFriday; break; //±Ý¿äÀÏ 15ºÐ
			case 6:	m_pClientList[iClientH]->m_iTimeLeft_ForceRecall = 20*m_sRaidTimeSaturday; break; //Åä¿äÀÏ 45ºÐ 
			case 0:	m_pClientList[iClientH]->m_iTimeLeft_ForceRecall = 20*m_sRaidTimeSunday; break; //ÀÏ¿äÀÏ 60ºÐ
			}
		}
		if (m_pClientList[iClientH]->m_iTimeLeft_ForceRecall > iTL_) 
			m_pClientList[iClientH]->m_iTimeLeft_ForceRecall = iTL_;
	}
}

int ITEMSPREAD_FIEXD_COORD [25][2] =
{
	{ 0,  0},	//1
	{ 1,  0},	//2
	{ 1,  1},	//3
	{ 0,  1},	//4
	{-1,  1},	//5
	{-1,  0},	//6
	{-1, -1},	//7
	{ 0, -1},	//8
	{ 1, -1},	//9
	{ 2, -1},	//10
	{ 2,  0},	//11
	{ 2,  1},	//12
	{ 2,  2},	//13
	{ 1,  2},	//14
	{ 0,  2},	//15
	{-1,  2},	//16
	{-2,  2},	//17
	{-2,  1},	//18
	{-2,  0},	//19
	{-2, -1},	//20
	{-2, -2},	//21
	{-1, -2},	//22
	{ 0, -2},	//23
	{ 1, -2},	//24
	{ 2, -2},	//25
};
//////////////////////////////////////////////////////////////////////////////////////
// Routine greatly simplified by Snoopy, EP items added                             //
//////////////////////////////////////////////////////////////////////////////////////
BOOL CGame::bGetMultipleItemNamesWhenDeleteNpc(short sNpcType, int iProbability, int iMin, int iMax, short sBaseX, short sBaseY,
											   int iItemSpreadType, int iSpreadRange,
											   int *iItemIDs, POINT *BasePos, int *iNumItem)
{	int		iItemID, iResult;
	int		iNum = 0;
	for(int i=0; i<iMax; i++ )
	{	iItemID = 0;
		switch(sNpcType)
		{	case 50: // Tigerworm have  1 classic TW drop then possible more drops (2->10)
				if (i == 0) { // n°1 Drop is a normal TW drop
					iResult = iDice(1,12000);
					// Table improved by Snoopy81 for low People servers
					if ((iResult >= 1) && (iResult <=  1500)) iItemID = 311 ;		  // MagicNecklace(DF+10)
					else if ((iResult > 1500) && (iResult <= 3000))  iItemID = 305 ;  // MagicNecklace(DM+1)
					else if ((iResult > 3000) && (iResult <= 4000))  iItemID = 614 ;  // SwordofIceElemental	
					else if ((iResult > 4000) && (iResult <= 4500))  iItemID = 290 ;  // Flameberge+3(LLF)
					else if ((iResult > 4500) && (iResult <= 5000))  iItemID = 633 ;  // RingofDemonpower
					else if ((iResult > 5000) && (iResult <= 5800))  iItemID = 492 ;  // BloodRapier		
					else if ((iResult > 5800) && (iResult <= 6300))  iItemID = 490 ;  // BloodSword		
					else if ((iResult > 6300) && (iResult <= 7000))  iItemID = 491 ;  // BloodAxe		
					else if ((iResult > 7000) && (iResult <= 8000))  iItemID = 291 ;  // MagicWand(MS30-LLF)	
					else if ((iResult > 8000) && (iResult <= 8500))  iItemID = 630 ;  // RingoftheXelima	
					else if ((iResult > 8500) && (iResult <= 9000))  iItemID = 612 ;  // XelimaRapier	
					else if ((iResult > 9000) && (iResult <= 9300))  iItemID = 610 ;  // XelimaBlade	
					else if ((iResult > 9300) && (iResult <= 9700))  iItemID = 611 ;  // XelimaAxe	
					else if ((iResult > 9700) && (iResult <= 10000)) iItemID = 631 ;  // RingoftheAbaddon
				}
				// TW additive possible drops (scarce !)
				if( iItemID == 0 )
				{	switch (iDice(1,25)) {
					case  1: if (iDice(1,60) == 3)	iItemID = 380; break; // IceStormManual
					case  2: if (iDice(1,300) == 3)	iItemID = 857; break; // I.M.CManual
					case  3: if (iDice(1,300) == 3) iItemID = 853; break; // E.S.W.Manual
					case  4: if (iDice(1,300) == 3)	iItemID = 852; break; // CancelManual
					case  5: if (iDice(1,80) == 3)	iItemID = 382; break; // BloodyShockW.Manual
					case  6: if (iDice(1,80) == 3)	iItemID = 381; break; // MassFireStrikeManual    
					case  7: if (iDice(1,2) == 2)	iItemID = 651; break; // Green Ball     
					case  8: if (iDice(1,10) == 2)  iItemID = 652; break; // Red Ball     
					case  9: if (iDice(1,14) == 2)  iItemID = 653; break; // Yellow Ball     
					case 10: if (iDice(1,20) == 2)  iItemID = 654; break; // Blue Ball     
					case 11: if (iDice(1,40) == 2)  iItemID = 655; break; // Pearl Ball   
					case 12: if (iDice(1,30) == 3)  iItemID = 950; break; // Egg950
					case 13: if (iDice(1,20) == 3)  iItemID = 951; break; // Egg951
					case 14: if (iDice(1,20) == 3)  iItemID = 952; break; // Egg952
					case 15: if (iDice(1,10) == 2)  iItemID = 953; break; // Egg953
					case 16: if (iDice(1,15) == 3)  iItemID = 954; break; // Egg954
					case 17: if (iDice(1,20) == 3)  iItemID = 955; break; // Egg955
					case 18: if (iDice(1,10) == 2)  iItemID = 956; break; // Egg956
					case 19: if (iDice(1,20) == 3)  iItemID = 957; break; // Egg957
					case 20: if (iDice(1,20) == 3)  iItemID = 958; break; // Egg958
					case 21: if (iDice(1,20) == 3)  iItemID = 959; break; // Egg959
					case 22: if (iDice(1,40) == 3)  iItemID = 960; break; // Egg960
					case 23: if (iDice(1,20) == 3)  iItemID = 961; break; // Egg961
					case 24: if (iDice(1,300) == 3) iItemID = 125; break; // Warrior Spirit Manual
					case 25: if (iDice(1,200) == 3)	iItemID = 126; break; // BMManual Manual
					}
				}
				break;

		case 69: // Normal Wyvern (5->15)
			// Wyvern.Rare drops
			if (i < iMin)
			{	switch (iDice(1,20)) {
				case 1: if (iDice(1,50) == 3)	iItemID = 614; break; // SwordofIceElemental
				case 2: if (iDice(1,75) == 3)	iItemID = 987; break; // IceRapier
				case 3: if (iDice(1,100) == 3)	iItemID = 988; break; // IceAxe
				case 4: if (iDice(1,150) == 3)	iItemID = 986; break; // IceGiantSword
				case 5: if (iDice(1,150) == 3)	iItemID = 625; break; // IceElementalBow
				case 6: if (iDice(1,200) == 3)	iItemID = 766; break; // IceGBH
				case 7: if (iDice(1,400) == 3)	iItemID = 767; break; // StormBringer
				case 8: if (iDice(1,150) == 3)	iItemID = 845; break; // StormBlade
				case 9: if (iDice(1,100) == 3)	iItemID = 848; break; // LightingBlade
				case 10:if (iDice(1,100) == 3)	iItemID = 985; break; // RevivalAxe
				case 11:if (iDice(1,40) == 3)	iItemID = 380; break; // IceStormManual
				case 12:if (iDice(1,100) == 3)	iItemID = 857; break; // I.M.C Manual
				case 13:if (iDice(1,100) == 3)	iItemID = 853; break; // E.S.W.Manual
				case 14:if (iDice(1,100) == 3)	iItemID = 852; break; // CancelManual
				case 15:if (iDice(1,100) == 3)	iItemID = 125; break; // Warrior Spirit Manual
				case 16:if (iDice(1,100) == 3)	iItemID = 126; break; // BMManual Manual
				case 17:if (iDice(1,150) == 3)	iItemID = 984; break; // LichMS10
				case 18:if (iDice(1,100) == 3)	iItemID = 735; break; // RingOfDragonPower       	
				case 19:if (iDice(1,150) == 3)	iItemID = 734; break; // RingOfArchMage 
				case 20:if (iDice(1,150) == 3)	iItemID = 648; break; // NeckMS15   
				}
			}
			// Wyvern more common drops
			if( iItemID == 0 )
			{	switch( iDice(1, 20) ) {	
				case 1: if (iDice(1,20) == 2)	iItemID = 642; break; // KnecklaceOfIcePro       
				case 2: if (iDice(1,100) == 2)	iItemID = 643; break; // KnecklaceOfIceEle   
				case 3: if (iDice(1,40) == 2)	iItemID = 637; break; // NecklaceOfLightPro       
				case 4: if (iDice(1,120) == 2)	iItemID = 644; break; // NecklaceOfAirEl       
				case 5: if (iDice(1,10) == 3)	iItemID = 634; break; // RingofWizard           
				case 6: if (iDice(1,20) == 3)	iItemID = 635; break; // RingofMage      
				case 7: if (iDice(1,50) == 3)	iItemID = 636; break; // RingofGrandMage        
				case 8: if (iDice(1,5) == 2)	iItemID = 654; break; // Blue Ball
				case 9:
				case 10:if (iDice(1,10) == 3)	iItemID = 380; break; // IceStormManual
				case 11:if (iDice(1,40) == 3)	iItemID = 946; break; // YellowArmorW	
				case 12:if (iDice(1,40) == 3)	iItemID = 947; break; // LuckyArmorW
				case 13:if (iDice(1,40) == 3)	iItemID = 948; break; // LicheArmorW
				case 14:if (iDice(1,40) == 3)	iItemID = 940; break; // YellowArmorM	
				case 15:if (iDice(1,40) == 3)	iItemID = 941; break; // LuckyArmorM
				case 16:if (iDice(1,40) == 3)	iItemID = 942; break; // LicheArmorM
				case 17:if (iDice(1,40) == 3)	iItemID = 997; break; // LicheRobeW
				case 18:
				case 19:
				case 20:if (iDice(1,5) == 3)	iItemID = 951; break; // Egg951
				case 25:if (iDice(1,30) == 3)	iItemID = 874; break; // Direction-Bow	
				}
			}
			break; 

		case 73:  // Fire-Wyvern (5-15)
			// Fire-Wyvern Rare drops
			if (i < iMin)
			{	switch (iDice(1, 20)) {
				case 1: if (iDice(1,40) == 3)	iItemID = 612; break; // XelimaRapier
				case 2: if (iDice(1,60) == 3)	iItemID = 611; break; // XelimaAxe
				case 3: if (iDice(1,80) == 3)	iItemID = 610; break; // XelimaBlade
				case 4: if (iDice(1,120) == 3)	iItemID = 989; break; // XelimaGiantHammer
				case 5: if (iDice(1,200) == 3)	iItemID = 983; break; // XelimaWandMS0
				case 6: if (iDice(1,200) == 3)	iItemID = 626; break; // XelimaBow  
				case 7: if (iDice(1,100) == 3)	iItemID = 847; break; // DarkExecutor 
				case 8: if (iDice(1,400) == 3)	iItemID = 767; break; // StormBringer
				case 9: if (iDice(1,100) == 2)	iItemID =  20; break; // Excaliber    
				case 10:if (iDice(1,100) == 3)	iItemID = 768; break; // DefenderAxe
				case 11:if (iDice(1,50) == 3)	iItemID = 857; break; // I.M.C.Manual
				case 12:if (iDice(1,50) == 3)	iItemID = 853; break; // E.S.W.Manual
				case 13:if (iDice(1,50) == 3)	iItemID = 852; break; // CancelManual
				case 14:if (iDice(1,50) == 3)	iItemID = 125; break; // Warrior Spirit Manual
				case 15:if (iDice(1,50) == 3)	iItemID = 126; break; // BMManual Manual					     
				case 16:if (iDice(1,50) == 2)	iItemID = 735; break; // RingOfDragonpower  
				case 17:if (iDice(1,150) == 3)	iItemID = 982; break; // BloodWandMS40   
				case 18:if (iDice(1,200) == 2)	iItemID = 630; break; // RingoftheXelima
				case 19:if (iDice(1,400) == 2)	iItemID = 860; break; // NecklaceOfXelima  
				case 20:if (iDice(1,100) == 3)	iItemID = 734; break; // RingOfArchMage  
				}
			}
			//  Fire-Wyvern more common drops (10 * fProbA <=> 1/40 or 1/200)
			if( iItemID == 0 )
			{	switch( iDice(1, 20) ) {   	
				case 1: if (iDice(1,20) == 2)	iItemID = 638; break; // KnecklaceOfFirePro 
				case 2: if (iDice(1,100) == 2)	iItemID = 645; break; // KnecklaceOfEfreet 					
				case 3: if (iDice(1,20) == 3)	iItemID = 634; break; // RingofWizard           
				case 4: if (iDice(1,40) == 3)	iItemID = 635; break; // RingofMage      
				case 5: if (iDice(1,80) == 3)	iItemID = 636; break; // RingofGrandMage  					
				case 6: if (iDice(1,20) == 3)	iItemID = 382; break; // BloodyShockW.Manual
				case 7: if (iDice(1,20) == 3)	iItemID = 381; break; // MassFireStrikeManual 
				case 8: if (iDice(1,40) == 3)	iItemID = 492; break; // BloodRapier  
				case 9: if (iDice(1,50) == 3)	iItemID = 491; break; // BloodAxe              
				case 10:if (iDice(1,60) == 3)	iItemID = 490; break; // BloodSword                 
				case 11:if (iDice(1,100) == 3)	iItemID = 990; break; // BloodBattleAxe  
				case 12:if (iDice(1,5) == 2)	iItemID = 652; break; // Red Ball
				case 13:if (iDice(1,40) == 3)	iItemID = 938; break; // BlueArmorM	
				case 14:if (iDice(1,40) == 3)	iItemID = 939; break; // RedArmorM	
				case 15:if (iDice(1,40) == 3)	iItemID = 944; break; // BlueArmorW
				case 16:if (iDice(1,40) == 3)	iItemID = 945; break; // RedArmorW	
				case 17:if (iDice(1,40) == 3)	iItemID = 996; break; // OgressArmorW
				case 18:if (iDice(1,20) == 3)	iItemID = 873; break; // Fire-Bow				case 19:
				case 20:                        iItemID = 950; break; // Egg950	
				}
			}
			break;

		case 81: // Abaddon (12-20)
			//  Abaddon Rare drops
			if (i < iMin)
			{	switch (iDice(1, 15)) {
				case 1: if (iDice(1,20) == 3)	iItemID = 630; break; // XelimaRing
				case 2: if (iDice(1,50) == 2)	iItemID = 631; break; // RingoftheAbaddon        
				case 3: if (iDice(1,50) == 3)	iItemID = 860; break; // NecklaceOfXelima
				case 4: if (iDice(1,20) == 3)	iItemID = 858; break; // NecklaceOfMerien
				case 5: if (iDice(1,30) == 3)	iItemID = 648; break; // NeckMS15
				case 6: if (iDice(1,10) == 3)	iItemID = 19;  break; // Sting-Dart				
				case 7: if (iDice(1,10) == 3)	iItemID = 20;  break; // Excalibur	
				case 8: if (iDice(1,50) == 3)	iItemID = 613; break; // MedusaSword  	
				case 9: if (iDice(1,20) == 3)	iItemID = 616; break; // DemonSlayer  	
				case 10:if (iDice(1,20) == 2)	iItemID = 861; break; // BerserkWand
				case 11:if (iDice(1,20) == 3)	iItemID = 865; break; // ResurWand(MS.20)	 
				case 12:if (iDice(1,40) == 3)	iItemID = 936; break; // Storm-Bow     
				case 13:if (iDice(1,20) == 3)	iItemID = 999; break; // PinkTowerShield
				case 14:if (iDice(1,20) == 3)	iItemID = 627; break; // MerienHat	
				case 15:if (iDice(1,20) == 3)	iItemID = 628; break; // MerienHelmM
				}
			}
			//  Abaddon more common drops
			if( iItemID == 0 )
			{	switch( iDice(1, 30) ) {            
				case  1: if (iDice(1,4) == 1)	iItemID = 492; break; // BloodRapier            
				case  2: if (iDice(1,5) == 3)	iItemID = 491; break; // BloodAxe    
				case  3: if (iDice(1,6) == 3)	iItemID = 490; break; // BloodSword    
				case  4: if (iDice(1,8) == 3)	iItemID = 990; break; // BloodBattleAxe
				case  5: if (iDice(1,25) == 3)	iItemID = 982; break; // BloodWandMS40

				case  6: if (iDice(1,10) == 3)	iItemID = 612; break; // XelimaRapier
				case  7: if (iDice(1,15) == 3)	iItemID = 611; break; // XelimaAxe
				case  8: if (iDice(1,20) == 3)	iItemID = 610; break; // XelimaBlade
				case  9: if (iDice(1,40) == 3)	iItemID = 989; break; // XelimaGiantHammer
				case 10: if (iDice(1,60) == 3)	iItemID = 983; break; // XelimaWandMS0
				case 11: if (iDice(1,60) == 3)	iItemID = 626; break; // XelimaBow
     	
				case 12: if (iDice(1,4) == 1)	iItemID = 638; break; // KnecklaceOfFirePro 
				case 13: if (iDice(1,15) == 3)	iItemID = 645; break; // KnecklaceOfEfreet  
				case 14: if (iDice(1,10) == 3)	iItemID = 735; break; // RingOfDragonPower 
			
				case 15:if (iDice(1,5) == 3)	iItemID = 380; break; // IceStormManual
				case 16:if (iDice(1,5) == 3)	iItemID = 382; break; // BloodyShockW.Manual
				case 17:if (iDice(1,5) == 3)	iItemID = 381; break; // MassFireStrikeManual 
				case 18:if (iDice(1,30) == 3)	iItemID = 857; break; // I.M.C.Manual
				case 19:if (iDice(1,30) == 3)	iItemID = 853; break; // E.S.W.Manual
				case 20:if (iDice(1,30) == 3)	iItemID = 852; break; // CancelManual
				case 21:if (iDice(1,30) == 3)	iItemID = 125; break; // Warrior Spirit Manual
				case 22:if (iDice(1,10) == 3)	iItemID = 126; break; // BMManual Manual

				case 23: if (iDice(1,10) == 3)	iItemID = 866; break; // ResurWandMS0
				case 24: if (iDice(1,10) == 3)	iItemID = 291; break; // MagicWand(MS30-LLF)  

				case 25: if (iDice(1,20) == 3)	iItemID = 943;  break; // AbaddonArmorM		
				case 26: if (iDice(1,20) == 3)	iItemID = 949;  break; // AbaddonArmorW	
				case 27: if (iDice(1,20) == 3)	iItemID = 998;  break; // PinkLagiShield
				case 28:
				case 29:
				case 30: iItemID = 960; break; // Egg960
				/*case 25: if (iDice(1,40) == 3)	iItemID = 618;  break; // DarkElfBow	
				case 25: if (iDice(1,40) == 3)	iItemID = 620;  break; // MerienShield	
				case 25: if (iDice(1,40) == 3)	iItemID = 621;  break; // MerienPlateMailM	
				case 25: if (iDice(1,40) == 3)	iItemID = 622;  break; // MerienPlateMailW	
				case 25: if (iDice(1,40) == 3)	iItemID = 849;  break; // KlonessBlade	
				case 25: if (iDice(1,40) == 3)	iItemID = 851;  break; // KlonessEsterk	
				case 25: if (iDice(1,40) == 3)	iItemID = 858;  break; // NecklaceOfMerien
				case 25: if (iDice(1,40) == 3)	iItemID = 859;  break; // NecklaceOfKloness	
				case 25: if (iDice(1,40) == 3)	iItemID = 863;  break; // KlonessMS20 	
				case 25: if (iDice(1,40) == 3)	iItemID = 864;  break; // KlonessMS28*/
				}
			}
			break;
		} // switch

		// SNOOPY: Changed some items here!
		if(    (iItemID == 0 )
			&& ((i < iMin)||(iDice(1,3)==2)) ) //1 in 3 chance above iMin
		{	// Here are spare items to fill the drop number
			// each item should have rouythlly  50% chance of dropping....with 50 iProbability
			switch( iDice(1, 30) ) {
				case  1: if (iDice(1,50)  < iProbability) iItemID = 740; break; // BagOfGold-5k
				case  2: if (iDice(1,75)  < iProbability) iItemID = 741; break; // BagOfGold-10k
				case  3: if (iDice(1,100) < iProbability) iItemID = 742; break; // BagOfGold-50k
				case  4: 
				case  5:
				case  6: if (iDice(1,50)  < iProbability) iItemID = 650; break; // ZemstoneOfSacrifice
				case  7: 
				case  8:
				case  9: if (iDice(1,50) < iProbability)  iItemID = 656; break; // StoneOfXelima
				case 10:
				case 11:
				case 12: if (iDice(1,100) < iProbability) iItemID = 657; break; // StoneOfMerien
				case 13: if (iDice(1,100) < iProbability) iItemID = 333; break; // PlatinumRing          
				case 14: if (iDice(1,100) < iProbability) iItemID = 334; break; // LuckyGoldRing         
				case 15: if (iDice(1,200) < iProbability) iItemID = 335; break; // EmeraldRing           
				case 16: if (iDice(1,100) < iProbability) iItemID = 336; break; // SapphireRing          
				case 17: if (iDice(1,120) < iProbability) iItemID = 337; break; // RubyRing              
				case 18: if (iDice(1,150) < iProbability) iItemID = 290; break; // Flameberge+3(LLF)
				case 19: if (iDice(1,100) < iProbability) iItemID = 292; break; // GoldenAxe+1
				case 20: if (iDice(1,200) < iProbability) iItemID = 259; break; // MagicWand(M.Shield)
				case 21: if (iDice(1,100) < iProbability) iItemID = 300; break; // MagicNecklace(RM10)
				case 22: if (iDice(1,100) < iProbability) iItemID = 311; break; // MagicNecklace(DF+10)
				case 23: if (iDice(1,200) < iProbability) iItemID = 305; break; // MagicNecklace(DM+1)
				case 24: if (iDice(1,150) < iProbability) iItemID = 308; break; // MagicNecklace(MS10)
				case 25: if (iDice(1,80)  < iProbability) iItemID = 868; break; // AcientTablet(LU)
				case 26: if (iDice(1,80)  < iProbability) iItemID = 869; break; // AcientTablet(LD)
				case 27: if (iDice(1,80)  < iProbability) iItemID = 870; break; // AcientTablet(RU)
				case 28: if (iDice(1,80)  < iProbability) iItemID = 871; break; // AcientTablet(RD)
				case 29:
				case 30:                                  iItemID = 651; break; // GreenBall
			}
		}
		// so you have iMin + 1 drops (sure if no drop, replaced by Gold)
		// and up to iMax drops (not replaced by Gold)...		// 
		if((iItemID == 0) && (i < iMin)) iItemID = 90; // Gold

		if( iItemID != 0 )
		{	// item id
			iItemIDs[iNum] = iItemID;			
			// item position
			switch(iItemSpreadType)	{
			case DEF_ITEMSPREAD_RANDOM: //1
				BasePos[iNum].x = sBaseX + iSpreadRange - iDice(1, iSpreadRange * 2 );
				BasePos[iNum].y = sBaseY + iSpreadRange - iDice(1, iSpreadRange * 2 );
				break;
			case DEF_ITEMSPREAD_FIXED: //2
				BasePos[iNum].x = sBaseX + ITEMSPREAD_FIEXD_COORD[iNum][0];
				BasePos[iNum].y = sBaseY + ITEMSPREAD_FIEXD_COORD[iNum][1];
				break;
			}
			iNum++;
		}
	} // for
	*iNumItem = iNum;
	return TRUE;
}

// 05/21/2004 - Hypnotoad - Balances to drop status
void CGame::NpcDeadItemGenerator(int iNpcH, short sAttackerH, char cAttackerType)
{	class CItem * pItem;
	char  cColor, cItemName[21];
	BOOL  bIsGold;
	int   iGenLevel, iResult, iItemID;
	DWORD dwType, dwValue;
	double dTmp1, dTmp2, dTmp3, dTempSecondaryDropRate;
	if (m_pNpcList[iNpcH] == NULL) return;
	if ((cAttackerType != DEF_OWNERTYPE_PLAYER) || (m_pNpcList[iNpcH]->m_bIsSummoned == TRUE)) return;
	if (m_pNpcList[iNpcH]->m_bIsUnsummoned == TRUE) return;
	if( NpcDeadItemGeneratorWithItemEvent(iNpcH, sAttackerH, cAttackerType) == TRUE) return; // Special item even performed
	ZeroMemory(cItemName, sizeof(cItemName));
	bIsGold = FALSE;
	switch (m_pNpcList[iNpcH]->m_sType) {		
	case 21: // Guard  // NPC not dropping
	case 34: // Dummy
	case 64: // Crop
		return;
	}	
	// SNOOPY Reputation was used only for 2nd drop rate and very high adjustement was possible
	// up to 4 times more items drops ! (with 3000 reputation)
	// SNOOPY: Reputation is now used here for overall drop rate, but with lesser advantage
	if (cAttackerType == DEF_OWNERTYPE_PLAYER) 
	{	dTmp2 = m_pClientList[sAttackerH]->m_iClientPrimaryDropRate;
	}else 
	{	dTmp2 = m_iPrimaryDropRate; // Lower => beter drop-rate
	}
	dTempSecondaryDropRate = m_iSecondaryDropRate;
	if (m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->m_iExtraDrop > 0) 
	{	dTempSecondaryDropRate = m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->m_iExtraDrop;
	}
	if (m_pNpcList[iNpcH]->m_iNpcBossType == 1) 
	{	dTmp2 = 1;
		dTempSecondaryDropRate = 3000 - m_pNpcList[iNpcH]->m_cSpecialAbility * 250;
	}
	if (iDice(1,10000) >= dTmp2) 
	{	// 6500 default
		// 7750 or 9000 for v2.191 server (I don't know witch reason lowers drop rate)
		// 8670 for REVIVAL server (Lower because Gold proportion is reduced later)
		// 8720 for EQUILIBRIUM server (same as REVIVAL for character with 100 reputation)
		// With Reputation adjustement, will be 8220 (19% droprate) to 9220(8% droprate)		
		if (iDice(1,10000) <= m_iGoldDropRate)  // Defaut  6000
		{	// 6000 defaut, 
			// 6500 on v2.191 server
			// 3000 for EQUILIBRIUM server ( because too much Gold in HB)
			// SNOOPY: Added Gold Drop Rate on config file
			iItemID = 90;			
			pItem = new class CItem;// If a non-existing itemID is given create no item
			if (_bInitItemAttr(pItem, iItemID) == FALSE) 
			{	delete pItem;
				return;	
			}
			pItem->m_dwCount = (DWORD)(iDice(1, (m_pNpcList[iNpcH]->m_iGoldDiceMax - m_pNpcList[iNpcH]->m_iGoldDiceMin)) + m_pNpcList[iNpcH]->m_iGoldDiceMin);
			if ((cAttackerType == DEF_OWNERTYPE_PLAYER) && (m_pClientList[sAttackerH]->m_iAddGold != NULL)) 
			{	dTmp1 = (double)m_pClientList[sAttackerH]->m_iAddGold;
				dTmp2 = (double)pItem->m_dwCount;
				dTmp3 = (dTmp1/100.0f)*dTmp2;
				pItem->m_dwCount += (int)dTmp3;
				if (pItem->m_dwCount == 0)
				{	delete pItem;
					return;	
			}	}
		}else 
		{	// 9000 default (stronglly adjusted for reputation)
			// 9000 on v2.191 server
			// 7800 for Equilibrium Project (more drops)
			// SNOOPY: Removed rep modifier here. It seems too strong....
			// And can exeed 10000 the max possible value...
						/*	dTmp1 = m_pClientList[sAttackerH]->m_iRating*m_cRepDropModifier;
							if (dTmp1 > 3000) dTmp1 = 3000;
							if (dTmp1 < -3000) dTmp1 = -3000;
							dTmp2 = (m_iSecondaryDropRate - (dTmp1));
							if (iDice(1,10000) <= dTmp2) { */			
			if (iDice(1,10000) <= dTempSecondaryDropRate)  
			{	// 40% Drop 90% of that is a standard drop
				// Standard Drop Calculation: (35/100) * (40/100) * (90/100) = 12.6%
				iResult = iDice(1,10000);
				if ((iResult >= 1) && (iResult <= 2500))          dwValue = 1; // Green Potion
				else if ((iResult >= 2501) && (iResult <= 4300))  dwValue = 2; // Red Potion
				else if ((iResult >= 4301) && (iResult <= 5900))  dwValue = 3; // Blue Potion
				else if ((iResult >= 5901) && (iResult <= 6900))  dwValue = 4; // Big Green Potion
				else if ((iResult >= 6901) && (iResult <= 7900))  dwValue = 5; // Big Red Potion
				else if ((iResult >= 7901) && (iResult <= 8700))  dwValue = 6; // Big Blue Potion
				else if ((iResult >= 8701) && (iResult <= 9000))  dwValue = 7; // PG, SPG
				else if ((iResult >= 9001) && (iResult <= 9200))  dwValue = 8; // Specials
				else if ((iResult >= 9201) && (iResult <= 10000)) dwValue = 9; // Candies, Xtra
// SNOOPY81-> Modified Drops of potions to suit alchemists needs as in Revival/Equilibrium
				switch (dwValue) {	
				case 1: iItemID = 95; break; // Green Potion
				case 2: iItemID = 91; break; // Red Potion
				case 3: iItemID = 93; break; // Blue Potion
				case 4: iItemID = 96; break; // Big Green Potion
				case 5: iItemID = 92; break; // Big Red Potion
				case 6: iItemID = 94; break; // Big Blue Potion
				case 7: switch(iDice(1,4)) {
						case 1: 
						case 2: 
						case 3: iItemID = 390; break; // Power Green Potion
						case 4: iItemID = 391; break; // Super Power Green Potion
						} 
						break;// End PG SPG loop
				case 8: switch(iDice(1,20)) {
						case 1:	iItemID = 273; break; // InvisibilityPotion
						case 2:	iItemID = 285; break; // HHPotion  
						case 3: iItemID = 286; break; // CyclPotion
						case 4: iItemID = 287; break; // TrollPotion
						case 5: iItemID = 660; break; // UnfreezePotion
						case 6: iItemID = 656; break; // Xelima Stone
						case 7: iItemID = 657; break; // Merien Stone
						case 8: 
						case 9: iItemID = 651; break; // GreenBall
						case 10: 
						case 11: switch(iDice(1,10)) {
								case 1: 
								case 2: 
								case 3: iItemID = 652; break; // RedBall
								case 4: 
								case 5: iItemID = 653; break; // YellowBall
								case 6: iItemID = 654; break; // BlueBall
								case 7:
								case 8:
								case 9:
								case 10:switch(iDice(1,14)) {
										case 1: iItemID = 881; break; // ArmorDye(Indigo)
										case 2: iItemID = 882; break; // ArmorDye(Crimson-Red)
										case 3: iItemID = 883; break; // ArmorDye(Gold)
										case 4: iItemID = 884; break; // ArmorDye(Aqua)
										case 5: iItemID = 885; break; // ArmorDye(Pink)
										case 6: iItemID = 886; break; // ArmorDye(Violet)
										case 7: iItemID = 887; break; // ArmorDye(Blue)
										case 8: iItemID = 888; break; // ArmorDye(Khaki)
										case 9: iItemID = 889; break; // ArmorDye(Yellow)
										case 10: iItemID = 890; break; // ArmorDye(Red)
										default: iItemID = 655; break; // PearlBall
										}
										break;
								}
								break;
							default: iItemID = 650; break; // Zemstone of Sacrifice
								//SNOOPY: Logging special 1st drops here
								wsprintf(G_cTxt, "NPC(%s)\t1st Drop\t%s(rare item)\t%s(%d %d)"
									, m_pNpcList[iNpcH]->m_cNpcName
									, m_pItemConfigList[iItemID]->m_cName
									, m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->m_cName
									, m_pNpcList[iNpcH]->m_sX
									, m_pNpcList[iNpcH]->m_sY);
								// SNOOPY: Added special Item events Logging
								PutItemLogFileList(G_cTxt);	
						}
						break; // end Specials loop
				case 9: 
					// SNOOPY81-> Removed Candie only december		
					/*	SYSTEMTIME SysTime;
						GetLocalTime(&SysTime);
						if (((short)SysTime.wMonth == 12) && (m_pNpcList[iNpcH]->m_sType == 61 || 55)) {
						*/ 
						switch(iDice(1,6)) {
						case 1: 
						case 2: 
						case 3: iItemID = 780; break; // Red Candy
						case 4: 
						case 5: iItemID = 782; break; // Green Candy
						case 6: switch(iDice(1,30)) {
								case 1: iItemID = 783; break; // XRedPotion 
								case 2: iItemID = 784; break; // XBluePotion 
								case 3: iItemID = 785; break; // XGreenPotion  
								default:iItemID = 781; break; // Blue Candy	
								}					
						}
						break;// end Canies Extra loop
				} // end of potions loop
				// If a non-existing item is created then delete the item
				pItem = new class CItem;
				if (_bInitItemAttr(pItem, iItemID) == FALSE) 
				{	delete pItem;
					return;	
				}
			}else // Item drop here
			{	// Valuable Drop Calculation: (35/100) * (40/100) * (10/100) = 1.4%
				// Define iGenLevel using Npc.cfg#
				iGenLevel = 0;
				//switch (m_pNpcList[iNpcH]->m_sType) {
				switch (m_pNpcList[iNpcH]->m_sOriginalType) {
				case 10: // Slime
				case 16: // Giant-Ant
				case 22: // Amphis
				case 55: // Rabbit
				case 56: //	Cat
					iGenLevel = 1;
					break;
				case 11: // Skeleton
				case 14: // Orc, Orc-Mage
				case 17: // Scorpion
				case 18: // Zombie
					iGenLevel = 2;
					break;
				case 12: // Stone-Golem
				case 23: // Clay-Golem
				case 65: // Ice-Golem
					iGenLevel = 3;
					break;
				case 27: // Hellbound
				case 57: // Frog
				case 61: // Rudolph
				case 76: // Giant-Tree	
				case 60: // Plant
				case 62: // DireBoar					
					iGenLevel = 4;
					break; 
				case 13: // Cyclops
				case 28: // Troll					
					iGenLevel = 5;
					break;
				case 29: // Ogre
				case 33: // WereWolf
				case 48: // Stalker
					iGenLevel = 6;
					break;
				case 53: // Beholder
				case 58: // MountainGiant
				case 72: // Claw-Turtle
				case 74: // Giant-Crayfish
					iGenLevel = 7;
					break;
				case 54: // Dark-Elf
				case 63: // Frost
					iGenLevel = 8;
					break;
				case 59: // Ettin
		 	    case 70: // Dragon
			    case 79: // Nizie
			    case 77: // MasterMage-Orc
					iGenLevel = 9;
					break;
				case 30: // Liche
				case 31: // Demon
				case 32: // Unicorn
				case 52: // Gagoyle
				case 71: // Centaurus
				case 75: // Giant-Lizard
			    case 78: // Minotaurus
				case 95: // Willowisp
				case 96: // Air Elemental
				case 97: // Fire Elemental
				case 98: // Earth Elemental
				case 99: // Ice Elemental
					iGenLevel = 10;
					break; 
				case 49: // Hellclaw
				case 50: // Tigerworm
				case 66: // Wyvern
				case 73: // Fire-Wyvern
				case 81: // Abaddon
					iGenLevel = 11;
					break; 
				case 80: // Tentocle
					iGenLevel = 12;
					break; 
				}
				if (iGenLevel == 0) return;
				if (iGenLevel == 12) // Small drops for Tentacle...
				{ 	switch (iDice(1,87)) { 
					case 1:  iItemID = 92;  break; // 92  BigHealthPotion
					case 2:  iItemID = 94;  break; // 94  BigManaPotion
					case 3:  iItemID = 96;	break; // 96  BigRevitPotion
					case 4:  iItemID = 97;  break; // 97  DilutionPotion
					case 5:  iItemID = 98;  break; // 98  Baguette
					case 6:  iItemID = 99;	break; // 99  Meat
					case 7:  iItemID = 100; break; // 100 Fish
					case 8:  iItemID = 101; break; // 101 RedFish
					case 9:  iItemID = 103; break; // 102 GreenFish
					case 10: iItemID = 103; break; // 103 YellowFish
					case 11: iItemID = 104; break; // 104 Map
					case 12: iItemID = 106; break; // 106 PretendCorpseManual
					case 13: iItemID = 107; break; // 107 ArrowAttackManual
					case 14: iItemID = 108; break; // 108 ShieldManual
					case 15: iItemID = 109; break; // 109 LongSwordManual
					case 16: iItemID = 110; break; // 110 FencingManual
					case 17: iItemID = 111; break; // 111 FishingManual
					case 18: iItemID = 112; break; // 112 AxeManual
					case 19: iItemID = 113; break; // 113 MagicResistManual
					case 20: iItemID = 114; break; // 114 RecallScroll
					case 21: iItemID = 115; break; // 115 InvisibilityScroll
					case 22: iItemID = 116; break; // 116 DetectInviScroll
					case 23: iItemID = 117; break; // 117 BleedingIsleTicket
					case 24: iItemID = 196; break; // 196 CyclopsHeart
					case 25: iItemID = 194; break; // 194 CyclopsEye
					case 26: iItemID = 199; break; // 199 HelhoundHeart
					case 27: iItemID = 210; break; // 210 OgreHeart
					case 28: iItemID = 222; break; // 222 TrollHeart
					case 29: iItemID = 226; break; // 226 AlchemyManual
					case 30: iItemID = 230; break; // 230 MiningManual
					case 31: iItemID = 235; break; // 235 ManuManual
					case 32: iItemID = 237; break; // 237 HammerAttackManual
					case 33: iItemID = 250; break; // 250 StaffAttackManual
					case 34: iItemID = 280; break; // 280 SummonPotion
					case 35: iItemID = 281; break; // 281 OrcPotion
					case 36: iItemID = 283; break; // 283 WWPotion
					case 37: iItemID = 281; break; // 281 OrcPotion
					case 38: iItemID = 284; break; // 284 GolemPotion
					case 39: iItemID = 285; break; // 285 HHPotion
					case 40: iItemID = 286; break; // 286 CyclPotion
					case 41: iItemID = 287; break; // 287 TrollPotion
					case 42: iItemID = 315; break; // 315 GoldNecklace
					case 43: iItemID = 316; break; // 316 SilverNecklace
					case 44: iItemID = 331; break; // 331 GoldRing
					case 45: iItemID = 332; break; // 332 SilverRing
					case 46: iItemID = 333; break; // 333 PlatinumRing
					case 47: iItemID = 334; break; // 334 LuckyGoldRing
					case 48: iItemID = 336; break; // 336 SapphireRing
					case 49: iItemID = 350; break; // 350 Diamond
					case 50: iItemID = 351; break; // 351 Ruby
					case 51: iItemID = 352; break; // 352 Sapphire
					case 52: iItemID = 353; break; // 353 Emerald
					case 53: iItemID = 355; break; // 355 Coal
					case 54: iItemID = 354; break; // 354 GoldNugget
					case 55: iItemID = 356; break; // 356 SilverNugget
					case 56: iItemID = 357; break; // 357 IronOre
					case 57: iItemID = 358; break; // 358 Crystal
					case 58: iItemID = 385; break; // 385 HandAttackManual
					case 59: iItemID = 386; break; // 386 ShortSwordManual
					case 60: iItemID = 391; break; // 390 PowerGreenPotion
					case 61: iItemID = 391; break; // 391 SuperPowerGreen
					case 62: iItemID = 507; break; // 507 BlondeStone
					case 63: iItemID = 508; break; // 508 Mithral
					case 64: iItemID = 520; break; // 520 Bouquette
					case 65: iItemID = 521; break; // 521 FlowerBasket
					case 66: iItemID = 522; break; // 522 FlowerPot
					case 67: iItemID = 548; break; // 548 WerewolfHeart
					case 68: iItemID = 576; break; // 576 RedSeaBream
					case 69: iItemID = 577; break; // 577 GrayMullet
					case 70: iItemID = 575; break; // 575 Salmon
					case 71: iItemID = 574; break; // 574 BlueSeaBream
					case 72: iItemID = 573; break; // 573 CrucianCarp
					case 73: iItemID = 572; break; // 572 GoldCarp
					case 74: iItemID = 571; break; // 571 GreenCarp
					case 75: iItemID = 570; break; // 570 RedCarp
					case 76: iItemID = 782; break; // 782 GreenCandy
					case 77: iItemID = 781; break; // 781 BlueCandy
					case 78: iItemID = 780; break; // 780 RedCandy
					case 79: iItemID = 973; break; // 973 Kro
					case 80: iItemID = 976; break; // 976 Loto
					case 81: 
					case 82:
					case 83:
					case 84:
					case 85://Rare items
						switch (iDice(1,30)) { 
						case 1:  iItemID = 270; break; // 270 HairColorPotion
						case 2:  iItemID = 271; break; // 271 HairStylePotion
						case 3:  iItemID = 272; break; // 272 SkinColorPotion
						case 4:  iItemID = 275; break; // 275 OgrePotion
						case 5:  iItemID = 276; break; // 276 UnderwearPotion
						case 6: 
						case 7:  iItemID = 651; break; // 651 GreenBall
						case 8:  iItemID = 652; break; // 652 RedBall
						case 9: 
						case 10: 
						case 11:
						case 12: iItemID = 650; break; // 650 Zem
						case 13: iItemID = 540; break; // 540 DemonEye 
						case 14: iItemID = 541; break; // 541 DemonHeart
						case 15: iItemID = 785; break; // 785 XGreenPotion
						case 16: iItemID = 784; break; // 784 XBluePotion
						case 17: iItemID = 783; break; // 783 XRedPotion
						case 18: iItemID = 963; break; // 963 EagleElixir
						case 19: iItemID = 964; break; // 964 TatooElixir
						case 20: iItemID = 965; break; // 965 BufaloElixir
						case 21: iItemID = 966; break; // 966 SnakeElixir
						case 22: iItemID = 967; break; // 967 MagicElixir
						case 23: iItemID = 968; break; // 968 SharpnessOil
						case 24: iItemID = 969; break; // 989 AgilityOil
						case 25: iItemID = 970; break; // 970 PoisonOil
						case 26: iItemID = 971; break; // 971 BerzerkOil
						case 27: iItemID = 972; break; // 972 TruthOil
						case 28: iItemID = 656; break; // 656 XelimaStone
						case 29: iItemID = 657; break; // 657 MerienStone 
						case 30:	
						case 31:// Very Rare items							
							switch (iDice(1,35)) { 
							case 1: iItemID = 274; break; // 274 SexChangePotion
							case 2: iItemID = 852; break; // 852 CancelManual
							case 3: iItemID = 853; break; // 853 E.S.W.Manual
							case 4: iItemID = 857; break; // 857 I.M.CManual
							case 5: iItemID = 380; break; // 380 IceStormManual
							case 6: iItemID = 381; break; // 381 MassFireStrikeManual
							case 7: iItemID = 382; break; // 382 BloodyShockWaveM
							case 8: iItemID = 653; break; // 653 YellowBall
							case 9: iItemID = 654; break; // 654 BlueBall
							case 10: iItemID = 655; break; // 655 PearlBall
							case 11: iItemID = 337; break; // 337 RubyRing
							case 12: 
							case 13: iItemID = 328; break; // 328 StrangeRing1
							case 14: 
							case 15: iItemID = 329; break; // 329 StrangeRing2
							case 16: 
							case 17: iItemID = 330; break; // 330 StrangeRing3
							case 18: iItemID = 544; break; // 544 UnicornHeart
							case 19: iItemID = 545; break; // 545 UnicornHorn
							case 20: iItemID = 950; break; // 950 Egg950
							case 21: iItemID = 951; break; // 951 Egg951
							case 22: iItemID = 952; break; // 952 Egg952
							case 23: iItemID = 953; break; // 953 Egg953
							case 24: iItemID = 954; break; // 954 Egg954
							case 25: iItemID = 955; break; // 955 Egg955
							case 26: iItemID = 956; break; // 956 Egg956
							case 27: iItemID = 957; break; // 957 Egg957
							case 28: iItemID = 958; break; // 958 Egg958
							case 29: iItemID = 959; break; // 959 Egg959
							case 30: iItemID = 961; break; // 961 Egg961
							case 31: iItemID = 978; break; // 978 Stone1
							case 32: iItemID = 979; break; // 979 Stone2
							case 33: iItemID = 980; break; // 980 Stone3
							case 34: iItemID = 981; break; // 981 Stone4
							case 35: iItemID = 282; break; // 282 DemonPotion
							}
							break;
						case 32: iItemID = 883; break; // 883 ArmorDye(Gold)
						case 33: iItemID = 884; break; // 884 ArmorDye(Aqua)
						case 34: iItemID = 885; break; // 885 ArmorDye(Pink)
						case 35: iItemID = 886; break; // 886 ArmorDye(Violet)
						case 36: iItemID = 887; break; // 887 ArmorDye(Blue)
						case 37: iItemID = 888; break; // 888 ArmorDye(Khaki)
						case 38: iItemID = 889; break; // 889 ArmorDye(Yellow)
						case 39: iItemID = 890; break; // 890 ArmorDye(Red)
						case 40: iItemID = 881; break; // 881 ArmorDye(Indigo)
						case 41: iItemID = 882; break; // 882 ArmorDye(CrimsonRed)
						}
						//SNOOPY: Logging rare & very rare 1st drops here
						wsprintf(G_cTxt, "NPC(%s)\t1st Drop\t%s(rare item)\t%s(%d %d)"
							, m_pNpcList[iNpcH]->m_cNpcName
							, m_pItemConfigList[iItemID]->m_cName
							, m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->m_cName
							, m_pNpcList[iNpcH]->m_sX
							, m_pNpcList[iNpcH]->m_sY);
						// SNOOPY: Added special Item events Logging
						PutItemLogFileList(G_cTxt);	
						break;
					case 86: iItemID = 273; break; // 273 InvisibilityPotion
					case 87: iItemID = 660; break; // 660 UnfreezePotion
					}
				}else // iGenLevel != 12
				{	// Weapon or armor Drop: 					
					if (iDice(1,10000) <= 6000) // 1.4% chance Valuable Drop 60% that it is a Weapon
					{	if (iDice(1,10000) <= 8000) 						
						{	switch (iGenLevel) { // 80% the Weapon is Melee
							case 1: // Slime, Giant-Ant, Amphis, Rabbit, Cat
								switch (iDice(1,3)) { 
								case 1: iItemID = 1;  break; // Dagger
								case 2: iItemID = 8;  break; // ShortSword
								case 3: iItemID = 59; break; // LightAxe
								}
								break; 
							case 2: // Skeleton, Orc, Orc-Mage, Scorpion, Zombie
								switch (iDice(1,6)) {
								case 1: iItemID = 15;  break; // Gradius
								case 2: iItemID = 34;  break; // Rapier
								case 3: iItemID = 31;  break; // Esterk
								case 4: iItemID = 68;  break; // DAxe
								case 5: iItemID = 23;  break; // Sabre
								case 6: iItemID = 28;  break; // Falchion
								}
								break;
							case 3: // Stone-Golem, Clay-Golem
								switch (iDice(1,4)) {
								case 1: iItemID = 16;  break; // Gradius+1
								case 2: iItemID = 37;  break; // Templar
								case 3: iItemID = 46;  break; // Claymore
								case 4: iItemID = 50;  break; // GS
								}
								break;
							case 4: // Hellbound, Rudolph
								switch (iDice(1,7)) {
								case 1: 
								case 2: iItemID = 35;  break; // Rapier+1
								case 3: iItemID = 36;  break; // Rapier+2
								case 4: iItemID = 32;  break; // Esterk+1
								case 5: 
								case 6: iItemID = 37;  break; // Templar
								case 7: iItemID = 38;  break; // Templar+1
								}
								break;
							case 5: // Cyclops, Troll, Beholder, Plant, DireBoar
								switch (iDice(1,8)) {
								case 1:
								case 2: iItemID = 68;  break; // Daxe
								case 3:
								case 4: iItemID = 69;  break; // DAxe+1
								case 5:
								case 6: iItemID = 71;  break; // WarAxe
								case 7: iItemID = 72;  break; // WarAxe+1
								case 8: iItemID = 560; break; // BatleAxe
								}
								break;
							case 6: // Ogre, WereWolf, Stalker, Dark-Elf, Ice-Golem
								switch (iDice(1,8)) {
								case 1: iItemID = 17;  break; // Gradius+2
								case 2: iItemID = 33;  break; // Esterk+2
								case 3: iItemID = 38;  break; // Templar+1
								case 4: iItemID = 39;  break; // Templar+2
								case 5: iItemID = 29;  break; // Falchion+1
								case 6: iItemID = 51;  break; // GS+1
								case 7: 
								case 8: iItemID = 54;  break; // Flam
								}
								break;
							case 7: // MountainGiant
								switch (iDice(1,11)) {
								case 1: 
								case 2: iItemID = 70;  break; // DAxe+2
								case 3: 
								case 4: 
								case 5: iItemID = 72;  break; // WarAxe+1
								case 6: 
								case 7: iItemID = 30;  break; // Falchion+2
								case 8: 
								case 9: iItemID = 760; break; // Hammer
								case 10: 
								case 11: iItemID = 560; break; // BAxe
								}
								break;
							case 8: // DarkElf
								switch (iDice(1,4)) {
								case 1: iItemID = 36;  break; // Rapier+2
								case 2: iItemID = 39;  break; // Templar+2
								case 3: iItemID = 52;  break; // GS+2
								case 4: iItemID = 55;  break; // Flam+1
								}
								break;
							case 9: // Ettin
								switch (iDice(1,5)) {
								case 1: iItemID = 615;  break; // GiS
								case 2: iItemID = 760;  break; // Hammer
								case 3: iItemID = 560;  break; // BAxe
								case 4: iItemID = 580;  break; // BAxe+1
								case 5: iItemID = 761;  break; // BHammer
								}
								break;
							case 10: // Demon, Unicorn, Hellclaw, Tigerworm, Gagoyle
								switch (iDice(1,7)) {
								case 1: iItemID = 615;  break; // GiS
								case 2: iItemID = 909;  break; // Hammer+1
								case 3: iItemID = 580;  break; // BattleAxe+1
								case 4: iItemID = 761;  break; // BHammer
								case 5: iItemID = 911;  break; // GiAxe
								case 6: iItemID = 910;  break; // Vampire
								case 7: iItemID = 762;  break; // GBHammer
								}
								break;
							case 11: // Wyverns, Abaddon, Hellclaw, Tigerworm,
								switch (iDice(1,3)) {
								case 1: iItemID = 911;  break; // GiAxe
								case 2: iItemID = 910;  break; // Vampire
								case 3: iItemID = 762;  break; // GBHammer
								}
								break;
							}
						}else 	// 20% the weapon is a Wand
						{	switch (iGenLevel) {
							case 2: 
							case 3:
								iItemID = 258; break; // MagicWand(MS0)
							case 4: 
							case 5: 
								iItemID = 257; break; // MagicWand(MS10)
							case 6:  // Ogre, WereWolf, Stalker, Dark-Elf, Ice-Golem
							case 8:  // DE
							case 10: // DD Lich...
								iItemID = 256; break; // MagicWand(MS20)
							case 11: // HC, Wyv Abaddon
								iItemID = 256; break; // WizzardMS20
							}	
						}// End of weapons case	
					}else // 1.4% chance Valuable Drop 40% that drop is an Armor/Shield
					{	switch (iDice(1, iGenLevel)) {				
						case 1: // Slime, Giant-Ant, Amphis, Rabbit, Cat
						case 2: // Skeleton, Orc, Orc-Mage, Scorpion, Zombie
							switch (iDice(1,2)) { 
							case 1: iItemID = 79;  break; // WoodShield
							case 2: iItemID = 81;  break; // TargeShield
							}
							break; 
						case 3: // Stone-Golem, Clay-Golem
							switch (iDice(1,12)) { 
							case 1: iItemID = 453; break; // ShirtM
							case 2: iItemID = 471; break; // ShirtW
							case 3: iItemID = 460; break; // KneeTrousersM
							case 4: iItemID = 481; break; // KneeTrousersW
							case 5: 
							case 6: 
							case 7: 
							case 8: 
							case 9: 
							case 10: 
							case 11:
							case 12: iItemID = 83;  break; // BlondeShield 
							}							
							break;
						case 4: // Hellbound, Rudolph
							switch (iDice(1,6)) {
							case 1: iItemID = 454; break; // Hauberk(M)
							case 2: iItemID = 472; break; // Hauberk(W)
							case 3: iItemID = 461; break; // ChainHose(M)
							case 4: iItemID = 482; break; // ChainHose(W)
							case 5: iItemID = 85;  break; // LagiShield
							case 6:
								switch (iDice(1,4)) {							
								case 1: iItemID = 453; break; // ShirtM
								case 2: iItemID = 471; break; // ShirtW
								case 3: iItemID = 460; break; // KneeTrousersM
								case 4: iItemID = 481; break; // KneeTrousersW
								}							
								break;
							}
							break;
						case 5: // Cyclops, Troll, Beholder, Plant, DireBoar
							switch (iDice(1,4)) {
							case 1: iItemID = 455; break; // LeatherArmor(M)
							case 2: iItemID = 475; break; // LeatherArmor(W)
							case 3: iItemID = 87;  break; // TowerShield	
							case 4:								
								switch (iDice(1,10)) {
								case 1: iItemID = 480; break; // TrousersW
								case 2: iItemID = 471; break; // SkirtW	
								case 3: iItemID = 460; break; // KneeTrousersM
								case 4: iItemID = 459; break; // TrousersM
								case 5: 
								case 6: iItemID = 484; break; // TunicM
								case 7: iItemID = 474; break; // LongBodiceW
								case 8: iItemID = 473; break; // BodiceW
								case 9: iItemID = 453; break; // ShirtM
								case 10: iItemID = 470; break; // ChemiseW
								}
							}
							break;
						case 6: // Ogre, WereWolf, Stalker, Dark-Elf, Ice-Golem
							switch (iDice(1,11)) {
							case 1: iItemID = 456; break; // ChainMail(M)
							case 2: iItemID = 476; break; // ChainMail(W)
							case 3: iItemID = 458; break; // PlateMail(M)
							case 4: iItemID = 478; break; // PlateMail(W)
							case 5: iItemID = 600; break; // Helm
							case 6: iItemID = 601; break; // FullHelm
							case 7: iItemID = 454; break; // Hauberk(M)
							case 8: iItemID = 472; break; // Hauberk(W)
							case 9: iItemID = 461; break; // ChainHose(M)
							case 10:iItemID = 482; break; // ChainHose(W)
							case 11:iItemID = 402; break; // Cape
							}
							break;
						case 7:// MG
							switch (iDice(1,5)) {
							case 1: iItemID = 462; break; // PlateLeggingsM 
							case 2: iItemID = 483; break; // PlateLeggingsW 
							case 3: iItemID = 457; break; // ScaleMail(M)
							case 4: iItemID = 477; break; // ScaleMail(W)
							case 5: iItemID = 679; break; // KnightFullHelm
							}
							break;
						case 8: // DarkElf, Frost
							switch (iDice(1,8)) {
							case 1: iItemID = 687; break; // KnightHauberkM
							case 2: iItemID = 688; break; // KnightHauberkW
							case 3: iItemID = 681; break; // WizardHauberkM
							case 4: iItemID = 682; break; // WizardHauberkW
							case 5: iItemID = 750; break; // HornedHelm
							case 6: iItemID = 751; break; // WingedHelm
							case 7: iItemID = 752; break; // WizardCap
							case 8: iItemID = 753; break; // WizardHat
							}
							break;
						case 9: // Ettins
							switch (iDice(1,5)) {
							case 1: iItemID = 675; break; // KnightPlateMailM 
							case 2: iItemID = 676; break; // KnightPlateMailW 
							case 3: iItemID = 86;  break; // KnightShield
							case 4: iItemID = 677; break; // KnightLeggingsM
							case 5: iItemID = 678; break; // KnightLeggingsW
							}
							break;
						case 10: // Liche, Demon, Unicorn, Hellclaw, Tigerworm, Gagoyle
							switch (iDice(1,6)) {
							case 1: iItemID = 675; break; // KnightPlateMailM 
							case 2: iItemID = 676; break; // KnightPlateMailW 
							case 3: iItemID = 451; break; // LongBoots
							case 4: iItemID = 590; break; // RobeM
							case 5: iItemID = 591; break; // RobeW
							case 6: iItemID = 402; break; // Cape
							}
							break;
						case 11: // HC, Wyvern, Abaddon
							iItemID = 451; // LongBoots again
							break;
				}	}	}
				pItem = new class CItem;
				if (_bInitItemAttr(pItem, iItemID) == FALSE) 
				{	delete pItem; return;	
				}
// SNOOPY81: Works for Weapons, PAweapons, and BloodWeapons
				if ((pItem->m_sItemEffectType == DEF_ITEMEFFECTTYPE_ATTACK)||(pItem->m_sItemEffectType == DEF_ITEMEFFECTTYPE_ATTACK_DEFENSE)||(pItem->m_sItemEffectType == DEF_ITEMEFFECTTYPE_ATTACK_MAXHPDOWN)) 
				{	iResult = iDice(1,10000);
					if ((iResult >= 1) && (iResult <= 299)) 
					{	dwType = 6; // Light
						cColor = 2; // gris
					}else if ((iResult >= 300) && (iResult <= 999)) 
					{	dwType = 8; // Strong
						cColor = 3; // gris
					}else if ((iResult >= 1000) && (iResult <= 2499)) 
					{	dwType = 1; // Critical
						cColor = 5; // Orange...
					}else if ((iResult >= 2500) && (iResult <= 3499)) 
					{	dwType = 4; // Wizard's
						cColor = 14; // rouge<-> bleu...
					}else if ((iResult >= 3500) && (iResult <= 4999)) 
					{	dwType = 5; // Agile
						cColor = 1; // gris clair
					}else if ((iResult >= 5000) && (iResult <= 5999)) 
					{	dwType = 3; // Rite 20%->15%
						cColor = 7; // White
					}else if ((iResult >= 6000) && (iResult <= 7699)) 
					{	dwType = 2; // Poison 16%->17%
						cColor = 4; // Vert
					}else if ((iResult >= 7700) && (iResult <= 9499)) 
					{	dwType = 7;  // Sharp 16%->18%
						cColor = 6; // blue
					}else if ((iResult >= 9500) && (iResult <= 10000)) 
					{	dwType = 9; // Ancient 3% -> 5%
						cColor = 8; // mauve
					}
					pItem->m_cItemColor = cColor;
					iResult = iDice(1, 32500);
					if ((iResult >= 1) && (iResult < 10000))           dwValue = 2;  // 10000/29348 = 34%
					else if ((iResult >= 10000) && (iResult < 17400))  dwValue = 3;  // 6600/29348 = 22.4%
					else if ((iResult >= 17400) && (iResult < 22400))  dwValue = 4;  // 4356/29348 = 14.8%
					else if ((iResult >= 22400) && (iResult < 25400))  dwValue = 5;  // 2874/29348 = 9.7%
					else if ((iResult >= 25400) && (iResult < 27400))  dwValue = 6;  // 1897/29348 = 6.4%
					else if ((iResult >= 27400) && (iResult < 28400))  dwValue = 7;  // 1252/29348 = 4.2%
					else if ((iResult >= 28400) && (iResult < 28900))  dwValue = 8;  // 826/29348 = 2.8%
					else if ((iResult >= 28900) && (iResult < 29300))  dwValue = 9;  // 545/29348 = 1.85%
					else if ((iResult >= 29300) && (iResult < 29600))  dwValue = 10; // 360/29348 = 1.2%
					else if ((iResult >= 29600) && (iResult < 29800))  dwValue = 11; // 237/29348 = 0.8%
					else if ((iResult >= 29800) && (iResult < 29900))  dwValue = 12; // 156/29348 = 0.5%
					else if ((iResult >= 29900) && (iResult < 29970))  dwValue = 13; // 103/29348 = 0.3%
					else if ((iResult >= 29970) && (iResult <= 32500))  dwValue = 1; // 68/29348 = 0.1%
					else dwValue = 1; 
					switch (dwType) {
					case 1: // Crit
						dwValue += 3; // augmenté probas ici 
						if (dwValue <= 5) dwValue = 5;
						break; 
					case 2: // Poison   augmenté probas ici 
						dwValue += 3;
						break; 
					case 6: // Light +16%  augmenté probas ici 
						dwValue += 3;
						break; 
					case 8: // Strong +14% augmenté probas ici 				
						dwValue += 3;
						break; 
					}
					// Object value cap for smallest mobs
					if ((iGenLevel <= 2) && (dwValue > 7)) dwValue = 7;
					pItem->m_dwAttribute = NULL;
					dwType  = dwType << 20;
					dwValue = dwValue << 16;
					pItem->m_dwAttribute = pItem->m_dwAttribute | dwType | dwValue;
					if (iDice(1,10000) >= (6000-(iGenLevel*300)))  // 40% of stated items more for higher GenLevels
					{	iResult = iDice(1,10000);
						if ((iResult >= 1) && (iResult <= 4999))          dwType = 2;  // Min HP +21%
						else if ((iResult >= 5000) && (iResult <= 8499))  dwType = 10; // rep max 7
						else if ((iResult >= 8500) && (iResult <= 9499))  dwType = 12; // Gold +50%
						else if ((iResult >= 9500) && (iResult <= 10000)) dwType = 11; // Exp +20%
						iResult = iDice(1, 32500);
						if ((iResult >= 1) && (iResult < 10000))           dwValue = 2;  // 10000/29348 = 34%
						else if ((iResult >= 10000) && (iResult < 17400))  dwValue = 3;  // 6600/29348 = 22.4%
						else if ((iResult >= 17400) && (iResult < 22400))  dwValue = 4;  // 4356/29348 = 14.8%
						else if ((iResult >= 22400) && (iResult < 25400))  dwValue = 5;  // 2874/29348 = 9.7%
						else if ((iResult >= 25400) && (iResult < 27400))  dwValue = 6;  // 1897/29348 = 6.4%
						else if ((iResult >= 27400) && (iResult < 28400))  dwValue = 7;  // 1252/29348 = 4.2%
						else if ((iResult >= 28400) && (iResult < 28900))  dwValue = 8;  // 826/29348 = 2.8%
						else if ((iResult >= 28900) && (iResult < 29300))  dwValue = 9;  // 545/29348 = 1.85%
						else if ((iResult >= 29300) && (iResult < 29600))  dwValue = 10; // 360/29348 = 1.2%
						else if ((iResult >= 29600) && (iResult < 29800))  dwValue = 11; // 237/29348 = 0.8%
						else if ((iResult >= 29800) && (iResult < 29900))  dwValue = 12; // 156/29348 = 0.5%
						else if ((iResult >= 29900) && (iResult < 29970))  dwValue = 13; // 103/29348 = 0.3%
						else if ((iResult >= 29970) && (iResult <= 32500))  dwValue = 1; // 68/29348 = 0.1%
						else dwValue = 1; 
						switch (dwType) {
						case 2: // Min HP +21%
							if (dwValue <= 3) dwValue = 3;
							break; 
						case 10: // rep max 7
							if (dwValue > 7) dwValue = 7; 
							break; 
						case 11: // Exp +20%
							dwValue = 2;
							break; 
						case 12: // Gold +50%
							dwValue = 5;
							break; 
						}
						// Object value cap for smallest mobs
						if ((iGenLevel <= 2) && (dwValue > 7)) dwValue = 7;
						dwType  = dwType << 12;
						dwValue = dwValue << 8;
						pItem->m_dwAttribute = pItem->m_dwAttribute | dwType | dwValue;
					}
				}else if (pItem->m_sItemEffectType == DEF_ITEMEFFECTTYPE_ATTACK_MANASAVE) 
				{	dwType = 10;
					cColor = 0;
					if (iDice(1, 6) == 2) 
					{	dwType = 4; // Wizard's staffes.
						cColor = 14; // Bleu<->rouge
					}
					pItem->m_cItemColor = cColor;
					iResult = iDice(1, 32700);
					if ((iResult >= 1) && (iResult < 10000))           dwValue = 3;  // 10000/29348 = 34%
					else if ((iResult >= 10000) && (iResult < 17400))  dwValue = 4;  // 6600/29348 = 22.4%
					else if ((iResult >= 17400) && (iResult < 22400))  dwValue = 5;  // 4356/29348 = 14.8%
					else if ((iResult >= 22400) && (iResult < 25400))  dwValue = 6;  // 2874/29348 = 9.7%
					else if ((iResult >= 25400) && (iResult < 27400))  dwValue = 7;  // 1897/29348 = 6.4%
					else if ((iResult >= 27400) && (iResult < 28400))  dwValue = 8;  // 1252/29348 = 4.2%
					else if ((iResult >= 28400) && (iResult < 28900))  dwValue = 9;  // 826/29348 = 2.8%
					else if ((iResult >= 28900) && (iResult < 29300))  dwValue = 10; // 545/29348 = 1.85%
					else if ((iResult >= 29300) && (iResult < 29600))  dwValue = 11; // 360/29348 = 1.2%
					else if ((iResult >= 29600) && (iResult < 29800))  dwValue = 12; // 237/29348 = 0.8%
					else if ((iResult >= 29800) && (iResult < 29900))  dwValue = 13; // 156/29348 = 0.5%
					else if ((iResult >= 29900) && (iResult < 29970))  dwValue = 14; // 103/29348 = 0.3%
					else if ((iResult >= 29970) && (iResult <= 32500)) dwValue = 2; // 68/29348 = 0.1%
					else dwValue = 1;
					// Object value cap for smallest mobs
					if ((iGenLevel <= 2) && (dwValue > 7)) dwValue = 7;
					pItem->m_dwAttribute = NULL;
					dwType  = dwType << 20;
					dwValue = dwValue << 16;
					pItem->m_dwAttribute = pItem->m_dwAttribute | dwType | dwValue;
					if (iDice(1,10000) >= (6000-(iGenLevel*300)))  // 40% of stated items more for higher GenLevels
					{	iResult = iDice(1,10000);
						if ((iResult >= 1) && (iResult <= 4999))          dwType = 2;  // Min HP +21%
						else if ((iResult >= 5000) && (iResult <= 8499))  dwType = 10; // rep
						else if ((iResult >= 8500) && (iResult <= 9499))  dwType = 12; // gold50
						else if ((iResult >= 9500) && (iResult <= 10000)) dwType = 11; // XP20
						iResult = iDice(1, 32500);
						if ((iResult >= 1) && (iResult < 10000))           dwValue = 2;  // 10000/29348 = 34%
						else if ((iResult >= 10000) && (iResult < 17400))  dwValue = 3;  // 6600/29348 = 22.4%
						else if ((iResult >= 17400) && (iResult < 22400))  dwValue = 4;  // 4356/29348 = 14.8%
						else if ((iResult >= 22400) && (iResult < 25400))  dwValue = 5;  // 2874/29348 = 9.7%
						else if ((iResult >= 25400) && (iResult < 27400))  dwValue = 6;  // 1897/29348 = 6.4%
						else if ((iResult >= 27400) && (iResult < 28400))  dwValue = 7;  // 1252/29348 = 4.2%
						else if ((iResult >= 28400) && (iResult < 28900))  dwValue = 8;  // 826/29348 = 2.8%
						else if ((iResult >= 28900) && (iResult < 29300))  dwValue = 9;  // 545/29348 = 1.85%
						else if ((iResult >= 29300) && (iResult < 29600))  dwValue = 10;  // 360/29348 = 1.2%
						else if ((iResult >= 29600) && (iResult < 29800))  dwValue = 11; // 237/29348 = 0.8%
						else if ((iResult >= 29800) && (iResult < 29900))  dwValue = 12; // 156/29348 = 0.5%
						else if ((iResult >= 29900) && (iResult < 29970))  dwValue = 13; // 103/29348 = 0.3%
						else if ((iResult >= 29970) && (iResult <= 32500))  dwValue = 1; // 68/29348 = 0.1%
						else dwValue = 1; 
						if ((iGenLevel <= 2) && (dwValue > 7)) dwValue = 7;
						switch (dwType) {
						case 2: // HP +21%
							if (dwValue <= 3) dwValue = 3;
							break; 
						case 10: // rep 7
							if (dwValue > 7) dwValue = 7; 
							break; 
						case 11: // Exp +20%
							dwValue = 2;
							break; 
						case 12: // Gold +50%
							dwValue = 5;
							break; 
						}
						dwType  = dwType << 12;
						dwValue = dwValue << 8;
						pItem->m_dwAttribute = pItem->m_dwAttribute | dwType | dwValue;
					}
				}
				else if (pItem->m_sItemEffectType == DEF_ITEMEFFECTTYPE_DEFENSE) 
				{	iResult = iDice(1,10000);
					if ((iResult >= 1) && (iResult <= 5999))          dwType = 8;
					else if ((iResult >= 6000) && (iResult <= 8999))  dwType = 6;
					else if ((iResult >= 9000) && (iResult <= 9554))  dwType = 11; //dwType = 11;
					else if ((iResult >= 9555) && (iResult <= 10000)) dwType = 12; //dwType = 12;
					iResult = iDice(1, 32500);
					if ((iResult >= 1) && (iResult < 10000))           dwValue = 2;  // 10000/29348 = 34%
					else if ((iResult >= 10000) && (iResult < 17400))  dwValue = 3;  // 6600/29348 = 22.4%
					else if ((iResult >= 17400) && (iResult < 22400))  dwValue = 4;  // 4356/29348 = 14.8%
					else if ((iResult >= 22400) && (iResult < 25400))  dwValue = 5;  // 2874/29348 = 9.7%
					else if ((iResult >= 25400) && (iResult < 27400))  dwValue = 6;  // 1897/29348 = 6.4%
					else if ((iResult >= 27400) && (iResult < 28400))  dwValue = 7;  // 1252/29348 = 4.2%
					else if ((iResult >= 28400) && (iResult < 28900))  dwValue = 8;  // 826/29348 = 2.8%
					else if ((iResult >= 28900) && (iResult < 29300))  dwValue = 9;  // 545/29348 = 1.85%
					else if ((iResult >= 29300) && (iResult < 29600))  dwValue = 10;  // 360/29348 = 1.2%
					else if ((iResult >= 29600) && (iResult < 29800))  dwValue = 11; // 237/29348 = 0.8%
					else if ((iResult >= 29800) && (iResult < 29900))  dwValue = 12; // 156/29348 = 0.5%
					else if ((iResult >= 29900) && (iResult < 29970))  dwValue = 13; // 103/29348 = 0.3%
					else if ((iResult >= 29970) && (iResult <= 32500))  dwValue = 1; // 68/29348 = 0.1%
					else dwValue = 1; 
					switch (dwType) {
					case 6:  // Light
						if (dwValue <= 4) dwValue = 4;
						break; 
					case 8:	 // Strong
						if (dwValue <= 2) dwValue = 2;
						break; 
					case 11: // ManaConv
					case 12: // Critincrease
						// v2.04
					//	dwValue = (dwValue+1) / 2;
					//	if (dwValue < 1) dwValue = 1;
					// Better ManaConv & Crit increase values
						if ((iGenLevel <= 2) && (dwValue > 2)) dwValue = 2;
						break;
					}
					if ((iGenLevel <= 2) && (dwValue > 7)) dwValue = 7;
					pItem->m_dwAttribute = NULL;
					dwType  = dwType << 20;
					dwValue = dwValue << 16;
					pItem->m_dwAttribute = pItem->m_dwAttribute | dwType | dwValue;
					if (iDice(1,10000) >= 6000) {
						iResult = iDice(1,10000);
						if ((iResult >= 1) && (iResult <= 999))           dwType = 3; // DefRatio 21%+
						else if ((iResult >= 1000) && (iResult <= 3999))  dwType = 1; // PoisonR 21%+
						else if ((iResult >= 4000) && (iResult <= 5499))  dwType = 5; // SPrec
						else if ((iResult >= 5500) && (iResult <= 6499))  dwType = 4; // HPrec
						else if ((iResult >= 6500) && (iResult <= 7499))  dwType = 6; // MPrec
						else if ((iResult >= 7500) && (iResult <= 9399))  dwType = 7; // MR
						else if ((iResult >= 9400) && (iResult <= 9699))  dwType = 8; // PA
						else if ((iResult >= 9700) && (iResult <= 10000)) dwType = 9; // MA

						iResult = iDice(1, 32500);
						if ((iResult >= 1) && (iResult < 10000))           dwValue = 2;  // 10000/29348 = 34%
						else if ((iResult >= 10000) && (iResult < 17400))  dwValue = 3;  // 6600/29348 = 22.4%
						else if ((iResult >= 17400) && (iResult < 22400))  dwValue = 4;  // 4356/29348 = 14.8%
						else if ((iResult >= 22400) && (iResult < 25400))  dwValue = 5;  // 2874/29348 = 9.7%
						else if ((iResult >= 25400) && (iResult < 27400))  dwValue = 6;  // 1897/29348 = 6.4%
						else if ((iResult >= 27400) && (iResult < 28400))  dwValue = 7;  // 1252/29348 = 4.2%
						else if ((iResult >= 28400) && (iResult < 28900))  dwValue = 8;  // 826/29348 = 2.8%
						else if ((iResult >= 28900) && (iResult < 29300))  dwValue = 9;  // 545/29348 = 1.85%
						else if ((iResult >= 29300) && (iResult < 29600))  dwValue = 10;  // 360/29348 = 1.2%
						else if ((iResult >= 29600) && (iResult < 29800))  dwValue = 11; // 237/29348 = 0.8%
						else if ((iResult >= 29800) && (iResult < 29900))  dwValue = 12; // 156/29348 = 0.5%
						else if ((iResult >= 29900) && (iResult < 29970))  dwValue = 13; // 103/29348 = 0.3%
						else if ((iResult >= 29970) && (iResult <= 32500))  dwValue = 1; // 68/29348 = 0.1%
						else dwValue = 1; // v2.03 906
						switch (dwType) {
						case 1: // PR +21%
						case 3: // DR +21%
						case 7: // MR +21%
						case 8: // PA +9%
						case 9: // MA +9%
							if (dwValue <= 3) dwValue = 3;
							break; 
						}
						if ((iGenLevel <= 2) && (dwValue > 7)) dwValue = 7;
						dwType  = dwType << 12;
						dwValue = dwValue << 8;
						pItem->m_dwAttribute = pItem->m_dwAttribute | dwType | dwValue;
					}
				}
				_AdjustRareItemValue(pItem);
			} 
		}// End off items loop
		pItem->m_sTouchEffectType   = DEF_ITET_ID;
		pItem->m_sTouchEffectValue1 = iDice(1,100000);
		pItem->m_sTouchEffectValue2 = iDice(1,100000);
		//pItem->m_sTouchEffectValue3 = timeGetTime();
		if (pItem->m_cItemType == DEF_ITEMTYPE_MATERIAL)
		{	pItem->m_sItemSpecEffectValue2 = iDice (1, 40) +60;
			pItem->m_sItemSpecEffectValue1 = pItem->m_wCurLifeSpan;
			pItem->m_dwAttribute = 1;
		}
		// Correct Date string	
		SYSTEMTIME SysTime;
		char cTemp[256];
		GetLocalTime(&SysTime);
		ZeroMemory(cTemp, sizeof(cTemp));
		wsprintf(cTemp, "%d%2d",  (short)SysTime.wMonth, (short)SysTime.wDay);
		pItem->m_sTouchEffectValue3 = atoi(cTemp);
		m_pMapList[ m_pNpcList[iNpcH]->m_cMapIndex ]->bSetItem(m_pNpcList[iNpcH]->m_sX, 
			m_pNpcList[iNpcH]->m_sY, 
			pItem);
		SendEventToNearClient_TypeB(MSGID_EVENT_COMMON, DEF_COMMONTYPE_ITEMDROP, m_pNpcList[iNpcH]->m_cMapIndex,
			m_pNpcList[iNpcH]->m_sX, m_pNpcList[iNpcH]->m_sY,
			pItem->m_sSprite, pItem->m_sSpriteFrame, pItem->m_cItemColor); //v1.4 color
		// SNOOPY: Didnt parse the npc name....
		_bItemLog(DEF_ITEMLOG_NEWGENDROP, NULL, m_pNpcList[iNpcH]->m_cNpcName, pItem);//DEF_ITEMLOG_NEWGENDROP
	}
}
BOOL CGame::NpcDeadItemGeneratorWithItemEvent(int iNpcH, short sAttackerH, char cAttackerType)
{class CItem * pItem;
 char  cTemp[20];
 int   i, j, iT1, iT2, iT3;
 int	iNbePossibleMob;
 SYSTEMTIME SysTime;
	if (cAttackerType!= DEF_OWNERTYPE_PLAYER) return FALSE;
	if (m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->m_iTotalItemEvents != NULL)
	{	if (iDice(1, 20000) > m_pNpcList[iNpcH]->m_iGoldDiceMax) return FALSE;
		if (iDice(1, 3) == 2) return FALSE;			
		GetLocalTime(&SysTime);
		for ( i = 0; i < m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->m_iTotalItemEvents; i++ )
		if (   ( SysTime.wMonth == m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->m_stItemEventList[i].iMonth) 
			&& ( SysTime.wDay   == m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->m_stItemEventList[i].iDay) 
			&& ( m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->m_stItemEventList[i].iDropped < m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->m_stItemEventList[i].iTotalNum ))		
		{	iNbePossibleMob = m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->m_stItemEventList[i].iNbeMob;
			for( j=0; j<iNbePossibleMob; j++) // Verifie si dans la liste de mobs
			{	if( strcmp(m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->m_stItemEventList[i].cMob[j], m_pNpcList[iNpcH]->m_cNpcName) == 0)
					break;
			}
			if( j >= iNbePossibleMob )	continue;	// Le mob qui droppe n'est pas ds la liste
			if (SysTime.wHour < 12 ) 
			{	if(iDice(1,9000) != 6433)continue;
			}else if (SysTime.wHour < 18 ) 
			{	if(iDice(1,3000) != 1433) continue; // Ca commence a drop a 18h00 !
			} 
			iT1 = 1440 / m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->m_stItemEventList[i].iTotalNum;   // Periode de temps pour un drop
			iT2 = ((SysTime.wHour*60) + SysTime.wMinute) / iT1;										   // Nbe theorique de drops déjà faits
			iT3 = 1 + iT2 - m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->m_stItemEventList[i].iDropped; // Nbe de drops non encore obtenus

			if (iT3 <= 0) continue;					// Déjà trop dropé (ca ne devrait pas arriver, cf + haut!)
			if (iDice(1, 20) > iT3 ) continue;		// 1/20 ou mieux si des drops n'ont pas été distribués
			pItem = new class CItem;
			if (_bInitItemAttr(pItem, m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->m_stItemEventList[i].cItemName) == FALSE) 
			{	delete pItem;
				pItem = NULL;
			}else 
			{	if ((pItem->m_cItemType == DEF_ITEMTYPE_CONSUME) ||(pItem->m_cItemType == DEF_ITEMTYPE_ARROW))
				{	pItem->m_dwCount = m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->m_stItemEventList[i].iAmount;				
				}		
				if (pItem->m_sItemEffectType == DEF_ITEMEFFECTTYPE_EVENT_ITEMDROP) 
				{	GetLocalTime(&SysTime);
					pItem->m_sTouchEffectType   = DEF_ITET_DATE;
					pItem->m_sTouchEffectValue1 = (short)SysTime.wMonth;
					pItem->m_sTouchEffectValue2 = (short)SysTime.wDay;
					pItem->m_sTouchEffectValue3 = (short)SysTime.wHour;
				}else		
				{	pItem->m_sTouchEffectType   = DEF_ITET_ID;
					pItem->m_sTouchEffectValue1 = iDice(1,100000);
					pItem->m_sTouchEffectValue2 = iDice(1,100000);
					if (pItem->m_cItemType == DEF_ITEMTYPE_MATERIAL)
					{	pItem->m_sItemSpecEffectValue2 = iDice (1, 40) +60;
						pItem->m_sItemSpecEffectValue1 = pItem->m_wCurLifeSpan;
						pItem->m_dwAttribute = 1;
					}
					ZeroMemory(cTemp, sizeof(cTemp));			
					wsprintf(cTemp, "%d%2d",  (short)SysTime.wMonth, (short)SysTime.wDay);
					pItem->m_sTouchEffectValue3 = atoi(cTemp);	
				}
				m_pMapList[ m_pNpcList[iNpcH]->m_cMapIndex ]->bSetItem(m_pNpcList[iNpcH]->m_sX, m_pNpcList[iNpcH]->m_sY, pItem);
				SendEventToNearClient_TypeB(MSGID_EVENT_COMMON, DEF_COMMONTYPE_ITEMDROP, m_pNpcList[iNpcH]->m_cMapIndex,
							                m_pNpcList[iNpcH]->m_sX, m_pNpcList[iNpcH]->m_sY,
									        pItem->m_sSprite, pItem->m_sSpriteFrame, pItem->m_cItemColor);
				m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->m_stItemEventList[i].iDropped++;
				wsprintf(G_cTxt, "PC(%s)\tObtained Item Event from a %s (%s) \t%s(%d %d)\tIP(%s)"
					, m_pClientList[sAttackerH]->m_cCharName
					, m_pClientList[sAttackerH]->m_cMapName
					, m_pNpcList[iNpcH]->m_cNpcName
					, pItem->m_cName
					, m_pClientList[sAttackerH]->m_sX
					, m_pClientList[sAttackerH]->m_sY
					, m_pClientList[sAttackerH]->m_cIPaddress);	
				PutLogEventFileList(G_cTxt);
				PutItemLogFileList(G_cTxt);	
				PutLogList(G_cTxt);	
				_bItemLog(DEF_ITEMLOG_ITEMEVENT, NULL, m_pNpcList[iNpcH]->m_cNpcName, pItem);
				return TRUE;
			}
	}	}	
	return FALSE;
} // NpcDeadItemGeneratorWithItemEvent
BOOL CGame::bReadAdminSetConfigFile(char * cFn)
{
	FILE * pFile;
	HANDLE hFile;
	DWORD  dwFileSize;
	char * cp, * token, cReadMode; //, cGSMode[16] = "";
	char seps[] = "= \t\n";
	class CStrTok * pStrTok;

	cReadMode = 0;

	hFile = CreateFile(cFn, GENERIC_READ, NULL, NULL, OPEN_EXISTING, NULL, NULL);
	dwFileSize = GetFileSize(hFile, NULL);
	if (hFile != INVALID_HANDLE_VALUE) CloseHandle(hFile);

	pFile = fopen(cFn, "rt");
	if (pFile == NULL) {
	 return FALSE;
	}
	else {
		 PutLogList("(!) Reading Admin settings file...");
		 cp = new char[dwFileSize+2];
		 ZeroMemory(cp, dwFileSize+2);
		 fread(cp, dwFileSize, 1, pFile);

		 pStrTok = new class CStrTok(cp, seps);
		 token = pStrTok->pGet();
		 //token = strtok( cp, seps );   
		 while( token != NULL )   {

		 if (cReadMode != 0) {
		   switch (cReadMode) {
		   case 1:
			if ((strlen(token) > 0) && (strlen(token) < 9))
			{	m_iAdminLevelGMKill = atoi(token);
			}
			else{
				m_iAdminLevelGMKill = 2;
			}
			cReadMode = 0;
			break;
//----------------------------------------------------------------
		   case 2:
			if ((strlen(token) > 0) && (strlen(token) < 9))
			{	m_iAdminLevelGMRevive = atoi(token);
			}
			else{
				m_iAdminLevelGMRevive = 2;
			}
			cReadMode = 0;
			break;
//----------------------------------------------------------------
		   case 3:
			if ((strlen(token) > 0) && (strlen(token) < 9))
			{	m_iAdminLevelGMCloseconn = atoi(token);
			}
			else{
				m_iAdminLevelGMCloseconn = 2;
			}
			cReadMode = 0;
			break;
//----------------------------------------------------------------
		   case 4:
			if ((strlen(token) > 0) && (strlen(token) < 9))
			{	m_iAdminLevelGMCheckRep = atoi(token);
			}
			else{
				m_iAdminLevelGMCheckRep = 2;
			}
			cReadMode = 0;
			break;
//----------------------------------------------------------------
		  case 5:
			if ((strlen(token) > 0) && (strlen(token) < 9))
			{	m_iAdminLevelWho = atoi(token);
			}
			else{
				m_iAdminLevelWho = 1;
			}
			cReadMode = 0;
			break;
//----------------------------------------------------------------
		  case 6:
			if ((strlen(token) > 0) && (strlen(token) < 9))
			{	m_iAdminLevelEnergySphere = atoi(token);
			}
			else{
				m_iAdminLevelEnergySphere = 2;
			}
			cReadMode = 0;
			break;
//----------------------------------------------------------------
		  case 7:
			if ((strlen(token) > 0) && (strlen(token) < 9))
			{	m_iAdminLevelShutdown = atoi(token);
			}
			else{
				m_iAdminLevelShutdown = 5;
			}
			cReadMode = 0;
			break;
//----------------------------------------------------------------
		  case 8:
			if ((strlen(token) > 0) && (strlen(token) < 9))
			{	m_iAdminLevelObserver = atoi(token);
			}
			else{
				m_iAdminLevelObserver = 5;
			}
			cReadMode = 0;
			break;
//----------------------------------------------------------------
		  case 9:
			if ((strlen(token) > 0) && (strlen(token) < 9))
			{	m_iAdminLevelShutup = atoi(token);
			}
			else{
				m_iAdminLevelShutup = 2;
			}
			cReadMode = 0;
			break;
//----------------------------------------------------------------
		  case 10:
			if ((strlen(token) > 0) && (strlen(token) < 9))
			{	m_iAdminLevelCallGaurd = atoi(token);
			}
			else{
				m_iAdminLevelCallGaurd = 2;
			}
			cReadMode = 0;
			break;
//----------------------------------------------------------------
		  case 11:
			if ((strlen(token) > 0) && (strlen(token) < 9))
			{	m_iAdminLevelSummonDemon = atoi(token);
			}
			else{
				m_iAdminLevelSummonDemon = 2;
			}
			cReadMode = 0;
			break;
//----------------------------------------------------------------		   
		  case 12:
			if ((strlen(token) > 0) && (strlen(token) < 9))
			{	m_iAdminLevelSummonDeath = atoi(token);
			}
			else{
				m_iAdminLevelSummonDeath = 3;
			}
			cReadMode = 0;
			break;
//----------------------------------------------------------------
		  case 13:
			if ((strlen(token) > 0) && (strlen(token) < 9))
			{	m_iAdminLevelReserveFightzone = atoi(token);
			}
			else{
				m_iAdminLevelReserveFightzone = 3;
			}
			cReadMode = 0;
			break;
//----------------------------------------------------------------
		  case 14:
			if ((strlen(token) > 0) && (strlen(token) < 9))
			{	m_iAdminLevelCreateFish = atoi(token);
			}
			else{
				m_iAdminLevelCreateFish = 3;
			}
			cReadMode = 0;
			break;
//----------------------------------------------------------------
		  case 15:
			if ((strlen(token) > 0) && (strlen(token) < 9))
			{	m_iAdminLevelTeleport = atoi(token);
			}
			else{
				m_iAdminLevelTeleport = 1;
			}
			cReadMode = 0;
			break;
//----------------------------------------------------------------
		  case 16:
			if ((strlen(token) > 0) && (strlen(token) < 9))
			{	m_iAdminLevelCheckIP = atoi(token);
			}
			else{
				m_iAdminLevelCheckIP = 2;
			}
			cReadMode = 0;
			break;
//----------------------------------------------------------------
		  case 17:
			if ((strlen(token) > 0) && (strlen(token) < 9))
			{	m_iAdminLevelPolymorph = atoi(token);
			}
			else{
				m_iAdminLevelPolymorph = 3;
			}
			cReadMode = 0;
			break;
//----------------------------------------------------------------
		  case 18:
			if ((strlen(token) > 0) && (strlen(token) < 9))
			{	m_iAdminLevelSetInvis = atoi(token);
			}
			else{
				m_iAdminLevelSetInvis = 2;
			}
			cReadMode = 0;
			break;
//----------------------------------------------------------------	
		  case 19:
			if ((strlen(token) > 0) && (strlen(token) < 9))
			{	m_iAdminLevelSetZerk = atoi(token);
			}
			else{
				m_iAdminLevelSetZerk = 2;
			}
			cReadMode = 0;
			break;
//----------------------------------------------------------------	
		  case 20:
			if ((strlen(token) > 0) && (strlen(token) < 9))
			{	m_iAdminLevelSetIce = atoi(token);
			}
			else{
				m_iAdminLevelSetIce = 2;
			}
			cReadMode = 0;
			break;
//----------------------------------------------------------------	
		  case 21:
			if ((strlen(token) > 0) && (strlen(token) < 9))
			{	m_iAdminLevelGetNpcStatus = atoi(token);
			}
			else{
				m_iAdminLevelGetNpcStatus = 3;
			}
			cReadMode = 0;
			break;
//----------------------------------------------------------------				
		  case 22:
			if ((strlen(token) > 0) && (strlen(token) < 9))
			{	m_iAdminLevelSetAttackMode = atoi(token);
			}
			else{
				m_iAdminLevelSetAttackMode = 2;
			}
			cReadMode = 0;
			break;
//----------------------------------------------------------------	
		  case 23:
			if ((strlen(token) > 0) && (strlen(token) < 9))
			{	m_iAdminLevelUnsummonAll = atoi(token);
			}
			else{
				m_iAdminLevelUnsummonAll = 2;
			}
			cReadMode = 0;
			break;
//----------------------------------------------------------------	
		  case 24:
			if ((strlen(token) > 0) && (strlen(token) < 9))
			{	m_iAdminLevelUnsummonDemon = atoi(token);
			}
			else{
				m_iAdminLevelUnsummonDemon = 2;
			}
			cReadMode = 0;
			break;
//----------------------------------------------------------------	
		  case 25:
			if ((strlen(token) > 0) && (strlen(token) < 9))
			{	m_iAdminLevelSummon = atoi(token);
			}
			else{
				m_iAdminLevelSummon = 3;
			}
			cReadMode = 0;
			break;
//----------------------------------------------------------------			
		  case 26:
			if ((strlen(token) > 0) && (strlen(token) < 9))
			{	m_iAdminLevelSummonAll = atoi(token);
			}
			else{
				m_iAdminLevelSummonAll = 3;
			}
			cReadMode = 0;
			break;
//----------------------------------------------------------------
		  case 27:
			if ((strlen(token) > 0) && (strlen(token) < 9))
			{	m_iAdminLevelSummonPlayer = atoi(token);
			}
			else{
				m_iAdminLevelSummonPlayer = 2;
			}
			cReadMode = 0;
			break;
//----------------------------------------------------------------	
		  case 28:
			if ((strlen(token) > 0) && (strlen(token) < 9))
			{	m_iAdminLevelDisconnectAll = atoi(token);
			}
			else{
				m_iAdminLevelDisconnectAll = 2;
			}
			cReadMode = 0;
			break;
//----------------------------------------------------------------	
		  case 29:
			if ((strlen(token) > 0) && (strlen(token) < 9))
			{	m_iAdminLevelEnableCreateItem = atoi(token);
			}
			else{
				m_iAdminLevelEnableCreateItem = 4;
			}
			cReadMode = 0;
			break;
//----------------------------------------------------------------			
		  case 30:
			if ((strlen(token) > 0) && (strlen(token) < 9))
			{	m_iAdminLevelCreateItem = atoi(token);
			}
			else{
				m_iAdminLevelCreateItem = 4;
			}
			cReadMode = 0;
			break;
//----------------------------------------------------------------
		  case 31:
			if ((strlen(token) > 0) && (strlen(token) < 9))
			{	m_iAdminLevelStorm = atoi(token);
			}
			else{
				m_iAdminLevelStorm = 4;
			}
			cReadMode = 0;
			break;
//----------------------------------------------------------------
		  case 32:
			if ((strlen(token) > 0) && (strlen(token) < 9))
			{	m_iAdminLevelWeather = atoi(token);
			}
			else{
				m_iAdminLevelWeather = 3;
			}
			cReadMode = 0;
			break;
//----------------------------------------------------------------
		  case 33:
			if ((strlen(token) > 0) && (strlen(token) < 9))
			{	m_iAdminLevelSetStatus = atoi(token);
			}
			else{
				m_iAdminLevelSetStatus = 2;
			}
			cReadMode = 0;
			break;
//----------------------------------------------------------------
		  case 34:
			if ((strlen(token) > 0) && (strlen(token) < 9))
			{	m_iAdminLevelGoto = atoi(token);
			}
			else{
				m_iAdminLevelGoto = 2;
			}
			cReadMode = 0;
			break;
//----------------------------------------------------------------	
		  case 35:
			if ((strlen(token) > 0) && (strlen(token) < 9))
			{	m_iAdminLevelMonsterCount = atoi(token);
			}
			else{
				m_iAdminLevelMonsterCount = 3;
			}
			cReadMode = 0;
			break;
//----------------------------------------------------------------			
		  case 36:
			if ((strlen(token) > 0) && (strlen(token) < 9))
			{	m_iAdminLevelSetRecallTime = atoi(token);
			}
			else{
				m_iAdminLevelSetRecallTime = 4;
			}
			cReadMode = 0;
			break;
//----------------------------------------------------------------	
		  case 37:
			if ((strlen(token) > 0) && (strlen(token) < 9))
			{	m_iAdminLevelUnsummonBoss = atoi(token);
			}
			else{
				m_iAdminLevelUnsummonBoss = 2;
			}
			cReadMode = 0;
			break;
//----------------------------------------------------------------	
		  case 38:
			if ((strlen(token) > 0) && (strlen(token) < 9))
			{	m_iAdminLevelClearNpc = atoi(token);
			}
			else{
				m_iAdminLevelClearNpc = 3;
			}
			cReadMode = 0;
			break;
//----------------------------------------------------------------				
		  case 39:
			if ((strlen(token) > 0) && (strlen(token) < 9))
			{	m_iAdminLevelTime = atoi(token);
			}
			else{
				m_iAdminLevelTime = 3;
			}
			cReadMode = 0;
			break;
//----------------------------------------------------------------
		  case 40:
			if ((strlen(token) > 0) && (strlen(token) < 9))
			{	m_iAdminLevelPushPlayer = atoi(token);
			}
			else{
				m_iAdminLevelPushPlayer = 2;
			}
			cReadMode = 0;
			break;
//-----------------------------------------------------------------
		  case 41:
			if ((strlen(token) > 0) && (strlen(token) < 9))
			{	m_iAdminLevelSummonGuild = atoi(token);
			}
			else{
				m_iAdminLevelSummonGuild = 2;
			}
			cReadMode = 0;
			break;
//-----------------------------------------------------------------
		  case 42:
			if ((strlen(token) > 0) && (strlen(token) < 9))
			{	m_iAdminLevelCheckStatus = atoi(token);
			}
			else{
				m_iAdminLevelCheckStatus = 2;
			}
			cReadMode = 0;
			break;
//-----------------------------------------------------------------
		  case 43:
			if ((strlen(token) > 0) && (strlen(token) < 9))
			{	m_iAdminLevelCleanMap = atoi(token);
			}
			else{
				m_iAdminLevelCleanMap = 3;
			}
			cReadMode = 0;
			break;
//-----------------------------------------------------------------
		  case 44: // Snoopy: new GM command
			if ((strlen(token) > 0) && (strlen(token) < 9))
			{	m_iAdminLevelSetPkMode = atoi(token);
			}
			else{
				m_iAdminLevelSetPkMode = 3;
			}
			cReadMode = 0;
			break;
//-----------------------------------------------------------------
		  case 45: // Snoopy: new GM command
			if ((strlen(token) > 0) && (strlen(token) < 9))
			{	m_iAdminLevelSetMapType = atoi(token);
			}
			else{
				m_iAdminLevelSetMapType = 3;
			}
			cReadMode = 0;
			break;
//-----------------------------------------------------------------
		  case 46: // Snoopy: new GM command
			if ((strlen(token) > 0) && (strlen(token) < 9))
			{	m_iAdminLevelGetServerInfo = atoi(token);
			}
			else{
				m_iAdminLevelGetServerInfo = 2;
			}
			cReadMode = 0;
			break;
//-----------------------------------------------------------------
		  case 47: // Snoopy: new GM command
			if ((strlen(token) > 0) && (strlen(token) < 9))
			{	m_iAdminLevelMapMobNum = atoi(token);
			}else
			{	m_iAdminLevelMapMobNum = 3;
			}
			cReadMode = 0;
			break;
//-----------------------------------------------------------------
		  case 48: // Snoopy: new GM command
			if ((strlen(token) > 0) && (strlen(token) < 9))
			{	m_iAdminLevelPopoEnabled = atoi(token);
			}else
			{	m_iAdminLevelPopoEnabled = 3;
			}
			cReadMode = 0;
			break;
//-----------------------------------------------------------------
		  case 49: // Snoopy: new GM command
			if ((strlen(token) > 0) && (strlen(token) < 9))
			{	m_iAdminLevelSpecialEvents = atoi(token);
			}else
			{	m_iAdminLevelSpecialEvents = 4;
			}
			cReadMode = 0;
			break;
//-----------------------------------------------------------------
			}
		  } else 
		  {	if (memcmp(token, "Admin-Level-/kill", 17) == 0)						cReadMode = 1;
			if (memcmp(token, "Admin-Level-/revive", 19) == 0)						cReadMode = 2;
			if (memcmp(token, "Admin-Level-/closecon", 21) == 0)					cReadMode = 3;
			if (memcmp(token, "Admin-Level-/checkrep", 21) == 0)					cReadMode = 4;
			if (memcmp(token, "Admin-Level-/who", 16) == 0)							cReadMode = 5;
			if (memcmp(token, "Admin-Level-/energysphere", 25) == 0)				cReadMode = 6;
			if (memcmp(token, "Admin-Level-/shutdownthisserverrightnow", 39) == 0)	cReadMode = 7;
			if (memcmp(token, "Admin-Level-/setobservermode", 28) == 0)				cReadMode = 8;
			if (memcmp(token, "Admin-Level-/shutup", 19) == 0)						cReadMode = 9;
			if (memcmp(token, "Admin-Level-/attack", 19) == 0)						cReadMode = 10;
			if (memcmp(token, "Admin-Level-/summondemon", 24) == 0)					cReadMode = 11;
			if (memcmp(token, "Admin-Level-/summondeath", 24) == 0)					cReadMode = 12;
			if (memcmp(token, "Admin-Level-/reservefightzone", 28) == 0)			cReadMode = 13;
			if (memcmp(token, "Admin-Level-/createfish", 23) == 0)					cReadMode = 14;
			if (memcmp(token, "Admin-Level-/teleport", 21) == 0)					cReadMode = 15;
			if (memcmp(token, "Admin-Level-/checkip", 20) == 0)						cReadMode = 16;
			if (memcmp(token, "Admin-Level-/polymorph", 22) == 0)					cReadMode = 17;
			if (memcmp(token, "Admin-Level-/setinvi", 20) == 0)						cReadMode = 18;
			if (memcmp(token, "Admin-Level-/setzerk", 20) == 0)						cReadMode = 19;
			if (memcmp(token, "Admin-Level-/setfreeze", 22) == 0)					cReadMode = 20;
			if (memcmp(token, "Admin-Level-/gns", 16) == 0)							cReadMode = 21;
			if (memcmp(token, "Admin-Level-/setattackmode", 26) == 0)				cReadMode = 22;
			if (memcmp(token, "Admin-Level-/unsummonall", 24) == 0)					cReadMode = 23;
			if (memcmp(token, "Admin-Level-/unsummondemon", 26) == 0)				cReadMode = 24;
			if (memcmp(token, "Admin-Level-/summonnpc", 22) == 0)					cReadMode = 25;
			if (memcmp(token, "Admin-Level-/summonall", 22) == 0)					cReadMode = 26;
			if (memcmp(token, "Admin-Level-/summonplayer", 25) == 0)				cReadMode = 27;
			if (memcmp(token, "Admin-Level-/disconnectall", 26) == 0)				cReadMode = 28;
			if (memcmp(token, "Admin-Level-/enableadmincreateitem", 34) == 0)		cReadMode = 29;
			if (memcmp(token, "Admin-Level-/createitem", 23) == 0)					cReadMode = 30;
			if (memcmp(token, "Admin-Level-/storm", 18) == 0)						cReadMode = 31;
			if (memcmp(token, "Admin-Level-/weather", 20) == 0)						cReadMode = 32;
			if (memcmp(token, "Admin-Level-/setstatus", 22) == 0)					cReadMode = 33;
			if (memcmp(token, "Admin-Level-/goto", 17) == 0)						cReadMode = 34;
			if (memcmp(token, "Admin-Level-/monstercount", 17) == 0)				cReadMode = 35;
			if (memcmp(token, "Admin-Level-/setforcerecalltime", 23) == 0)			cReadMode = 36;
			if (memcmp(token, "Admin-Level-/unsummonboss", 25) == 0)				cReadMode = 37;
			if (memcmp(token, "Admin-Level-/clearnpc", 21) == 0)					cReadMode = 38;
			if (memcmp(token, "Admin-Level-/time", 17) == 0)						cReadMode = 39;
			if (memcmp(token, "Admin-Level-/send", 17) == 0)						cReadMode = 40;
			if (memcmp(token, "Admin-Level-/summonguild", 24) == 0)					cReadMode = 41;
			if (memcmp(token, "Admin-Level-/checkstatus", 24) == 0)					cReadMode = 42;	
			if (memcmp(token, "Admin-Level-/clearmap", 21) == 0)					cReadMode = 43;	
			// Added by Snoopy
			if (memcmp(token, "Admin-Level-/setpkmode", 22) == 0)					cReadMode = 44;	
			if (memcmp(token, "Admin-Level-/setmaptype", 23) == 0)					cReadMode = 45;
			if (memcmp(token, "Admin-Level-/readmapinfo", 24) == 0)					cReadMode = 46;
			if (memcmp(token, "Admin-Level-/setmapmobnum", 25) == 0)				cReadMode = 47;
			if (memcmp(token, "Admin-Level-/popoenabled", 25) == 0)					cReadMode = 48;
			if (memcmp(token, "Admin-Level-specialevents", 26) == 0)				cReadMode = 49;
		  }
		  token = pStrTok->pGet();
		  //token = strtok( NULL, seps );
		 }
		 delete pStrTok;
		 delete cp;
		}
		if (pFile != NULL) fclose(pFile);
		return TRUE;
}

void CGame::AdminOrder_Time(int iClientH, char * pData, DWORD dwMsgSize)
{	// Time command By ACiDx Last edit on Sept,06,04
	//SNOOPY removed! it's a global variable 
	// BOOL m_bManualTime;
	char   seps[] = "= \t\n";
	char   * token, cBuff[256]; 
	class  CStrTok * pStrTok;
	int i;
		if ((dwMsgSize)	<= 0) return;
		if (m_pClientList[iClientH] == NULL) return;
		if (m_pClientList[iClientH]->m_iAdminUserLevel < m_iAdminLevelTime) {
			SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_ADMINUSERLEVELLOW, NULL, NULL, NULL, NULL);
			return;
		}	
		ZeroMemory(cBuff, sizeof(cBuff));
		memcpy(cBuff, pData, dwMsgSize);
		pStrTok = new class CStrTok(cBuff, seps);
		token = pStrTok->pGet();
		token = pStrTok->pGet();
		if (token != NULL) 
		{	if (token[0] == '2') 
			{	m_cDayOrNight = (char) 2;		
				wsprintf(G_cTxt, "GM Order(%-10s): Forces night mode", m_pClientList[iClientH]->m_cCharName);
				bSendMsgToLS(MSGID_GAMEMASTERLOG, iClientH, FALSE, G_cTxt);
				m_bManualTime = TRUE;
			}else if (token[0] == '1') 
			{	m_cDayOrNight = (char) 1;
				wsprintf(G_cTxt, "GM Order(%-10s): Forces day mode", m_pClientList[iClientH]->m_cCharName);
				bSendMsgToLS(MSGID_GAMEMASTERLOG, iClientH, FALSE, G_cTxt);
				m_bManualTime = TRUE;
			}else if (token[0] == '0') 		
			{	bSendMsgToLS(MSGID_GAMEMASTERLOG, iClientH, FALSE, G_cTxt);
				wsprintf(G_cTxt, "GM Order(%-10s): Disable force time mode", m_pClientList[iClientH]->m_cCharName);			
				m_bManualTime = FALSE;				
				CheckDayOrNightMode();
			}
		for (i = 1; i < DEF_MAXCLIENTS; i++) 
		if ((m_pClientList[i] != NULL) && (m_pClientList[i]->m_bIsInitComplete == TRUE)) {
			if ((m_pClientList[i]->m_cMapIndex >= 0) && 
				(m_pMapList[m_pClientList[i]->m_cMapIndex] != NULL) &&
				(m_pMapList[m_pClientList[i]->m_cMapIndex]->m_bIsFixedDayMode == FALSE))
				SendNotifyMsg(NULL, i, DEF_NOTIFY_TIMECHANGE, m_cDayOrNight, NULL, NULL, NULL);	
		}
	}
	delete pStrTok;
}

void CGame::AdminOrder_CheckRep(int iClientH, char *pData,DWORD dwMsgSize)
{class  CStrTok * pStrTok;
 short m_iRating;
 char   * token, cName[11], cTargetName[11], cRepMessage[256], cTemp[256], seps[] = "= \t\n", cBuff[256];
 register int i;
 int Reputa;
	if (m_pClientList[iClientH] == NULL) return;
	ZeroMemory(cTemp, sizeof(cTemp));
	ZeroMemory(cRepMessage, sizeof(cRepMessage));	
	if (   (m_pClientList[iClientH]->m_iAdminUserLevel < m_iAdminLevelGMCheckRep) 
		|| (m_pClientList[iClientH]->m_iAdminUserLevel == 0))
	{	// SNOOPY replaced by reputation rating for Equilibrium Porject
		// Reputation will be used up to 500 by Kloness items
		//                     and up to 500 to increase Drop rate			
		Reputa =  m_pClientList[iClientH]->m_iRating;
		if (Reputa < 0   ) { wsprintf(cRepMessage, " <%d> You reputation is questionable.", Reputa); };
		if (Reputa < -20 ) { wsprintf(cRepMessage, " <%d> You reputation is bad.", Reputa); };
		if (Reputa < -50 ) { wsprintf(cRepMessage, " <%d> You reputation is ignoble.", Reputa); };
		if (Reputa <-100 ) { wsprintf(cRepMessage, " <%d> You reputation is dreafull.", Reputa); };
		if (Reputa == 0  ) { wsprintf(cRepMessage, " <%d> You're perfectelly unknown.", Reputa); };
		if (Reputa > 0   ) { wsprintf(cRepMessage, " <%d> You're unimportant.", Reputa); };
		if (Reputa > 29  ) { wsprintf(cRepMessage, " <%d> You reputation is noticeable.", Reputa); };
		if (Reputa > 59  ) { wsprintf(cRepMessage, " <%d> You're somebody.", Reputa); };
		if (Reputa > 99  ) { wsprintf(cRepMessage, " <%d> You're a respectable person.", Reputa); };
		if (Reputa > 149 ) { wsprintf(cRepMessage, " <%d> You're an honorable person.", Reputa); };
		if (Reputa > 199 ) { wsprintf(cRepMessage, " <%d> Your name is memorable!", Reputa); };
		if (Reputa > 299 ) { wsprintf(cRepMessage, " <%d> Your name is really famous.", Reputa); };
		if (Reputa > 399 ) { wsprintf(cRepMessage, " <%d> You became a legend!", Reputa); };
		if (Reputa > 499 ) { wsprintf(cRepMessage, " <%d> Do you really exist? Are you more than a myth?", Reputa); };
		ShowClientMsg(iClientH, "Reputation", cRepMessage);	
	}else // Only detailled info if admin level is enought
	{	if ((dwMsgSize)	<= 0) return;
		ZeroMemory(cTargetName, sizeof(cTargetName));
		ZeroMemory(cBuff, sizeof(cBuff));
		memcpy(cBuff, pData, dwMsgSize);
		pStrTok = new class CStrTok(cBuff, seps);
		token = pStrTok->pGet();
		token = pStrTok->pGet();		
		if (token != NULL) 
		{	ZeroMemory(cName, sizeof(cName));
			strcpy(cName, token);
		}else 
		{	ZeroMemory(cName, sizeof(cName));
			strcpy(cName, "null");
		}
		token = pStrTok->pGet();		
		if (token != NULL) 
		{	m_iRating = atoi(token);
		} 		
		delete pStrTok;
		if (token == NULL) {token = "null";}		
		if (cName != NULL) 
		{	token = cName;
			if (strlen(token) > 10) 
  				memcpy(cTargetName, token, 10);
			else memcpy(cTargetName, token, strlen(token));
			for (i = 1; i < DEF_MAXCLIENTS; i++) 
  			if ((m_pClientList[i] != NULL) && (memcmp(m_pClientList[i]->m_cCharName, cTargetName, 10) == 0)) {
				wsprintf(cRepMessage, " %s has %d reputation points.", m_pClientList[i]->m_cCharName, m_pClientList[i]->m_iRating);
				ShowClientMsg(iClientH, "Reputation",  cRepMessage);
				wsprintf(G_cTxt, "GM Order(%-10s): /checkrep %s (%d)", m_pClientList[iClientH]->m_cCharName, m_pClientList[i]->m_cCharName, m_pClientList[i]->m_iRating);
				bSendMsgToLS(MSGID_GAMEMASTERLOG, iClientH, FALSE, G_cTxt);
	}	}	}
}

void CGame::AdminOrder_CheckStats(int iClientH, int iTargetH)
{	char   cStatsMessage[256];
	if (m_pClientList[iTargetH] == NULL) return;
	WORD wWeaponType = ((m_pClientList[iTargetH]->m_sAppr2 & 0x0FF0) >> 4);
		// Compute MR
	int iTargetMagicResistRatio = m_pClientList[iTargetH]->m_cSkillMastery[3] + m_pClientList[iTargetH]->m_iAddMR;
	if ((m_pClientList[iTargetH]->m_iMag + m_pClientList[iTargetH]->m_iAngelicMag) > 50) 
		iTargetMagicResistRatio += ((m_pClientList[iTargetH]->m_iMag + m_pClientList[iTargetH]->m_iAngelicMag) - 50);
	iTargetMagicResistRatio += m_pClientList[iTargetH]->m_iAddResistMagic; 
	// Compute Hit ratio
	int iAttackerHitRatioL = m_pClientList[iTargetH]->m_iHitRatio;
	if (wWeaponType == 0) // OpenHand hit ratio counted at : iCalculateAttackEffect
	{	iAttackerHitRatioL += m_pClientList[iTargetH]->m_cSkillMastery[5];	
	}

	if (m_pClientList[iTargetH]->m_cMagicEffectStatus[DEF_MAGICTYPE_METAMORPHOSIS_TEMP_DEXT] > m_pClientList[iTargetH]->m_iDex)
	{	iAttackerHitRatioL += ( 10 * m_pClientList[iTargetH]->m_cMagicEffectStatus[DEF_MAGICTYPE_METAMORPHOSIS_TEMP_DEXT]);
		iAttackerHitRatioL -= 50; // For dex above 50 only
	}else if ((m_pClientList[iTargetH]->m_iDex + m_pClientList[iTargetH]->m_iAngelicDex) > 50) 
	{	iAttackerHitRatioL += ((m_pClientList[iTargetH]->m_iDex + m_pClientList[iTargetH]->m_iAngelicDex) - 50); 	
	}
	iAttackerHitRatioL += 25; //fixed bonus
	if (   (m_pClientList[iTargetH]->m_cHeroArmourBonus == 1) 
		|| (   (m_pClientList[iTargetH]->m_iPriestDruidID == 5) // Chevalier
			&& (m_pClientList[iTargetH]->m_bSpecialFeatureAllowed == TRUE) ))
	{	iAttackerHitRatioL += 25; 
	}

	int iDefRatio = m_pClientList[iTargetH]->m_iDefenseRatio + m_pClientList[iTargetH]->m_iAddDR + m_pClientList[iTargetH]->m_cMagicEffectStatus[DEF_MAGICTYPE_DEFENCESHIELD_VALUE];
	int iDefRatioPvP = m_pClientList[iTargetH]->m_iDefenseRatio2 + (m_pClientList[iTargetH]->m_iAddDR / 2) + m_pClientList[iTargetH]->m_cMagicEffectStatus[DEF_MAGICTYPE_DEFENCESHIELD_VALUE];

	// Snoopy: Test PvP mode moins favorable aux bourinos low dext.
	if ((m_pClientList[iTargetH]->m_iDex + m_pClientList[iTargetH]->m_iAngelicDex) > 101)
		iDefRatioPvP += (((m_pClientList[iTargetH]->m_iDex + m_pClientList[iTargetH]->m_iAngelicDex)-100)/4);
	if ((m_pClientList[iTargetH]->m_iDex + m_pClientList[iTargetH]->m_iAngelicDex) > 201)
		iDefRatioPvP += (((m_pClientList[iTargetH]->m_iDex + m_pClientList[iTargetH]->m_iAngelicDex)-200)/4);	
	
	if (m_pClientList[iTargetH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_METAMORPHOSIS ] > 0)
	{	iDefRatioPvP  = m_pClientList[iTargetH]->m_iDefenseRatio3;	
		iDefRatioPvP += (10 * m_pClientList[iTargetH]->m_cMagicEffectStatus[DEF_MAGICTYPE_METAMORPHOSIS_TEMP_DEXT]);
		iDefRatioPvP += m_pClientList[iTargetH]->m_iAddDR/2;
		iDefRatioPvP += 92; // represents armor improvements for D/R
		iDefRatio  = m_pClientList[iTargetH]->m_iDefenseRatio3;	
		iDefRatio += (20 * (m_pClientList[iTargetH]->m_cMagicEffectStatus[DEF_MAGICTYPE_METAMORPHOSIS_TEMP_DEXT]));
		iDefRatio += m_pClientList[iTargetH]->m_iAddDR;
		iDefRatio += 92; // represents armor improvements	
	}

	iAttackerHitRatioL += m_pClientList[iTargetH]->m_iAddAR; 
	iAttackerHitRatioL += m_pClientList[iTargetH]->m_iCustomItemValue_Attack;
	//Weater effect on hit ratio
	if (wWeaponType >= 40) {
		switch (m_pMapList[m_pClientList[iTargetH]->m_cMapIndex]->m_cWhetherStatus) {
		case 0:	break;
		case 1:	iAttackerHitRatioL -= (iAttackerHitRatioL / 20); break;
		case 2:	iAttackerHitRatioL -= (iAttackerHitRatioL / 10); break;
		case 3:	iAttackerHitRatioL -= (iAttackerHitRatioL / 4);  break;
		// SNOOPY: Added same malus for snow weather
		case 4:	iAttackerHitRatioL -= (iAttackerHitRatioL / 40); break;
		case 5:	iAttackerHitRatioL -= (iAttackerHitRatioL / 20); break;
		case 6:	iAttackerHitRatioL -= (iAttackerHitRatioL / 8);  break;
		default: break;
		}
	}
	if (   (m_pClientList[iTargetH]->m_iPriestDruidID == 3) // Monks
		&& (m_pClientList[iTargetH]->m_bSpecialFeatureAllowed == TRUE))
	{	iAttackerHitRatioL += (m_pClientList[iTargetH]->m_cSkillMastery[5]/2);
	}

	// Adjustment for hidden Weapons/armors ToHit bonusses
	int iAttackerHitRatioSM;
	if (m_pClientList[iTargetH]->m_cMagicEffectStatus[DEF_MAGICTYPE_METAMORPHOSIS_TEMP_DEXT] > m_pClientList[iTargetH]->m_iDex)
	{	iAttackerHitRatioSM = iAttackerHitRatioL;
		iAttackerHitRatioL += 20; //Big sword have bonusses to Hit Big monsters
	}else
	{	iAttackerHitRatioSM = iAttackerHitRatioL + m_pClientList[iTargetH]->m_iHitRatio_ItemEffect_SM;
		iAttackerHitRatioL += m_pClientList[iTargetH]->m_iHitRatio_ItemEffect_L;	
	}

	ZeroMemory(cStatsMessage, sizeof(cStatsMessage));	
	if (m_bPVPHPMode == TRUE)
	{	wsprintf(cStatsMessage, " %d/%d HitRate, %d/%d DefRate, %d MR"
			, iAttackerHitRatioSM
			, iAttackerHitRatioL
			, iDefRatio
			, iDefRatioPvP
			, iTargetMagicResistRatio);
	}else
	{	wsprintf(cStatsMessage, " %d/%d HitRate, %d DefRate, %d MR"
			, iAttackerHitRatioSM
			, iAttackerHitRatioL
			, iDefRatio
			, iTargetMagicResistRatio);
	}	

	char cTitle [256];
	ZeroMemory(cTitle, sizeof(cTitle));	
	switch (m_pClientList[iClientH]->m_iPriestDruidID) {
	default:
		break;
	case  1: // Priest
		strcpy (cTitle, "(Priest) ");
		break;
	case  2: // Druid
		if (m_pClientList[iClientH]->m_bSpecialFeatureAllowed == TRUE) strcpy (cTitle, "(Druid) ");
		break;
	case  3: // Monk
		if (m_pClientList[iClientH]->m_bSpecialFeatureAllowed == TRUE) strcpy (cTitle, "(Monk) ");
		break;
	case  4: // Paladin
		strcpy (cTitle, "(Paladin) ");
		break;
	case  5: // Knight
		if (m_pClientList[iClientH]->m_bSpecialFeatureAllowed == TRUE) strcpy (cTitle, "(Knight) ");
		break;
	case  6: // Barbarian
		if (m_pClientList[iClientH]->m_bSpecialFeatureAllowed == TRUE) strcpy (cTitle, "(Barbarian) ");
		break;
	}
	strcat (cTitle, cStatsMessage);
	ShowClientMsg(iClientH,  "Stats", cTitle);

}
void CGame::AdminOrder_Pushplayer(int iClientH, char * pData, DWORD dwMsgSize)
{	//Push Player- By:ACiDx  Monday , September 2004
	//Teleports a Defined Player to Defined Destination
	// /push playername mapname sX dX
 char   seps[] = "= \t\n";
 char   * token, cBuff[256], cMapName[256], cName[11], cTargetName[11];
 class  CStrTok * pStrTok;
 register int dX, dY;
 register int i;
 BOOL   bFlag;
	ZeroMemory(cTargetName, sizeof(cTargetName));
	ZeroMemory(cName, sizeof(cName));
	ZeroMemory(cBuff, sizeof(cBuff));
	dX = dY = -1;
	if (m_pClientList[iClientH] == NULL) return;
	if ((dwMsgSize)	<= 0) return;
	if (m_pClientList[iClientH]->m_iAdminUserLevel < m_iAdminLevelPushPlayer) 
	{	SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_ADMINUSERLEVELLOW, NULL, NULL, NULL, NULL);
		return;
	}
	ZeroMemory(cBuff, sizeof(cBuff));
	memcpy(cBuff, pData, dwMsgSize);
	pStrTok = new class CStrTok(cBuff, seps);
	token = pStrTok->pGet();
	token = pStrTok->pGet();	
	if (token != NULL) 
	{	ZeroMemory(cName, sizeof(cName));
		strcpy(cName, token);
	}else
	{	ZeroMemory(cName, sizeof(cName));
		strcpy(cName, "null");
	}
	token = pStrTok->pGet();
	if (token != NULL) 
	{	ZeroMemory(cMapName, sizeof(cMapName));
		strcpy(cMapName, token);
	}
	token = pStrTok->pGet();
	if (token != NULL) 
	{	dX = atoi(token);
	}
	token = pStrTok->pGet();
	if (token != NULL) 
	{	dY = atoi(token);
	}
	if (token == NULL) { token = "null"; }
	if (cName != NULL) {		token = cName;
	if (strlen(token) > 10) 
			memcpy(cTargetName, token, 10);
		else memcpy(cTargetName, token, strlen(token));
		for (i = 1; i < DEF_MAXCLIENTS; i++) 
			if ((m_pClientList[i] != NULL) && (memcmp(m_pClientList[i]->m_cCharName, cTargetName, 10) == 0)) {
			bFlag = FALSE;
			//Asks For Flag on maps
			if (strcmp("2ndmiddle", cMapName) == 0) bFlag = TRUE;
			if (strcmp("abaddon", cMapName) == 0) bFlag = TRUE; 
			if (strcmp("arebrk12", cMapName) == 0) bFlag = TRUE;
			if (strcmp("arefarm", cMapName) == 0) bFlag = TRUE;
			if (strcmp("arejail", cMapName) == 0) bFlag = TRUE;
			if (strcmp("aresden", cMapName) == 0) bFlag = TRUE;
			if (strcmp("aresdend1", cMapName) == 0) bFlag = TRUE;
			if (strcmp("areuni", cMapName) == 0) bFlag = TRUE;
			if (strcmp("arewrhus", cMapName) == 0) bFlag = TRUE;
			if (strcmp("bisle", cMapName) == 0)   bFlag = TRUE;
			if (strcmp("bsmith_1", cMapName) == 0) bFlag = TRUE;
			if (strcmp("bsmith_1f", cMapName) == 0) bFlag = TRUE;
			if (strcmp("bsmith_2", cMapName) == 0) bFlag = TRUE;
			if (strcmp("bsmith_2f", cMapName) == 0) bFlag = TRUE;
			if (strcmp("BtField", cMapName) == 0) bFlag = TRUE;
			if (strcmp("cath_1", cMapName) == 0) bFlag = TRUE;
			if (strcmp("cath_2", cMapName) == 0)      bFlag = TRUE;
			if (strcmp("CmdHall_1", cMapName) == 0) bFlag = TRUE;
			if (strcmp("CmdHall_2", cMapName) == 0) bFlag = TRUE;
			if (strcmp("default", cMapName) == 0) bFlag = TRUE;
			if (strcmp("dglv2", cMapName) == 0) bFlag = TRUE;
			if (strcmp("dglv3", cMapName) == 0) bFlag = TRUE;
			if (strcmp("dglv4", cMapName) == 0) bFlag = TRUE;
			if (strcmp("druncncity", cMapName) == 0) bFlag = TRUE; 
			if (strcmp("elvbrk12", cMapName) == 0) bFlag = TRUE;
			if (strcmp("elvfarm", cMapName) == 0) bFlag = TRUE;
			if (strcmp("elvine", cMapName) == 0)  bFlag = TRUE;
			if (strcmp("elvined1", cMapName) == 0)    bFlag = TRUE;
			if (strcmp("elvjail", cMapName) == 0)    bFlag = TRUE;
			if (strcmp("elvwrhus", cMapName) == 0) bFlag = TRUE;
			if (strcmp("fightzone1", cMapName) == 0) bFlag = TRUE;
			if (strcmp("fightzone2", cMapName) == 0) bFlag = TRUE;
			if (strcmp("fightzone3", cMapName) == 0) bFlag = TRUE;
			if (strcmp("fightzone4", cMapName) == 0) bFlag = TRUE;
			if (strcmp("fightzone5", cMapName) == 0) bFlag = TRUE;
			if (strcmp("fightzone6", cMapName) == 0) bFlag = TRUE;
			if (strcmp("fightzone7", cMapName) == 0) bFlag = TRUE;
			if (strcmp("fightzone8", cMapName) == 0) bFlag = TRUE;
			if (strcmp("fightzone9", cMapName) == 0) bFlag = TRUE;
			if (strcmp("GodH", cMapName) == 0)   bFlag = TRUE;
			if (strcmp("gshop_1", cMapName) == 0) bFlag = TRUE;
			if (strcmp("gshop_1f", cMapName) == 0) bFlag = TRUE;
			if (strcmp("gshop_2", cMapName) == 0)     bFlag = TRUE;
			if (strcmp("gshop_2f", cMapName) == 0)     bFlag = TRUE;
			if (strcmp("HRampart", cMapName) == 0)     bFlag = TRUE;
			if (strcmp("huntzone2", cMapName) == 0) bFlag = TRUE;
			if (strcmp("huntzone4", cMapName) == 0) bFlag = TRUE;
			if (strcmp("icebound", cMapName) == 0) bFlag = TRUE; 
			if (strcmp("inferniaA", cMapName) == 0) bFlag = TRUE; 
			if (strcmp("inferniaB", cMapName) == 0) bFlag = TRUE; 
			if (strcmp("maze", cMapName) == 0) bFlag = TRUE; 
			if (strcmp("middled1n", cMapName) == 0) bFlag = TRUE;
			if (strcmp("middled1x", cMapName) == 0) bFlag = TRUE;
			if (strcmp("middleland", cMapName) == 0) bFlag = TRUE;
			if (strcmp("penalty", cMapName) == 0) bFlag = TRUE;
			if (strcmp("procella", cMapName) == 0) bFlag = TRUE;
			if (strcmp("resurr1", cMapName) == 0) bFlag = TRUE;
			if (strcmp("resurr2", cMapName) == 0) bFlag = TRUE;
			if (strcmp("toh1", cMapName) == 0) bFlag = TRUE;
			if (strcmp("toh2", cMapName) == 0) bFlag = TRUE;
			if (strcmp("wrhus_1", cMapName) == 0) bFlag = TRUE;
			if (strcmp("wrhus_1f", cMapName) == 0) bFlag = TRUE;
			if (strcmp("wrhus_2", cMapName) == 0)     bFlag = TRUE;
			if (strcmp("wrhus_2f", cMapName) == 0)     bFlag = TRUE;
			if (strcmp("wzdtwr_1", cMapName) == 0) bFlag = TRUE;

			if (strcmp("toh3", cMapName) == 0) bFlag = TRUE;
			if (strcmp("Test", cMapName) == 0) bFlag = TRUE;
			if (strcmp("GMMap", cMapName) == 0) bFlag = TRUE;
			if (strcmp("fightzone10", cMapName) == 0) bFlag = TRUE;
//SNOOPY81 for Equilibrium
			if (m_bMapModeEquilibrium) {
				// Equilibrium maps
				if (strcmp("lost", cMapName) == 0) bFlag = TRUE;
				if (strcmp("bsmith_3", cMapName) == 0) bFlag = TRUE;
				if (strcmp("gshop_3", cMapName) == 0)     bFlag = TRUE;
				if (strcmp("catacombs", cMapName) == 0) bFlag = TRUE;
				if (strcmp("qusmarsh", cMapName) == 0) bFlag = TRUE;
				if (strcmp("stadium", cMapName) == 0) bFlag = TRUE;
				if (strcmp("asgarde", cMapName) == 0) bFlag = TRUE;
//SNOOPY: Easier GM TP...
	if (strcmp("QM", cMapName) == 0)	{ strcpy(cMapName,"qusmarsh"); bFlag = TRUE;}
	if (strcmp("Garden", cMapName) ==0) { strcpy(cMapName,"areuni"); bFlag = TRUE;}
	if (strcmp("WWH", cMapName) == 0)	{ strcpy(cMapName,"elvwrhus"); bFlag = TRUE;}
	if (strcmp("WH", cMapName) == 0)	{ strcpy(cMapName,"arewrhus"); bFlag = TRUE;}
	if (strcmp("BS", cMapName) == 0)	{ strcpy(cMapName,"bsmith_3"); bFlag = TRUE;}
	if (strcmp("Shop", cMapName) == 0)	{ strcpy(cMapName,"gshop_3"); bFlag = TRUE;}
			}else {
				// Maps not hosted on Equilibrium mode
				if (strcmp("cityhall_1", cMapName) == 0) bFlag = TRUE;
				if (strcmp("cityhall_2", cMapName) == 0) bFlag = TRUE;
				if (strcmp("gldhall_1",  cMapName) == 0) bFlag = TRUE;
				if (strcmp("gldhall_2",  cMapName) == 0) bFlag = TRUE;
				if (strcmp("wzdtwr_2",   cMapName) == 0) bFlag = TRUE;

				if (strcmp("elvbrk11", cMapName) == 0) bFlag = TRUE;
				if (strcmp("arebrk11", cMapName) == 0) bFlag = TRUE;
				if (strcmp("arebrk21", cMapName) == 0) bFlag = TRUE;
				if (strcmp("arebrk22", cMapName) == 0) bFlag = TRUE;
				if (strcmp("elvbrk21", cMapName) == 0) bFlag = TRUE;
				if (strcmp("elvbrk22", cMapName) == 0) bFlag = TRUE;

				if (strcmp("huntzone1", cMapName) == 0) bFlag = TRUE;
				if (strcmp("huntzone3", cMapName) == 0) bFlag = TRUE;
				if (strcmp("elvuni",	cMapName) == 0) bFlag = TRUE;

//				if (strcmp("aremidl", cMapName) == 0) bFlag = TRUE;
//				if (strcmp("aremidr", cMapName) == 0) bFlag = TRUE;
//				if (strcmp("elvmidl", cMapName) == 0) bFlag = TRUE;
//				if (strcmp("elvmidr", cMapName) == 0) bFlag = TRUE;
			}
//SNOOPY: Easier GM TP...
	if (strcmp("ML", cMapName) == 0)	{ strcpy(cMapName,"middleland"); bFlag = TRUE;}
	if (strcmp("PL", cMapName) == 0)	{ strcpy(cMapName,"2ndmiddle"); bFlag = TRUE;}
	if (strcmp("BI", cMapName) == 0)	{ strcpy(cMapName,"bisle"); bFlag = TRUE;}
	if (strcmp("IB", cMapName) == 0)	{ strcpy(cMapName,"icebound"); bFlag = TRUE;}
	if (strcmp("EF", cMapName) == 0)	{ strcpy(cMapName,"huntzone2"); bFlag = TRUE;}
	if (strcmp("SW", cMapName) == 0)	{ strcpy(cMapName,"huntzone4"); bFlag = TRUE;}
			//Defines I as Max clients
				if (bFlag == TRUE)
				{	//Reqeust the Push/Teleport
					wsprintf(G_cTxt,"GM Order(%-10s): /push (%s) to [%s](%d,%d)"
						, m_pClientList[iClientH]->m_cCharName, m_pClientList[i]->m_cCharName, cMapName, dX, dY);
					bSendMsgToLS(MSGID_GAMEMASTERLOG, iClientH, FALSE, G_cTxt);
					RequestTeleportHandler(i, "2   ", cMapName, dX, dY);  
				}	
				delete pStrTok;
				return;
			}
	}
	delete pStrTok;
}

void CGame::AdminOrder_SummonGuild(int iClientH, char *pData, DWORD dwMsgSize)
{char   seps[] = "= \t\n";
 char   * token, * cp, cBuff[256], cMapName[11]; 
 char cGuildName[20]; 
 WORD   *wp;
 int    pX, pY, i;
 class  CStrTok * pStrTok;
 DWORD  dwGoldCount;
	if (m_pClientList[iClientH] == NULL) return;
	if ((dwMsgSize) <= 0) return;
	if (   (m_pClientList[iClientH]->m_iAdminUserLevel < m_iAdminLevelSummonGuild)
		&& (m_pClientList[iClientH]->m_iAdminUserLevel != 0))
	{	SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_ADMINUSERLEVELLOW, NULL, NULL, NULL, NULL);
		return;
	}
	if (m_pClientList[iClientH]->m_iAdminUserLevel == 0) // Check if gm:
	{	if (m_pClientList[iClientH]->m_iGuildRank != 0) return;		
		dwGoldCount = dwGetItemCount(iClientH, "Gold");  // dwGoldCount = player gold
		if (m_iSummonGuildCost > dwGoldCount) 
		{	return;
		}else	// if summonguildcost is less than player gold
		{	SetItemCount(iClientH, "Gold", dwGoldCount - m_iSummonGuildCost); // reduce gold by summonguildcost			
		}
	}else
	{	wsprintf(G_cTxt, "GM Order(%-10s): /summonguild (%s)", m_pClientList[iClientH]->m_cCharName, m_pClientList[iClientH]->m_cGuildName);
		bSendMsgToLS(MSGID_GAMEMASTERLOG, iClientH, FALSE, G_cTxt);
	}
	ZeroMemory(cBuff, sizeof(cBuff));
	memcpy(cBuff, pData, dwMsgSize);
	pStrTok = new class CStrTok(cBuff, seps);
	token = pStrTok->pGet();
	token = pStrTok->pGet();
	if (token == NULL) 
	{	delete pStrTok;
		return;
	}
	pX = m_pClientList[iClientH]->m_sX;
	pY = m_pClientList[iClientH]->m_sY;
	ZeroMemory(cMapName, sizeof(cMapName));
	memcpy(cMapName, m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cName, 11);
	ZeroMemory(cGuildName, sizeof(cGuildName));
	if (strlen(token) > 20)
			memcpy(cGuildName, token, 20);
		else memcpy(cGuildName, token, strlen(token));
	for (i = 0; i < DEF_MAXCLIENTS; i++)
	if ((m_pClientList[i] != NULL) && (strcmp(m_pClientList[i]->m_cGuildName, token) == 0)) 
	{	wsprintf(G_cTxt,"PC(%s) summoned by Guild(%s) to %s.", m_pClientList[i]->m_cCharName, cGuildName, cMapName);
		PutLogList(G_cTxt);
		RequestTeleportHandler(i, "2   ", cMapName, pX, pY);		
	}
	wsprintf(G_cTxt,"Guild(%s) summoned by PC(%s) to %s.", cGuildName, m_pClientList[iClientH]->m_cCharName, cMapName);
	PutLogList(G_cTxt);
	ZeroMemory(cBuff, sizeof(cBuff));
	cp = (char *)cBuff;
	*cp = GSM_REQUEST_SUMMONGUILD;
	cp++;
	memcpy(cp, cGuildName, 20);
	cp += 20;
	memcpy(cp, cMapName, 10);
	cp += 10;
	wp = (WORD *)cp;
	*wp = m_pClientList[iClientH]->m_sX;
	cp += 2;
	wp = (WORD *)cp;
	*wp = m_pClientList[iClientH]->m_sY;
	cp += 2;
	bStockMsgToGateServer(cBuff, 35);
	delete pStrTok;
}

void CGame::SendCollectedMana()
{char * cp, cData[120];
 WORD * wp;
	//SendMsgToGateServer(MSGID_COLLECTEDMANA, NULL);
	if ((m_iCollectedMana[1] == 0) && (m_iCollectedMana[2] == 0)) return;
	//testcode
	//wsprintf(G_cTxt, "Sending Collected Mana: Aresden->%d  Elvine->%d", m_iCollectedMana[1], m_iCollectedMana[2]);
	//PutLogList(G_cTxt);
	ZeroMemory(cData, sizeof(cData));
	cp = (char *)(cData);
	*cp = GSM_COLLECTEDMANA;
	cp++;
	wp = (WORD *)cp;
	*wp = (WORD)m_iCollectedMana[1];
	cp += 2;
	wp = (WORD *)cp;
	*wp = (WORD)m_iCollectedMana[2];
	cp += 2;
	CollectedManaHandler(m_iCollectedMana[1], m_iCollectedMana[2]);
	bStockMsgToGateServer(cData, 5);	
	
	m_iLastSentAresdenMana = m_iCollectedMana[1];
	m_iLastSentElvineMana = m_iCollectedMana[2];
	m_iCollectedMana[0] = 0;
	m_iCollectedMana[1] = 0;
	m_iCollectedMana[2] = 0;
}

void CGame::CollectedManaHandler(WORD wAresdenMana, WORD wElvineMana)
{	if (m_iAresdenMapIndex != -1) 
	{	m_iAresdenMana += wAresdenMana;
		if (wAresdenMana > 0) 
		{	wsprintf(G_cTxt, "Aresden Mana: +%d Total:%d", wAresdenMana, m_iAresdenMana);
			PutLogEventFileList(G_cTxt);
		}
	}
	if (m_iElvineMapIndex != -1) 
	{	m_iElvineMana += wElvineMana;
		if (wElvineMana > 0) 
		{	wsprintf(G_cTxt, "Elvine Mana: +%d Total:%d", wElvineMana, m_iElvineMana);
			PutLogEventFileList(G_cTxt);
		}
	}
}
//New Changed 11/05/2004
// v2.15
void CGame::CalcMeteorStrikeEffectHandler(int iMapIndex)
{int i, iActiveStructure, iStructureHP[DEF_MAXSTRIKEPOINTS] ;
 char * cp, * cp2, cData[120], cWinnerSide, cTempData[120];
 WORD * wp;
	if (m_bIsCrusadeMode == FALSE) return;
	for(i = 0 ; i < DEF_MAXSTRIKEPOINTS; i++)
		iStructureHP[i] = 0 ;
	iActiveStructure = 0;
	for (i = 1; i <= m_pMapList[iMapIndex]->m_iTotalStrikePoints; i++) {
		if (m_pMapList[iMapIndex]->m_stStrikePoint[i].iHP > 0) {
			iActiveStructure++;
			iStructureHP[i] = m_pMapList[iMapIndex]->m_stStrikePoint[i].iHP ;
		}
	}
	// SNOOPY
	if (DEF_MAXSTRIKEPOINTS >6)
	{	wsprintf(G_cTxt, "ActiveStructure:%d  MapIndex:%d Life: %d %d %d %d %d %d"
			, iActiveStructure
			, iMapIndex
			, iStructureHP[1]
			, iStructureHP[2]
			, iStructureHP[3]
			, iStructureHP[4]
			, iStructureHP[5]
			, iStructureHP[6]);
		PutLogList(G_cTxt);		
		PutLogEventFileList(G_cTxt);
	}
	if (iActiveStructure == 0) 
	{	if (iMapIndex == m_iAresdenMapIndex) 
		{	cWinnerSide = 2;
			LocalEndCrusadeMode(2); // No more Active structures at Aresden => Elvines wins
			_bCrusadeLog(DEF_CRUSADELOG_ENDCRUSADE, FALSE, FALSE, "Elvine Wictory!");
		}else
		{	if (iMapIndex == m_iElvineMapIndex) 
			{	cWinnerSide = 1;
				LocalEndCrusadeMode(1); // No more Active structures at Elvines => Aresden wins
				_bCrusadeLog(DEF_CRUSADELOG_ENDCRUSADE, FALSE, FALSE, "Aresden Wictory!");
			}else 
			{	cWinnerSide = 0;
				LocalEndCrusadeMode(0); 	
				_bCrusadeLog(DEF_CRUSADELOG_ENDCRUSADE, FALSE, FALSE, "Draw!");
			}
		}
		ZeroMemory(cData, sizeof(cData));
		cp = (char *)(cData);
		*cp =  GSM_ENDCRUSADE;
		cp++;
		*cp = cWinnerSide;
		cp++;
		wp  = (WORD *)cp;
		*wp = m_stMeteorStrikeResult.iCrashedStructureNum;
		cp += 2;
		wp  = (WORD *)cp;
		*wp = m_stMeteorStrikeResult.iStructureDamageAmount;
		cp += 2;
		wp  = (WORD *)cp;
		*wp = m_stMeteorStrikeResult.iCasualties;
		cp += 2;
		memcpy(cp, m_pMapList[iMapIndex]->m_cName, 10);
		cp += 10;
		bStockMsgToGateServer(cData, 18);
	}else // some structures still remain
	{	ZeroMemory(cData, sizeof(cData));
		cp = (char *)(cData);
		*cp =  GSM_GRANDMAGICRESULT;
		cp++;		
		memcpy(cp, m_pMapList[iMapIndex]->m_cName, 10);
		cp += 10;
		wp  = (WORD *)cp;
		*wp = m_stMeteorStrikeResult.iCrashedStructureNum;
		cp += 2;
		wp  = (WORD *)cp;
		*wp = m_stMeteorStrikeResult.iStructureDamageAmount;
		cp += 2;
		wp  = (WORD *)cp;
		*wp = m_stMeteorStrikeResult.iCasualties;
		cp += 2;
		wp  = (WORD *)cp;
		*wp = (WORD) iActiveStructure;
		cp += 2;
		ZeroMemory(cTempData, sizeof(cTempData));
		cp2 = (char *)(cTempData); 
		wp = (WORD *)cp2;
		*wp = (WORD) m_pMapList[iMapIndex]->m_iTotalStrikePoints;
		cp2 += 2;
		for (i = 1; i <= m_pMapList[iMapIndex]->m_iTotalStrikePoints;i++)
		{	wp = (WORD *)cp2;
			*wp = (WORD) iStructureHP[i];
			cp2 += 2;
		}
		memcpy(cp,cTempData,2*(m_pMapList[iMapIndex]->m_iTotalStrikePoints+1) ) ;
		bStockMsgToGateServer(cData, 18 + (m_pMapList[iMapIndex]->m_iTotalStrikePoints+1)*2 );
		GrandMagicResultHandler(m_pMapList[iMapIndex]->m_cName, m_stMeteorStrikeResult.iCrashedStructureNum, m_stMeteorStrikeResult.iStructureDamageAmount, m_stMeteorStrikeResult.iCasualties, iActiveStructure,m_pMapList[iMapIndex]->m_iTotalStrikePoints, cTempData);
	}
	m_stMeteorStrikeResult.iCasualties            = 0;
	m_stMeteorStrikeResult.iCrashedStructureNum   = 0;
	m_stMeteorStrikeResult.iStructureDamageAmount = 0;
}

void CGame::_LinkStrikePointMapIndex()
{
 int i, z, x;

	for (i = 0; i < DEF_MAXMAPS; i++)
	if ((m_pMapList[i] != NULL) && (m_pMapList[i]->m_iTotalStrikePoints != 0)) {
		for (z = 0; z < DEF_MAXSTRIKEPOINTS; z++) 
		if (strlen(m_pMapList[i]->m_stStrikePoint[z].cRelatedMapName) != 0) {
			for (x = 0; x < DEF_MAXMAPS; x++) 
			if ((m_pMapList[x] != NULL) && (strcmp(m_pMapList[x]->m_cName,m_pMapList[i]->m_stStrikePoint[z].cRelatedMapName) == 0)) {
				m_pMapList[i]->m_stStrikePoint[z].iMapIndex = x;
				//testcode
				wsprintf(G_cTxt, "(!) Map(%s) Strike Point(%d) Related Map(%s) Index(%d)", m_pMapList[i]->m_cName, z, m_pMapList[i]->m_stStrikePoint[z].cRelatedMapName, x);
				PutLogList(G_cTxt);
				//PutLogEventFileList(G_cTxt);
				goto LSPMI_LOOPBREAK;
			}
LSPMI_LOOPBREAK:;
		}
	}
}

BOOL CGame::_bRegisterMap(char * pName)
{int i;
 char cTmpName[11], cTxt[120];
	ZeroMemory(cTmpName, sizeof(cTmpName));
	strcpy(cTmpName, pName);
	for (i = 0; i < DEF_MAXMAPS; i++)
	if ((m_pMapList[i] != NULL) && (memcmp(m_pMapList[i]->m_cName, cTmpName, 10) == 0)) 
	{	wsprintf(cTxt, "(!!!) CRITICAL ERROR! Map (%s) Duplicate map name.", cTmpName);
		PutLogList(cTxt);	return FALSE;
	}
	for (i = 0; i < DEF_MAXMAPS; i++)
	if (m_pMapList[i] == NULL) 
	{	m_pMapList[i] = (class CMap *)new class CMap(this);
		wsprintf(cTxt, "(*) Add map (%s)   - Reading %s.amd...", pName, pName);
		PutLogList(cTxt);
		if (m_pMapList[i]->bInit(pName) == FALSE) 
		{	wsprintf(cTxt, "(!!!) CRITICAL ERROR! Map (%s) Failed reading %s.amd.", pName, pName);
			PutLogList(cTxt);	return FALSE;	
		};		
		//PutLogList("(*) Map list loading success.");		
		if ((m_iMiddlelandMapIndex == -1) && (strcmp("middleland", pName) == 0)) 
			m_iMiddlelandMapIndex = i;
		if ((m_iAresdenMapIndex == -1) && (strcmp("aresden", pName) == 0)) 
			m_iAresdenMapIndex = i;
		if ((m_iElvineMapIndex == -1)  && (strcmp("elvine", pName) == 0)) 
			m_iElvineMapIndex = i;
		if ((m_iBTFieldMapIndex == -1) && (strcmp("BtField", pName) == 0)) 
			m_iBTFieldMapIndex = i;
		if ((m_iRampartMapIndex == -1) && (strcmp("HRampart", pName) == 0)) 			
			m_iRampartMapIndex	  = i;
		if ((m_iGodHMapIndex == -1)    && (strcmp("GodH", pName) == 0)) 
			m_iGodHMapIndex = i;
		//Avatar
		if ((m_iPLmapIndex == -1)      && (strcmp("2ndmiddle", pName) == 0)) 
			m_iPLmapIndex = i;
		m_iTotalMaps++;
		return TRUE;
	}
	wsprintf(cTxt, "(!!!) CRITICAL ERROR! Map (%s) Too much maps.", pName);
	PutLogList(cTxt); return FALSE;
}

//New Changed 11/05/2004
void CGame::GrandMagicResultHandler(char *cMapName, int iCrashedStructureNum, int iStructureDamageAmount, int iCasualities, int iActiveStructure, int iTotalStrikePoints, char * cData)
{ int i;	
	for (i = 1; i < DEF_MAXCLIENTS; i++)
	if (m_pClientList[i] != NULL) 
	{	SendNotifyMsg(NULL, i, DEF_NOTIFY_GRANDMAGICRESULT, iCrashedStructureNum, iStructureDamageAmount, iCasualities, cMapName, iActiveStructure, NULL, NULL, NULL, NULL, iTotalStrikePoints, cData);
	}
}

void CGame::AdminOrder_CheckStatus(int iClientH, char *pData,DWORD dwMsgSize)
{char cStatMessage[256];
 char   seps[] = "= \t\n";
 char   cBuff[256];
 class  CStrTok * pStrTok;
 char   * token, cName[11], cTargetName[11];
 register int i;
	if (m_pClientList[iClientH] == NULL) return;
	if (m_pClientList[iClientH]->m_iAdminUserLevel < m_iAdminLevelCheckStatus) 
	{	SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_ADMINUSERLEVELLOW, NULL, NULL, NULL, NULL);
		return;
	}
	if ((dwMsgSize)	<= 0) return;
	ZeroMemory(cTargetName, sizeof(cTargetName));
	ZeroMemory(cBuff, sizeof(cBuff));
	memcpy(cBuff, pData, dwMsgSize);
	pStrTok = new class CStrTok(cBuff, seps);
	token = pStrTok->pGet();
	token = pStrTok->pGet();		
	if (token != NULL) 
	{	ZeroMemory(cName, sizeof(cName));
		strcpy(cName, token);
	}else 
	{	ZeroMemory(cName, sizeof(cName));
		strcpy(cName, "null");
	}
	token = pStrTok->pGet();		
	if (token == NULL) 
	{ 	token = "null"; 
	}		
	if (cName != NULL) 
	{	token = cName;
		if (strlen(token) > 10) 
			memcpy(cTargetName, token, 10);
		else memcpy(cTargetName, token, strlen(token));
		for (i = 1; i < DEF_MAXCLIENTS; i++)
		if ((m_pClientList[i] != NULL) && (memcmp(m_pClientList[i]->m_cCharName, cTargetName, 10) == 0)) 
		{	ZeroMemory(cStatMessage, sizeof(cStatMessage));
			wsprintf(cStatMessage, " Str:%d Dex:%d Vit:%d Int:%d Mag:%d Chr:%d", m_pClientList[i]->m_iStr,  m_pClientList[i]->m_iDex, m_pClientList[i]->m_iVit, m_pClientList[i]->m_iInt,m_pClientList[i]->m_iMag, m_pClientList[i]->m_iCharisma);
			ShowClientMsg(iClientH, cTargetName, cStatMessage);
			AdminOrder_CheckStats(iClientH,i);	
			wsprintf(G_cTxt,"GM Order(%-10s): /checkstatus %s", m_pClientList[iClientH]->m_cCharName, cTargetName);
			bSendMsgToLS(MSGID_GAMEMASTERLOG, iClientH, FALSE, G_cTxt);
	}	}
	delete pStrTok;
}

// check if upgrade success
BOOL CGame::bCheckIsItemUpgradeSuccess(int iClientH, int iItemIndex, int iSomH, BOOL bBonus)
{
	int iValue, iProb, iResult;
	if (m_pClientList[iClientH]->m_pItemList[iSomH] == NULL) return FALSE;

	iValue = (m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwAttribute & 0x0F0000000) >> 28;

	switch (iValue) {// Depends on alreaddy existing + of item
	case 0: iProb = 30; break;  // +1 :90%     +1~+2
	case 1: iProb = 25; break;  // +2 :80%      +3
	case 2: iProb = 20; break;  // +3 :48%      +4 
	case 3: iProb = 15; break;  // +4 :24%      +5
	case 4: iProb = 10; break;  // +5 :9.6%     +6
	case 5: iProb = 10; break;  // +6 :2.8%     +7
	case 6: iProb =  8; break;  // +7 :0.57%    +8
	case 7: iProb =  8; break;  // +8 :0.05%    +9
	case 8: iProb =  5; break;  // +9 :0.004%   +10
	case 9: iProb =  3; break;  // +10:0.00016%
	default: iProb = 1; break;
	}
	// Mabuf Items have a success bonus
	if (   ((m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwAttribute & 0x00000001) != NULL) 
		&& (m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sItemSpecEffectValue2 > 100)) {	
		if (iProb > 20) 
			iProb += (m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sItemSpecEffectValue2 / 10);
		else if (iProb > 7) 
			iProb += (m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sItemSpecEffectValue2 / 20);
		else
			iProb += (m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sItemSpecEffectValue2 / 40);
	}
	if ( bBonus == TRUE) iProb *=2 ;
	iProb *= 100;
	iResult = iDice(1,10000);
	if (iProb >= iResult) { 
		_bItemLog(DEF_ITEMLOG_UPGRADESUCCESS, iClientH, (int) -1, m_pClientList[iClientH]->m_pItemList[iItemIndex], TRUE);
		return TRUE;
	}
	_bItemLog(DEF_ITEMLOG_UPGRADEFAIL, iClientH, (int) -1, m_pClientList[iClientH]->m_pItemList[iItemIndex], TRUE);
	return FALSE;
}

BOOL CGame::bReadAdminListConfigFile(char *pFn)
{FILE * pFile;
 HANDLE hFile;
 DWORD  dwFileSize;
 char * cp, * token, cReadModeA, cReadModeB;
 char seps[] = "= \t\n";
 class CStrTok * pStrTok;
 int   iIndex;
 char len;
	cReadModeA = 0;
	cReadModeB = 0;
	iIndex = 0;	
	for (int i = 0; i < DEF_MAXADMINS; i++)
	{	ZeroMemory(m_stAdminList[i].m_cGMName, sizeof(m_stAdminList[i].m_cGMName));
	}
	hFile = CreateFile(pFn, GENERIC_READ, NULL, NULL, OPEN_EXISTING, NULL, NULL);
	dwFileSize = GetFileSize(hFile, NULL);
	if (hFile != INVALID_HANDLE_VALUE) CloseHandle(hFile);
	pFile = fopen(pFn, "rt");
	if (pFile == NULL) 
	{	PutLogList("(!) Cannot open AdminList.cfg file.");
		return FALSE;
	}else 
	{	PutLogList("(!) Reading AdminList.cfg...");
		cp = new char[dwFileSize+2];
		ZeroMemory(cp, dwFileSize+2);
		fread(cp, dwFileSize, 1, pFile);
		pStrTok = new class CStrTok(cp, seps);
		token = pStrTok->pGet();
		while( token != NULL )   {
			if (cReadModeA != 0) {
				switch (cReadModeA) {
				case 1: if (iIndex >= DEF_MAXADMINS) 
						{	PutLogList("(!) WARNING! Too many GMs on the AdminList.cfg!"); 
							delete pStrTok;
							delete cp;
							return TRUE;
						}
						len = strlen(token);
						if(len > 10) len = 10;
						ZeroMemory(m_stAdminList[iIndex].m_cGMName, sizeof(m_stAdminList[iIndex].m_cGMName));
						memcpy(m_stAdminList[iIndex].m_cGMName, token, strlen(token));
						iIndex++;
						cReadModeA = 0;
						cReadModeB = 0;
						break;
				}
			}else 
			{	if (memcmp(token, "verified-admin", 14) == 0) 
				{	cReadModeA = 1;
					cReadModeB = 1;
				}
			}			
			token = pStrTok->pGet();
		}
		delete pStrTok;
		delete cp;
	}
	if (pFile != NULL) fclose(pFile);
	return TRUE;
}

BOOL CGame::bReadBannedListConfigFile(char *pFn)
{FILE * pFile;
 HANDLE hFile;
 DWORD  dwFileSize;
 char * cp, * token, cReadModeA, cReadModeB;
 char seps[] = "= \t\n";
 class CStrTok * pStrTok;
 int   iIndex;
 char len;
	cReadModeA = 0;
	cReadModeB = 0;
	iIndex = 0;
	for (int i = 0; i < DEF_MAXBANNED; i++) 
	{	ZeroMemory(m_stBannedList[i].m_cBannedIPaddress, sizeof(m_stBannedList[i].m_cBannedIPaddress));
	}	
	hFile = CreateFile(pFn, GENERIC_READ, NULL, NULL, OPEN_EXISTING, NULL, NULL);
	dwFileSize = GetFileSize(hFile, NULL);
	if (hFile != INVALID_HANDLE_VALUE) CloseHandle(hFile);
	pFile = fopen(pFn, "rt");
	if (pFile == NULL) 
	{	PutLogList("(!) Cannot open BannedList.cfg file.");
		return FALSE;
	}else 
	{	PutLogList("(!) Reading BannedList.cfg...");
		cp = new char[dwFileSize+2];
		ZeroMemory(cp, dwFileSize+2);
		fread(cp, dwFileSize, 1, pFile);
		pStrTok = new class CStrTok(cp, seps);
		token = pStrTok->pGet();
		while( token != NULL )   
		{	if (cReadModeA != 0) 
			{	switch (cReadModeA) {
				case 1:
					if (iIndex >= DEF_MAXBANNED) 
					{	PutLogList("(!) WARNING! Too many banned on the BannedList.cfg!"); 
						delete pStrTok;
						delete cp;
						return TRUE;
					}
					len = strlen(token);
					if(len > 20) len = 20;
					ZeroMemory(m_stBannedList[iIndex].m_cBannedIPaddress, sizeof(m_stBannedList[iIndex].m_cBannedIPaddress));
					memcpy(m_stBannedList[iIndex].m_cBannedIPaddress, token, strlen(token));
					iIndex++;
					cReadModeA = 0;
					cReadModeB = 0;
					break;
				}
			}else 
			{	if (memcmp(token, "banned-ip", 9) == 0) 
				{	cReadModeA = 1;
					cReadModeB = 1;
				}
			}			
			token = pStrTok->pGet();
		}
		delete pStrTok;
		delete cp;
	}
	if (pFile != NULL) fclose(pFile);
	return TRUE;
}

void CGame::AdminOrder_CleanMap(int iClientH, char * pData, DWORD dwMsgSize)
{	// Revoves everything on the ground
	char   seps[] = "= \t\n";
	class  CStrTok * pStrTok;
	char   * token, cMapName[11], cBuff[256];
	BOOL bFlag = FALSE;	
	int i, m_x, m_y, iMapIndex;
	CItem *pItem;
	short sRemainItemSprite, sRemainItemSpriteFrame;
	char cRemainItemColor;
	if (m_pClientList[iClientH] == NULL) return;
	if ((dwMsgSize)	<= 0) return;
	if (m_pClientList[iClientH]->m_iAdminUserLevel < m_iAdminLevelCleanMap) 
	{	SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_ADMINUSERLEVELLOW, NULL, NULL, NULL, NULL);
		return;
	}
	ZeroMemory(cBuff, sizeof(cBuff));
	memcpy(cBuff, pData, dwMsgSize);
	pStrTok = new class CStrTok(cBuff, seps);
	token = pStrTok->pGet();
	token = pStrTok->pGet();

	ZeroMemory(cMapName, sizeof(cMapName));
	if (token != NULL) 
	{	strcpy(cMapName, token);
		iMapIndex = -1;
		for (i = 0; i < DEF_MAXMAPS; i++)	//Enum all maps
		{	if (m_pMapList[i] != NULL) 	//Is allocated map
			{	if (   (memcmp(m_pMapList[i]->m_cName, cMapName, 10) == 0) 	//is map same name
					&& (strlen(cMapName)>2))
				{	bFlag = TRUE; //Set flag
					iMapIndex = i;
					break;	//Break maps loop	
		}	}	}	
		if (iMapIndex == -1)
		{	strcpy(cMapName, m_pClientList[iClientH]->m_cMapName);
			iMapIndex = m_pClientList[iClientH]->m_cMapIndex;
		}
	}else		
	{	strcpy(cMapName, m_pClientList[iClientH]->m_cMapName);
		iMapIndex = m_pClientList[iClientH]->m_cMapIndex;
	}
	m_x = m_pMapList[iMapIndex]->m_sSizeX; //Get X and Y coords
	m_y = m_pMapList[iMapIndex]->m_sSizeY;
	for(int j = 1; j < m_x; j++)
	for(int k = 1; k < m_y; k++)
	{	do 	//Delete all items on current tile
		{	pItem = m_pMapList[iMapIndex]->pGetItem(j, k, &sRemainItemSprite, &sRemainItemSpriteFrame, &cRemainItemColor);
			if (pItem != NULL) { delete pItem; }//Delete item;
		}while (pItem != NULL);
	}

	wsprintf(G_cTxt,"GM Order(%-10s): /cleanmap (%s)", m_pClientList[iClientH]->m_cCharName, cMapName);
	bSendMsgToLS(MSGID_GAMEMASTERLOG, iClientH, FALSE, G_cTxt);
	// Teleport everybody again on his own position
	for(i = 1; i < DEF_MAXCLIENTS; i++)
	{	if (m_pClientList[i] != NULL) 
		{	if (m_pClientList[i]->m_cMapIndex == iMapIndex)
			{	RequestTeleportHandler(i,"2   ", m_pClientList[i]->m_cMapName, m_pClientList[i]->m_sX, m_pClientList[i]->m_sY);
	}	}	}
	// Admin Log
	wsprintf(G_cTxt, "Admin Order(%s): ClearMap\tAdminIP(%s)"
		, m_pClientList[iClientH]->m_cCharName
		, m_pClientList[iClientH]->m_cIPaddress);
	PutAdminLogFileList(G_cTxt);		// Admin Log
	wsprintf(G_cTxt, " Cleared all items on ground at %s.", cMapName);							
	ShowClientMsg(iClientH,  "Clean map", G_cTxt);
	delete pStrTok;
	return;
}
void CGame::AdminOrder_CleanBumps(int iClientH, char * pData, DWORD dwMsgSize)
{	// Free all owner empty pointer
	char   seps[] = "= \t\n";
	class  CStrTok * pStrTok;
	class CTile* pTile;
	char   * token, cMapName[11], cBuff[256];
	BOOL bFlag = FALSE;	
	int i, m_x, m_y, iMapIndex;
	if (m_pClientList[iClientH] == NULL) return;
	if ((dwMsgSize)	<= 0) return;
	if (m_pClientList[iClientH]->m_iAdminUserLevel < m_iAdminLevelCleanMap) 
	{	SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_ADMINUSERLEVELLOW, NULL, NULL, NULL, NULL);
		return;
	}
	ZeroMemory(cBuff, sizeof(cBuff));
	memcpy(cBuff, pData, dwMsgSize);
	pStrTok = new class CStrTok(cBuff, seps);
	token = pStrTok->pGet();
	token = pStrTok->pGet();

	ZeroMemory(cMapName, sizeof(cMapName));
	if (token != NULL) 
	{	strcpy(cMapName, token);
		iMapIndex = -1;
		for (i = 0; i < DEF_MAXMAPS; i++)	//Enum all maps
		{	if (m_pMapList[i] != NULL) 	//Is allocated map
			{	if (   (memcmp(m_pMapList[i]->m_cName, cMapName, 10) == 0) 	//is map same name
					&& (strlen(cMapName)>2))
				{	bFlag = TRUE; //Set flag
					iMapIndex = i;
					break;	//Break maps loop	
		}	}	}	
		if (iMapIndex == -1)
		{	strcpy(cMapName, m_pClientList[iClientH]->m_cMapName);
			iMapIndex = m_pClientList[iClientH]->m_cMapIndex;
		}
	}else		
	{	strcpy(cMapName, m_pClientList[iClientH]->m_cMapName);
		iMapIndex = m_pClientList[iClientH]->m_cMapIndex;
	}
	m_x = m_pMapList[iMapIndex]->m_sSizeX;  // Get X and Y coords
	m_y = m_pMapList[iMapIndex]->m_sSizeY;
	int iCompteurNul = 0;
	int iCompteurPla = 0;
	int iCompteurMob = 0;
	int iCompteurOth = 0;
	int iCompteurUnk = 0;
	for(int j = 1; j < m_x; j++)			// Then, hunt any empty owner pointer
	for(int k = 1; k < m_y; k++)
	{	pTile = (class CTile *)(m_pMapList[iMapIndex]->m_pTile + j + k*m_y);
		/*if ((pTile != NULL) && (pTile->m_sOwner != NULL) && (pTile->m_cOwnerClass == NULL))
		{	pTile->m_sOwner = NULL;
			iCompteurNul ++;
		}*/	
		if ((pTile != NULL) && (pTile->m_sOwner != NULL))
		{	switch (pTile->m_cOwnerClass) {
			case NULL:
				pTile->m_sOwner = NULL;
				iCompteurNul ++;
				break;

			case DEF_OWNERTYPE_PLAYER:					
				if (m_pClientList[pTile->m_sOwner] == NULL)
				{	wsprintf(G_cTxt, "ClearBumps: NULL PC");
					PutLogList(G_cTxt);	
					wsprintf(G_cTxt, "NULL PC");	
					ShowClientMsg(iClientH,  "CleanBumps", G_cTxt);
					iCompteurPla ++;
					pTile->m_sOwner = NULL;
					break;
				}else if (m_pClientList[pTile->m_sOwner]->m_cMapIndex != iMapIndex)
				{	wsprintf(G_cTxt, "ClearBumps: PC(%s) still on wrong map (%s). \t%s(%d %d)\tIP(%s)"						
						, m_pClientList[i]->m_cCharName
						, m_pMapList[iMapIndex]->m_cName
						, m_pClientList[i]->m_cMapName
						, m_pClientList[i]->m_sX
						, m_pClientList[i]->m_sY
						, m_pClientList[i]->m_cIPaddress);
					PutAdminLogFileList(G_cTxt);
					PutLogList(G_cTxt);	
					wsprintf(G_cTxt, "CPC(%s) on wrong map (%s)."						
						, m_pClientList[i]->m_cCharName
						, m_pClientList[i]->m_cMapName);	
					ShowClientMsg(iClientH,  "CleanBumps", G_cTxt);
					iCompteurPla ++;
					pTile->m_sOwner = NULL;
					//DeleteClient(i, TRUE, TRUE);
					break;
				}
				break;

			case DEF_OWNERTYPE_NPC: // 2
				if (m_pNpcList[pTile->m_sOwner] == NULL) 			
				{	wsprintf(G_cTxt, "NULL Mob");	
					ShowClientMsg(iClientH,  "ClearBumps", G_cTxt);
					iCompteurMob ++;
					pTile->m_sOwner = NULL;	
				}
				break;

			case DEF_OWNERTYPE_PLAYER_INDIRECT: //	3
			case DEF_OWNERTYPE_PLAYER_WAITING: // 	8 // Snoopy: added to wait for the player connecting again...
			case DEF_OWNERTYPE_PLAYER_FREE: // 		9 // Snoopy: added for every player to take over this summon
				if (m_pNpcList[pTile->m_sOwner] == NULL) 			
				{	wsprintf(G_cTxt, "NULL Exotic OwnerClass");	
					ShowClientMsg(iClientH,  "ClearBumps", G_cTxt);
					iCompteurOth ++;
					pTile->m_sOwner = NULL;	
				}
				break;

			default:
				wsprintf(G_cTxt, "Unknown Tile OwnerClass (%d)", pTile->m_cOwnerClass);	
				ShowClientMsg(iClientH,  "CleanBumps", G_cTxt);
				iCompteurUnk ++;
				pTile->m_sOwner = NULL;	
				break;
	}	}	}

	wsprintf(G_cTxt,"GM Order(%-10s): /cleanbumps (%s)", m_pClientList[iClientH]->m_cCharName, cMapName);
	bSendMsgToLS(MSGID_GAMEMASTERLOG, iClientH, FALSE, G_cTxt);
	// Teleport everybody again on his own position
	for(i = 1; i < DEF_MAXCLIENTS; i++)
	{	if (m_pClientList[i] != NULL) 
		{	if (m_pClientList[i]->m_cMapIndex == iMapIndex)
			{	RequestTeleportHandler(i,"2   ", m_pClientList[i]->m_cMapName, m_pClientList[i]->m_sX, m_pClientList[i]->m_sY);
	}	}	}
	// Admin Log
	wsprintf(G_cTxt, "Admin Order(%s): CleanBumps\tAdminIP(%s)"
		, m_pClientList[iClientH]->m_cCharName
		, m_pClientList[iClientH]->m_cIPaddress);
	PutAdminLogFileList(G_cTxt);		// Admin Log
	wsprintf(G_cTxt, " Removed all unvalid owner pointers at %s. (%d-%d-%d-%d-%d)"
		, cMapName
		, iCompteurNul, iCompteurPla, iCompteurMob, iCompteurOth, iCompteurUnk);							
	ShowClientMsg(iClientH,  "Clean Bumps", G_cTxt);
	delete pStrTok;
	return;
}

void CGame::ShowClientMsg(int iClientH, char* pFrom, char* pMsg)
{	// Snoopy: changed to change the talker's name by calling function
	char * cp, cTemp[256];
	DWORD * dwp, dwMsgSize;
	WORD * wp;
	short * sp;

	ZeroMemory(cTemp, sizeof(cTemp));

	dwp = (DWORD *)cTemp;
	*dwp = MSGID_COMMAND_CHATMSG;

	wp  = (WORD *)(cTemp + DEF_INDEX2_MSGTYPE);
	*wp = NULL;

	cp  = (char *)(cTemp + DEF_INDEX2_MSGTYPE + 2);
	sp  = (short *)cp;
	*sp = NULL;
	cp += 2;

	sp  = (short *)cp;
	*sp = NULL;
	cp += 2;

	int iMaxSize = strlen(pFrom);
	if (iMaxSize> 10) iMaxSize = 10;

	memcpy(cp, pFrom, iMaxSize); // Player name :P
	cp += 10;

	*cp = 10; // chat type
	cp++;

	dwMsgSize = strlen(pMsg);
	if(dwMsgSize > 100) dwMsgSize = 100;
	memcpy(cp, pMsg, dwMsgSize);
	cp += dwMsgSize;

	m_pClientList[iClientH]->m_pXSock->iSendMsg(cTemp, dwMsgSize + 22);
}

void CGame::Command_YellowBall(int iClientH, char* pData, DWORD dwMsgSize)
{	char   seps[] = "= \t\n";
	char   * token, cBuff[256], cPlayerName[11],cMapName[32];
	class  CStrTok * pStrTok;
	char *cp;
	WORD *wp;
	int iSoxH, iSoX, i;
	if (m_pClientList[iClientH] == NULL) return;
	if ((dwMsgSize)	<= 0) return;
	iSoX = 0;
	for (i = 0; i < DEF_MAXITEMS; i++)
	if (m_pClientList[iClientH]->m_pItemList[i] != NULL) 
	{	switch (m_pClientList[iClientH]->m_pItemList[i]->m_sIDnum) {
		case 653: iSoX++; iSoxH = i; break; 
		}
	}
	if (iSoX > 0) 			
	{	ZeroMemory(cPlayerName, sizeof(cPlayerName));
		ZeroMemory(cBuff, sizeof(cBuff));
		memcpy(cBuff, pData, dwMsgSize);
		pStrTok = new class CStrTok(cBuff, seps);
		token = pStrTok->pGet();
		token = pStrTok->pGet();
		if (token == NULL) 
		{	delete pStrTok;
			return;
		}
		if (strlen(token) > 10) 
		{	memcpy(cPlayerName,token,10);
		}else
		{	memcpy(cPlayerName,token,strlen(token));
		}
		for(int i = 1; i < DEF_MAXCLIENTS; i++){
			if (m_pClientList[i] != NULL) {
				if (memcmp(cPlayerName,m_pClientList[i]->m_cCharName,10) == 0) {
					if ((m_pClientList[iClientH]->m_cLocation) != (m_pClientList[i]->m_cLocation)) return;
					ZeroMemory(cMapName,sizeof(cMapName));
					strcpy(cMapName, m_pClientList[i]->m_cMapName);
					wsprintf(G_cTxt, "PC(%s)\tUsed YellowBall\tPC(%s)\tWas summoned\t%s(%d %d)\tIP(%s)"
						, m_pClientList[iClientH]->m_cCharName
						, m_pClientList[i]->m_cCharName
						, m_pClientList[i]->m_cMapName
						, m_pClientList[i]->m_sX
						, m_pClientList[i]->m_sY
						, m_pClientList[i]->m_cIPaddress);	
					// Special item Log
					PutItemLogFileList(G_cTxt);	
					PutLogEventFileList(G_cTxt);
					PutLogList(G_cTxt);	
					// Normal Item Log
					bSendMsgToLS(MSGID_GAMEITEMLOG, iClientH, NULL,G_cTxt);
					ItemDepleteHandler(iClientH, iSoxH, TRUE);
					RequestTeleportHandler(iClientH,"2   ", cMapName, m_pClientList[i]->m_sX,m_pClientList[i]->m_sY);
					delete pStrTok;
					return;
				}
			}
		}
		m_pClientList[iClientH]->m_bIsAdminOrderGoto = TRUE;
		ZeroMemory(cBuff,sizeof(cBuff));
		cp = (char *)cBuff;
		*cp = GSM_REQUEST_FINDCHARACTER;
		cp++;
		wp = (WORD *)cp;
		*wp = m_wServerID_GSS;
		cp += 2;
		wp = (WORD *)cp;
		*wp = iClientH;
		cp += 2;
		memcpy(cp,cPlayerName,10);
		cp += 10;
		memcpy(cp,m_pClientList[iClientH]->m_cCharName,10);
		cp += 10;
		bStockMsgToGateServer(cBuff,25);	
		delete pStrTok;	
	}
}

void CGame::Command_RedBall(int iClientH, char *pData,DWORD dwMsgSize)
{char seps[] = "= \t\n", cName[21], cNpcName[21], cNpcWaypoint[11];	
 register int iNamingValue, tX, tY, i, x, iNpcID;
 int iSoxH, iSoX;    
	if (m_pClientList[iClientH] == NULL) return;
	// SNOOPY: Usable not everywhere???
/*	if (   (memcmp(m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cName, "huntzone1", 9) != 0) 
		&& (memcmp(m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cName, "huntzone2", 9) != 0) 
		&& (memcmp(m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cName, "huntzone3", 9) != 0) 
		&& (memcmp(m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cName, "huntzone4", 9) != 0)) 
	{ return;}	*/	     
    iSoX = 0;
	for (i = 0; i < DEF_MAXITEMS; i++)
	if (m_pClientList[iClientH]->m_pItemList[i] != NULL) {
		switch (m_pClientList[iClientH]->m_pItemList[i]->m_sIDnum) {
		case 652: iSoX++; iSoxH = i; break; // ½ºÅæ ¿Àºê Á¦¸®¸¶ 
		}
	}
	if (iSoX > 0) 			
	{	iNamingValue = m_pMapList[ m_pClientList[iClientH]->m_cMapIndex ]->iGetEmptyNamingValue();
		if (iNamingValue == -1) 
		{}else 
		{	ZeroMemory(cNpcName, sizeof(cNpcName));
			switch (iDice(1,5)) {
			case 1: strcpy(cNpcName, "Wyvern");    iNpcID = 66; break; 
			case 2: strcpy(cNpcName, "Hellclaw");  iNpcID = 49; break;
			case 3: strcpy(cNpcName, "Demon");     iNpcID = 31; break;
			case 4: strcpy(cNpcName, "Tigerworm"); iNpcID = 50; break;
			case 5: strcpy(cNpcName, "Gagoyle");   iNpcID = 52; break;
			}
			ZeroMemory(cName, sizeof(cName));
			wsprintf(cName, "XX%d", iNamingValue);
			cName[0] = '_';
			cName[1] = m_pClientList[iClientH]->m_cMapIndex+65;
			ZeroMemory(cNpcWaypoint, sizeof(cNpcWaypoint));
			tX = (int)m_pClientList[iClientH]->m_sX;
			tY = (int)m_pClientList[iClientH]->m_sY;
			if (bCreateNewNpc(cNpcName, cName, m_pMapList[ m_pClientList[iClientH]->m_cMapIndex ]->m_cName, 0, (rand() % 9), 
				DEF_MOVETYPE_RANDOM, &tX, &tY, cNpcWaypoint, NULL, NULL, -1, FALSE, FALSE) == FALSE) 
			{	m_pMapList[ m_pClientList[iClientH]->m_cMapIndex ]->SetNamingValueEmpty(iNamingValue);
			}else 
			{	wsprintf(G_cTxt, "PC(%s)\tUsed RedBall summoning(%s) \t%s(%d %d)\tIP(%s)"
					, m_pClientList[iClientH]->m_cCharName
					, cNpcName
					, m_pMapList[ m_pClientList[iClientH]->m_cMapIndex ]->m_cName
					, tX
					, tY 
					, m_pClientList[iClientH]->m_cIPaddress);
				// Special item Log
				PutLogList(G_cTxt);	
				PutItemLogFileList(G_cTxt);
				PutLogEventFileList(G_cTxt);
				// Normal Item Log
				bSendMsgToLS(MSGID_GAMEITEMLOG, iClientH, NULL,G_cTxt);
			}
		}
//SNOOPY: Show Spawns on minimap: Faultlly shows on all hosted maps from this server!				
		DWORD wX = m_pClientList[iClientH]->m_sX;
		DWORD wY = m_pClientList[iClientH]->m_sY;
		{	for (x = 1; x < DEF_MAXCLIENTS; x++)
			if (   (iNpcID != -1)    
				&& (m_pClientList[x] != NULL) 
				&& (m_pClientList[x]->m_bIsInitComplete == TRUE)			
				&& (memcmp(m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cName, m_pMapList[m_pClientList[x]->m_cMapIndex]->m_cName, strlen(m_pMapList[m_pClientList[x]->m_cMapIndex]->m_cName)) == 0))
			{	SendNotifyMsg(NULL, x, DEF_NOTIFY_SPAWNEVENT, wX, wY, iNpcID, NULL, NULL, NULL);
			}
		}
		ItemDepleteHandler(iClientH, iSoxH, TRUE);
	}
}

void CGame::Command_BlueBall(int iClientH, char *pData,DWORD dwMsgSize)
{char seps[] = "= \t\n";
 char   cName_Master[10], cName_Slave[10], cNpcName[256], cWaypoint[11], cSA; 
 int    pX, pY, j, iNum, iNamingValue, iNpcID;
 register int i, x;
 BOOL   bMaster;
 int iSoxH, iSoX;    
	if (m_pClientList[iClientH] == NULL) return;
/*	if (   (memcmp(m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cName, "huntzone1", 9) != 0) 
		&& (memcmp(m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cName, "huntzone2", 9) != 0) 
		&& (memcmp(m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cName, "huntzone3", 9) != 0) 
		&& (memcmp(m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cName, "huntzone4", 9) != 0)) 
	{ return;}*/
	   iSoX = 0;
	for (i = 0; i < DEF_MAXITEMS; i++)
	if (m_pClientList[iClientH]->m_pItemList[i] != NULL) 
	{	switch (m_pClientList[iClientH]->m_pItemList[i]->m_sIDnum) {
		case 654: iSoX++; iSoxH = i; break;
		}
	}
	if (iSoX > 0) 			
	{	iNamingValue = m_pMapList[ m_pClientList[iClientH]->m_cMapIndex ]->iGetEmptyNamingValue();
		if (iNamingValue == -1) 
		{}else 
		{	ZeroMemory(cNpcName, sizeof(cNpcName));
			switch (iDice(1,37)) {
				case 1: strcpy(cNpcName, "Slime");			iNpcID = 10; break;
				case 2: strcpy(cNpcName, "Giant-Ant");		iNpcID = 16; break;
				case 3: strcpy(cNpcName, "Zombie");			iNpcID = 18; break;
				case 4: strcpy(cNpcName, "Scorpion");		iNpcID = 17; break;
				case 5: strcpy(cNpcName, "Skeleton");		iNpcID = 11; break;
				case 6: strcpy(cNpcName, "Orc-Mage");		iNpcID = 14; break;
				case 7: strcpy(cNpcName, "Clay-Golem");		iNpcID = 23; break;
				case 8: strcpy(cNpcName, "Stone-Golem");	iNpcID = 12; break;
				case 9: strcpy(cNpcName, "Hellbound");		iNpcID = 27; break;
				case 10: strcpy(cNpcName, "Frog");			iNpcID = 57; break;
				case 11: strcpy(cNpcName, "Troll");			iNpcID = 28; break;
				case 12: strcpy(cNpcName, "Cyclops");		iNpcID = 13; break;
				case 13: strcpy(cNpcName, "Ice-Golem");		iNpcID = 65; break;
				case 14: strcpy(cNpcName, "Beholder");		iNpcID = 53; break;
				case 15: strcpy(cNpcName, "Plant");			iNpcID = 60; break;
				case 16: strcpy(cNpcName, "Ogre");			iNpcID = 29; break;
		        case 17: strcpy(cNpcName, "Mountain-Giant");iNpcID = 58; break;
                case 18: strcpy(cNpcName, "DireBoar");		iNpcID = 62; break;
		        case 19: strcpy(cNpcName, "Liche");			iNpcID = 30; break;
			    case 20: strcpy(cNpcName, "Stalker");		iNpcID = 48; break;
                case 21: strcpy(cNpcName, "WereWolf");		iNpcID = 33; break;
			    case 22: strcpy(cNpcName, "Dark-Elf");		iNpcID = 54; break;
			    case 23: strcpy(cNpcName, "Frost");			iNpcID = 63; break;
				case 24: strcpy(cNpcName, "Orc");			iNpcID = 14; break;
				case 25: strcpy(cNpcName, "Ettin");			iNpcID = 59; break;
				case 26: strcpy(cNpcName, "Tentocle");		iNpcID = 80; break;
				case 27: strcpy(cNpcName, "Giant-Crayfish");iNpcID = 74; break;
				case 28: strcpy(cNpcName, "Giant-Tree");	iNpcID = 76; break;
				case 29: strcpy(cNpcName, "Rudolph");		iNpcID = 61; break;
				case 30: strcpy(cNpcName, "Claw-Turtle");	iNpcID = 72; break;
				case 31: strcpy(cNpcName, "Centaurus");		iNpcID = 71; break;
				case 32: strcpy(cNpcName, "Dragon");		iNpcID = 70; break;
				case 33: strcpy(cNpcName, "Giant-Lizard");	iNpcID = 75; break;
				case 34: strcpy(cNpcName, "MasterMage-Orc");iNpcID = 77; break;
				case 35: strcpy(cNpcName, "Minotaurs");		iNpcID = 78; break;
				case 36: strcpy(cNpcName, "Unicorn");		iNpcID = 32; break;
				case 37: strcpy(cNpcName, "Nizie");			iNpcID = 79; break;
			}
			iNum = 10;
			cSA = 0;
			pX = m_pClientList[iClientH]->m_sX;
			pY = m_pClientList[iClientH]->m_sY;

			wsprintf(G_cTxt, "PC(%s)\tUsed BlueBall summoning(%s)spawn. \t%s(%d %d)\tIP(%s)"
				, m_pClientList[iClientH]->m_cCharName
				, cNpcName
				, m_pMapList[ m_pClientList[iClientH]->m_cMapIndex ]->m_cName
				, m_pClientList[iClientH]->m_sX
				, m_pClientList[iClientH]->m_sY 
				, m_pClientList[iClientH]->m_cIPaddress);
			PutLogList(G_cTxt);	
			PutItemLogFileList(G_cTxt);	
			PutLogEventFileList(G_cTxt);
			// Normal Item Log
			bSendMsgToLS(MSGID_GAMEITEMLOG, iClientH, NULL,G_cTxt);
			iNamingValue = m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->iGetEmptyNamingValue();
			if (iNamingValue != -1) 
			{	ZeroMemory(cName_Master, sizeof(cName_Master));
				wsprintf(cName_Master, "XX%d", iNamingValue);
				cName_Master[0] = '_';
				cName_Master[1] = m_pClientList[iClientH]->m_cMapIndex + 65;
				if ((bMaster = bCreateNewNpc(cNpcName, cName_Master, m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cName, (rand() % 3), cSA, DEF_MOVETYPE_RANDOM, &pX, &pY, cWaypoint, NULL, NULL, -1, FALSE, FALSE, FALSE, TRUE)) == FALSE) 
				{	m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->SetNamingValueEmpty(iNamingValue);
				}
			}		

			for (j = 0; j < (iNum - 1); j++) {
				iNamingValue = m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->iGetEmptyNamingValue();
				if (iNamingValue != -1) // Slave Mob
				{	ZeroMemory(cName_Slave, sizeof(cName_Slave));
					wsprintf(cName_Slave, "XX%d", iNamingValue);
					cName_Slave[0] = '_';
					cName_Slave[1] = m_pClientList[iClientH]->m_cMapIndex + 65;				
					if (bCreateNewNpc(cNpcName, cName_Slave, m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cName, (rand() % 3), cSA, DEF_MOVETYPE_RANDOM, &pX, &pY, cWaypoint, NULL, NULL, -1, FALSE, FALSE, FALSE) == FALSE) 
					{	m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->SetNamingValueEmpty(iNamingValue);
					}else // Slave
					{	bSetNpcFollowMode(cName_Slave, cName_Master, DEF_OWNERTYPE_NPC);
					}
				}
			}
		//delete pStrTok;
		}
//SNOOPY: Show Spawns on minimap: Faultlly shows on all hosted maps from this server!		
		DWORD wX = m_pClientList[iClientH]->m_sX;
		DWORD wY = m_pClientList[iClientH]->m_sY;
		for (x = 1; x < DEF_MAXCLIENTS; x++)
		if (   (iNpcID != -1)    
			&& (m_pClientList[x] != NULL) 
			&& (m_pClientList[x]->m_bIsInitComplete == TRUE)			
			&& (memcmp(m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cName, m_pMapList[m_pClientList[x]->m_cMapIndex]->m_cName, strlen(m_pMapList[m_pClientList[x]->m_cMapIndex]->m_cName)) == 0)) 
		{	SendNotifyMsg(NULL, x, DEF_NOTIFY_SPAWNEVENT, wX, wY, iNpcID, NULL, NULL, NULL);
		}
		ItemDepleteHandler(iClientH, iSoxH, TRUE);
	}
}

void CGame::GlobalUpdateConfigs(char cConfigType)
{char * cp, cData[120];
	ZeroMemory(cData, sizeof(cData));
	cp = (char *)cData;
	*cp = GSM_UPDATECONFIGS;
	cp++;
	*cp = (char)cConfigType;
	cp++;	
	LocalUpdateConfigs(cConfigType);
	bStockMsgToGateServer(cData, 5);
}
void CGame::LocalUpdateConfigs(char cConfigType)
{	if (cConfigType == 1) 
	{	if (bReadSettingsConfigFile("..\\GameConfigs\\Settings.cfg"))		PutLogList("(!!!) Settings.cfg updated successfully!");
	}
	if (cConfigType == 2) 
	{	if (bReadAdminListConfigFile("..\\GameConfigs\\AdminList.cfg"))		PutLogList("(!!!) AdminList.cfg updated successfully!");
	}
	if (cConfigType == 3) 
	{	if (bReadBannedListConfigFile("..\\GameConfigs\\BannedList.cfg"))	PutLogList("(!!!) BannedList.cfg updated successfully!");
	}
	if (cConfigType == 4) 
	{	if (bReadAdminSetConfigFile("..\\GameConfigs\\AdminSettings.cfg"))	PutLogList("(!!!) AdminSettings.cfg updated successfully!");
	}
	if (cConfigType == 5) 
	{	if (bDecodeTeleportList("..\\GameConfigs\\TeleportList.cfg"))		PutLogList("(!!!) TeleportList.cfg updated successfully!");
	}	
}

//**************************************************************************************
// HBx server introduced only the skeletton off Apocalypse functions, and sometime not so good!
// I rewrote them, maybe not following the "official" pattern but it works!
// I also needed to add many new functions.
//**************************************************************************************
// SNOOPY: Revamped Apocalypse functions:
//         bReadApocalypseGUIDFile(DWORD dwApocalypseGUID) 
//         Reads the GUID file when server starts
// DynamicGateType = 1: Opens Gate when Apoc begins, for 15 min
// DynamicGateType = 2: Open the gate when map is empty
// DynamicGateType = 3: Gate stays closed will change to 4 value to open it, along with a boss spawn.
// DynamicGateType = 4: Gate is openned. (set by server when Abaddon is spawning)
// DynamicGateType = 5: Gate is used by GM command    
// m_iApocalypseMobGenType = 1: Gate will open as soon as the map is empty
// m_iApocalypseMobGenType = 2: A big mob will spawn when map is empty, gate will open depend if Type 2 or 3.
//**************************************************************************************
BOOL CGame::bReadApocalypseGUIDFile(char * cFn)
{FILE * pFile;
 HANDLE hFile;
 DWORD  dwFileSize;
 char * cp, * token, cReadMode;
 char seps[] = "= \t\n";
 class CStrTok * pStrTok;
	cReadMode = 0;
	hFile = CreateFile(cFn, GENERIC_READ, NULL, NULL, OPEN_EXISTING, NULL, NULL);
	dwFileSize = GetFileSize(hFile, NULL);
	if (hFile != INVALID_HANDLE_VALUE) CloseHandle(hFile);
	pFile = fopen(cFn, "rt");
	if (pFile == NULL) 
	{	PutLogList("(!) Cannot open ApocalypseGUID file.");
		return FALSE;
	}else 
	{	PutLogList("(_) Reading ApocalypseGUID file...");
		cp = new char[dwFileSize+2];
		ZeroMemory(cp, dwFileSize+2);
		fread(cp, dwFileSize, 1, pFile);
		pStrTok = new class CStrTok(cp, seps);
		token = pStrTok->pGet();
		while( token != NULL )   
		{	if (cReadMode != 0) 
			{	switch (cReadMode) {
				case 1:
					m_dwApocalypseGUID = _atoi64(token);
					cReadMode = 0;
					break;
				}
			}else 
			{	if (memcmp(token, "Apocalypse GUID", 14) == 0) cReadMode = 1;
			}			
			token = pStrTok->pGet();
		}
		delete pStrTok;
		delete cp;
	}
	if (pFile != NULL) fclose(pFile);
	wsprintf(G_cTxt, "(_) Read ApocalypseGUID (%d) file.", m_dwApocalypseGUID);
	PutLogList(G_cTxt);
	return TRUE;
}
//**************************************************************************************
// SNOOPY: Revamped Apocalypse functions:
//         _CreateApocalypseGUID(DWORD dwApocalypseGUID) 
//         Create the GUID file if it doesn't exist at Apoc beginning
//         or at the Apocalypse end.
//**************************************************************************************
void CGame::_CreateApocalypseGUID(DWORD dwApocalypseGUID)
{char * cp, cTxt[256], cFn[256], cTemp[1024];	
 FILE * pFile;		
	_mkdir("GameData");
	ZeroMemory(cFn, sizeof(cFn));	
	strcat(cFn,"GameData");
	strcat(cFn,"\\");
	strcat(cFn,"\\");					  
	strcat(cFn,"ApocalypseGUID.Txt");		
	pFile = fopen(cFn, "wt");
	if (pFile == NULL) 
	{ 	wsprintf(cTxt, "(!) Cannot create Apocalypse GUID (%d) file", dwApocalypseGUID);
		PutLogList(cTxt);
	}else 
	{	ZeroMemory(cTemp, sizeof(cTemp));		
		ZeroMemory(cTxt, sizeof(cTxt));
		wsprintf(cTxt, "ApocalypseGUID = %d\n", dwApocalypseGUID);
		strcat(cTemp, cTxt);		
		cp = (char *)cTemp;
		fwrite(cp, strlen(cp), 1, pFile);		
		wsprintf(cTxt, "(_) Apocalypse GUID (%d) file created", dwApocalypseGUID);
		PutLogList(cTxt);
	}
	if (pFile != NULL) fclose(pFile);
}
//**************************************************************************************
// SNOOPY: GlobalStartApocalypseMode
//		   Called by: by local command or GM command
//         -> Notify all game servers to start apocalypse
//         -> Used to force Open or Closed the initial Gates
//**************************************************************************************
void CGame::GlobalStartApocalypseMode(int iClientH, int iMode)
{	char * cp, cData[120];
	DWORD * dwp, dwApocalypseGUID;
	char cString[200];
	ZeroMemory(cString, sizeof(cString));
	if ((iClientH != 0) && (m_pClientList[iClientH]->m_iAdminUserLevel < 3)) {
		SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_ADMINUSERLEVELLOW, NULL, NULL, NULL, NULL);
		return;
	}
	if ((m_bIsApocalypseMode == TRUE) && (iMode == 0)) return;
	if (m_bIsHeldenianMode == TRUE) return;
	if (m_bIsCrusadeMode == TRUE) return;	
	if (m_bIsAvatarMode == TRUE) return;

	switch (iMode){
	case 1: // Force open Gates
		dwApocalypseGUID = 1; 
		if (iClientH !=0)
		{	wsprintf(G_cTxt, "Admin Order(%s): /openapocalypsegate \tAdminIP(%s)"
				, m_pClientList[iClientH]->m_cCharName
				, m_pClientList[iClientH]->m_cIPaddress);
			wsprintf(cString, "Apocalypse gate opening in progress.");
		}else
		{	wsprintf(G_cTxt, "Local command: openapocalypsegate");
		};		
		_bCrusadeLog(DEF_CRUSADELOG_APOCALYPSE, NULL, 0, "Apocalypse gates opened.");
		break;
	case 2: // Force close gates
		dwApocalypseGUID = 2; 
		if (iClientH !=0)
		{	wsprintf(G_cTxt, "Admin Order(%s): /closeapocalypsegate \tAdminIP(%s)"
			, m_pClientList[iClientH]->m_cCharName
			, m_pClientList[iClientH]->m_cIPaddress);
			wsprintf(cString, "Apocalypse gate closing in progress.");
		}else
		{	wsprintf(G_cTxt, "Local command: closeapocalypsegate");
		};			
		_bCrusadeLog(DEF_CRUSADELOG_APOCALYPSE, NULL, 0, "Apocalypse gates closed.");	
		break;
	case 0: // Start Apocalypse
		dwApocalypseGUID = timeGetTime(); 
		if (dwApocalypseGUID < 10) dwApocalypseGUID += 10;
		if (iClientH !=0)
		{	wsprintf(G_cTxt, "Admin Order(%s): /beginapocalypse \tAdminIP(%s)"
				, m_pClientList[iClientH]->m_cCharName
				, m_pClientList[iClientH]->m_cIPaddress);
			wsprintf(cString, "Apocalypse starting in progress.");
		}else
		{	wsprintf(G_cTxt, "Local command: beginapocalypse");
		};	
		_bCrusadeLog(DEF_CRUSADELOG_APOCALYPSE, NULL, 0, "Begin Apocalypse.");	
		break;
	}
	PutAdminLogFileList(G_cTxt);		
	PutLogEventFileList(G_cTxt);
	PutLogList(G_cTxt);	
	if (iClientH !=0)
	{	SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_IPACCOUNTINFO, NULL, NULL, NULL, cString);
	}
	
	ZeroMemory(cData, sizeof(cData));
	cp = (char *)cData;
	*cp = GSM_BEGINAPOCALYPSE;
	cp++;
	dwp = (DWORD *)cp;
	*dwp = dwApocalypseGUID;
	cp += 4;
	bStockMsgToGateServer(cData, 5);
	LocalStartApocalypse(dwApocalypseGUID); // Gate will no return order to this server
}

//**************************************************************************************
// SNOOPY: Revamped Apocalypse functions:
//         LocalStartApocalypse
//		   called by:      started by Gate msg
//         -> Notify players
//         -> Opens the gates
//		   -> Prevent npc generation on "kill all to go out" maps
//		   -> Execute local Openning or closing gates by GM command
//**************************************************************************************
void CGame::LocalStartApocalypse(DWORD dwApocalypseGUID)
{	if (dwApocalypseGUID == 1)// Means want to open Gate
	{	ForceOpen_ApocalypseGate();
		return;
	}
	if (dwApocalypseGUID == 2)// Means want to open Gate
	{	ForceClose_ApocalypseGate();
		return;
	}	
 register int i;
	m_bIsApocalypseMode = TRUE;
	if (dwApocalypseGUID != NULL) 
	{	m_dwApocalypseGUID = dwApocalypseGUID;
		_CreateApocalypseGUID(dwApocalypseGUID);	
		m_dwApocalypseGateOpenTime = dwApocalypseGUID;
		m_dwApocalypseGateCloseTime = dwApocalypseGUID +20*60*1000; // will close in 20 minutes
	}
	for (i = 1; i < DEF_MAXCLIENTS; i++) 
	{	if (m_pClientList[i] != NULL) 
		{	SendNotifyMsg(NULL, i, DEF_NOTIFY_APOCGATESTARTMSG, NULL, NULL, NULL, NULL);	
	}	}
	for (i = 0; i < DEF_MAXMAPS; i++)
	{	if (m_pMapList[i] != NULL) 
		{	if (m_pMapList[i]->m_iApocalypseMobGenType != 0) 
			//1 for no respawn, 2 for Boss spawn when map empty
			{	m_pMapList[i]->m_iMaximumObjectDefault = m_pMapList[i]->m_iMaximumObject;
				m_pMapList[i]->m_iMaximumObject = 0;	
	}	}	}
	OpenCloseApocalypseGate();
	wsprintf(G_cTxt,"(_)Apocalypse Mode ON.");
	PutLogList(G_cTxt);		
	PutLogList(" ");		
	PutLogEventFileList(G_cTxt);	
	PutLogEventFileList(" ");
}

//**************************************************************************************
// SNOOPY: Revamped Apocalypse functions:
//         GlobalEndApocalypseMode:  
//         -> Notify all game servers
//**************************************************************************************
void CGame::GlobalEndApocalypseMode(int iClientH)
{	char * cp, cData[120];
	if (m_bIsApocalypseMode == FALSE) return;

	if (iClientH > 0)	
	{	wsprintf(G_cTxt, "Admin Order(%s): /endapocalypse \tAdminIP(%s)"
			, m_pClientList[iClientH]->m_cCharName
			, m_pClientList[iClientH]->m_cIPaddress);
		char cString[200];
		ZeroMemory(cString, sizeof(cString));
		wsprintf(cString, "Apocalypse ending in progress.");
		SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_IPACCOUNTINFO, NULL, NULL, NULL, cString);
	}else
	{	wsprintf(G_cTxt, "Automated: endapocalypse");
	}
	PutAdminLogFileList(G_cTxt);		
	PutLogEventFileList(G_cTxt);
	PutLogList(G_cTxt);	

	ZeroMemory(cData, sizeof(cData));
	cp = (char *)cData;
	*cp = GSM_ENDAPOCALYPSE;
	cp++;	
	bStockMsgToGateServer(cData, 5);
	_bCrusadeLog(DEF_CRUSADELOG_APOCALYPSE, NULL, 0, "End Apocalypse.");	
	LocalEndApocalypse(); // Gate will not return order to this server
}

//**************************************************************************************
// SNOOPY: Revamped Apocalypse functions:
//         LocalEndApocalypse: started by Gate msg
//         -> Notify players
//         -> Close the gates
//		   -> Enable npc generation on all maps
//**************************************************************************************
void CGame::LocalEndApocalypse()
{	wsprintf(G_cTxt, "(!) Received LocalEndApocalypse.");
	PutLogList(G_cTxt);
	m_bIsApocalypseMode = FALSE;
	m_bIsApocalypseGateOpen	= FALSE; 
 register int i;	
 DWORD  dwTime = timeGetTime();
	m_dwApocalypseGateCloseTime = dwTime -1;
	m_dwApocalypseGateOpenTime = dwTime -100; // alreaddy closed
	for (i = 1; i < DEF_MAXCLIENTS; i++) 
	{	if (m_pClientList[i] != NULL)
		{	SendNotifyMsg(NULL, i, DEF_NOTIFY_APOCGATEENDMSG, NULL, NULL, NULL, NULL);
			if (   (m_pClientList[i]->m_iAdminUserLevel == 0)
				&& (m_pMapList[m_pClientList[i]->m_cMapIndex]->m_bIsApocalypseMap == TRUE)) 
			{	// forced recall
				SendNotifyMsg(NULL, i, DEF_NOTIFY_TOBERECALLED, NULL, NULL, NULL, NULL);
				RequestTeleportHandler(i, "0   ");
	}	}	}	
	// restore normal spawn on apoc maps
	for (i = 0; i < DEF_MAXMAPS; i++)
	{	if (m_pMapList[i] != NULL) 
		{	if (m_pMapList[i]->m_iApocalypseMobGenType != 0) 
			//1 for not respawn, 2 for Boss spawn.
			{	m_pMapList[i]->m_iMaximumObject = m_pMapList[i]->m_iMaximumObjectDefault;
			}
			if (m_pMapList[i]->m_cDynamicGateType == 4 )
			{	m_pMapList[i]->m_cDynamicGateType = 3;
			}
			if (m_pMapList[i]->m_cDynamicGateType == 2)
			{	GenerateSlime(i);	// to force the gate to close		
			}
			Open_EmptyMap_Gate(i);
	}	}
	wsprintf(G_cTxt,"(_) Apocalypse Mode OFF.");
	PutLogList(G_cTxt);
	PutLogList(" ");
	PutLogEventFileList(G_cTxt);
	PutLogEventFileList(" ");
}
//**************************************************************************************
// SNOOPY: Revamped Apocalypse functions:
//         OpenCloseApocalypseGate 
//         Called by ::ForceOpen_ApocalypseGate, ::ForceClose_ApocalypseGate
//         Called by ::LocalStartApocalypse
//         Check if Gates's needs to be openned or closed 
//		   then notify any change to all clients.on current server
//		   NB: Opens/closes only type 1 Gates
//**************************************************************************************
void CGame::OpenCloseApocalypseGate()
{	DWORD  dwTime = timeGetTime();
	BOOL bIsOpen = m_bIsApocalypseGateOpen;	
	if (   (dwTime >= m_dwApocalypseGateOpenTime)
		&& (dwTime < m_dwApocalypseGateCloseTime))
	{	m_bIsApocalypseGateOpen	= TRUE;
	}else
	{	m_bIsApocalypseGateOpen	= FALSE;
	}
	// If nothing has changed return...
	if (bIsOpen == m_bIsApocalypseGateOpen) return;

	if (m_bIsApocalypseGateOpen	== TRUE) 
	{	wsprintf(G_cTxt,"(!)Apocalypse Gate opened.");
	}else
	{	wsprintf(G_cTxt,"(!)Apocalypse Gate closed.");
	}
	PutLogList(G_cTxt);	
	PutLogEventFileList(G_cTxt);
	// Then notify all clients of change,
	register int i;		
	for (i = 1; i < DEF_MAXCLIENTS; i++) 
	{	if (m_pClientList[i] != NULL)
		{	Notify_ApocalypseGateState(i);
		}	
	}
}

//**************************************************************************************
// SNOOPY: Revamped Apocalypse functions: (used also for Admin Gate)
//         Notify_ApocalypseGateState 
//         Called by ::RequestInitDataHandler (when client log in)
//         Called by ::RequestTeleportHandler (when client changes map on same server)
//         Called by ::OpenCloseApocalypseGate (when Gate is openned or closed)
//         Notify the client of Gate's state, needed to show in player's screen
//**************************************************************************************
void CGame::Notify_ApocalypseGateState(int iClientH)
{	if (iClientH <= 0)	return;
	if (m_pClientList[iClientH] <= 0)	return;
	if (m_pClientList[iClientH]->m_bIsInitComplete == FALSE) return;
	int iMapIndex = m_pClientList[iClientH]->m_cMapIndex;
	int gX, gY;
	switch (m_pMapList[iMapIndex]->m_cDynamicGateType){
	case 0:	// No gate on current map		
		if (m_bIsApocalypseMode == FALSE) break;
		if(m_bIsApocalypseGateOpen == TRUE) 
		{	SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_APOCGATEOPEN, 0, 0, NULL, m_pClientList[iClientH]->m_cMapName);
			SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_APOCGATESTARTMSG, NULL, NULL, NULL, NULL);
		}else
		{	SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_APOCGATECLOSE, 0, 0, NULL, m_pClientList[iClientH]->m_cMapName);
			SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_APOCGATEENDMSG, NULL, NULL, NULL, NULL);
		}
		break;
	case 1:	// Initial Dynamic gates (toh, IB, D4...)
		if (m_bIsApocalypseMode == FALSE) break;
		gX = (m_pMapList[iMapIndex]->m_sDynamicGateCoordRectX1 + m_pMapList[iMapIndex]->m_sDynamicGateCoordRectX2)/2;
		gY = (m_pMapList[iMapIndex]->m_sDynamicGateCoordRectY1 + m_pMapList[iMapIndex]->m_sDynamicGateCoordRectY2)/2;
		if(m_bIsApocalypseGateOpen == TRUE) 
		{	SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_APOCGATEOPEN, gX, gY, NULL, m_pClientList[iClientH]->m_cMapName);
			SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_APOCGATESTARTMSG, NULL, NULL, NULL, NULL);
		}else
		{	SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_APOCGATECLOSE, gX, gY, NULL, m_pClientList[iClientH]->m_cMapName);
			SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_APOCGATEENDMSG, NULL, NULL, NULL, NULL);
		}
		break;
	case 2: // Empty maps Dynamic gates (inferniaA, inferniaB, procella...)
		if (m_bIsApocalypseMode == FALSE) break;
		gX = (m_pMapList[iMapIndex]->m_sDynamicGateCoordRectX1 + m_pMapList[iMapIndex]->m_sDynamicGateCoordRectX2)/2;
		gY = (m_pMapList[iMapIndex]->m_sDynamicGateCoordRectY1 + m_pMapList[iMapIndex]->m_sDynamicGateCoordRectY2)/2;
		if (m_pMapList[iMapIndex]->m_iTotalActiveObject == 0)
		{	SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_APOCGATEOPEN, gX, gY, NULL, m_pClientList[iClientH]->m_cMapName);
			SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_APOCGATESTARTMSG, NULL, NULL, NULL, NULL);
		}else
		{	SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_APOCGATECLOSE, gX, gY , NULL, m_pClientList[iClientH]->m_cMapName);
		}
		break;
	case 3: // Hide the n°3 gates ..
		if (m_bIsApocalypseMode == FALSE) break;
		gX = (m_pMapList[iMapIndex]->m_sDynamicGateCoordRectX1 + m_pMapList[iMapIndex]->m_sDynamicGateCoordRectX2)/2;
		gY = (m_pMapList[iMapIndex]->m_sDynamicGateCoordRectY1 + m_pMapList[iMapIndex]->m_sDynamicGateCoordRectY2)/2;
		SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_APOCGATECLOSE, gX, gY, NULL, m_pClientList[iClientH]->m_cMapName);
		break;	
	case 4: // Show the gate on abaddon map..when Abaddon spawning.
		if (m_bIsApocalypseMode == FALSE) break;
		gX = (m_pMapList[iMapIndex]->m_sDynamicGateCoordRectX1 + m_pMapList[iMapIndex]->m_sDynamicGateCoordRectX2)/2;
		gY = (m_pMapList[iMapIndex]->m_sDynamicGateCoordRectY1 + m_pMapList[iMapIndex]->m_sDynamicGateCoordRectY2)/2;
		SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_APOCGATEOPEN, gX, gY, NULL, m_pClientList[iClientH]->m_cMapName);
		SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_APOCGATESTARTMSG, NULL, NULL, NULL, NULL);
		break;
	case 5:	// GM command Dynamic gates (even not in apocalypse mode)
		gX = m_pMapList[iMapIndex]->m_sDynamicGateCoordRectX1 + 1;
		gY = m_pMapList[iMapIndex]->m_sDynamicGateCoordRectY1 + 1;
		SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_APOCGATEOPEN, gX, gY, NULL, m_pClientList[iClientH]->m_cMapName);
		break;
	}
}

//**************************************************************************************
// SNOOPY: Revamped Apocalypse functions: (used also for Admin Gate)
//         Use_ApocalypseGate 
//         Called by ::CheckClientResponseTime()
//         Test if client uses Dynamic Gate, then TP him. used as well out of apoc mode (gate 5)
//**************************************************************************************
void CGame::Use_ApocalypseGate(int iClientH)
{	if (iClientH <= 0)	return;
	if (m_pClientList[iClientH] == NULL) return;
	if (m_pClientList[iClientH]->m_bIsInitComplete == FALSE) return;
	int iMapIndex = m_pClientList[iClientH]->m_cMapIndex;
	switch(m_pMapList[iMapIndex]->m_cDynamicGateType) {
	case 0: // No Dynamic Gate on this map
		return; break;
	case 1: // Apocalypse normal gate
		if (m_bIsApocalypseMode == FALSE)		return;
		if (m_bIsApocalypseGateOpen == FALSE)	return; 
		break;
	case 2: // Apocalypse gate opened when map empty
		if (m_bIsApocalypseMode == FALSE)		return;
		if (m_pMapList[iMapIndex]->m_iTotalActiveObject != 0) return; 
		break;
	case 3: // Apocalypse gate still closed
		return; break;
	case 4: // Apocalypse gate opened when Abaddon spawned.
		if (m_bIsApocalypseMode == FALSE)		return;
		break;
	case 5: // Admin created gate
		break;
	}
	if (   (m_pClientList[iClientH]->m_sX >= m_pMapList[iMapIndex]->m_sDynamicGateCoordRectX1)
		&& (m_pClientList[iClientH]->m_sX <= m_pMapList[iMapIndex]->m_sDynamicGateCoordRectX2)
		&& (m_pClientList[iClientH]->m_sY >= m_pMapList[iMapIndex]->m_sDynamicGateCoordRectY1)
		&& (m_pClientList[iClientH]->m_sY <= m_pMapList[iMapIndex]->m_sDynamicGateCoordRectY2))
	{	RequestTeleportHandler(iClientH, "2   "
								, m_pMapList[iMapIndex]->m_cDynamicGateCoordDestMap
								, m_pMapList[iMapIndex]->m_sDynamicGateCoordTgtX
								, m_pMapList[iMapIndex]->m_sDynamicGateCoordTgtY);	
	}
}

//**************************************************************************************
// SNOOPY: Revamped Apocalypse functions:
//         Open_EmptyMap_Gate 
//		   Called by ::DeleteNpc when last npc killed on map disapears
//         Show just-openned gates to the client
//**************************************************************************************
void CGame::Open_EmptyMap_Gate(int MapIndex)
{	if (m_pMapList[MapIndex]->m_cDynamicGateType < 2 )	return; 
	//if (m_pMapList[MapIndex]->m_cDynamicGateType == 3 ) return; 
	register int i;
	for (i = 1; i < DEF_MAXCLIENTS; i++) 
	{	if (m_pClientList[i] == NULL) continue;
		if (m_pClientList[i]->m_cMapIndex != MapIndex) continue;
		Notify_ApocalypseGateState(i);		
	} 
}

//**************************************************************************************
// SNOOPY: Revamped Apocalypse functions:
//         GenerateApocalypseBoss 
//		   Called by ::NpcKilledHandler
//         Creates the appropriate npc depending on map definition file
//         then change the Dynamic Gate type from 3 to 4 (to open it)
//**************************************************************************************
void CGame::GenerateApocalypseBoss(int MapIndex)
{	if (m_pMapList[MapIndex]->m_iTotalActiveObject != 0) return;
	char cName[21], cNpcName[21], cNpcWaypoint[11];	
	int x, i5;
	int iNamingValue;
	ZeroMemory(cNpcWaypoint, sizeof(cNpcWaypoint));

	iNamingValue = m_pMapList[MapIndex]->iGetEmptyNamingValue();
	if (iNamingValue == -1) 
	{}else 
	{	ZeroMemory(cNpcName, sizeof(cNpcName));
		switch (m_pMapList[MapIndex]->m_iApocalypseBossMobNpcID) {
		case 0: return; break;
		case 49: strcpy(cNpcName, "Hellclaw");break;
		case 50: strcpy(cNpcName, "Tigerworm");break;	
		case 66: strcpy(cNpcName, "Wyvern");break;	
		case 73: strcpy(cNpcName, "Fire-Wyvern");break;	
		case 81: strcpy(cNpcName, "Abaddon");break;	
		default: strcpy(cNpcName, "Demon");break;	
		}
		ZeroMemory(cName, sizeof(cName));
		wsprintf(cName, "XX%d", iNamingValue);
		cName[0] = '_';
		cName[1] = MapIndex+65;	
		if (bCreateNewNpc(cNpcName, cName, m_pMapList[MapIndex]->m_cName, 0, 0
			, DEF_MOVETYPE_RANDOMAREA, NULL, NULL, cNpcWaypoint, &m_pMapList[MapIndex]->m_sApocalypseBossMobRect, NULL, -1, FALSE, FALSE, FALSE, TRUE) == FALSE) 
		{	m_pMapList[MapIndex]->SetNamingValueEmpty(iNamingValue);
		}else 
		{	wsprintf(G_cTxt, "%s has spawned in %s"
				, cNpcName
				, m_pMapList[MapIndex]->m_cName);
			PutLogList(G_cTxt);	
			PutLogFileList(G_cTxt);	
			PutLogEventFileList(G_cTxt);			
			_bCrusadeLog(DEF_CRUSADELOG_APOCALYPSE, NULL, 0, G_cTxt);	
		}
		// Search npc ID
		for (i5 = 1; i5 < DEF_MAXNPCS; i5++)
		{	if ((m_pNpcList[i5] != NULL) && (memcmp(m_pNpcList[i5]->m_cName, cName, 5) == 0) ) 
			{	break;
		}	}
		// Show Spawns on minimap, and tell everybody on Apocalypse server.					
		DWORD wX = m_pNpcList[i5]->m_sX;
		DWORD wY = m_pNpcList[i5]->m_sX;
		for (x = 1; x < DEF_MAXCLIENTS; x++)
		if (   (m_pClientList[x] != NULL) 
			&& (m_pClientList[x]->m_bIsInitComplete == TRUE))
		{	if(memcmp(m_pMapList[MapIndex]->m_cName, m_pMapList[m_pClientList[x]->m_cMapIndex]->m_cName, strlen(m_pMapList[MapIndex]->m_cName)) == 0)
			{	SendNotifyMsg(NULL, x, DEF_NOTIFY_SPAWNEVENT, wX, wY, m_pMapList[MapIndex]->m_iApocalypseBossMobNpcID, NULL, NULL, NULL);
			}
			// Tell everybody on this server if Abaddon has appeared
			if (m_pMapList[MapIndex]->m_iApocalypseBossMobNpcID == 81) 
			{	char cInfoString[100];
				ZeroMemory(cInfoString,  sizeof(cInfoString));
				wsprintf(cInfoString, "Abbadon has appeared ...");
				SendNotifyMsg(NULL, x, DEF_NOTIFY_IPACCOUNTINFO, NULL, NULL, NULL, cInfoString);
		}	}

		// Prepare Abaddon's death, and Apocalypse end.
		if (m_pMapList[MapIndex]->m_iApocalypseBossMobNpcID == 81)
		{	// Abaddon should die by himself		
			DWORD dwTime = timeGetTime();
			dwTime += 1000*60*5; // 5 minute
			bRegisterDelayEvent(DEF_DELAYEVENTTYPE_KILL_ABADDON, 0, dwTime, i5
						, DEF_OWNERTYPE_NPC, MapIndex, 0, 0, 0, 0, 0);
			dwTime = timeGetTime();
			dwTime += 1000*60*15; // 15 minutes
			bRegisterDelayEvent(DEF_DELAYEVENTTYPE_END_APOCALYPSE, 0, dwTime, 0
						, 0, MapIndex, 0, 0, 0, 0, 0);
		}
		// Finally open the Exit Gate if type 3 & not 2
		// NB: if m_iApocalypseMobGenType 2 with GateType 2, need to Kill the boss to open the gate.
		if (m_pMapList[MapIndex]->m_cDynamicGateType == 3 )
		{	m_pMapList[MapIndex]->m_cDynamicGateType = 4;
			Open_EmptyMap_Gate(MapIndex);
	}	}
}
//**************************************************************************************
// SNOOPY: Revamped Apocalypse functions:
//         GenerateSlime 
//         Generate a npc now to close the gate
//**************************************************************************************
void CGame::GenerateSlime(int MapIndex)
{	if (m_pMapList[MapIndex]->m_iTotalActiveObject != 0) return;
	char cName[21], cNpcName[21], cNpcWaypoint[11];	
	int iNamingValue;
	ZeroMemory(cNpcWaypoint, sizeof(cNpcWaypoint));

	iNamingValue = m_pMapList[MapIndex]->iGetEmptyNamingValue();
	if (iNamingValue == -1) 
	{}else 
	{	strcpy(cNpcName, "Slime");
		ZeroMemory(cName, sizeof(cName));
		wsprintf(cName, "XX%d", iNamingValue);
		cName[0] = '_';
		cName[1] = MapIndex+65;							
		if (bCreateNewNpc(cNpcName, cName, m_pMapList[MapIndex]->m_cName, 0, 0
			, DEF_MOVETYPE_RANDOMAREA, NULL, NULL, cNpcWaypoint, &m_pMapList[MapIndex]->m_sApocalypseBossMobRect, NULL, NULL, FALSE, FALSE, FALSE, TRUE) == FALSE) 
		{	m_pMapList[MapIndex]->SetNamingValueEmpty(iNamingValue);
	}	}
}

//**************************************************************************************
// SNOOPY: Revamped Apocalypse functions:
//         ForceOpen_ApocalypseGate 
//         Local execution off a global GM command to force open the gate
//			Beware this will affect only current server
//**************************************************************************************
void CGame::ForceOpen_ApocalypseGate()
{	if (m_bIsApocalypseMode == FALSE)	return;	
	DWORD  dwTime = timeGetTime();
	m_dwApocalypseGateOpenTime = dwTime;
	m_dwApocalypseGateCloseTime = dwTime +15*60*1000; // will close in 15 minutes
	OpenCloseApocalypseGate();
}
//**************************************************************************************
// SNOOPY: Revamped Apocalypse functions:
//         ForceClose_ApocalypseGate 
//         GM command to force open the gate
//         Beware this will affect only current server
//**************************************************************************************
void CGame::ForceClose_ApocalypseGate()
{	if (m_bIsApocalypseMode == FALSE)	return;	
	DWORD  dwTime = timeGetTime();
	m_dwApocalypseGateCloseTime = dwTime -1;
	m_dwApocalypseGateOpenTime = dwTime -100; // alreaddy closed
	OpenCloseApocalypseGate();
}

//**************************************************************************************
//**************************************************************************************
//**************************************************************************************
//**************************************************************************************
/*void CGame::ApocalypseStarter()
{SYSTEMTIME SysTime;
 int i;
	if (m_bIsApocalypseMode == TRUE) return;
	if (m_bIsApocalypseStarter == FALSE) return;
	GetLocalTime(&SysTime);	
	for (i = 0; i < DEF_MAXAPOCALYPSE; i++)
	if	((m_stApocalypseScheduleStart[i].iDay == SysTime.wDayOfWeek) && 
		(m_stApocalypseScheduleStart[i].iHour == SysTime.wHour) && 
		(m_stApocalypseScheduleStart[i].iMinute == SysTime.wMinute)) {
			PutLogList("(!) Automated apocalypse is initiated!");
			PutLogEventFileList("(!) Automated apocalypse is initiated!");
			GlobalStartApocalypseMode(-1, 0);
			return;
	}
}*/
void CGame::ApocalypseEnder()
{
 SYSTEMTIME SysTime;
 int i;

	if (m_bIsApocalypseMode == FALSE) return;
	if (m_bIsApocalypseStarter == FALSE) return;

	GetLocalTime(&SysTime);
	
	for (i = 0; i < DEF_MAXAPOCALYPSE; i++)
	if	((m_stApocalypseScheduleEnd[i].iDay == SysTime.wDayOfWeek) && 
		(m_stApocalypseScheduleEnd[i].iHour == SysTime.wHour) && 
		(m_stApocalypseScheduleEnd[i].iMinute == SysTime.wMinute)) {
			PutLogList("(!) Automated apocalypse is concluded!");
			PutLogEventFileList("(!) Automated apocalypse is concluded!");
			GlobalEndApocalypseMode(0);
			return;
	}
}
// New 06/05/2004
// SNOOPY: Fixed Party Code
void CGame::RequestCreatePartyHandler(int iClientH)
{	char *cp, cData[120];
	DWORD * dwp;
	WORD * wp;
	if (m_pClientList[iClientH] == NULL) return;
	if (m_pClientList[iClientH]->m_bIsInitComplete == FALSE) return;
	if (m_pClientList[iClientH]->m_iPartyStatus != DEF_PARTYSTATUS_NULL) 
	{	return;
	}
	m_pClientList[iClientH]->m_iPartyStatus = DEF_PARTYSTATUS_PROCESSING;
	// Gate Server  PartyID
	ZeroMemory(cData, sizeof(cData));
	cp = (char *)cData;
	dwp = (DWORD *)cp;
	*dwp = MSGID_PARTYOPERATION;
	cp += 4;
	wp = (WORD*)cp;
	*wp = 1; // 1, request create
	cp += 2;
	wp = (WORD *)cp;
	*wp = iClientH;
	cp += 2;
	memcpy(cp, m_pClientList[iClientH]->m_cCharName, 10);
	cp += 10;
	// Party message
	if (m_iPartyLog == TRUE) 
	{	wsprintf(G_cTxt, "<Msg1 -> Gate> (create): %s<%d>"
			, m_pClientList[iClientH]->m_cCharName
			, iClientH);
		PutPartyLogFileList(G_cTxt);
	}
	SendMsgToGateServer(MSGID_PARTYOPERATION, iClientH, cData);
}

// Last Updated October 28, 2004 - 3.51 translation
// SNOOPY: Fixed Party Code
// Recive and interprets Gate messages...
void CGame::PartyOperationResultHandler(char *pData)
{
	char * cp, cResult, cName[12];
	WORD * wp;
	int i, iClientH, iPartyID, iTotal;

	cp = (char *)(pData + 4);  
	wp = (WORD *)cp;
	cp += 2;

	switch (*wp) {
	case 1: // Create a new party
		cResult = *cp;
		cp++;
		wp = (WORD *)cp;
		iClientH = (int)*wp;
		cp += 2;
		ZeroMemory(cName, sizeof(cName));
		memcpy(cName, cp, 10);
		cp += 10;
		wp = (WORD *)cp;
		iPartyID = (int)*wp;
		cp += 2;
		if (m_pClientList[iClientH] == NULL) return;
		// Party message
		if (m_iPartyLog == TRUE) 
		{	wsprintf(G_cTxt, "<Gate -> Msg1> (Create):     PartyID:%d %s<%d> (cResult:%d)"
				, iPartyID
				, cName
				, iClientH
				, (int) cResult);
			PutPartyLogFileList(G_cTxt);
		}
		PartyOperationResult_Create(iClientH, cName, cResult, iPartyID);
		break;

	case 2: // Delete a party
		wp = (WORD *)cp;
		iPartyID = *wp;
		cp += 2;
		// Party message		
		if (m_iPartyLog == TRUE) 
		{	wsprintf(G_cTxt, "<Gate -> Msg2> (Delete):     PartyID:%d"
				, iPartyID);
			PutPartyLogFileList(G_cTxt);
		}
		PartyOperationResult_Delete(iPartyID);

		break;

	case 3: // Actualize Party  (Character was saved with party info, deletes it !  )
		wp = (WORD *)cp;
		iClientH = *wp;
		cp += 2;

		ZeroMemory(cName, sizeof(cName));
		memcpy(cName, cp, 10);
		cp += 10;
		// Snoopy: Strange bug here, <0 and above positive integer!!!!
		//if ((iClientH < 0) && (iClientH > DEF_MAXCLIENTS)) return;
		if ((iClientH < 1) || (iClientH > DEF_MAXCLIENTS)) return;

		if (m_pClientList[iClientH] == NULL) return;
		if (strcmp(m_pClientList[iClientH]->m_cCharName, cName) != 0) return;

		// Party message
		if (m_iPartyLog == TRUE) 
		{	wsprintf(G_cTxt, "<Gate -> Msg3> (Actualise):  PartyID:%d %s<%d> (initial nb %d)"
				, m_pClientList[iClientH]->m_iPartyID
				, m_pClientList[iClientH]->m_cCharName
				, iClientH
				, m_stPartyInfo[m_pClientList[iClientH]->m_iPartyID].iTotalMembers);
			PutPartyLogFileList(G_cTxt);
		}

		for (i = 0; i < DEF_MAXPARTYMEMBERS; i++)
		{	if (m_stPartyInfo[m_pClientList[iClientH]->m_iPartyID].iIndex[i] == iClientH) 
			{	m_stPartyInfo[m_pClientList[iClientH]->m_iPartyID].iIndex[i] = 0;
				m_stPartyInfo[m_pClientList[iClientH]->m_iPartyID].iTotalMembers--;
				goto PORH_LOOPBREAK1;
			}
		}
PORH_LOOPBREAK1:;
		for (i = 0; i < DEF_MAXPARTYMEMBERS-1; i++)
		{	if ((m_stPartyInfo[m_pClientList[iClientH]->m_iPartyID].iIndex[i] == 0) 
			&& (m_stPartyInfo[m_pClientList[iClientH]->m_iPartyID].iIndex[i+1] != 0)) 
			{	m_stPartyInfo[m_pClientList[iClientH]->m_iPartyID].iIndex[i] = m_stPartyInfo[m_pClientList[iClientH]->m_iPartyID].iIndex[i+1];
				m_stPartyInfo[m_pClientList[iClientH]->m_iPartyID].iIndex[i+1] = 0;
			}
		}
		m_pClientList[iClientH]->m_iPartyID = NULL;
		m_pClientList[iClientH]->m_iPartyStatus = DEF_PARTYSTATUS_NULL;

		SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_PARTY, 8, 0, NULL, NULL);
		break;

	case 4: // Join a party
		cResult = *cp;
		cp++;

		wp = (WORD *)cp;
		iClientH = (int)*wp;
		cp += 2;

		ZeroMemory(cName, sizeof(cName));
		memcpy(cName, cp, 10);
		cp += 10;

		wp = (WORD *)cp;
		iPartyID = (int)*wp;
		cp += 2;

		if (m_pClientList[iClientH] == NULL) return;
		// Party message
		if (m_iPartyLog == TRUE) 
		{	wsprintf(G_cTxt, "<Gate -> Msg4> (Add member): PartyID:%d %s<%d> (result:%d)"
				, iPartyID
				, cName
				, iClientH
				, (int) cResult);
			PutPartyLogFileList(G_cTxt);
		}
		PartyOperationResult_Join(iClientH, cName, cResult, iPartyID);

		break;

	case 5: // info
		
		wp = (WORD *)cp;
		iClientH = (int)*wp;
		cp += 2;

		ZeroMemory(cName, sizeof(cName));
		memcpy(cName, cp, 10);
		cp += 10;

		wp = (WORD *)cp;
		iTotal = (int)*wp;
		cp += 2;

		if (m_pClientList[iClientH] == NULL) return;
		// Party message
		if (m_iPartyLog == TRUE) 
		{	wsprintf(G_cTxt, "<Gate -> Msg5> (Party info): PartyID:%d %s<%d> (total %d)"
				, m_pClientList[iClientH]->m_iPartyID
				, cName
				, iClientH
				, iTotal);
			PutPartyLogFileList(G_cTxt);
		}
		PartyOperationResult_Info(iClientH, cName, iTotal, cp);

		break;

	case 6:	// Dismiss some one from a party
		cResult = *cp;
		cp++;

		wp = (WORD *)cp;
		iClientH = (int)*wp;
		cp += 2;

		ZeroMemory(cName, sizeof(cName));
		memcpy(cName, cp, 10);
		cp += 10;

		wp = (WORD *)cp;
		iPartyID = (int)*wp;
		cp += 2;

		if (m_pClientList[iClientH] == NULL) return;
		// Party message
		if (m_iPartyLog == TRUE) 
		{	wsprintf(G_cTxt, "<Gate -> Msg6> (Dismiss):    PartyID:%d %s<%d> (result:%d)"
				, iPartyID
				, cName
				, iClientH
				, (int) cResult);
			PutPartyLogFileList(G_cTxt);
		}
		PartyOperationResult_Dismiss(iClientH, cName, cResult, iPartyID);
		break;
	}
}

// SNOOPY: Fixed Party Code
// Gate asks to create the party on the server where client currentlly are located
void CGame::PartyOperationResult_Create(int iClientH, char *pName, int iResult, int iPartyID)
{
	char * cp, cData[120];
	DWORD * dwp;
	WORD * wp;
	int i;

	if (m_pClientList[iClientH] == NULL) return;
	if (strcmp(m_pClientList[iClientH]->m_cCharName, pName) != 0) return;

	// SNOOPY: Prevent creation of a n° 0 party
	if ( (iPartyID == 0) && (iResult !=0) ) return; 

	switch (iResult) {
	case 0: // Failure ?

		if (m_pClientList[iClientH]->m_iPartyStatus != DEF_PARTYSTATUS_PROCESSING) return;
		if (strcmp(m_pClientList[iClientH]->m_cCharName, pName) != 0) return;

		m_pClientList[iClientH]->m_iPartyID = NULL;
		m_pClientList[iClientH]->m_iPartyStatus = DEF_PARTYSTATUS_NULL;
		m_pClientList[iClientH]->m_iReqJoinPartyClientH = NULL;
		// SNOOPY added this for safety
		ZeroMemory(m_pClientList[iClientH]->m_cReqJoinPartyName, sizeof(m_pClientList[iClientH]->m_cReqJoinPartyName));

		SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_PARTY, 1, 0, NULL, NULL);
		break;

	case 1: // create the party
		if (m_pClientList[iClientH]->m_iPartyStatus != DEF_PARTYSTATUS_PROCESSING) return;
		if (strcmp(m_pClientList[iClientH]->m_cCharName, pName) != 0) return;

		m_pClientList[iClientH]->m_iPartyID = iPartyID;
		m_pClientList[iClientH]->m_iPartyStatus = DEF_PARTYSTATUS_CONFIRM;
		SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_PARTY, 1, 1, NULL, NULL);

		// Add the client to newly created party
		for (i = 0; i < DEF_MAXPARTYMEMBERS; i++)
		{	if (m_stPartyInfo[m_pClientList[iClientH]->m_iPartyID].iIndex[i] == 0) 
			{	m_stPartyInfo[m_pClientList[iClientH]->m_iPartyID].iIndex[i] = iClientH;
				m_stPartyInfo[m_pClientList[iClientH]->m_iPartyID].iTotalMembers++;
				// Party message
				if (m_iPartyLog == TRUE) 
				{	wsprintf(G_cTxt, "Party was created:       PartyID:%d %s<%d> (total %d) %s(%d %d)IP(%s)"
						, m_pClientList[iClientH]->m_iPartyID
						, m_pClientList[iClientH]->m_cCharName
						, iClientH
						, m_stPartyInfo[m_pClientList[iClientH]->m_iPartyID].iTotalMembers
						, m_pClientList[iClientH]->m_cMapName
						, m_pClientList[iClientH]->m_sX
						, m_pClientList[iClientH]->m_sY
						, m_pClientList[iClientH]->m_cIPaddress);	
					PutPartyLogFileList(G_cTxt);
				}
				goto PORC_LOOPBREAK1;
			}
		}
PORC_LOOPBREAK1:;

		// ask Gate server about client joining newlly created party
		if ((m_pClientList[iClientH]->m_iReqJoinPartyClientH != NULL) && (strlen(m_pClientList[iClientH]->m_cReqJoinPartyName) != NULL)) {
			ZeroMemory(cData, sizeof(cData));
			cp = (char *)cData;
			dwp = (DWORD *)cp;
			*dwp = MSGID_PARTYOPERATION;
			cp += 4;
			wp = (WORD*)cp;
			*wp = 3; // 3 : Join
			cp += 2;
			wp = (WORD *)cp;
			*wp = m_pClientList[iClientH]->m_iReqJoinPartyClientH;
			cp += 2;
			memcpy(cp, m_pClientList[iClientH]->m_cReqJoinPartyName, 10);
			cp += 10;
			wp = (WORD *)cp;
			*wp = m_pClientList[iClientH]->m_iPartyID;
			cp += 2;
			// Party message
			if (m_iPartyLog == TRUE) 
			{	wsprintf(G_cTxt, "<Msg3 -> Gate> (Join-1): PC(%s) iClientH(%d) m_iPartyID(%d) "
					, m_pClientList[m_pClientList[iClientH]->m_iReqJoinPartyClientH]->m_cCharName
					, (int) m_pClientList[iClientH]->m_iReqJoinPartyClientH
					, m_pClientList[m_pClientList[iClientH]->m_iReqJoinPartyClientH]->m_iPartyID);
				PutPartyLogFileList(G_cTxt);
			}
			SendMsgToGateServer(MSGID_PARTYOPERATION, iClientH, cData);
			m_pClientList[iClientH]->m_iReqJoinPartyClientH = NULL;
			ZeroMemory(m_pClientList[iClientH]->m_cReqJoinPartyName, sizeof(m_pClientList[iClientH]->m_cReqJoinPartyName));
		}
		break;
	}
}

// SNOOPY: Fixed Party Code
// Last Updated October 28, 2004 - 3.51 translation
void CGame::PartyOperationResult_Join(int iClientH, char *pName, int iResult, int iPartyID)
{
	int i;

	if (m_pClientList[iClientH] == NULL) return;

	
	// SNOOPY: Prevent creation of a n° 0 party
	if ((iPartyID == 0) && (iResult !=0)) return; 

	switch (iResult) {
	case 0: // Failure ?
		if (m_pClientList[iClientH]->m_iPartyStatus != DEF_PARTYSTATUS_PROCESSING) return;
		
		// if party is in another server, do nothing..
		if (strcmp(m_pClientList[iClientH]->m_cCharName, pName) != 0) return;

		m_pClientList[iClientH]->m_iPartyID = NULL;
		m_pClientList[iClientH]->m_iPartyStatus = DEF_PARTYSTATUS_NULL;
		SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_PARTY, 4, 0, NULL, pName);

		m_pClientList[iClientH]->m_iReqJoinPartyClientH = NULL;
		ZeroMemory(m_pClientList[iClientH]->m_cReqJoinPartyName, sizeof(m_pClientList[iClientH]->m_cReqJoinPartyName));
		break;

	case 1: // Success
		if (m_pClientList[iClientH]->m_iPartyStatus != DEF_PARTYSTATUS_PROCESSING) return;
		
		// if party is in another server, do nothing...
		if (strcmp(m_pClientList[iClientH]->m_cCharName, pName) != 0) return;

		m_pClientList[iClientH]->m_iPartyID = iPartyID;
		m_pClientList[iClientH]->m_iPartyStatus = DEF_PARTYSTATUS_CONFIRM;
		SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_PARTY, 4, 1, NULL, pName);

		m_pClientList[iClientH]->m_iReqJoinPartyClientH = NULL;
		ZeroMemory(m_pClientList[iClientH]->m_cReqJoinPartyName, sizeof(m_pClientList[iClientH]->m_cReqJoinPartyName));

		for (i = 0; i < DEF_MAXPARTYMEMBERS; i++)
		{	if (m_stPartyInfo[m_pClientList[iClientH]->m_iPartyID].iIndex[i] == 0) 
			{	m_stPartyInfo[m_pClientList[iClientH]->m_iPartyID].iIndex[i] = iClientH;
				m_stPartyInfo[m_pClientList[iClientH]->m_iPartyID].iTotalMembers++;
				goto PORC_LOOPBREAK1;
			}
		} // for loop

PORC_LOOPBREAK1:;
		for (i = 1; i < DEF_MAXCLIENTS; i++)
		{	// SNOOPY: Try to inform asker of the party content immediatelly
			if (   (m_pClientList[i] != NULL)	
				&& (m_pClientList[i]->m_iPartyID != NULL)
				&& (m_pClientList[i]->m_iPartyID == iPartyID)) 
			{	if ((i != iClientH)) 
				{	SendNotifyMsg(NULL, i, DEF_NOTIFY_PARTY, 4, 1, NULL, pName);
					// Send EventA to show the magic auras
					SendEventToNearClient_TypeA(i, DEF_OWNERTYPE_PLAYER, MSGID_EVENT_MOTION, DEF_OBJECTNULLACTION, NULL, NULL, NULL);
				}else
				{	// Send back party info as if client was asking for it
					JoinPartyHandler(iClientH, 2, NULL);
				}
			}
		} // for loop
		// Party message
		if (m_iPartyLog == TRUE) 
		{	wsprintf(G_cTxt, "New member joined party: PartyID:%d %s<%d> (total %d) %s(%d %d)IP(%s)"
				, m_pClientList[iClientH]->m_iPartyID
				, m_pClientList[iClientH]->m_cCharName
				, iClientH
				, m_stPartyInfo[m_pClientList[iClientH]->m_iPartyID].iTotalMembers
				, m_pClientList[iClientH]->m_cMapName
				, m_pClientList[iClientH]->m_sX
				, m_pClientList[iClientH]->m_sY
				, m_pClientList[iClientH]->m_cIPaddress);	
			PutPartyLogFileList(G_cTxt);
		}
		break;
	}
}
  
// SNOOPY: Fixed Party Code
void CGame::PartyOperationResult_Dismiss(int iClientH, char *pName, int iResult, int iPartyID)
{	int i;
	// SNOOPY: Prevent dismissing th 0 party
	if ((iPartyID == 0) && (iResult != 0)) return; 
	if (m_stPartyInfo[iPartyID].iTotalMembers == 0) 
	{	if (m_iPartyLog == TRUE) 
		{	wsprintf(G_cTxt, "Party member withdraw:   PartyID:%d %s<%d> (Party already deleted, aborting!)"
				, iPartyID
				, pName
				, iClientH);	
			PutPartyLogFileList(G_cTxt);
		}
		return; 
	}

	switch (iResult) {
	case 0: // failure
		break;

	case 1: // success
		// iClient parsed is a wrong one 
		// (may be in the case of a client's party destroyed from another server)
		if (iClientH == NULL) 
		{	// find the rigth iClient
			for (i = 1; i < DEF_MAXCLIENTS; i++)
			{	if ((m_pClientList[i] != NULL) && (strcmp(m_pClientList[i]->m_cCharName, pName) == 0))
				{	iClientH = i;
					goto PORD_LOOPBREAK;
				}
			}
			// Notify everybody of client leaving party
			for (i = 1; i < DEF_MAXCLIENTS; i++)
			{	if (   (m_pClientList[i] != NULL) 
					&& (m_pClientList[i]->m_iPartyID != NULL) 
					&& (m_pClientList[i]->m_iPartyID == iPartyID)) 
				{	SendNotifyMsg(NULL, i, DEF_NOTIFY_PARTY, 6, 1, NULL, pName);
				}
			}

			// Remove from party structure
PORD_LOOPBREAK:;
			for (i = 0; i < DEF_MAXPARTYMEMBERS; i++)
			{	if (m_stPartyInfo[iPartyID].iIndex[i] == iClientH) 
				{	m_stPartyInfo[iPartyID].iIndex[i] = 0;
					m_stPartyInfo[iPartyID].iTotalMembers--;
					goto PORC_LOOPBREAK1;
				}
			}

			// Re-organize party Structure
PORC_LOOPBREAK1:;
			for (i = 0; i < DEF_MAXPARTYMEMBERS-1; i++)
			{	if (   (m_stPartyInfo[iPartyID].iIndex[i] == 0) 
					&& (m_stPartyInfo[iPartyID].iIndex[i+1] != 0)) 
				{	m_stPartyInfo[iPartyID].iIndex[i]   = m_stPartyInfo[iPartyID].iIndex[i+1];
					m_stPartyInfo[iPartyID].iIndex[i+1] = 0;
				}
			}
			// Remove party info from character data
			if (m_pClientList[iClientH] != NULL) 
			{	m_pClientList[iClientH]->m_iPartyID = NULL;
				m_pClientList[iClientH]->m_iPartyStatus = DEF_PARTYSTATUS_NULL;
				m_pClientList[iClientH]->m_iReqJoinPartyClientH = NULL;
				// SNOOPY: Added safety here
				ZeroMemory(m_pClientList[iClientH]->m_cReqJoinPartyName, sizeof(m_pClientList[iClientH]->m_cReqJoinPartyName));
			}
			if (m_iPartyLog == TRUE)
			{	if (m_pClientList[iClientH] != NULL)
				{	// Party message
					wsprintf(G_cTxt, "Party member withdraw: X PartyID:%d %s<%d> (remain %d) %s(%d %d)IP(%s)"
						, iPartyID
						, m_pClientList[iClientH]->m_cCharName
						, iClientH
						, m_stPartyInfo[iPartyID].iTotalMembers
						, m_pClientList[iClientH]->m_cMapName
						, m_pClientList[iClientH]->m_sX
						, m_pClientList[iClientH]->m_sY
						, m_pClientList[iClientH]->m_cIPaddress);	
				}else
				{	wsprintf(G_cTxt, "Party member withdraw: X PartyID:%d %s<?> (Not on this server)"
						, iPartyID
						, pName);	
				}
				PutPartyLogFileList(G_cTxt);
			}
			return;
		}
		// iClient parsed is not NULL
		if ((m_pClientList[iClientH] != NULL) // Abort if already Party processing
			&& (m_pClientList[iClientH]->m_iPartyStatus != DEF_PARTYSTATUS_PROCESSING)) 
		{	// Party message
			if (m_iPartyLog == TRUE) 
			{	wsprintf(G_cTxt, "Party member withdraw: * PartyID:%d %s<%d> (Client not party processing)"
					, iPartyID
					, pName
					, iClientH);
				PutPartyLogFileList(G_cTxt);			
			}
			return;
		}

		if ((m_pClientList[iClientH] != NULL) // Abort if Client not on this server
			&& (strcmp(m_pClientList[iClientH]->m_cCharName, pName) != 0)) 
		{	// Party message
			if (m_iPartyLog == TRUE) 
			{	wsprintf(G_cTxt, "Party member withdraw: * PartyID:%d %s<%d> (Name mismatch: %s)"
					, iPartyID
					, m_pClientList[iClientH]->m_cCharName
					, iClientH
					, pName);
				PutPartyLogFileList(G_cTxt);	
			}
			return;
		}

		// Notify everybody of client leaving party
		for (i = 1; i < DEF_MAXCLIENTS; i++)
		{	if (   (m_pClientList[i] != NULL) 
				&& (m_pClientList[i]->m_iPartyID != NULL) 
				&& (m_pClientList[i]->m_iPartyID == iPartyID))
			{	SendNotifyMsg(NULL, i, DEF_NOTIFY_PARTY, 6, 1, NULL, pName);
			}
		}

		// Remove from party structure
		for (i = 0; i < DEF_MAXPARTYMEMBERS; i++)
		{	if (m_stPartyInfo[iPartyID].iIndex[i] == iClientH) 
			{	m_stPartyInfo[iPartyID].iIndex[i] = 0;
				m_stPartyInfo[iPartyID].iTotalMembers--;
				goto PORC_LOOPBREAK2;
			}
		}

		// Re-organize party Structure
PORC_LOOPBREAK2:;
		for (i = 0; i < DEF_MAXPARTYMEMBERS-1; i++)
		{	if ((m_stPartyInfo[iPartyID].iIndex[i] == 0) 
				&& (m_stPartyInfo[iPartyID].iIndex[i+1] != 0)) 
			{	m_stPartyInfo[iPartyID].iIndex[i]   = m_stPartyInfo[iPartyID].iIndex[i+1];
				m_stPartyInfo[iPartyID].iIndex[i+1] = 0;		
				// Snoopy, Resend eventA to party members to remove the aura from dismissed character
				SendEventToNearClient_TypeA(i, DEF_OWNERTYPE_PLAYER, MSGID_EVENT_MOTION, DEF_OBJECTNULLACTION, NULL, NULL, NULL);
			}	
		}

		// Remove party info from character data
		if (m_pClientList[iClientH] != NULL) 
		{	m_pClientList[iClientH]->m_iPartyID = NULL;
			m_pClientList[iClientH]->m_iPartyStatus = DEF_PARTYSTATUS_NULL;
			m_pClientList[iClientH]->m_iReqJoinPartyClientH = NULL;		
			
			// SNOOPY: Added safety here
			ZeroMemory(m_pClientList[iClientH]->m_cReqJoinPartyName, sizeof(m_pClientList[iClientH]->m_cReqJoinPartyName));
			// Snoopy, Remove magic aura off ex-party members
			SendEventToNearClient_TypeA(iClientH, DEF_OWNERTYPE_PLAYER, MSGID_EVENT_MOTION, DEF_OBJECTNULLACTION, NULL, NULL, NULL);
		}
		if (m_iPartyLog == TRUE)// Party message
		{	if (m_pClientList[iClientH] != NULL) 
			{	wsprintf(G_cTxt, "Party member withdraw: * PartyID:%d %s<%d> (remain %d) %s(%d %d)IP(%s)"
					, iPartyID
					, m_pClientList[iClientH]->m_cCharName
					, iClientH
					, m_stPartyInfo[iPartyID].iTotalMembers
					, m_pClientList[iClientH]->m_cMapName
					, m_pClientList[iClientH]->m_sX
					, m_pClientList[iClientH]->m_sY
					, m_pClientList[iClientH]->m_cIPaddress);	
			}else
			{	wsprintf(G_cTxt, "Party member withdraw: * PartyID:%d %s<?> (Not on this server)"
					, iPartyID
					, pName);	
			}
			PutPartyLogFileList(G_cTxt);
		}
		break;
	}
}

// SNOOPY: Fixed Party Code
void CGame::PartyOperationResult_Delete(int iPartyID)
{
	int i;
	
	for (i = 0; i < DEF_MAXPARTYMEMBERS; i++)
	{
		m_stPartyInfo[iPartyID].iIndex[i] = 0;
	}
	m_stPartyInfo[iPartyID].iTotalMembers = 0;

	// Nullify party & notify to everybody
	for (i = 1; i < DEF_MAXCLIENTS; i++)
	{	if (   (m_pClientList[i] != NULL) 
			&& (m_pClientList[i]->m_iPartyID == iPartyID)) 
		{	SendNotifyMsg(NULL, i, DEF_NOTIFY_PARTY, 2, 0, NULL, NULL);
			m_pClientList[i]->m_iPartyID = NULL;
			m_pClientList[i]->m_iPartyStatus = DEF_PARTYSTATUS_NULL;
			m_pClientList[i]->m_iReqJoinPartyClientH = NULL;
			// SNOOPY: Added safety here
			ZeroMemory(m_pClientList[i]->m_cReqJoinPartyName, sizeof(m_pClientList[i]->m_cReqJoinPartyName));

			// Snoopy, Remove magic aura off ex-party members
			SendEventToNearClient_TypeA(i, DEF_OWNERTYPE_PLAYER, MSGID_EVENT_MOTION, DEF_OBJECTNULLACTION, NULL, NULL, NULL);
		}
	}
	// Party message
	if (m_iPartyLog == TRUE) 
	{	wsprintf(G_cTxt, "Party was deleted:       PartyID:%d"
		, iPartyID);	
		PutPartyLogFileList(G_cTxt);
	}
}

// only used by /joinparty command
// SNOOPY: Fixed Party Code
void CGame::RequestJoinPartyHandler(int iClientH, char *pData, DWORD dwMsgSize)
{	char   seps[] = "= \t\n";
	char   * cp, * token, cBuff[256], cData[120], cName[12];
	class  CStrTok * pStrTok;
	DWORD * dwp;
	WORD  * wp;
	int i;	
	if (m_pClientList[iClientH] == NULL) return;
	if (m_pClientList[iClientH]->m_iPartyStatus != DEF_PARTYSTATUS_NULL) return;
	if ((dwMsgSize)	<= 0) return;
	if ((m_bAdminSecurity == TRUE) && (m_pClientList[iClientH]->m_iAdminUserLevel > 0)) return;
	ZeroMemory(cBuff, sizeof(cBuff));
	memcpy(cBuff, pData, dwMsgSize);
	pStrTok = new class CStrTok(cBuff, seps);
	token = pStrTok->pGet();
	token = pStrTok->pGet();
	if (token != NULL) 
	{	ZeroMemory(cName, sizeof(cName));
		strcpy(cName, token);
	}
	else { delete pStrTok; return;}
	for (i = 1; i < DEF_MAXCLIENTS; i++)
		if (   (m_pClientList[i] != NULL) 
			&& (strcmp(m_pClientList[i]->m_cCharName, cName) == 0)) 
		{	if (   (m_pClientList[i]->m_iPartyID == NULL) 
				|| (m_pClientList[i]->m_iPartyStatus != DEF_PARTYSTATUS_CONFIRM)) 
			{	delete pStrTok;	return;
			}
			ZeroMemory(cData, sizeof(cData));			
			cp = (char *)cData;
			dwp = (DWORD *)cp;
			*dwp = MSGID_PARTYOPERATION;
			cp += 4;
			wp = (WORD*)cp;
			*wp = 3; // 3: Join
			cp += 2;
			wp = (WORD *)cp;
			*wp = iClientH;
			cp += 2;
			memcpy(cp, m_pClientList[iClientH]->m_cCharName, 10);
			cp += 10;
			wp = (WORD *)cp;
			*wp = m_pClientList[i]->m_iPartyID;
			cp += 2;
			// Party message
			if (m_iPartyLog == TRUE) 
			{	wsprintf(G_cTxt, "<Msg3 -> Gate> (Join-2): PartyID:%d %s<%d>"
					, m_pClientList[iClientH]->m_iPartyID
					, m_pClientList[iClientH]->m_cCharName
					, iClientH);	
				PutPartyLogFileList(G_cTxt);
			}
			SendMsgToGateServer(MSGID_PARTYOPERATION, iClientH, cData);
			delete pStrTok;
			return;
		}
	SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_PLAYERNOTONGAME, NULL, NULL, NULL, cName);	
	delete pStrTok;
}

// called by "/dismissparty" command
//        or cancellation of a join operation by asker
// SNOOPY: Fixed Party Code
void CGame::RequestDismissPartyHandler(int iClientH)
{	char * cp, cData[120];
	DWORD * dwp;
	WORD  * wp;
	if (m_pClientList[iClientH] == NULL) return;
	if (m_pClientList[iClientH]->m_iPartyStatus != DEF_PARTYSTATUS_CONFIRM) return;

	ZeroMemory(cData, sizeof(cData));
	cp = (char *)cData;
	dwp = (DWORD *)cp;
	*dwp = MSGID_PARTYOPERATION;
	cp += 4;
	wp = (WORD*)cp;
	*wp = 4; // 4: Withdraw from party
	cp += 2;
	wp = (WORD *)cp;
	*wp = iClientH;
	cp += 2;
	memcpy(cp, m_pClientList[iClientH]->m_cCharName, 10);
	cp += 10;
	wp = (WORD *)cp;
	*wp = m_pClientList[iClientH]->m_iPartyID;
	cp += 2;
	if (m_iPartyLog == TRUE) 	// Party message
	{	wsprintf(G_cTxt, "<Msg4 -> Gate> (withdraw req-1): PartyID:%d %s<%d>"
			, m_pClientList[iClientH]->m_iPartyID
			, m_pClientList[iClientH]->m_cCharName
			, iClientH);	
		PutPartyLogFileList(G_cTxt);
	}
	SendMsgToGateServer(MSGID_PARTYOPERATION, iClientH, cData);
	m_pClientList[iClientH]->m_iPartyStatus = DEF_PARTYSTATUS_PROCESSING;
}

// Must be calle too on client connecting to confirm to the gate server
// that he is connected, and not to remove him from his party.
// SNOOPY: Fixed Party Code
void CGame::GetPartyInfoHandler(int iClientH)
{	char * cp, cData[120];
	DWORD * dwp;
	WORD  * wp;
	if (m_pClientList[iClientH] == NULL) return;
	if (m_pClientList[iClientH]->m_iPartyStatus != DEF_PARTYSTATUS_CONFIRM) return;

	// 1 - Inform the Gate server that Client is well connected
	//     to prevent Gate from dismissing the client from party
	ZeroMemory(cData, sizeof(cData));
	cp = (char *)cData;
	dwp = (DWORD *)cp;
	*dwp = MSGID_PARTYOPERATION;
	cp += 4;
	wp = (WORD*)cp;
	*wp = 5; // 5: Inform Gate that client is reconnected
	cp += 2;
	wp = (WORD *)cp;
	*wp = iClientH;
	cp += 2;
	memcpy(cp, m_pClientList[iClientH]->m_cCharName, 10);
	cp += 10;
	wp = (WORD *)cp;
	*wp = m_pClientList[iClientH]->m_iPartyID;
	cp += 2;

	// Party message
	if (m_iPartyLog == TRUE) 
	{	wsprintf(G_cTxt, "<Msg5 -> Gate> (Client reconnected): PartyID:%d %s<%d>"
			, m_pClientList[iClientH]->m_iPartyID
			, m_pClientList[iClientH]->m_cCharName
			, iClientH);	
		PutPartyLogFileList(G_cTxt);
	}
	SendMsgToGateServer(MSGID_PARTYOPERATION, iClientH, cData);

	// 2 - Ask the Gate server to send back information about 
	//     client's party, just in case of the server haven't it.
	ZeroMemory(cData, sizeof(cData));
	cp = (char *)cData;
	dwp = (DWORD *)cp;
	*dwp = MSGID_PARTYOPERATION;
	cp += 4;
	wp = (WORD*)cp;
	*wp = 6; // 6: Asks Gate to inform server about Party
	cp += 2;
	wp = (WORD *)cp;
	*wp = iClientH;
	cp += 2;
	memcpy(cp, m_pClientList[iClientH]->m_cCharName, 10);
	cp += 10;
	wp = (WORD *)cp;
	*wp = m_pClientList[iClientH]->m_iPartyID;
	cp += 2;

	// Party message
	if (m_iPartyLog == TRUE) 
	{	wsprintf(G_cTxt, "<Msg6 -> Gate> (Party info request): PartyID:%d %s<%d>"
			, m_pClientList[iClientH]->m_iPartyID
			, m_pClientList[iClientH]->m_cCharName
			, iClientH);	
		PutPartyLogFileList(G_cTxt);
	}
	SendMsgToGateServer(MSGID_PARTYOPERATION, iClientH, cData);
}
// SNOOPY: Fixed Party Code
void CGame::PartyOperationResult_Info(int iClientH, char * pName, int iTotal, char *pNameList)
{
	if (m_pClientList[iClientH] == NULL) return;
	if (strcmp(m_pClientList[iClientH]->m_cCharName, pName) != 0) return;
	if (m_pClientList[iClientH]->m_iPartyStatus != DEF_PARTYSTATUS_CONFIRM) return;
	SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_PARTY, 5, 1, iTotal, pNameList);

// Try and get Party list
	char * pMyNameList[11][9];
	int i;	
	int k;
	int iPartyID = m_pClientList[iClientH]->m_iPartyID; 
	bool b_IsHere;
	// first reset the party structure
	for (k = 0; k < DEF_MAXPARTYMEMBERS; k++)
	{	m_stPartyInfo[iPartyID].iIndex[k] = NULL;	
	}
	// Then create a new party structure
	m_stPartyInfo[iPartyID].iTotalMembers = iTotal;
	for (k = 0; k < iTotal; k++)
	{	pMyNameList[0][k] = pNameList +(11*k);
		//if (m_iPartyLog == TRUE) PutPartyLogFileList(pMyNameList[0][k]);
		b_IsHere = FALSE;	
		for (i = 1; i < DEF_MAXCLIENTS; i++)
		{	if (m_pClientList[i] != NULL) 
			{	if (strcmp(m_pClientList[i]->m_cCharName, pMyNameList[0][k]) == 0)
				{	// Same name, character is on this server
					m_stPartyInfo[iPartyID].iIndex[k] = i;	
				 	if (m_iPartyLog == TRUE) 
					{	wsprintf(G_cTxt, "Party info, on server :      PartyID:%d %s<%d> (total %d) added: %s<%d>"
							, iPartyID
							, pName
							, iClientH
							, m_stPartyInfo[iPartyID].iTotalMembers
							, pMyNameList[0][k]
							, i);	
						PutPartyLogFileList(G_cTxt);
					}
					b_IsHere = TRUE;						
				}
			}
		}
		if (   (m_iPartyLog == TRUE) 
			&& (b_IsHere == FALSE)) // Character is not on this server
		{	wsprintf(G_cTxt, "Party info, not here  :      PartyID:%d %s<%d> (total %d) name : %s<.>"
				, iPartyID
				, pName
				, iClientH
				, m_stPartyInfo[iPartyID].iTotalMembers
				, pMyNameList[0][k]);	
			PutPartyLogFileList(G_cTxt);
		}
	}
}
// SNOOPY: Fixed Party Code
void CGame::RequestDeletePartyHandler(int iClientH)
{	// Remove the client from his party
	char * cp, cData[120];
	DWORD * dwp;
	WORD * wp;
	if (m_pClientList[iClientH] == NULL) return;
	if (m_pClientList[iClientH]->m_iPartyID != NULL) {
		ZeroMemory(cData, sizeof(cData));
		cp = (char *)cData;
		dwp = (DWORD *)cp;
		*dwp = MSGID_PARTYOPERATION;
		cp += 4;
		wp = (WORD*)cp;
		*wp = 4; // delete
		cp += 2;
		wp = (WORD *)cp;
		*wp = iClientH;
		cp += 2;
		memcpy(cp, m_pClientList[iClientH]->m_cCharName, 10);
		cp += 10;
		wp = (WORD *)cp;
		*wp = m_pClientList[iClientH]->m_iPartyID;
		cp += 2;
		// Party message
		if (m_iPartyLog == TRUE) 
		{	wsprintf(G_cTxt, "<Msg4 -> Gate> (withdraw req-2): PartyID:%d %s<%d>"
				, m_pClientList[iClientH]->m_iPartyID
				, m_pClientList[iClientH]->m_cCharName
				, iClientH);	
			PutPartyLogFileList(G_cTxt);
		}
		SendMsgToGateServer(MSGID_PARTYOPERATION, iClientH, cData);
		m_pClientList[iClientH]->m_iPartyStatus = DEF_PARTYSTATUS_PROCESSING;
	}
}

// SNOOPY: Fixed Party Code
void CGame::RequestAcceptJoinPartyHandler(int iClientH, int iResult)
{
	char *cp, cData[120];
	DWORD * dwp;
	WORD * wp;
	int iH;

	if (m_pClientList[iClientH] == NULL) return;

	switch (iResult) {
	case 0: // reject
		iH = m_pClientList[iClientH]->m_iReqJoinPartyClientH;
		if (m_pClientList[iH] == NULL) {
			return;
		}
		if (strcmp(m_pClientList[iH]->m_cCharName, m_pClientList[iClientH]->m_cReqJoinPartyName) != 0) {
			return;
		}
		if (m_pClientList[iH]->m_iPartyStatus != DEF_PARTYSTATUS_PROCESSING) {
			return;
		}
		if ((m_pClientList[iH]->m_iReqJoinPartyClientH != iClientH) || (strcmp(m_pClientList[iH]->m_cReqJoinPartyName, m_pClientList[iClientH]->m_cCharName) != 0)) {
			return;
		}
		// Party message
		if (m_iPartyLog == TRUE) 
		{	wsprintf(G_cTxt, "<Client Ans0 > (refused) by PartyID:%d %s<%d> (Asker: %s<%d>)"
				, m_pClientList[iClientH]->m_iPartyID
				, m_pClientList[iClientH]->m_cCharName
				, iClientH
				, m_pClientList[iH]->m_cCharName
				, iH);	
			PutPartyLogFileList(G_cTxt);
		}
		SendNotifyMsg(NULL, iH, DEF_NOTIFY_PARTY, 7, 0, NULL, NULL);

		m_pClientList[iH]->m_iPartyID = NULL;
		m_pClientList[iH]->m_iPartyStatus = DEF_PARTYSTATUS_NULL;
		m_pClientList[iH]->m_iReqJoinPartyClientH = NULL;
		ZeroMemory(m_pClientList[iH]->m_cReqJoinPartyName, sizeof(m_pClientList[iH]->m_cReqJoinPartyName));

		m_pClientList[iClientH]->m_iReqJoinPartyClientH = NULL;
		ZeroMemory(m_pClientList[iClientH]->m_cReqJoinPartyName, sizeof(m_pClientList[iClientH]->m_cReqJoinPartyName));
		break;

	case 1: // acceptation
		if ((m_pClientList[iClientH]->m_iPartyStatus == DEF_PARTYSTATUS_CONFIRM) && (m_pClientList[iClientH]->m_iPartyID != NULL)) {
			// Asked client is already in party
			iH = m_pClientList[iClientH]->m_iReqJoinPartyClientH;
			if (m_pClientList[iH] == NULL) {
				return;
			}
			if (strcmp(m_pClientList[iH]->m_cCharName, m_pClientList[iClientH]->m_cReqJoinPartyName) != 0) {
				return;
			}
			if (m_pClientList[iH]->m_iPartyStatus != DEF_PARTYSTATUS_PROCESSING) {
				return;
			}
			if ((m_pClientList[iH]->m_iReqJoinPartyClientH != iClientH) || (strcmp(m_pClientList[iH]->m_cReqJoinPartyName, m_pClientList[iClientH]->m_cCharName) != 0)) {
				return;
			}			
			// Party message
			if (m_iPartyLog == TRUE) 
			{	wsprintf(G_cTxt, "<Client ans1> (accepted) by PartyID:%d %s<%d> (Asker: %s<%d>)"
					, m_pClientList[iClientH]->m_iPartyID
					, m_pClientList[iClientH]->m_cCharName
					, iClientH
					, m_pClientList[iH]->m_cCharName
					, iH);	
				PutPartyLogFileList(G_cTxt);
			}
			// msg to Gate
			ZeroMemory(cData, sizeof(cData));
			cp = (char *)cData;
			dwp = (DWORD *)cp;
			*dwp = MSGID_PARTYOPERATION;
			cp += 4;
			wp = (WORD*)cp;
			*wp = 3; // join
			cp += 2;
			wp = (WORD *)cp;
			*wp = m_pClientList[iClientH]->m_iReqJoinPartyClientH;
			cp += 2;
			memcpy(cp, m_pClientList[iClientH]->m_cReqJoinPartyName, 10);
			cp += 10;
			wp = (WORD *)cp;
			*wp = m_pClientList[iClientH]->m_iPartyID;
			cp += 2;			
			// Party message
			if (m_iPartyLog == TRUE) 
			{	wsprintf(G_cTxt, "<Msg3 -> Gate> (Join already existing party): PC(%s) iClientH(%d) m_iPartyID(%d) "
					, m_pClientList[iClientH]->m_cCharName
					, (int) iClientH
					, m_pClientList[iClientH]->m_iPartyID);
				PutPartyLogFileList(G_cTxt);
			}
			SendMsgToGateServer(MSGID_PARTYOPERATION, iClientH, cData);
		}else  // Asked client is not in party
		{	iH = m_pClientList[iClientH]->m_iReqJoinPartyClientH;
			if (m_pClientList[iH] == NULL) {
				return;
			}
			if (strcmp(m_pClientList[iH]->m_cCharName, m_pClientList[iClientH]->m_cReqJoinPartyName) != 0) {
				return;
			}
			if (m_pClientList[iH]->m_iPartyStatus != DEF_PARTYSTATUS_PROCESSING) {
				return;
			}
			if ((m_pClientList[iH]->m_iReqJoinPartyClientH != iClientH) || (strcmp(m_pClientList[iH]->m_cReqJoinPartyName, m_pClientList[iClientH]->m_cCharName) != 0)) {
				return;
			}
			//testcode
			if (m_iPartyLog == TRUE) 
			{	wsprintf(G_cTxt, "<Client Ans1 > (accepted) by PartyID:%d %s<%d> (-> create party) (Asker: %s<%d>)"
					, m_pClientList[iClientH]->m_iPartyID
					, m_pClientList[iClientH]->m_cCharName
					, iClientH
					, m_pClientList[iH]->m_cCharName
					, iH);	
				PutPartyLogFileList(G_cTxt);
			}
			// Then create a new Party
			if (m_pClientList[iClientH]->m_iPartyStatus == DEF_PARTYSTATUS_NULL) 
			{	RequestCreatePartyHandler(iClientH);
			}else{}
		}
		break;

	case 2: // Dismissing party during time someone asks to join ?
		// PutLogList("Client Party Ans 2 (cancelled)");
		// if client is in party, break it
		if (m_iPartyLog == TRUE) 
		{	wsprintf(G_cTxt, "<Client Ans2 > (cancelled) by PartyID:%d %s<%d>"
				, m_pClientList[iClientH]->m_iPartyID
				, m_pClientList[iClientH]->m_cCharName);	
			PutPartyLogFileList(G_cTxt);
		}
		if (   (m_pClientList[iClientH]->m_iPartyID != NULL) 
			&& (m_pClientList[iClientH]->m_iPartyStatus == DEF_PARTYSTATUS_CONFIRM)) 
		{	RequestDismissPartyHandler(iClientH);
		}else 	// Client is not in party then reject asker
		{	iH = m_pClientList[iClientH]->m_iReqJoinPartyClientH;
			if (   (m_pClientList[iH] != NULL) 
				&& (m_pClientList[iH]->m_iReqJoinPartyClientH == iClientH) 
				&& (strcmp(m_pClientList[iH]->m_cReqJoinPartyName, m_pClientList[iClientH]->m_cCharName) == 0)) 
			{	m_pClientList[iH]->m_iReqJoinPartyClientH = NULL;
				ZeroMemory(m_pClientList[iH]->m_cReqJoinPartyName, sizeof(m_pClientList[iH]->m_cReqJoinPartyName));
			}
			m_pClientList[iClientH]->m_iPartyID = NULL;
			m_pClientList[iClientH]->m_iPartyStatus = DEF_PARTYSTATUS_NULL;
			m_pClientList[iClientH]->m_iReqJoinPartyClientH = NULL;
			ZeroMemory(m_pClientList[iClientH]->m_cReqJoinPartyName, sizeof(m_pClientList[iClientH]->m_cReqJoinPartyName));
		}
		break;
	}
}

// SNOOPY: Added function to limit chances of high % items with low completion items & oils
int CGame::SkillCap (int Value, int SkillAl)
{   int ValueR = 13;
    if (SkillAl<131) ValueR = 10; 
    if (SkillAl<121) ValueR = 9; 
    if (SkillAl<111) ValueR = 8; 
    if (SkillAl<101) ValueR = 7; // MPrec perfect or Ball corrected max = 100
    if (SkillAl<91)  ValueR = 6;
    if (SkillAl<81)  ValueR = 5; // Max for blood weapons
    if (SkillAl<71)  ValueR = 4;
    if (SkillAl<61)  ValueR = 3;

    if (ValueR<Value)
    {   return (ValueR);
    }else
    {   return (Value);
    }
}

//***************************************************************************
//  Snoopy: Rewriten most of this function, to clarify some things          *
//          Diminish chances to loose alreaddy Xelima/Merien upgraded item  *
//          Add Manuf enchantements                                         *
//          Add gizon item upgrades                                         *
//          Added Merien Upgrade for Misc things                            *
//          (rings, necks, Bars=>100% purity                                *
//***************************************************************************
void CGame::RequestItemUpgradeHandler(int iClientH, int iItemIndex)
{	int i, /*iItemX,iItemY, */iSoM, iSoX, iSomH, iSoxH, iValue; // v2.172
	DWORD dwTemp, dwSWEType;
	double dV1, dV2, dV3;
	short sItemUpgrade = 2;

	// SNOOPY values for upgrades
	int dwType = 0;
	int dwValue = 0;
	int dwType2 = 0;
	int dwValue2 = 0;
	// For logging
	
	// Prepare String
	char cConcatString[500];
	char * p_CharResult;
	ZeroMemory(cConcatString,  sizeof(cConcatString));

	if (m_pClientList[iClientH] == NULL) return;
	if ((iItemIndex < 0) || (iItemIndex >= DEF_MAXITEMS)) return;
	if (m_pClientList[iClientH]->m_pItemList[iItemIndex] == NULL) return;

	iValue = (m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwAttribute & 0xF0000000) >> 28;
	if (iValue >= 15 || iValue < 0 ) 
	{	SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_ITEMUPGRADEFAIL, 1, NULL, NULL, NULL); // dejà au max
		return;
	}

	bool b_IsManufItem = FALSE;
	bool b_IsBloodItem = FALSE;
	int iOil, iElixir, iBall;

	// Look for Xelima or merien stones
	iSoX = iSoM = 0;
	iOil = iElixir = iBall = -1;
	for (i = 0; i < DEF_MAXITEMS; i++)
	{	if (m_pClientList[iClientH]->m_pItemList[i] != NULL) 
		{	switch (m_pClientList[iClientH]->m_pItemList[i]->m_sIDnum) {
				case 656: iSoX++; iSoxH = i; break; // XelimaStone
				case 657: iSoM++; iSomH = i; break; // MerienStone 
				case 968: iOil = i; break; //  SharpnessOil
				case 969: iOil = i; break; //  AgilityOil	
				case 970: iOil = i; break; //  PoisonOil
				case 971: iOil = i; break; //  BerzerkOil
				case 972: iOil = i; break; //  TruthOil
				case 977: iOil = i; break; //  Strange Stone
				case 963: iElixir = i; break; //  EagleElixir
				case 964: iElixir = i; break; //  TatooElixir
				case 965: iElixir = i; break; //  BufaloElixir
				case 966: iElixir = i; break; //  SnakeElixir
				case 967: iElixir = i; break; //  MagicElixir
				case 651: iBall = i; break; //  GreenBall
				case 652: iBall = i; break; //  RedBall
				case 653: iBall = i; break; //  YellowBall
				case 654: iBall = i; break; //  BlueBall
				case 655: iBall = i; break; //  PearlBall		
	}	}	}
	// v1.41 Custom-Made <==> Manuf items
	if ((m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwAttribute & 0x00000001) != NULL) 
	{	b_IsManufItem = TRUE;
	}
	if ((m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwAttribute & 0x00FFFF00) != NULL) 
	{	b_IsManufItem = FALSE; // Already enchanted item
	}
	// Blood weapons
	if (   (m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sItemEffectType == DEF_ITEMEFFECTTYPE_ATTACK_MAXHPDOWN)
		&& (m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_cCategory == 1))  
	{	b_IsBloodItem = TRUE; 
	}
	bool bIsNormalUpgrade = FALSE;
	bool bIsGizonUpgrade = FALSE;

	if ((iSoX >0) || (iSoM >0)) 
	{	bIsNormalUpgrade = TRUE;
	}else 
	{	if ((iOil == -1) && (m_pClientList[iClientH]->m_iGizonItemUpgradeLeft <= 0)) 
		{	// Neither gizon upgrade nor Alchimy upgrade is possible
			SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_ITEMUPGRADEFAIL, 2, NULL, NULL, NULL);
			return; 
		}
		// Gizon or Alchimy Upgrade
		bIsNormalUpgrade = FALSE;
		if (iOil == -1) 
		{	bIsGizonUpgrade = TRUE;
		}else 
		{	bIsGizonUpgrade = FALSE;
		}
	}
/////////////// 1st case: Alchemy upgrade ///////////////////////////////////////////
	if (   (bIsNormalUpgrade == FALSE) 
		&& (bIsGizonUpgrade == FALSE) 
		&& ((b_IsManufItem == TRUE) || (b_IsBloodItem == TRUE))
		&& (m_iAlchimyItemUpgradeEnabled == TRUE)) 
	{	int i_ManufBonus  = m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sItemSpecEffectValue2/2;
		int i_AlchiBonus1 = m_pClientList[iClientH]->m_pItemList[iOil]->m_sItemSpecEffectValue2/2;	
		int i_AlchiBonus2 = 0;	
		// Alchi Bonusses range from 5 to 50
		int i_BallBonus = 0;
		int ItemColor = m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_cItemColor;
		bool RecAble = false;  // May have recovery type.
		int TotalBonus1, TotalBonus2, BonusCap;

		// Determine bonusses
		if (iElixir!=-1) i_AlchiBonus2 = m_pClientList[iClientH]->m_pItemList[iElixir]->m_sItemSpecEffectValue2 / 2;
		
		if (iBall!=-1) 
		{	switch (m_pClientList[iClientH]->m_pItemList[iBall]->m_sIDnum) {
			case 651: i_BallBonus = 10;	break; // GreenBall
			case 652: i_BallBonus = 20; break; // RedBall
			case 653: i_BallBonus = 25; break; // YellowBall
			case 654: i_BallBonus = 30; break; // BlueBall
			case 655: i_BallBonus = 35; break; // PearlBall
			}
			if(m_pClientList[iClientH]->m_pItemList[iBall]->m_sIDnum != -1) RecAble = true;

			// No XXrec armor less than 110% Completion, and less than 50% purity
			if (i_ManufBonus  < 10) RecAble = false;
			if (i_AlchiBonus2 < 25) RecAble = false;

			// GreenBalls seldom gives XXrec
			if (   (m_pClientList[iClientH]->m_pItemList[iBall]->m_sIDnum == 951) 
				&& (iDice(1,300) >= i_AlchiBonus2+i_ManufBonus)) 
			{	RecAble = false;
			}
			// HauberkM and GreenBalls never gives XXrec
			if (   (m_pClientList[iClientH]->m_pItemList[iBall]->m_sIDnum == 951) 
				&& (m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sSprite == 7)
				&& (m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sSpriteFrame == 1)) 
			{	RecAble = false;
			}
			// HauberkW and GreenBalls never gives XXrec
			if (   (m_pClientList[iClientH]->m_pItemList[iBall]->m_sIDnum == 951) 
				&& (m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sSprite == 11)
				&& (m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sSpriteFrame == 2)) 
			{	RecAble = false;
			}
		}
		TotalBonus1 = i_AlchiBonus1 + i_ManufBonus + i_BallBonus;
		TotalBonus2 = i_AlchiBonus2 + i_ManufBonus + i_BallBonus;
		//            1..50         + 1..50         + 0..10..20..35  = 0..135 = 25..100 (more probably 80..90)  
		if (TotalBonus1 > 100) TotalBonus1 = 100;
		if (TotalBonus2 > 100) TotalBonus2 = 100;
		if (TotalBonus1 < 25) TotalBonus1 = 25;
		if (TotalBonus2 < 25) TotalBonus2 = 25;

		switch (m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_cCategory){			
		case 1: // Weapons
			// Needing 100% Purity Oil to enchant Blood weapons
			if (b_IsBloodItem == TRUE) 
			{	// Ancient Stone used
				//PutLogList("tag ");
				if (m_pClientList[iClientH]->m_pItemList[iOil]->m_sIDnum == 977)
				// If Elixir present, need 100% Purity Elixir
				{	if (( i_AlchiBonus2 >0) && ( i_AlchiBonus2 < 50 ))// Cannot upgrade Blood weapons with lesser oils							 
					{	SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_ITEMUPGRADEFAIL, 32, NULL, NULL, NULL);
						return; 
						break;
					}
				}else // Used Oil
				{	// Need 100% purity Oil or Strange Stone
					if (   ( i_AlchiBonus1 < 50 ) // If Elixir present, need 100% Purity Elixir
						|| (( i_AlchiBonus2 >0) && ( i_AlchiBonus2 < 50 )))  
					{	// Cannot upgrade Blood weapons with lesser oils
						SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_ITEMUPGRADEFAIL, 2, NULL, NULL, NULL);
						return; 
						break;
			}	}	}

			switch (m_pClientList[iClientH]->m_pItemList[iOil]->m_sIDnum) {
			case 968: //  SharpnessOil
				dwType = 7;  // Sharp
				dwValue = iDice(1,7);
				ItemColor = 6;
				break; 

			case 969:  //  AgilityOil
				dwType = 5; // Agile
				dwValue = iDice(1,7);	
				ItemColor = 1;				
				break; 	

			case 970:  //  PoisonOil
				dwType = 2; // Poisonous
				dwValue = 5;
				ItemColor = 4;
				// Get exact value
				BonusCap = TotalBonus1 - 20; // 5..80
			       while (iDice(1,100)<BonusCap) {  dwValue++; }
				dwValue = SkillCap(dwValue, TotalBonus1+31); //46..131= +65 max
				if (i_ManufBonus<0) dwValue --;
				if (dwValue<4) dwValue=4;
				break; 

			case 971:  //  BerzerkOil 
				dwType = 1; // Critical
				dwValue = 6;
				ItemColor = 5;
				// Get exact value
				BonusCap = TotalBonus1 - 20; // 5..80
				while (iDice(1,100)<BonusCap) {  dwValue++; }
				dwValue = SkillCap(dwValue, TotalBonus1+31); //46..131= +13 max
				if (i_ManufBonus<0) dwValue --;
				if (dwValue<5) dwValue=5;
				break; 

			case 972:  //  TruthOil
				dwType = 3; //Rite
				dwValue = 1;
				ItemColor = 7;					
				break;

			case 977:  //  Strange Stone
				dwType = 9; // Ancient
				dwValue = iDice(1,7);
				ItemColor = 8;					
				break;

			default:
				break;
			}
			if (iElixir >= 0)
			{	switch (m_pClientList[iClientH]->m_pItemList[iElixir]->m_sIDnum) {				
				case 963: //  EagleElixir
					dwType2 = 2;  // Armes HitProba
					dwValue2 = 3;
					BonusCap = TotalBonus2 - 25; // 0..75,  Blood weapons max is 0..60
			        while (iDice(1,100)<BonusCap) {  dwValue2++; }
					dwValue2 = SkillCap(dwValue2, TotalBonus2); // 25..100 (49% max si tout parfait, blood 42% max PearlBall)
					if (i_ManufBonus<0) dwValue2 --;
					if (dwValue2<3) dwValue2=3;
					break; 
					
				case 965: //  BufaloElixir
					dwType2 = 10;  // Armes rep+
					dwValue2 = 2;
					BonusCap = TotalBonus2 - 20; // 5..80,  Blood weapons max is 0..65
			        while (iDice(1,100)<BonusCap) {  dwValue2++; }
					dwValue2 = SkillCap(dwValue2, TotalBonus2); // 25..100 (rep+7 max, blood rep6 max)
					if (dwValue2<2) dwValue2=2; // mini 2 unless bad manuf weapon
					if (i_ManufBonus<0) dwValue2 --;
					if (dwValue2>7) dwValue2=7;
					break; 
	
				default:
					break;
				}
			}else
			{	dwType2 = 0; 
				dwValue2 = 0;
			}				
			break; // End of case 1: // Weapons

			case 5: // Shields
			case 6: // Armors
				switch (m_pClientList[iClientH]->m_pItemList[iOil]->m_sIDnum) {
				case 970: //  PoisonOil
				case 972: //  TruthOil
				case 977: //  Strange Stone					
					// Cannot upgrade armor with those oils
					SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_ITEMUPGRADEFAIL, 2, NULL, NULL, NULL);
					return; 
					break;

				case 968: //  SharpnessOil
					dwType = 11;  // Armure Mana conv
					dwValue = 3;
					BonusCap = TotalBonus1;
					if (BonusCap>80) BonusCap = 80;
			        while (iDice(1,100)<BonusCap) {  dwValue++; }
					dwValue = SkillCap(dwValue, TotalBonus1 + 31);// divided by 2 below !
					if (i_ManufBonus<0) dwValue --;
					dwValue = (dwValue+1)/2;
					if (dwValue<2) dwValue=2;
					break; 

				case 969:  //  AgilityOil
					dwType = 6; // Armure Light
					dwValue = 4;
					BonusCap = TotalBonus1 -10;
					if (BonusCap>80) BonusCap = 80;
			        while (iDice(1,100)<BonusCap) {  dwValue++; }
					dwValue = SkillCap(dwValue, TotalBonus1 + 21);
					if (i_ManufBonus<0) dwValue --;
					if (dwValue<4) dwValue=4;
					break; 	
					
				case 971:  //  BerzerkOil 
					dwType = 12; // Armures Crit Increase
					dwValue = 3;
					// Get exact value
					BonusCap = TotalBonus1;
					if (BonusCap>80) BonusCap = 80;
			        while (iDice(1,100)<BonusCap) {  dwValue++; }
					dwValue = SkillCap(dwValue, TotalBonus1 + 31);// divided by 2 below !
					if (i_ManufBonus<0) dwValue --;
					dwValue = (dwValue+1)/2;
					if (dwValue<2) dwValue=2;
					break; 
				default:
					break;
				}
				if (iElixir >= 0)
				{	switch (m_pClientList[iClientH]->m_pItemList[iElixir]->m_sIDnum) {					
					case 964:  //  TatooElixir					
					if (RecAble) 
					{	dwType2 = 4;  // Armure HPrec
						dwValue2 = 2; 
						// Get exact value
						BonusCap = TotalBonus2 - 30;
					    while (iDice(1,100)<BonusCap) {  dwValue2++; }
						dwValue2 = SkillCap(dwValue2, TotalBonus2); // max HPrec49%
						if (i_ManufBonus<0) dwValue2 --;
						if (dwValue2<2) dwValue2=2;
					}else 
					{	dwType2 = 3;  // Armure DefRatio
						dwValue2 = 3;
						// Get exact value
						BonusCap = TotalBonus2; // because no Ball possible here (or only GreenBall)
						if (BonusCap>80) BonusCap = 80; // 25..80 
					       while (iDice(1,100)<BonusCap) {  dwValue2++; }
						dwValue2 = SkillCap(dwValue2, BonusCap+20);// max DR49%
						if (i_ManufBonus<0) dwValue2 --;
						if (dwValue2<2) dwValue2=2;
					}
					break;

				case 966:  //  SnakeElixir
					if (RecAble) 
					{	dwType2 = 5;  // Armure SPrec
						dwValue2 = 3; 
						// Get exact value
						BonusCap = TotalBonus2 - 20;
				        while (iDice(1,100)<BonusCap) {  dwValue2++; }
						dwValue2 = SkillCap(dwValue2, TotalBonus2);// max SPrec49%
						if (i_ManufBonus<0) dwValue2 --;
						if (dwValue2<3) dwValue2=3;
					}else 
					{	dwType2 = 1;    // Armure Poison Resist
						dwValue2 = 3;
						// Get exact value
						BonusCap = TotalBonus2;
						if (BonusCap>85) BonusCap = 85;
				        while (iDice(1,100)<BonusCap) {  dwValue2++; }
						dwValue2 = SkillCap(dwValue2, BonusCap + 20);// Max PR56%
						if (i_ManufBonus<0) dwValue2 --;
						if (dwValue2<2) dwValue2=2;
					}
					break;

				case 967: //  MagicElixir
					if (RecAble) 
					{	dwType2 = 6;  // Armure MPrec
						dwValue2 = 2; 
						// Get exact value
						BonusCap = TotalBonus2 - 30; // 70max
				        while (iDice(1,100)<BonusCap) {  dwValue2++; }
						dwValue2 = SkillCap(dwValue2, TotalBonus2);// max MPrec49%
						if (i_ManufBonus<0) dwValue2 --;
						if (dwValue2<2) dwValue2=2;
					}else 
					{	dwType2 = 7;    // Armure Magic Resist
						dwValue2 = 3;
						// Get exact value
						BonusCap = TotalBonus2;
						if (BonusCap>80) BonusCap = 80;
				        while (iDice(1,100)<BonusCap) {  dwValue2++; }
						dwValue2 = SkillCap(dwValue2, BonusCap + 20);// 25..100= Max MR49%
						if (i_ManufBonus<0) dwValue2 --;
						if (dwValue2<2) dwValue2=2;
					}
					break;	
					
				default:
					break;			
				}
				
			}else
			{	dwType2 = 0; 
				dwValue2 = 0;
			}				
			break; // End of cases 5, 6, Shields, armors
			
			case 8: //Wands
			default:
				// Cannot upgrade wands with oils
				SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_ITEMUPGRADEFAIL, 2, NULL, NULL, NULL);
				return; 
				break;
		} // End of category switch
		
		// SNOOPY: Added special Item events Logging
		// 1st line: item to be enchanted
		wsprintf(G_cTxt, "PC(%s)\tEnchanting  \t%s(%d %d %d %d %x)\t%s(%d %d)\tIP(%s)"
			, m_pClientList[iClientH]->m_cCharName
			, m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_cName
			, m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwCount
			, m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sTouchEffectValue1
			, m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sTouchEffectValue2
			, m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sTouchEffectValue3
			, m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwAttribute
			, m_pClientList[iClientH]->m_cMapName
			, m_pClientList[iClientH]->m_sX
			, m_pClientList[iClientH]->m_sY
			, m_pClientList[iClientH]->m_cIPaddress);
		PutItemLogFileList(G_cTxt);

		// SNOOPY: Added special Item events Logging
		// 2nd line: oils used
		wsprintf(G_cTxt, "PC(%s)\tEnchant with\t"
			, m_pClientList[iClientH]->m_cCharName );			
		//	Deplete potions iOil, iElixir, iBall;
		if ( iOil    != -1 ) 
		{	ZeroMemory(cConcatString,  sizeof(cConcatString));
			wsprintf(cConcatString, "%s(%d %d %d %d %d%%)\t"
				, m_pClientList[iClientH]->m_pItemList[iOil]->m_cName
				, m_pClientList[iClientH]->m_pItemList[iOil]->m_dwCount
				, m_pClientList[iClientH]->m_pItemList[iOil]->m_sTouchEffectValue1
				, m_pClientList[iClientH]->m_pItemList[iOil]->m_sTouchEffectValue2
				, m_pClientList[iClientH]->m_pItemList[iOil]->m_sTouchEffectValue3
				, m_pClientList[iClientH]->m_pItemList[iOil]->m_sItemSpecEffectValue2 );
			p_CharResult = lstrcat(G_cTxt, cConcatString);
			if (p_CharResult == NULL) { //concat error)
				ZeroMemory(G_cTxt,  sizeof(G_cTxt));
				wsprintf(G_cTxt, "PC(%s)\tEnchant (Concat error)\t"
				, m_pClientList[iClientH]->m_cCharName );	
			}
			ZeroMemory(cConcatString,  sizeof(cConcatString));

			ItemDepleteHandler(iClientH, iOil, TRUE);
		}
		if ( iElixir != -1 ) 			
		{	ZeroMemory(cConcatString,  sizeof(cConcatString));
			wsprintf(cConcatString, "%s(%d %d %d %d %d%%)\t"
				, m_pClientList[iClientH]->m_pItemList[iElixir]->m_cName
				, m_pClientList[iClientH]->m_pItemList[iElixir]->m_dwCount
				, m_pClientList[iClientH]->m_pItemList[iElixir]->m_sTouchEffectValue1
				, m_pClientList[iClientH]->m_pItemList[iElixir]->m_sTouchEffectValue2
				, m_pClientList[iClientH]->m_pItemList[iElixir]->m_sTouchEffectValue3
				, m_pClientList[iClientH]->m_pItemList[iElixir]->m_sItemSpecEffectValue2 );
			p_CharResult = lstrcat(G_cTxt, cConcatString);
			if (p_CharResult == NULL)  //concat error)
			{	wsprintf(G_cTxt, "PC(%s)\tEnchant (Concat error)\t"
				, m_pClientList[iClientH]->m_cCharName );	
			}			
			ItemDepleteHandler(iClientH, iElixir, TRUE);
		}
		if ( iBall   != -1 ) 
		{	ZeroMemory(cConcatString,  sizeof(cConcatString));
			wsprintf(cConcatString, "%s(%d %d %d %d)\t"
				, m_pClientList[iClientH]->m_pItemList[iBall]->m_cName
				, m_pClientList[iClientH]->m_pItemList[iBall]->m_dwCount
				, m_pClientList[iClientH]->m_pItemList[iBall]->m_sTouchEffectValue1
				, m_pClientList[iClientH]->m_pItemList[iBall]->m_sTouchEffectValue2
				, m_pClientList[iClientH]->m_pItemList[iBall]->m_sTouchEffectValue3 );
			p_CharResult = lstrcat(G_cTxt, cConcatString);
			if (p_CharResult == NULL) { //concat error)
				wsprintf(G_cTxt, "PC(%s)\tEnchant (Concat error)\t"
				, m_pClientList[iClientH]->m_cCharName );	
			}
			ItemDepleteHandler(iClientH, iBall, TRUE);		
		}
		// End of 2nd log line		
		ZeroMemory(cConcatString,  sizeof(cConcatString));
		wsprintf(cConcatString, "%s(%d %d)\tIP(%s)"
			, m_pClientList[iClientH]->m_cMapName
			, m_pClientList[iClientH]->m_sX
			, m_pClientList[iClientH]->m_sY
			, m_pClientList[iClientH]->m_cIPaddress);
		p_CharResult = lstrcat(G_cTxt, cConcatString);
		if (p_CharResult == NULL) { //concat error)
			wsprintf(G_cTxt, "PC(%s)\tEnchant (Concat error)\t"
			, m_pClientList[iClientH]->m_cCharName );	
		}	
		PutItemLogFileList(G_cTxt);	

		// Now change the item
		m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwAttribute += (dwType  << 20) + (dwValue << 16) + (dwType2  << 12) + (dwValue2 << 8);
		// Tweak item color
		if (b_IsBloodItem == FALSE) m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_cItemColor = ItemColor;		
		
		// SNOOPY: Added special Item events Logging
		// 3rd line: oils used
		wsprintf(G_cTxt, "PC(%s)\tEnch. result\t%s(%d %d %d %d %x)\t%s(%d %d)\tIP(%s)"
			, m_pClientList[iClientH]->m_cCharName
			, m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_cName
			, m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwCount
			, m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sTouchEffectValue1
			, m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sTouchEffectValue2
			, m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sTouchEffectValue3
			, m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwAttribute
			, m_pClientList[iClientH]->m_cMapName
			, m_pClientList[iClientH]->m_sX
			, m_pClientList[iClientH]->m_sY
			, m_pClientList[iClientH]->m_cIPaddress );
		PutItemLogFileList(G_cTxt);	
		
		// Notify client
		SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_GIZONITEMCHANGE, iItemIndex, 
			m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_cItemType,
			m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_wCurLifeSpan, 
			m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_cName,
			m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sSprite,
			m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sSpriteFrame,
			m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_cItemColor,
			m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sItemSpecEffectValue2,
			m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwAttribute ) ;

		// Normal Log
		_bItemLog(DEF_ITEMLOG_UPGRADESUCCESS, iClientH, (int) -1, m_pClientList[iClientH]->m_pItemList[iItemIndex]);

		return;
	} // End of Alchemy upgrade

/////////////// 2nd case: Gizon upgrade ///////////////////////////////////////////
	if (   (bIsNormalUpgrade == FALSE) 
		&& (bIsGizonUpgrade == TRUE)
		&& (m_iGizonItemUpgradeEnabled == TRUE)) 
		// Safety check (should be useless here)
	{	if (m_pClientList[iClientH]->m_iGizonItemUpgradeLeft <= 0)  
		{	SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_ITEMUPGRADEFAIL, 3, NULL, NULL, NULL); // 3 manque gizon
			return; 
		}
		int iItemUpgradeCost;
		int iOverCost = 1;
		int iItemUpgradesAlreadyDone;
		
		switch (m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_cCategory) {
		case 1: // Weapons
		case 3: // Bows
		case 5: // Shields
		case 6: // Armors
		case 8: // Wands 	
		case 9:  // Armor, never dyable
		case 10: // Armors, dyable
		case 11: // Robes
		case 12: // Boots, capes
		case 13: // Clothes , not Dyable
			switch (m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sIDnum) {
				case 20:  // Excalibur
				case 321: // Cleric symbols
				case 322:
				case 323:
				case 324:
				case 325:
				case 398: // Contrib cape
				case 400: // Hero Cape
				case 401: // Hero cape
				case 403: // All hero items
				case 404:
				case 405:
				case 406:
				case 407:
				case 408:
				case 409:
				case 410:
				case 411:
				case 412:
				case 413:
				case 414:
				case 415:
				case 416:
				case 417:
				case 418:
				case 419:
				case 420:
				case 421:
				case 422:
				case 423:
				case 424:
				case 425:
				case 426:
				case 427:
				case 428:
				case 490: // BloodSword	
				case 491: // BloodAxe
				case 492: // BloodRapier
				case 990: // BloodBattleAxe
				case 982: // BloodWand
				case 627: // Merien Helm
				case 628: // Merien Hat
				case 707: // DarkMage robes
				case 708: // "
				case 766: // IceGBH
				case 767: // StormBringer 
				case 768: // DefenderAxe
				case 912: // Master armors
				case 913:
				case 914:
				case 915:
				case 916:
				case 917:
				case 918:
				case 919:
				case 925: // Warlord armors
				case 926:
				case 927:
				case 928:
				case 929:
				case 930:
					// All those weapon are impossible to upgrade using gizon points
					// Even if they're found stated someway
					SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_ITEMUPGRADEFAIL, 2, NULL, NULL, NULL); 
					return; 
					break;
				case 985: // RevivalAxe
				case 991: // DrowBlade
				case 996: // OgressArmorW
				case 997: // LicheRobeW
				case 998: // PinkLagiShield
				case 999: // PinkTowerShield
					// All those items can be upgraded, but for twice the cost
					// because they're always found with fixed enchantments
					iOverCost = 2;
				default:
					// determine item current state..
					dwType   = (m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwAttribute & 0x00F00000) >> 20; 
					dwValue  = (m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwAttribute & 0x000F0000) >> 16; 
					dwType2  = (m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwAttribute & 0x0000F000) >> 12; 
					dwValue2 = (m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwAttribute & 0x00000F00) >> 8; 					

					if ((dwType2 >0) && (dwValue2 >=15)) // Item is stated already to +15.
					{	SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_ITEMUPGRADEFAIL, 2, NULL, NULL, NULL); 
						return;
					}
					if ((dwType2 == 0) && (dwValue >=15)) // Item is already +15.
					{	SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_ITEMUPGRADEFAIL, 2, NULL, NULL, NULL); 
						return;
					}
					if ((dwType2 == 11) && (dwValue >=5)) // Item is already +40%
					{	SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_ITEMUPGRADEFAIL, 2, NULL, NULL, NULL); 
						return;
					}

					// Determine if item is upgradable and over-cost
					switch (dwType2) {
					case 0:  // none: can't upgrade 2nd stat
							switch (dwType) {
							case 0:  //not enchanted item....
									SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_ITEMUPGRADEFAIL, 2, NULL, NULL, NULL); 
									return;
									break;
							case 1:  // critical
									if (dwValue>=13) iOverCost *= 2;
									break;
							case 2:  // Poisonous
									if (dwValue>=13) iOverCost *= 2;
									break;
							case 6:  // Light
									if (dwValue>=13) iOverCost *= 2;
									break;
							case 8:  // Strong
									if (dwValue>=13) iOverCost *= 2;
									break;
							case 10:  // CP wands
									if (dwValue>=13) iOverCost *= 2;
									break;
							case 11:  // Mana converting
									if (dwValue>=13) iOverCost *= 2;
									break;
							case 12:  // Crit Increase
									if (dwValue>=13) iOverCost *= 2;
									break;
							default: //not upgradable item..
									SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_ITEMUPGRADEFAIL, 2, NULL, NULL, NULL); 
									return;
									break;	
							}
							break;

					case 1:  // PR 
							if (dwValue2>=13) iOverCost *= 2;
							break;
					case 2:  // HP 
							if (dwValue2>=13) iOverCost *= 2;
							break;
					case 3:  // DR 
							if (dwValue2>=13) iOverCost *= 2;
							break;
					case 4:  // HP rec 
							if (dwValue2>=13) iOverCost *= 2;
							break;
					case 5:  // SP rec 
							if (dwValue2>=13) iOverCost *= 2;
							break;
					case 6:  // MP rec 
							if (dwValue2>=13) iOverCost *= 2;
							break;
					case 7:  // MR 
							if (dwValue2>=13) iOverCost *= 2;
							break;
					case 8:  // PA  
							if (dwValue2>=13) iOverCost *= 2;
							break;
					case 9:  // MA 
							if (dwValue2>=13) iOverCost *= 2;
							break;
					case 10: // Rep+ 
							if (dwValue2>=7)  iOverCost *= 2;
							break;
					case 11: // XP20% 
							if (dwValue2==2)       iOverCost *= 6;  // 20%->30% = 2+4=6
							else if (dwValue2==3)  iOverCost *= 12;  // 30%->40% = 8+16=24
							else if (dwValue2==4)  iOverCost *= 32; // 40%->50% = 32+64=96
							else if (dwValue2==5)  iOverCost *= 96; // 50%->60% = 128+256=384
							else if (dwValue2>=6) iOverCost *= 307; // 60%->70% = 512+1024=1536
							break;
					case 12: // Gold 50% 
							if (dwValue2>=5)  iOverCost *= 2;
							break;
					}

					iItemUpgradesAlreadyDone = m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sItemSpecEffectValue3;
					// Cost = 1, 2, 4, 8, 16, 32, 64.....
					iItemUpgradeCost = 1;
					for (i=0; i<iItemUpgradesAlreadyDone; i++) 
					{	iItemUpgradeCost *=2;
					}
					iItemUpgradeCost *= iOverCost;
					if (m_pClientList[iClientH]->m_iGizonItemUpgradeLeft < iItemUpgradeCost)  
						// Not enough gizon points....
					{	SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_ITEMUPGRADEFAIL, 3, NULL, NULL, NULL); 
						return; 
					}

					// SNOOPY: Added special Item events Logging
					// 1st line: item to be enchanted
					wsprintf(G_cTxt, "PC(%s)\tGizon Upg.  \t%s(%d %d %d %d %x)\tCost: %d  Have:   %d gizons\t%s(%d %d)\tIP(%s)"
						, m_pClientList[iClientH]->m_cCharName
						, m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_cName
						, m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwCount
						, m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sTouchEffectValue1
						, m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sTouchEffectValue2
						, m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sTouchEffectValue3
						, m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwAttribute
						, iItemUpgradeCost
						, m_pClientList[iClientH]->m_iGizonItemUpgradeLeft
						, m_pClientList[iClientH]->m_cMapName
						, m_pClientList[iClientH]->m_sX
						, m_pClientList[iClientH]->m_sY
						, m_pClientList[iClientH]->m_cIPaddress);
					PutItemLogFileList(G_cTxt);

					// Upgrade the item
					if (dwType2 != 0) 
					{	dwValue2++;
						m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwAttribute += 0x00000100; 
					}else 
					{	dwValue++;
						m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwAttribute += 0x00010000; 
					}
					// Note on the item nb of gizon upgrade done on this item
					m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sItemSpecEffectValue3++;

					// Modify attribute to send gizoned info to my client400.
					dwTemp = m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwAttribute;
					dwTemp = dwTemp & 0xF0FFFFFF; 	
					dwTemp = dwTemp | (m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sItemSpecEffectValue3 <<24);
					m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwAttribute = dwTemp;

					// SNOOPY: Added special Item events Logging
					// 2nd line: Result
					wsprintf(G_cTxt, "PC(%s)\tEnch. result\t%s(%d %d %d %d %x)\tCost: %d  Remain: %d gizons\t%s(%d %d)\tIP(%s)"
						, m_pClientList[iClientH]->m_cCharName
						, m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_cName
						, m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwCount
						, m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sTouchEffectValue1
						, m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sTouchEffectValue2
						, m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sTouchEffectValue3
						, m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwAttribute
						, iItemUpgradeCost
						, (int)(m_pClientList[iClientH]->m_iGizonItemUpgradeLeft - iItemUpgradeCost)
						, m_pClientList[iClientH]->m_cMapName
						, m_pClientList[iClientH]->m_sX
						, m_pClientList[iClientH]->m_sY
						, m_pClientList[iClientH]->m_cIPaddress );
					PutItemLogFileList(G_cTxt);	

					// Notify the client
					SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_GIZONITEMCHANGE, iItemIndex, 
						m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_cItemType,
						m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_wCurLifeSpan, 
						m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_cName,
						m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sSprite,
						m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sSpriteFrame,
						m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_cItemColor,
						m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sItemSpecEffectValue2,
						m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwAttribute ) ;

					// Normal item log
					_bItemLog(DEF_ITEMLOG_UPGRADESUCCESS, iClientH, (int) -1, m_pClientList[iClientH]->m_pItemList[iItemIndex]);
					
					// Remove gizon points, and notify client
					m_pClientList[iClientH]->m_iGizonItemUpgradeLeft -=  iItemUpgradeCost; 
					SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_GIZONITEMUPGRADELEFT, m_pClientList[iClientH]->m_iGizonItemUpgradeLeft, NULL, NULL, NULL);
					return;
					break;
			} // End off weapons idNum switch
			break;

// ******* Angel Code - Begin ******* //
		case 46: // Pendants are category 46
			if (m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_cItemType != 1) 
			{	SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_ITEMUPGRADEFAIL, 2, NULL, NULL, NULL);			
				return; // Pendants are type 1
			}
			if (m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_cEquipPos < 11) 
			{	SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_ITEMUPGRADEFAIL, 2, NULL, NULL, NULL);			
				return; // Pendants are left finger or more
			}
			if (m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sItemEffectType != 14) 
			{	SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_ITEMUPGRADEFAIL, 2, NULL, NULL, NULL);			
				return; // Pendants are EffectType 14
			}
			switch (m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sItemEffectValue1) {
			default: // Other items are not upgradable
				SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_ITEMUPGRADEFAIL, 2, NULL, NULL, NULL);			
				return; // Pendants are EffectType 14

			case 16: // AngelicPandent(STR)
			case 17: // AngelicPandent(DEX)
			case 18: // AngelicPandent(INT)
			case 19: // AngelicPandent(MAG)
				if (m_pClientList[iClientH]->m_iGizonItemUpgradeLeft <= 0) 
				{	SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_ITEMUPGRADEFAIL, 3, NULL, NULL, NULL);
					return;
				}
				if(iValue >= 10)
				{	SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_ITEMUPGRADEFAIL, 1, NULL, NULL, NULL);//au max
					return;
				}
				switch (iValue) {
				case 0:	sItemUpgrade = 2; break;
				case 1: sItemUpgrade = 4; break;
				case 2: sItemUpgrade = 6; break;
				case 3: sItemUpgrade = 8; break;
				case 4: sItemUpgrade = 10; break;
				case 5: sItemUpgrade = 12; break;
				case 6: sItemUpgrade = 14; break;
				case 7: sItemUpgrade = 16; break;
				case 8: sItemUpgrade = 18; break;
				case 9: sItemUpgrade = 20; break;
				case 10: sItemUpgrade = 22; break;
				case 11: sItemUpgrade = 24; break;
				case 12: sItemUpgrade = 26; break;
				case 13: sItemUpgrade = 28; break;
				case 14: sItemUpgrade = 30; break;
				default:
					SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_ITEMUPGRADEFAIL, 1, NULL, NULL, NULL);
					return;
					break;
				}
				/*if (   (m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sTouchEffectValue1 != m_pClientList[iClientH]->m_sCharIDnum1) 
					|| (m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sTouchEffectValue2 != m_pClientList[iClientH]->m_sCharIDnum2) 
					|| (m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sTouchEffectValue3 != m_pClientList[iClientH]->m_sCharIDnum3)) 
				{	SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_ITEMUPGRADEFAIL, 2, NULL, NULL, NULL);
					return; // Optional upgrade only by owner
				}*/
				if (( m_pClientList[iClientH]->m_iGizonItemUpgradeLeft - sItemUpgrade ) < 0) 
				{	SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_ITEMUPGRADEFAIL, 3, NULL, NULL, NULL);
					return; 
				}
				int iDicePTA = iDice(1,100);
				if(iDicePTA <= 70)
				{	m_pClientList[iClientH]->m_iGizonItemUpgradeLeft -= sItemUpgrade; 
					SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_GIZONITEMUPGRADELEFT, m_pClientList[iClientH]->m_iGizonItemUpgradeLeft, NULL, NULL, NULL);
					iValue++;
					if (iValue > 10) iValue = 10;
					dwTemp = m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwAttribute;
					dwTemp = dwTemp & 0x0FFFFFFF;
					m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwAttribute = dwTemp | (iValue << 28);
					SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_ITEMATTRIBUTECHANGE, iItemIndex, m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwAttribute, NULL, NULL);
					_bItemLog(DEF_ITEMLOG_UPGRADESUCCESS, iClientH, (int) -1, m_pClientList[iClientH]->m_pItemList[iItemIndex]);
				}else
				{	m_pClientList[iClientH]->m_iGizonItemUpgradeLeft--;
					SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_GIZONITEMUPGRADELEFT, m_pClientList[iClientH]->m_iGizonItemUpgradeLeft, NULL, NULL, NULL);
					SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_ITEMUPGRADEFAIL, 2, NULL, NULL, NULL);
				}					
				return;
				break;
			}
		break;
// ******* Angel Code - End ******* //

		default: // Others categories
			// Those items are not upgradable....
			SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_ITEMUPGRADEFAIL, 2, NULL, NULL, NULL); 
			return;
		} // End of item category switch

	} // End of Gizon upgrade
/////////////// last case: Normal upgrade ///////////////////////////////////////////

	switch (m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_cCategory) {
	case 3: // Bows -> allowed it
	case 1: // Weapons
		switch (m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sIDnum) {
		case 6:   // EldinielHand
		case 7:   // AresienHand
		case 20:  // Excalibur
		case 610: // XelimaBlade
		case 611: // XelimaAxe
		case 612: // XelimaRapier	
		case 613: // Medusa swd
		case 625: // IceElementalBow	
		case 626: // XelimaBow					
		case 709: // DarkKnightBlade 
		//case 873: // Fire-Bow
		//case 874: // Direction-Bow
		case 989: // XelimaGiantHammer
			// Forbidden to upgrade those weapons using Xelima stone
			SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_ITEMUPGRADEFAIL, 2, NULL, NULL, NULL); 
			return; 
			break;

		default: // For all other weapons
		// Forbidden for Ancient weapons 
			if ((m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwAttribute & 0x00F00000) != NULL) 
			{	dwSWEType  = (m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwAttribute & 0x00F00000) >> 20;  
				if (dwSWEType == 9)  // not possible for Ancient weapons
				{	SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_ITEMUPGRADEFAIL, 2, NULL, NULL, NULL);
					return;
			}	}
			// v2.16 2002-5-21 
			iSoX = iSoM = 0;
			for (i = 0; i < DEF_MAXITEMS; i++)
			{	if (m_pClientList[iClientH]->m_pItemList[i] != NULL) 
				{	switch (m_pClientList[iClientH]->m_pItemList[i]->m_sIDnum) {
					case 656: iSoX++; iSoxH = i; break; // XelimaStone
					case 657: iSoM++; iSomH = i; break; // MerienStone 
					}
			}	}
			if (iSoX > 0) 
			{	if (bCheckIsItemUpgradeSuccess(iClientH, iItemIndex, iSoxH) == FALSE) 
				{	// Failure
					SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_ITEMATTRIBUTECHANGE, iItemIndex, m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwAttribute, NULL, NULL);
					// If item already upgraded once deplete item
					iValue = (m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwAttribute & 0xF0000000) >> 28; // v2.172
					// Snoopy: Added non systematic item loose
					// +0->+1  never loose item
					// +1->+2  1/3 of loosing item
					// +2->+3  2/3 of loosing item
					// +3->+4  sure of loosing item
					if (iValue >= iDice(1,3)) ItemDepleteHandler(iClientH, iItemIndex, FALSE); 
					// Deplete Xelima Stone
					ItemDepleteHandler(iClientH, iSoxH, FALSE);	
					return;
				}
				// Upgrade success
				// On manuf items, Xelima upgrade works up to +10
				if ((m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwAttribute & 0x00000001) != NULL) 
				{	iValue++;
					if (iValue > 10) 
						iValue = 10;
					else 
					{	dwTemp = m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwAttribute;
						dwTemp = dwTemp & 0x0FFFFFFF; 
						m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwAttribute = dwTemp | (iValue << 28); 
						// Deplete Xelima Stone
						ItemDepleteHandler(iClientH, iSoxH, FALSE);
					}
				}else  // on non-manuf items, Xelima upgrade works up to +7
				{	// Max is +7
					iValue++;
					if (iValue > 7) 
						iValue = 7;
					else {
						dwTemp = m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwAttribute;
						dwTemp = dwTemp & 0x0FFFFFFF; 
						m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwAttribute = dwTemp | (iValue << 28);
						// Deplete Xelima Stone
						ItemDepleteHandler(iClientH, iSoxH, FALSE);				
				}	}
			} // end of SoX >0
			SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_ITEMATTRIBUTECHANGE, iItemIndex, m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwAttribute, NULL, NULL);
			break;
		} // End of weapons n° switch
		break; // End of weapons category


	case 5: // Shields				
		if ((m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwAttribute & 0x00F00000) != NULL) 
		{	dwSWEType  = (m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwAttribute & 0x00F00000) >> 20;  
			if (dwSWEType == 8) // not possible on Strong armors/shields
			{ 	SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_ITEMUPGRADEFAIL, 2, NULL, NULL, NULL);
				return;
		}	}
		switch (m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sIDnum) {
		case 620: // Merien Shield
		case 623: // GM-Shield
			// Forbidden to upgrade those items using Merien Stone
			SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_ITEMUPGRADEFAIL, 2, NULL, NULL, NULL);
			return;
			break;
		default: 
			break;
		} 
		iSoX = iSoM = 0;
		for (i = 0; i < DEF_MAXITEMS; i++)
		{	if (m_pClientList[iClientH]->m_pItemList[i] != NULL) 
			{	switch (m_pClientList[iClientH]->m_pItemList[i]->m_sIDnum) {
				case 656: iSoX++; iSoxH = i; break; 
				case 657: iSoM++; iSomH = i; break;
		}	}	}
		// Shields are easier to upgrade
		if (iSoM > 0) 
		{	if (bCheckIsItemUpgradeSuccess(iClientH, iItemIndex, iSomH, TRUE) == FALSE) 
			{	// Failure
				SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_ITEMATTRIBUTECHANGE, iItemIndex, m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwAttribute, NULL, NULL);
				iValue = (m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwAttribute & 0xF0000000) >> 28; 
				// Snoopy: Added non systematic item loose
				// +0->+1  never loose item
				// +1->+2  1/3 of loosing item
				// +2->+3  2/3 of loosing item
				// +3->+4  sure of loosing item
				if (iValue >= iDice(1,3)) ItemDepleteHandler(iClientH, iItemIndex, FALSE); 
				// Deplete Merien Stone
				ItemDepleteHandler(iClientH, iSomH, FALSE);	
				return;
			}
			// Upgrade success
			// Shields upgrade works up to +10
			iValue++;
			if (iValue > 10) 
				iValue = 10;
			else 
			{	dwTemp = m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwAttribute;
				dwTemp = dwTemp & 0x0FFFFFFF; //
				m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwAttribute = dwTemp | (iValue << 28); 

				if ((m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwAttribute & 0x00000001) != NULL) 
				{	//  Normal item: Expand item life by 20%
					dV1 = (double)m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_wMaxLifeSpan;
					dV2 = 0.2f * dV1;
					dV3 = dV1 + dV2;
				}else // Manuf item: Expand item life by +15%
				{	dV1 = (double)m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_wMaxLifeSpan;
					dV2 = 0.15f * dV1;
					dV3 = dV1 + dV2;
				}
				m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sItemSpecEffectValue1 = (short)dV3;
				// 
				if (m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sItemSpecEffectValue1 < 0) 
					m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sItemSpecEffectValue1 = m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_wMaxLifeSpan;
				m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_wMaxLifeSpan = m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sItemSpecEffectValue1;
				// Deplete de Merien stone
				ItemDepleteHandler(iClientH, iSomH, FALSE);	
			}
		} // End of SoM >0
		SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_ITEMATTRIBUTECHANGE, iItemIndex, m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwAttribute, m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sItemSpecEffectValue1, NULL, m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sItemSpecEffectValue2);
		break; // End of armors category

	case 6:  // Standard Armors
	case 9:  // Armors ,never dyable ( hero/ executor armors)
	case 10: // Armors dyable (master)
	case 11: // Standard Robes
	case 12: // Standard Capes, Boots
	case 13: // Equipable protection not dyeable, repaired at shop
		switch (m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sIDnum) {
		case 398: // Contrib cape
		case 399: // Contrib cape
		case 400: // Hero cape
		case 401: // Hero cape			
		case 403: // Hero armor
		case 404: // Hero armor
		case 405: // Hero armor
		case 406: // Hero armor
		case 407: // Hero armor
		case 408: // Hero armor
		case 409: // Hero armor
		case 410: // Hero armor
		case 411: // Hero armor
		case 412: // Hero armor
		case 413: // Hero armor
		case 414: // Hero armor
		case 415: // Hero armor
		case 416: // Hero armor
		case 417: // Hero armor
		case 418: // Hero armor
		case 419: // Hero armor
		case 420: // Hero armor
		case 421: // Hero armor
		case 422: // Hero armor
		case 423: // Hero armor
		case 424: // Hero armor
		case 425: // Hero armor
		case 426: // Hero armor
		case 427: // Hero armor
		case 621: // Merien Plate
		case 622: // Merien Plate
		case 627: // Merien Hat
		case 628: // Merien HelmM
		case 700: // Dark Knight armor
		case 701: // Dark Knight armor
		case 702: // Dark Knight armor 
		case 703: // Dark Knight armor
		case 704: // Dark Knight armor
		case 705: // Dark Knight armor
		case 706: // Dark Knight armor..
		case 707: // Dark Knight armor
		case 708: // Dark Knight armor
			// Forbidden on those armors
			SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_ITEMUPGRADEFAIL, 2, NULL, NULL, NULL);
			return;
			break;

		default:
			if ((m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwAttribute & 0x00F00000) != NULL) {
				dwSWEType  = (m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwAttribute & 0x00F00000) >> 20;  
				if (dwSWEType == 8) // not possible on Strong armors/shields
				{ 	SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_ITEMUPGRADEFAIL, 2, NULL, NULL, NULL);
					return;
			}	}
			iSoX = iSoM = 0;
			for (i = 0; i < DEF_MAXITEMS; i++)
			{	if (m_pClientList[iClientH]->m_pItemList[i] != NULL) 
				{	switch (m_pClientList[iClientH]->m_pItemList[i]->m_sIDnum) {
					case 656: iSoX++; iSoxH = i; break;
					case 657: iSoM++; iSomH = i; break;
			}	}	}
			// NB: Armors are easyer to Upgrade
			if (iSoM > 0) 
			{	if (bCheckIsItemUpgradeSuccess(iClientH, iItemIndex, iSomH, TRUE) == FALSE) 
				{	// Failure
					SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_ITEMATTRIBUTECHANGE, iItemIndex, m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwAttribute, NULL, NULL);
					iValue = (m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwAttribute & 0xF0000000) >> 28;
					// Snoopy: Added non systematic item loose
					// +0->+1  never loose item
					// +1->+2  1/3 of loosing item
					// +2->+3  2/3 of loosing item
					// +3->+4  sure of loosing item
					if (iValue >= iDice(1,3)) ItemDepleteHandler(iClientH, iItemIndex, FALSE); 
					// Deplete Merien Stone	
					ItemDepleteHandler(iClientH, iSomH, FALSE);	
					return;
				}
				// Upgrade success
				// Shields upgrade works up to +10
				iValue++;
				if (iValue > 10) 
					iValue = 10; 
				else {
					dwTemp = m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwAttribute;
					dwTemp = dwTemp & 0x0FFFFFFF;
					m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwAttribute = dwTemp | (iValue << 28);
					if ((m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwAttribute & 0x00000001) != NULL) 
					{	//  Normal item: Expand item life by 20%
						dV1 = (double)m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_wMaxLifeSpan;
						dV2 = 0.2f * dV1;
						dV3 = dV1 + dV2;
					}else 
					{	// Manuf item: Expand item life by +15%
						dV1 = (double)m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_wMaxLifeSpan;
						dV2 = 0.15f * dV1;
						dV3 = dV1 + dV2;
					}
					m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sItemSpecEffectValue1 = (short)dV3;
					if (m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sItemSpecEffectValue1 < 0) 
						m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sItemSpecEffectValue1 = m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_wMaxLifeSpan;
					m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_wMaxLifeSpan = m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sItemSpecEffectValue1;
					// Deplete the Merien Stone
					ItemDepleteHandler(iClientH, iSomH, FALSE);	
				}
			} // end of SoM >0
			SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_ITEMATTRIBUTECHANGE, iItemIndex
				, m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwAttribute
				, m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sItemSpecEffectValue1
				, NULL, m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sItemSpecEffectValue2);
			break; // end of Default case
		} // end of armors N° switch
		break;

	case 8: // Wands 
		switch (m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sIDnum) {
		case 291: // MS30
		//case 861: // BerzerkWand
		case 863: // KlonessMS20
		case 864: // KlonessMS28 
		case 865: // ResurWandMS20
		case 866: // ResurWandMS0 
		case 982: // BloodWandMS40
		case 983: // XelimaWandMS0
			// Fordibben for those items
			SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_ITEMUPGRADEFAIL, 2, NULL, NULL, NULL);
			return; 
			break;
		default:
			if ((m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwAttribute & 0x00F00000) != NULL) 
			{	dwSWEType  = (m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwAttribute & 0x00F00000) >> 20; 				
				if (dwSWEType == 8) // not possible on Strong Wands if one can exist...
				{ 	SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_ITEMUPGRADEFAIL, 2, NULL, NULL, NULL);
					return;
			}	}
			iSoX = iSoM = 0;
			for (i = 0; i < DEF_MAXITEMS; i++)
			{	if (m_pClientList[iClientH]->m_pItemList[i] != NULL) 
				{	switch (m_pClientList[iClientH]->m_pItemList[i]->m_sIDnum) {
					case 656: iSoX++; iSoxH = i; break;
					case 657: iSoM++; iSomH = i; break; 
			}	}	}
			if (iSoX > 0) 
			{	if (bCheckIsItemUpgradeSuccess(iClientH, iItemIndex, iSoxH) == FALSE) 
				{	// Failure
					SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_ITEMATTRIBUTECHANGE, iItemIndex, m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwAttribute, NULL, NULL);
					iValue = (m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwAttribute & 0xF0000000) >> 28;
					// Snoopy: Added non systematic item loose
					// +0->+1  never loose item
					// +1->+2  1/3 of loosing item
					// +2->+3  2/3 of loosing item
					// +3->+4  sure of loosing item
					if (iValue >= iDice(1,3)) ItemDepleteHandler(iClientH, iItemIndex, FALSE); 
					// Deplete Merien Stone									
					ItemDepleteHandler(iClientH, iSoxH, FALSE);	
					return;
				}
				// Success				
				iValue++;
				if (iValue > 7) // Max + is +7
					iValue = 7;
				else {
					dwTemp = m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwAttribute;
					dwTemp = dwTemp & 0x0FFFFFFF; 
					m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwAttribute = dwTemp | (iValue << 28);
					ItemDepleteHandler(iClientH, iSoxH, FALSE);
				}
			} // end of SoX >0
			SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_ITEMATTRIBUTECHANGE, iItemIndex, m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwAttribute, NULL, NULL);
			break;
		} // End of Wand n° switch
		break;


	case 31: // Manuf bars: upgrade to 100% Purity
		switch (m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sIDnum) {	
		case 500: // IronBar
		case 501: // SuperCoal
		case 502: // UltraCoal
		case 503: // GoldBar
		case 504: // SilverBar
		case 505: // BlondeBar
		case 506: // MihralBar
			// upgrade Purity..				
			iSoX = iSoM = 0;
			for (i = 0; i < DEF_MAXITEMS; i++)
			{	if (m_pClientList[iClientH]->m_pItemList[i] != NULL) 
				{	switch (m_pClientList[iClientH]->m_pItemList[i]->m_sIDnum) {
					case 656: iSoX++; iSoxH = i; break;
					case 657: iSoM++; iSomH = i; break; 
			}	}	}
			if (iSoM > 0) 
			{	// Never fails
				m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sItemSpecEffectValue2 = 100;
				SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_ITEMATTRIBUTECHANGE, iItemIndex, m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwAttribute, NULL, NULL);
				// Remove Merien Stone
				ItemDepleteHandler(iClientH, iSomH, FALSE);	
				return;
				break; 
			} // end of SoX >0
			SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_ITEMATTRIBUTECHANGE, iItemIndex, m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwAttribute, NULL, NULL);
			break;

		default:
			SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_ITEMUPGRADEFAIL, 2, NULL, NULL, NULL);
			break;
		}
		break;

	case 46: // Rings, Necks, Manuf bars, mics with Merien stones
		if (m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sIDnum > 1010)
		{	// Excludes Magins, Pendants, craftings necks etc....
			SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_ITEMUPGRADEFAIL, 2, NULL, NULL, NULL);
			break;
		}
		switch (m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sIDnum) {		
		// Item that you cannot upgrade
		case 327: // Cursed ring 
		case 328: // Cursed ring 
		case 329: // Cursed ring 
		case 330: // Cursed ring 
		case 338: // Memorial ring
		case 350: // Diam 
		case 351: // Ruby
		case 352: // Sapphire
		case 353: // Emerald
		case 354: // GoldNugget
		case 355: // Coal
		case 356: // SilverNugget
		case 357: // IronOre
		case 358: // Crystal
		case 507: // BlondeStone
		case 508: // Mithral
		case 520: // Bouquette
		case 521: // FlowerBasket
		case 522: // FlowerPot
		case 630: // XelimaRing
		case 631: // AbaddonRing
		case 648: // NeckMS15
		case 693: // GMPowerRing
		case 859: // NecklaceOfKloness
		case 860: // NecklaceOfXelima
			// Fordibben for those items
			SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_ITEMUPGRADEFAIL, 2, NULL, NULL, NULL);
			return; 
			break;

		// Finally items that may be upgraded.
		case 300: // Neck RM10
		case 305: // Neck DM+1
		case 308: // Neck MS10
		case 311: // Neck DF10

		case 331: // Gold ring
		case 332: // Sylver Ring
		case 333: // Platinum ring
		case 334: // Lucky ring
		case 335: // Emmy ring
		case 336: // saphyre ring
		case 337: // ruby ring
		case 632: // ogre ring
		case 633: // demon
		case 634: // wizard
		case 635: // mage
		case 636: // grand mage
		case 637: // light pro neck
		case 638: // fire pro neck
		case 639: // Poison pro
		case 640: // sufferent
		case 641: // medusa
		case 642: // ice pro
		case 643: // ice elem
		case 644: // air elem
		case 645: // effreti
		case 646:  // Beholder
		case 647: // Stone golem
		case 734: // ArchMage
		case 735: // Dragon power
		case 858: // NecklaceOfMerien
		case 1007: // Air ring
		case 1008: // Earth ring
		case 1009: // Fire ring
		case 1010: // Ice ring

		default: // other items:
			iSoX = iSoM = 0;
			for (i = 0; i < DEF_MAXITEMS; i++)
			{	if (m_pClientList[iClientH]->m_pItemList[i] != NULL) 
				{	switch (m_pClientList[iClientH]->m_pItemList[i]->m_sIDnum) {
					case 656: iSoX++; iSoxH = i; break;
					case 657: iSoM++; iSomH = i; break; 
					}
			}	}
			if (iSoM > 0) 
			{	if (bCheckIsItemUpgradeSuccess(iClientH, iItemIndex, iSomH) == FALSE) 
				{	SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_ITEMATTRIBUTECHANGE, iItemIndex, m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwAttribute, NULL, NULL);
					iValue = (m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwAttribute & 0xF0000000) >> 28;
					// Snoopy: Added non systematic item loose
					// +0->+1  never loose item
					// +1->+2  1/3 of loosing item
					// +2->+3  2/3 of loosing item
					// +3->+4  sure of loosing item
					if (iValue >= iDice(1,3)) ItemDepleteHandler(iClientH, iItemIndex, FALSE); 
					// Deplete Merien Stone									
					ItemDepleteHandler(iClientH, iSomH, FALSE);	
					return;
				}
				// Success
				iValue++;
				if (iValue > 7) // Max + is +7
					iValue = 7;
				else 
				{	dwTemp = m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwAttribute;
					dwTemp = dwTemp & 0x0FFFFFFF; 
					m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwAttribute = dwTemp | (iValue << 28);
					ItemDepleteHandler(iClientH, iSomH, FALSE);
				}
			} // end of SoM >0
			SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_ITEMATTRIBUTECHANGE, iItemIndex, m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwAttribute, NULL, NULL);
			break;
		} // End of Rings n° switch
		break;

	default: // Other categorie, you can't upgrade.
		SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_ITEMUPGRADEFAIL, 2, NULL, NULL, NULL);
		break;
	}
}
/*********************************************************************************************************************
**  BOOL CGame::SetAngelFlag(short sOwnerH, char cOwnerType, int iStatus, int iTemp)		Snoopy					**	
** description	  :: Sets the staus to send or not Angels to every client											**
*********************************************************************************************************************/
void CGame::SetAngelFlag(short sOwnerH, char cOwnerType, int iStatus, int iTemp) 
{ 	if (cOwnerType != DEF_OWNERTYPE_PLAYER) return;
	if (m_pClientList[sOwnerH] == NULL) return;
	switch (iStatus) {
	case 1: // STR Angel yellow
		m_pClientList[sOwnerH]->m_iStatus = m_pClientList[sOwnerH]->m_iStatus | 0x00001000;		
		break;
	case 2: // DEX Angel red
		m_pClientList[sOwnerH]->m_iStatus = m_pClientList[sOwnerH]->m_iStatus | 0x00002000;
		break;
	case 3: // INT Angel blue
		m_pClientList[sOwnerH]->m_iStatus = m_pClientList[sOwnerH]->m_iStatus | 0x00004000;
		break;
	case 4: // MAG Angel green
		m_pClientList[sOwnerH]->m_iStatus = m_pClientList[sOwnerH]->m_iStatus | 0x00008000;
		break;
	default:
	case 0: // Remove all Angels except for messenger
		if ((m_iAvatarMessenger != sOwnerH) && (iTemp == 0))
		m_pClientList[sOwnerH]->m_iStatus = m_pClientList[sOwnerH]->m_iStatus & 0xFFFF00FF;
		break;
	}
	if (iTemp >4)
	{	int iAngelicStars = (iTemp/3)*(iTemp/5);
		m_pClientList[sOwnerH]->m_iStatus = m_pClientList[sOwnerH]->m_iStatus | (iAngelicStars << 8);
	}

	SendEventToNearClient_TypeA(sOwnerH, DEF_OWNERTYPE_PLAYER, MSGID_EVENT_MOTION, DEF_OBJECTNULLACTION, NULL, NULL, NULL);
}


/*void CGame::Command_GreenBall(int iClientH, char * pData, DWORD dwMsgSize) 
{char   seps[] = "= \t\n"; 
char   * token, cBuff[256]; 
class  CStrTok * pStrTok; 
char cPrevMode; 
int i, j, sType, sTime; 
DWORD dwTime; 
short itemeq;
    iSoX = 0;
	for (i = 0; i < DEF_MAXITEMS; i++)
	if (m_pClientList[iClientH]->m_pItemList[i] != NULL) {
		switch (m_pClientList[iClientH]->m_pItemList[i]->m_sIDnum) {
		case 652: iSoX++; iSoxH = i; break; // ½ºÅæ ¿Àºê Á¦¸®¸¶ 
	}	}
  dwTime = timeGetTime(); 
  if (m_pClientList[iClientH] == NULL) return; 
  if ((dwMsgSize)   <= 0) return; 
  ZeroMemory(cBuff, sizeof(cBuff)); 
  memcpy(cBuff, pData, dwMsgSize); 
  pStrTok = new class CStrTok(cBuff, seps); 
  token = pStrTok->pGet(); 
  token = pStrTok->pGet();    
  if (token == NULL)  
  {   delete pStrTok; 
     return; 
  } 
  sTime = 600;   
  for (i = 0; i < DEF_MAXMAPS; i++) { 
     if ((m_pMapList[i] != NULL) && (m_pMapList[i]->m_bIsFixedDayMode == FALSE)) { 
        cPrevMode = m_pMapList[i]->m_cWhetherStatus; 
        if (m_pMapList[i]->m_cWhetherStatus != NULL) { 
           if ((dwTime - m_pMapList[i]->m_dwWhetherStartTime) > m_pMapList[i]->m_dwWhetherLastTime) 
              m_pMapList[i]->m_cWhetherStatus = NULL; 
        }else { 
           sTime *= 1000; 
           m_pMapList[i]->m_cWhetherStatus = sType; 
           m_pMapList[i]->m_dwWhetherStartTime = dwTime; 
           m_pMapList[i]->m_dwWhetherLastTime  = sTime; 
        } 
        if (cPrevMode != m_pMapList[i]->m_cWhetherStatus) { 
           for (j = 1; j < DEF_MAXCLIENTS; j++) 
           if ((m_pClientList[j] != NULL) && (m_pClientList[j]->m_bIsInitComplete == TRUE) && (m_pClientList[j]->m_cMapIndex == i)) 
              SendNotifyMsg(NULL, j, DEF_NOTIFY_WHETHERCHANGE, m_pMapList[i]->m_cWhetherStatus, NULL, NULL, NULL);    
      
  } }}
	ItemDepleteHandler(iClientH, itemeq, FALSE);
}*/

void CGame::TimeHitPointsUp(int iClientH)
{register int iMaxHP, iTemp, iTotal;
 double dV1, dV2, dV3;
	if (m_pClientList[iClientH] == NULL)						return;
	if (m_pClientList[iClientH]->m_bIsInitComplete == FALSE)	return;	
	if (m_pClientList[iClientH]->m_iHungerStatus <= 0)			return;
	if (m_pClientList[iClientH]->m_bIsKilled == TRUE)			return;
	if (m_pClientList[iClientH]->m_iHP <= 0)					return; // add by snoopy (resurect player with more than 0HP....
	if (m_pClientList[iClientH]->m_bSkillUsingStatus[19] == TRUE) return;	

	iMaxHP = iGetMaxHP(iClientH, TRUE);	// BloodEffect limite le regen

	if (m_pClientList[iClientH]->m_iHP < iMaxHP) 		
	{	iTemp = iDice(1, (m_pClientList[iClientH]->m_iVit));
		if (iTemp < (m_pClientList[iClientH]->m_iVit/2)) iTemp = (m_pClientList[iClientH]->m_iVit/2);
		if (m_pClientList[iClientH]->m_iSideEffect_MaxHPdown != 0) // Blood Effect limite le volume de regen
			iTemp -= (iTemp / m_pClientList[iClientH]->m_iSideEffect_MaxHPdown);
		iTotal = iTemp + m_pClientList[iClientH]->m_iHPstock;
		if (m_pClientList[iClientH]->m_iAddHP != 0) 
		{	dV2 = (double)iTotal;
			dV3 = (double)m_pClientList[iClientH]->m_iAddHP;
			dV1 = (dV3 / 100.0f)*dV2;
			iTotal += (int)dV1;
		}
		m_pClientList[iClientH]->m_iHP += iTotal;
		if (m_pClientList[iClientH]->m_iHP > iMaxHP) m_pClientList[iClientH]->m_iHP = iMaxHP;
		if (m_pClientList[iClientH]->m_iHP <= 0) m_pClientList[iClientH]->m_iHP = 0;
		SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_HP, NULL, NULL, NULL, NULL);
	}
	m_pClientList[iClientH]->m_iHPstock = 0;
}

char CGame::_cCheckHeroItemEquipped(int iClientH)
{	short sHeroLeggings, sHeroHauberk, sHeroArmor, sHeroHelm;
	int CrasyTotal = 0;
	if (m_pClientList[iClientH] == NULL) return 0;
	sHeroHelm = m_pClientList[iClientH]->m_sItemEquipmentStatus[DEF_EQUIPPOS_HEAD];
	sHeroArmor = m_pClientList[iClientH]->m_sItemEquipmentStatus[DEF_EQUIPPOS_BODY];
	sHeroHauberk = m_pClientList[iClientH]->m_sItemEquipmentStatus[DEF_EQUIPPOS_ARMS];
	sHeroLeggings = m_pClientList[iClientH]->m_sItemEquipmentStatus[DEF_EQUIPPOS_PANTS];

	if ((sHeroHelm < 0) || (sHeroLeggings < 0) || (sHeroArmor < 0) || (sHeroHauberk < 0)) return 0; 

	if(m_pClientList[iClientH]->m_pItemList[sHeroHelm] == NULL) return 0;
	if(m_pClientList[iClientH]->m_pItemList[sHeroLeggings] == NULL) return 0;
	if(m_pClientList[iClientH]->m_pItemList[sHeroArmor] == NULL) return 0;
	if(m_pClientList[iClientH]->m_pItemList[sHeroHauberk] == NULL) return 0;	
/*	if (   (m_pClientList[iClientH]->m_pItemList[sHeroHelm]->m_sTouchEffectType != 0) 
		&& (m_pClientList[iClientH]->m_pItemList[sHeroHelm]->m_sTouchEffectValue1 == m_pClientList[iClientH]->m_sCharIDnum1) 
		&& (m_pClientList[iClientH]->m_pItemList[sHeroHelm]->m_sTouchEffectValue2 == m_pClientList[iClientH]->m_sCharIDnum2) 
		&& (m_pClientList[iClientH]->m_pItemList[sHeroHelm]->m_sTouchEffectValue3 == m_pClientList[iClientH]->m_sCharIDnum3)) 
	{
	}*/
	if (   (m_pClientList[iClientH]->m_pItemList[sHeroHelm]->m_sIDnum >= 403)
		&& (m_pClientList[iClientH]->m_pItemList[sHeroHelm]->m_sIDnum <= 410) )
		CrasyTotal += 50;
	if (   (m_pClientList[iClientH]->m_pItemList[sHeroArmor]->m_sIDnum >= 411)
		&& (m_pClientList[iClientH]->m_pItemList[sHeroArmor]->m_sIDnum <= 418) )
		CrasyTotal += 80;
	if (   (m_pClientList[iClientH]->m_pItemList[sHeroHauberk]->m_sIDnum >= 419)
		&& (m_pClientList[iClientH]->m_pItemList[sHeroHauberk]->m_sIDnum <= 422) )
		CrasyTotal += 30;
	if (   (m_pClientList[iClientH]->m_pItemList[sHeroLeggings]->m_sIDnum >= 423)
		&& (m_pClientList[iClientH]->m_pItemList[sHeroLeggings]->m_sIDnum <= 426) )
		CrasyTotal += 40;
	if (m_pClientList[iClientH]->m_iCrazyPlayerKiller < CrasyTotal) 
		m_pClientList[iClientH]->m_iCrazyPlayerKiller = CrasyTotal;

	if ((m_pClientList[iClientH]->m_pItemList[sHeroHelm]->m_sIDnum == 403) &&
		(m_pClientList[iClientH]->m_pItemList[sHeroArmor]->m_sIDnum == 411) &&
		(m_pClientList[iClientH]->m_pItemList[sHeroHauberk]->m_sIDnum == 419) &&
		(m_pClientList[iClientH]->m_pItemList[sHeroLeggings]->m_sIDnum == 423)) return 1;

	if ((m_pClientList[iClientH]->m_pItemList[sHeroHelm]->m_sIDnum == 407) &&
		(m_pClientList[iClientH]->m_pItemList[sHeroArmor]->m_sIDnum == 415) &&
		(m_pClientList[iClientH]->m_pItemList[sHeroHauberk]->m_sIDnum == 419) &&
		(m_pClientList[iClientH]->m_pItemList[sHeroLeggings]->m_sIDnum == 423)) return 2;
	
	if ((m_pClientList[iClientH]->m_pItemList[sHeroHelm]->m_sIDnum == 404) &&
		(m_pClientList[iClientH]->m_pItemList[sHeroArmor]->m_sIDnum == 412) &&
		(m_pClientList[iClientH]->m_pItemList[sHeroHauberk]->m_sIDnum == 420) &&
		(m_pClientList[iClientH]->m_pItemList[sHeroLeggings]->m_sIDnum == 424)) return 1;

	if ((m_pClientList[iClientH]->m_pItemList[sHeroHelm]->m_sIDnum == 408) &&
		(m_pClientList[iClientH]->m_pItemList[sHeroArmor]->m_sIDnum == 416) &&
		(m_pClientList[iClientH]->m_pItemList[sHeroHauberk]->m_sIDnum == 420) &&
		(m_pClientList[iClientH]->m_pItemList[sHeroLeggings]->m_sIDnum == 424)) return 2;

	if ((m_pClientList[iClientH]->m_pItemList[sHeroHelm]->m_sIDnum == 405) &&
		(m_pClientList[iClientH]->m_pItemList[sHeroArmor]->m_sIDnum == 413) &&
		(m_pClientList[iClientH]->m_pItemList[sHeroHauberk]->m_sIDnum == 421) &&
		(m_pClientList[iClientH]->m_pItemList[sHeroLeggings]->m_sIDnum == 425)) return 1;

	if ((m_pClientList[iClientH]->m_pItemList[sHeroHelm]->m_sIDnum == 409) &&
		(m_pClientList[iClientH]->m_pItemList[sHeroArmor]->m_sIDnum == 417) &&
		(m_pClientList[iClientH]->m_pItemList[sHeroHauberk]->m_sIDnum == 421) &&
		(m_pClientList[iClientH]->m_pItemList[sHeroLeggings]->m_sIDnum == 425)) return 2;

	if ((m_pClientList[iClientH]->m_pItemList[sHeroHelm]->m_sIDnum == 406) &&
		(m_pClientList[iClientH]->m_pItemList[sHeroArmor]->m_sIDnum == 414) &&
		(m_pClientList[iClientH]->m_pItemList[sHeroHauberk]->m_sIDnum == 422) &&
		(m_pClientList[iClientH]->m_pItemList[sHeroLeggings]->m_sIDnum == 426)) return 1;

	if ((m_pClientList[iClientH]->m_pItemList[sHeroHelm]->m_sIDnum == 410) &&
		(m_pClientList[iClientH]->m_pItemList[sHeroArmor]->m_sIDnum == 418) &&
		(m_pClientList[iClientH]->m_pItemList[sHeroHauberk]->m_sIDnum == 422) &&
		(m_pClientList[iClientH]->m_pItemList[sHeroLeggings]->m_sIDnum == 426)) return 2;

	return 0;
}

BOOL CGame::bPlantSeedBag(int iMapIndex, int dX, int dY, int iItemEffectValue1, int iItemEffectValue2, int iClientH)
{	int iNamingValue, tX, tY;
	short sOwnerH;
	char cOwnerType, cNpcName[21], cName[21], cNpcWaypointIndex[11];
	BOOL bRet;
	if(m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_iTotalAgriculture >= 200)
	{	SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_NOMOREAGRICULTURE, NULL, NULL, NULL, NULL);
		return FALSE;
	}
	if (iItemEffectValue2 > m_pClientList[iClientH]->m_cSkillMastery[2]) 
	{	SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_AGRICULTURESKILLLIMIT, NULL, NULL, NULL, NULL);
		return FALSE;
	}
	iNamingValue = m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->iGetEmptyNamingValue();

	if (iNamingValue == -1) 
	{}else
	{	m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, dX, dY);
		if ((sOwnerH != NULL) && (sOwnerH == DEF_OWNERTYPE_NPC) && (m_pNpcList[sOwnerH]->m_cActionLimit == 5)) 
		{	SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_AGRICULTURENOAREA, NULL, NULL, NULL, NULL);
			return FALSE;
		}else
		{	if (m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->bGetIsFarm(dX, dY) == FALSE) 
			{	SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_AGRICULTURENOAREA, NULL, NULL, NULL, NULL);
				return FALSE;
			}
			ZeroMemory(cNpcName, sizeof(cNpcName));
			strcpy(cNpcName, "Crops");
			ZeroMemory(cName, sizeof(cName));
			wsprintf(cName, "XX%d", iNamingValue);
			cName[0] = '_';
			cName[1] = iMapIndex+65;
			ZeroMemory(cNpcWaypointIndex,sizeof(cNpcWaypointIndex));
			tX = dX;
			tY = dY;
			bRet = bCreateNewNpc(cNpcName, cName, m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cName, 0, 0, DEF_MOVETYPE_RANDOM, &tX, &tY, cNpcWaypointIndex, NULL, NULL, 0, FALSE, TRUE);
			if (bRet == FALSE) 
			{	m_pMapList[iMapIndex]->SetNamingValueEmpty(iNamingValue);
			}else
			{	m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, tX, tY);
				if (m_pNpcList[sOwnerH] == NULL) return 0;
				m_pNpcList[sOwnerH]->m_cCropType = iItemEffectValue1;
				switch (iItemEffectValue1) {
				case 1: m_pNpcList[sOwnerH]->m_cCropSkill = iItemEffectValue2; break;
				case 2: m_pNpcList[sOwnerH]->m_cCropSkill = iItemEffectValue2; break;
				case 3: m_pNpcList[sOwnerH]->m_cCropSkill = iItemEffectValue2; break;
				case 4: m_pNpcList[sOwnerH]->m_cCropSkill = iItemEffectValue2; break;
				case 5: m_pNpcList[sOwnerH]->m_cCropSkill = iItemEffectValue2; break;
				case 6: m_pNpcList[sOwnerH]->m_cCropSkill = iItemEffectValue2; break;
				case 7: m_pNpcList[sOwnerH]->m_cCropSkill = iItemEffectValue2; break;
				case 8: m_pNpcList[sOwnerH]->m_cCropSkill = iItemEffectValue2; break;
				case 9: m_pNpcList[sOwnerH]->m_cCropSkill = iItemEffectValue2; break;
				case 10: m_pNpcList[sOwnerH]->m_cCropSkill = iItemEffectValue2; break;
				case 11: m_pNpcList[sOwnerH]->m_cCropSkill = iItemEffectValue2; break;
				case 12: m_pNpcList[sOwnerH]->m_cCropSkill = iItemEffectValue2; break;
				case 13: m_pNpcList[sOwnerH]->m_cCropSkill = iItemEffectValue2; break;
				default: m_pNpcList[sOwnerH]->m_cCropSkill = 100; break;				
				}
				m_pNpcList[sOwnerH]->m_sAppr2 = 1;
				SendEventToNearClient_TypeA(sOwnerH, DEF_OWNERTYPE_NPC, MSGID_EVENT_LOG, DEF_MSGTYPE_CONFIRM, NULL, NULL, NULL);
				wsprintf(G_cTxt, "(skill:%d type:%d)plant(%s) Agriculture begin(%d,%d) sum(%d)!", m_pNpcList[sOwnerH]->m_cCropSkill, m_pNpcList[sOwnerH]->m_cCropType, cNpcName, tX, tY, m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_iTotalAgriculture);
				// SNOOPY to special log PutLogList(G_cTxt);
				PutSkillLogFileList(G_cTxt);
				return TRUE;
			}
		}
	}
	return FALSE;
}

void CGame::_CheckFarmingAction(short sAttackerH, short sTargetH, BOOL bType)
{
 char cCropType;
 int iItemID;
 class CItem * pItem;

 iItemID = 0;
 cCropType = 0;

	cCropType = m_pNpcList[sTargetH]->m_cCropType;
	switch (cCropType) {
	case 1: GetExp(sAttackerH, iDice(3,10)); iItemID = 820; break; // WaterMelon
	case 2: GetExp(sAttackerH, iDice(3,10)); iItemID = 821; break; // Pumpkin
	case 3: GetExp(sAttackerH, iDice(4,10)); iItemID = 822; break; // Garlic
	case 4: GetExp(sAttackerH, iDice(4,10)); iItemID = 823; break; // Barley
	case 5: GetExp(sAttackerH, iDice(5,10)); iItemID = 824; break; // Carrot
	case 6: GetExp(sAttackerH, iDice(5,10)); iItemID = 825; break; // Radish
	case 7: GetExp(sAttackerH, iDice(6,10)); iItemID = 826; break; // Corn
	case 8: GetExp(sAttackerH, iDice(6,10)); iItemID = 827; break; // ChineseBellflower
	case 9: GetExp(sAttackerH, iDice(7,10)); iItemID = 828; break; // Melone
	case 10: GetExp(sAttackerH, iDice(7,10)); iItemID = 829; break; // Tommato
	case 11: GetExp(sAttackerH, iDice(8,10)); iItemID = 830; break; // Grapes
	case 12: GetExp(sAttackerH, iDice(8,10)); iItemID = 831; break; // BlueGrapes
	case 13: GetExp(sAttackerH, iDice(9,10)); iItemID = 832; break; // Mushroom
	default: GetExp(sAttackerH, iDice(10,10)); iItemID = 721; break; // Ginseng
	
	}
	
	pItem = new class CItem;
	if (_bInitItemAttr(pItem, iItemID) == FALSE) 
	{	delete pItem;
	}
	if (bType == 0) 
	{	m_pMapList[m_pClientList[sAttackerH]->m_cMapIndex]->bSetItem(m_pClientList[sAttackerH]->m_sX, m_pClientList[sAttackerH]->m_sY, pItem);
		SendEventToNearClient_TypeB(MSGID_EVENT_COMMON, DEF_COMMONTYPE_ITEMDROP, m_pClientList[sAttackerH]->m_cMapIndex,
			m_pClientList[sAttackerH]->m_sX, m_pClientList[sAttackerH]->m_sY,  pItem->m_sSprite, 
			pItem->m_sSpriteFrame, pItem->m_cItemColor, FALSE);
	}else if (bType == 1) 
	{	m_pMapList[m_pNpcList[sTargetH]->m_cMapIndex]->bSetItem(m_pNpcList[sTargetH]->m_sX, m_pNpcList[sTargetH]->m_sY, pItem);
		SendEventToNearClient_TypeB(MSGID_EVENT_COMMON, DEF_COMMONTYPE_ITEMDROP, m_pNpcList[sTargetH]->m_cMapIndex,
			m_pNpcList[sTargetH]->m_sX, m_pNpcList[sTargetH]->m_sY,  pItem->m_sSprite, 
			pItem->m_sSpriteFrame, pItem->m_cItemColor, FALSE);
	} 

}
// Snoopy: Added cAttackerType to this function, because m_sUsingWeaponSkill from a npc coul hang server !
void CGame::CalculateEnduranceDecrement(short sTargetH, short sAttackerH, char cTargetType, char cAttackerType, int iArmorType)
{short sItemIndex;
 int iHammerChance, iDownValue = 1;

	if (cTargetType != DEF_OWNERTYPE_PLAYER)  return;
	if (m_pClientList[sTargetH] == NULL) return;

	// Faultlly PC attacker  ->return
	if (   (cAttackerType == DEF_OWNERTYPE_PLAYER) 
		&& (m_pClientList[sAttackerH] == NULL)) 

	// No strip if un Warrior spirit effect
	if (m_pClientList[sTargetH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_METAMORPHOSIS ] > 0) return;	

	if (   (cAttackerType == DEF_OWNERTYPE_PLAYER)  
		&& (m_pClientList[sAttackerH] != NULL)
		&& (m_pClientList[sTargetH]->m_cSide != m_pClientList[sAttackerH]->m_cSide)) 
	{	switch (m_pClientList[sAttackerH]->m_sUsingWeaponSkill) {
		case 14: 
			if (   (30 == ((m_pClientList[sAttackerH]->m_sAppr2  & 0x0FF0) >> 4)) 
				|| (31 == ((m_pClientList[sAttackerH]->m_sAppr2  & 0x0FF0) >> 4)) 
				|| (32 == ((m_pClientList[sAttackerH]->m_sAppr2  & 0x0FF0) >> 4))) 
			{	sItemIndex = m_pClientList[sAttackerH]->m_sItemEquipmentStatus[DEF_EQUIPPOS_TWOHAND];
				if ((sItemIndex != -1) && (m_pClientList[sAttackerH]->m_pItemList[sItemIndex] != NULL)) 
// SNOOPY: Added items for Equilibrium
				{	if (m_pClientList[sAttackerH]->m_pItemList[sItemIndex]->m_sIDnum == 760)  // Hammer 
					{	iDownValue = 19;
						break;
					}							
					if (m_pClientList[sAttackerH]->m_pItemList[sItemIndex]->m_sIDnum == 909)  // Hammer+1
					{	iDownValue = 19;
						break;
					}							
					if (m_pClientList[sAttackerH]->m_pItemList[sItemIndex]->m_sIDnum == 761)  // BattleHammer 
					{	iDownValue = 29;
						iHammerChance = 100;
						break;
					}
					if (m_pClientList[sAttackerH]->m_pItemList[sItemIndex]->m_sIDnum == 762)  // GiantBattleHammer
					{	iDownValue = 34;
						iHammerChance = 100;
						break;
					}
					if (m_pClientList[sAttackerH]->m_pItemList[sItemIndex]->m_sIDnum == 932)  // GodHammer
					{	iDownValue = 39;
						iHammerChance = 100;
						break;
					}
					if (m_pClientList[sAttackerH]->m_pItemList[sItemIndex]->m_sIDnum == 766)  // IceHammer
					{	iDownValue = 34;
						iHammerChance = 100;
						break;
					}
					if (m_pClientList[sAttackerH]->m_pItemList[sItemIndex]->m_sIDnum == 989)  // XelimaGiantHammer
					{	iDownValue = 39;
						iHammerChance = 100;
						break;					
				}	}
			}else 
			{ 	iDownValue = 14;
				iHammerChance = 100; 
				break;
			}
			break;

		case 10: iDownValue = 3; break; // Axes

		default: iDownValue = 1; break;
		}
		if (m_pClientList[sTargetH]->m_bIsSpecialAbilityEnabled == TRUE) 
		{	if (m_pClientList[sTargetH]->m_iSpecialAbilityType == 52) 
			{	iDownValue = 0; 
				iHammerChance = 0;
	}	}	}
	
	// Now decrement armor piece using computed value
	if ((m_pClientList[sTargetH]->m_cSide != 0) && (m_pClientList[sTargetH]->m_pItemList[iArmorType]->m_wCurLifeSpan > 0)) 
	{	m_pClientList[sTargetH]->m_pItemList[iArmorType]->m_wCurLifeSpan -= iDownValue;
	}
	if (m_pClientList[sTargetH]->m_pItemList[iArmorType]->m_wCurLifeSpan <= 0) 
	{	m_pClientList[sTargetH]->m_pItemList[iArmorType]->m_wCurLifeSpan = 0;
		SendNotifyMsg(NULL, sTargetH, DEF_NOTIFY_ITEMLIFESPANEND, m_pClientList[sTargetH]->m_pItemList[iArmorType]->m_cEquipPos, iArmorType, NULL, NULL);
		ReleaseItemHandler(sTargetH, iArmorType, TRUE);
		return;
	}

	// Strip the armor piece
	if (   (cAttackerType == DEF_OWNERTYPE_PLAYER) 
		&& (m_pClientList[sAttackerH] != NULL)
		&& (m_pClientList[sAttackerH]->m_sUsingWeaponSkill == 14) 
		&& (iHammerChance == 100)) 
	{	if (m_pClientList[sTargetH]->m_pItemList[iArmorType]->m_wMaxLifeSpan < 2000) 
		{	iHammerChance = iDice(2, 3*(m_pClientList[sTargetH]->m_pItemList[iArmorType]->m_wMaxLifeSpan - m_pClientList[sTargetH]->m_pItemList[iArmorType]->m_wCurLifeSpan));
			//idée? iHammerChance = iDice(1, 4*(m_pClientList[sTargetH]->m_pItemList[iArmorType]->m_wMaxLifeSpan - m_pClientList[sTargetH]->m_pItemList[iArmorType]->m_wCurLifeSpan));
		}else 
		{	iHammerChance = iDice(2, 2*(m_pClientList[sTargetH]->m_pItemList[iArmorType]->m_wMaxLifeSpan - m_pClientList[sTargetH]->m_pItemList[iArmorType]->m_wCurLifeSpan));
			//idée? iHammerChance = iDice(1, 3*(m_pClientList[sTargetH]->m_pItemList[iArmorType]->m_wMaxLifeSpan - m_pClientList[sTargetH]->m_pItemList[iArmorType]->m_wCurLifeSpan));
		}			
		if (   (30 == ((m_pClientList[sAttackerH]->m_sAppr2  & 0x0FF0) >> 4)) 
			|| (31 == ((m_pClientList[sAttackerH]->m_sAppr2  & 0x0FF0) >> 4)) 
			|| (32 == ((m_pClientList[sAttackerH]->m_sAppr2  & 0x0FF0) >> 4))) 
		{	sItemIndex = m_pClientList[sAttackerH]->m_sItemEquipmentStatus[DEF_EQUIPPOS_TWOHAND];
			if ((sItemIndex != -1) && (m_pClientList[sAttackerH]->m_pItemList[sItemIndex] != NULL)) 
			{	if (m_pClientList[sAttackerH]->m_pItemList[sItemIndex]->m_sIDnum == 760)  // Hammer 
				{	iHammerChance = (iHammerChance*5)/12; 
				}else if (m_pClientList[sAttackerH]->m_pItemList[sItemIndex]->m_sIDnum == 909)  // Hammer+1 
				{	iHammerChance = (iHammerChance*5)/11; 
				}else if (m_pClientList[sAttackerH]->m_pItemList[sItemIndex]->m_sIDnum == 761)  // BattleHammer 
				{	iHammerChance = (iHammerChance*5)/8; 
				}else if (m_pClientList[sAttackerH]->m_pItemList[sItemIndex]->m_sIDnum == 762)  // GiantBattleHammer
				{	iHammerChance = iHammerChance;
				}else if (m_pClientList[sAttackerH]->m_pItemList[sItemIndex]->m_sIDnum == 669)  // Penitence
				{	iHammerChance = (iHammerChance*5)/15; 
				}else if (m_pClientList[sAttackerH]->m_pItemList[sItemIndex]->m_sIDnum == 932)  // GodHammer 
				{	iHammerChance = (iHammerChance*5)/4; 
				}else if (m_pClientList[sAttackerH]->m_pItemList[sItemIndex]->m_sIDnum == 670)  // Knight Penitence
				{	iHammerChance = (iHammerChance*5)/10; 
				}else if (m_pClientList[sAttackerH]->m_pItemList[sItemIndex]->m_sIDnum == 766)  // IceHammer 
				{	iHammerChance = iHammerChance;
				}else if (m_pClientList[sAttackerH]->m_pItemList[sItemIndex]->m_sIDnum == 904)  // Master Penitence
				{	iHammerChance = (iHammerChance*5)/8; 
				}else if (m_pClientList[sAttackerH]->m_pItemList[sItemIndex]->m_sIDnum == 989)  // XelimaHammer 
				{	iHammerChance = (iHammerChance*5)/4; 
				}else
				{	iHammerChance = (iHammerChance*5)/20;										// very low if forgotten item
		}	}	}
		if (   (m_pClientList[sTargetH]->m_pItemList[iArmorType]->m_sIDnum == 622) 
			|| (m_pClientList[sTargetH]->m_pItemList[iArmorType]->m_sIDnum == 621)) 
		{	iHammerChance = 0; // Never unequip Merien plates !
		}
		if (m_pClientList[sTargetH]->m_pItemList[iArmorType]->m_wCurLifeSpan < iHammerChance) 
		{	//wsprintf(G_cTxt, "(iHammerChance (%d), target armor endurance (%d)!", iHammerChance, m_pClientList[sTargetH]->m_pItemList[iArmorType]->m_wCurLifeSpan);
			//PutLogList(G_cTxt);
			ReleaseItemHandler(sTargetH, iArmorType, TRUE);
			SendNotifyMsg(NULL, sTargetH, DEF_NOTIFY_ITEMRELEASED, m_pClientList[sTargetH]->m_pItemList[iArmorType]->m_cEquipPos, iArmorType, NULL, NULL);
			return;
	}	}
}

int CGame::iCalculateAttackEffect(short sTargetH, char cTargetType, short sAttackerH, char cAttackerType, int tdX, int tdY, int iAttackMode, BOOL bNearAttack, BOOL bIsDash, BOOL bDontDepleteArrow, BOOL bMainGaucheAttack)
{	int    iAP_SM, iAP_L, iAttackerHitRatio, iTargetDefenseRatio, iDestHitRatio, iResult, iAP_Abs_Armor, iAP_Abs_Shield;
	char   cAttackerName[21], cAttackerDir, cAttackerSide, cTargetDir, cProtect, cCropSkill, cFarmingSkill;
	short  sWeaponIndex, sAttackerWeapon, dX, dY, sX, sY, sAtkX, sAtkY, sTgtX, sTgtY;
	DWORD  dwTime;
	WORD   wWeaponType;
	double dTmp1, dTmp2, dTmp3;
	BOOL   bKilled;
	BOOL   bNormalMissileAttack;
	char   cIsAttackerBerserk;
	BOOL   bIsMonkAttack = FALSE;
	int    iFlyingNpcAttack = -30;  // Base chance to fly npc
	int	   iFlyerMaxPossibleHD = 0;
	int    iKilledDice, iDamage, iExp, iWepLifeOff, iSideCondition, iMaxSuperAttack, iWeaponSkill, iComboBonus, iTemp;
	int    /*iAttackerHP,*/ iMoveDamage, iRepDamage = 0;
	char   cAttackerSA;
	int    iAttackerSAvalue, iHitPoint;
	char   cDamageMoveDir;
	int    iPartyID, iConstructionPoint, iWarContribution, tX, tY, iDst1, iDst2;
	short sItemIndex;
	short sSkillUsed = -1;	
	BOOL bPvPCritAttack = FALSE;// SNOOPY: Support for HIGH pvp-tohit-mode		
	int iAP_Abs_Cape;// SNOOPY: Added support for damage absorbtion for capes (when hitted on back)
	int iFarmingSSN;// SNOOPY: 1 or 0 depending if you can improve the skill or not	
	int iProtectDR;	// SNOOPY: Support for custom Defence shields spells.		

	dwTime = timeGetTime();
	bKilled = FALSE;
	iExp = 0;
	iPartyID = 0;
	bNormalMissileAttack = FALSE;
	ZeroMemory(cAttackerName, sizeof(cAttackerName));
	cAttackerSA      = NULL;
	iAttackerSAvalue = 0;
	wWeaponType      = NULL;
	// compute Attack points, HitRatio 
	switch (cAttackerType) {
	case DEF_OWNERTYPE_PLAYER:
		if (m_pClientList[sAttackerH] == NULL) return 0;
		if ((m_bAdminSecurity == TRUE) && (m_pClientList[sAttackerH]->m_iAdminUserLevel > 0)) return 0;
		if (   (m_pMapList[m_pClientList[sAttackerH]->m_cMapIndex]->m_bIsAttackEnabled == FALSE)
			&& (m_pClientList[sAttackerH]->m_iAdminUserLevel == 0)) return 0;
		
		if (   (m_bIsHeldenianMode == TRUE)				
			&& (m_bHeldenianWarInitiated == FALSE)			// No attack work before war has begun
			&& (m_pMapList[m_pClientList[sAttackerH]->m_cMapIndex] != 0) 
			&& (m_pMapList[m_pClientList[sAttackerH]->m_cMapIndex]->m_bIsHeldenianMap == 1)) return 0; 

		if ((m_bIsCrusadeMode == FALSE) && (m_pClientList[sAttackerH]->m_bIsPlayerCivil == TRUE) && (cTargetType == DEF_OWNERTYPE_PLAYER)) return 0;
	
		if ((m_pClientList[sAttackerH]->m_iStatus & 0x10) != 0) 
		{	SetInvisibilityFlag(sAttackerH, DEF_OWNERTYPE_PLAYER, FALSE);
			bRemoveFromDelayEventList(sAttackerH, DEF_OWNERTYPE_PLAYER, DEF_MAGICTYPE_INVISIBILITY);
			m_pClientList[sAttackerH]->m_cMagicEffectStatus[DEF_MAGICTYPE_INVISIBILITY] = NULL;
		}		
		//if ((m_pClientList[sAttackerH]->m_sAppr2 & 0xF000) == 0) return 0;
		if (m_pClientList[sAttackerH]->m_IsPeaceMode == TRUE) return 0; 
		iAP_SM = 0;
		iAP_L  = 0;
		iFlyerMaxPossibleHD = m_pClientList[sAttackerH]->m_iStr;
		wWeaponType = ((m_pClientList[sAttackerH]->m_sAppr2 & 0x0FF0) >> 4);
		
		if (m_pClientList[sAttackerH]->m_cMagicEffectStatus[DEF_MAGICTYPE_BERSERK] != 0)
			cIsAttackerBerserk = m_pClientList[sAttackerH]->m_cMagicEffectStatus[DEF_MAGICTYPE_BERSERK];
		else cIsAttackerBerserk = 0;

		sSkillUsed = m_pClientList[sAttackerH]->m_sUsingWeaponSkill;

		cAttackerSide = m_pClientList[sAttackerH]->m_cSide;
		// SNOOPY Added a 2nd attack if character has a MainGauche.
		if (bMainGaucheAttack)
		{	iFlyingNpcAttack -=100;
			sSkillUsed = 20;
			iAttackerHitRatio = m_pClientList[sAttackerH]->m_iHitRatio3 + m_pClientList[sAttackerH]->m_cSkillMastery[20];			
			if ( iAttackerHitRatio < 1 ) iAttackerHitRatio = 1;
			// Compute damage
			iAP_SM = iDice(1, 6);
			iAP_L  = iDice(1, 8);
			sItemIndex = m_pClientList[sAttackerH]->m_sItemEquipmentStatus[DEF_EQUIPPOS_LHAND];
			if ((m_pClientList[sAttackerH]->m_pItemList[sItemIndex]->m_dwAttribute & 0x00F00000) != NULL) 
			{	int dwSWEType  = (m_pClientList[sAttackerH]->m_pItemList[sItemIndex]->m_dwAttribute & 0x00F00000) >> 20;  
				int dwSWEValue = (m_pClientList[sAttackerH]->m_pItemList[sItemIndex]->m_dwAttribute & 0x000F0000) >> 16;
				// CriticalDamage && Poison Damage will have no effect on armors & MainGauche
				switch (dwSWEType) {
				case 7: // Sharp
					iAP_SM = iDice(1, 7);
					iAP_L  = iDice(1, 9);				
					break;
				case 9: // Ancient
					iAP_SM = iDice(1, 8);
					iAP_L  = iDice(1, 10);
					break;				
			}	}

			dTmp1 = (double)iAP_SM;
			if (m_pClientList[sAttackerH]->m_iStr <= 0)
				dTmp2 = 1.0f;
			else dTmp2 = (double)(m_pClientList[sAttackerH]->m_iStr + m_pClientList[sAttackerH]->m_iAngelicStr);

			dTmp2 = dTmp2 / 5.0f;
			dTmp3 = dTmp1 + (dTmp1 * (dTmp2 / 100.0f));
			iAP_SM = (int)(dTmp3 +0.5f);

			dTmp1 = (double)iAP_L;
			if (m_pClientList[sAttackerH]->m_iStr <= 0)
				dTmp2 = 1.0f;
			else dTmp2 = (double)(m_pClientList[sAttackerH]->m_iStr + m_pClientList[sAttackerH]->m_iAngelicStr);

			dTmp2 = dTmp2 / 5.0f;
			dTmp3 = dTmp1 + (dTmp1 * (dTmp2 / 100.0f));
			iAP_L = (int)(dTmp3 +0.5f);
		}else				
		if (wWeaponType == 0) 
// Snoopy81 -> (Monks if STR 41+ or Str> Vit, use Str else use Vit)
			//iAP_SM = iAP_L    = iDice(1, (m_pClientList[sAttackerH]->m_iStr / 12));
		{	iAttackerHitRatio = m_pClientList[sAttackerH]->m_iHitRatio + m_pClientList[sAttackerH]->m_cSkillMastery[5];			
			if (m_pClientList[sAttackerH]->m_iPriestDruidID == 3) // Monks
			{	// Monks deal terrible damage on small creatures, but some less damage on big ones.
				// They can use item in left hand
				// but if they don't they have a +50 To Hit bonus (half of openhand skill)
				iAP_SM = iDice(2, (m_pClientList[sAttackerH]->m_iVit / 13)) +2 ;
				iAP_L  = iDice(2, (m_pClientList[sAttackerH]->m_iVit / 13)) -2 ;
				// Check for NunChaKu in left hand
				sItemIndex = m_pClientList[sAttackerH]->m_sItemEquipmentStatus[DEF_EQUIPPOS_LHAND];
				if (sItemIndex != -1)  
				{	if (    (m_pClientList[sAttackerH]->m_pItemList[sItemIndex] != NULL)
						&&  (m_pClientList[sAttackerH]->m_pItemList[sItemIndex]->m_sIDnum == 11) )					
					{ 	// NB: NunChaKu is useless if Vit >= 200
						iAP_SM = iDice(1, (m_pClientList[sAttackerH]->m_iVit / 13)) +2;
						iAP_SM += iDice(1, 15);		
						iAP_L = iDice(1, (m_pClientList[sAttackerH]->m_iVit / 13)) - 2;
						iAP_L += iDice(1, 15);
					}
				}else
				{	// Monk without armor, nothing in hands have Special Monk Attacks
					if (m_pClientList[sAttackerH]->m_bSpecialFeatureAllowed == TRUE) 
					{	iFlyingNpcAttack += 70;
						bIsMonkAttack = TRUE; // gives a chance of super Attack
						iAttackerHitRatio += (m_pClientList[sAttackerH]->m_cSkillMastery[5]/2);
				}	}
			}else
			{	iFlyingNpcAttack -=100; // No fly npc for boxers
				iAP_SM = iAP_L = iDice(1, ((m_pClientList[sAttackerH]->m_iStr + m_pClientList[sAttackerH]->m_iAngelicStr) / 12));
			};		
// <- Snoopy81
			if (iAP_SM <= 0) iAP_SM = 1;
			if (iAP_L  <= 0) iAP_L  = 1;
			m_pClientList[sAttackerH]->m_sUsingWeaponSkill = 5 ;			
			sSkillUsed = 5;

		}else if ((wWeaponType >= 1) && (wWeaponType < 40)) 
		{	iAP_SM = iDice(m_pClientList[sAttackerH]->m_cAttackDiceThrow_SM, m_pClientList[sAttackerH]->m_cAttackDiceRange_SM);
			iAP_L  = iDice(m_pClientList[sAttackerH]->m_cAttackDiceThrow_L, m_pClientList[sAttackerH]->m_cAttackDiceRange_L);

			iAP_SM += m_pClientList[sAttackerH]->m_cAttackBonus_SM;
			iAP_L  += m_pClientList[sAttackerH]->m_cAttackBonus_L;

			iAttackerHitRatio = m_pClientList[sAttackerH]->m_iHitRatio;

			dTmp1 = (double)iAP_SM;
			if (m_pClientList[sAttackerH]->m_iStr <= 0)
				dTmp2 = 1.0f;
			else dTmp2 = (double)(m_pClientList[sAttackerH]->m_iStr + m_pClientList[sAttackerH]->m_iAngelicStr);

			dTmp2 = dTmp2 / 5.0f;
			dTmp3 = dTmp1 + (dTmp1 * (dTmp2 / 100.0f));
			iAP_SM = (int)(dTmp3 +0.5f);

			dTmp1 = (double)iAP_L;
			if (m_pClientList[sAttackerH]->m_iStr <= 0)
				dTmp2 = 1.0f;
			else dTmp2 = (double)(m_pClientList[sAttackerH]->m_iStr + m_pClientList[sAttackerH]->m_iAngelicStr);

			dTmp2 = dTmp2 / 5.0f;
			dTmp3 = dTmp1 + (dTmp1 * (dTmp2 / 100.0f));
			iAP_L = (int)(dTmp3 +0.5f);
			switch (sSkillUsed) {	
			//case 5:  break; //Boxing already computed
			case 8:  iFlyingNpcAttack += 20; break; // Long Sword
			case 10: iFlyingNpcAttack += 30; break; // Axe
			case 14: iFlyingNpcAttack += 50; break; // Hammer
			default: break;
			}
		}else if (wWeaponType >= 40) 
		{	iFlyingNpcAttack -= 100; // No fly for bowmen
			iAP_SM = iDice(m_pClientList[sAttackerH]->m_cAttackDiceThrow_SM, m_pClientList[sAttackerH]->m_cAttackDiceRange_SM);
			iAP_L  = iDice(m_pClientList[sAttackerH]->m_cAttackDiceThrow_L, m_pClientList[sAttackerH]->m_cAttackDiceRange_L);
			iAP_SM += m_pClientList[sAttackerH]->m_cAttackBonus_SM;
			iAP_L  += m_pClientList[sAttackerH]->m_cAttackBonus_L;
			iAttackerHitRatio = m_pClientList[sAttackerH]->m_iHitRatio;
			bNormalMissileAttack = TRUE;
// Snoopy81 -> Bowmen if STR 130+ or str> Dex, use str else use Dex)
			//iAP_SM += iDice(1, (m_pClientList[sAttackerH]->m_iStr / 20));
			//iAP_L  += iDice(1, (m_pClientList[sAttackerH]->m_iStr / 20));
			if (m_pClientList[sAttackerH]->m_iStr < m_pClientList[sAttackerH]->m_iDex)
			{	// if Dext> Str: this is an archer.
				iAP_SM += iDice(1, ((m_pClientList[sAttackerH]->m_iDex + m_pClientList[sAttackerH]->m_iAngelicDex) / 13));
				iAP_L  += iDice(1, ((m_pClientList[sAttackerH]->m_iDex + m_pClientList[sAttackerH]->m_iAngelicDex) / 13));
				}else
			{	// if Str> Dext or Str >65 classic warrior.
				iAP_SM += iDice(1, ((m_pClientList[sAttackerH]->m_iStr + m_pClientList[sAttackerH]->m_iAngelicStr) / 20));
				iAP_L  += iDice(1, ((m_pClientList[sAttackerH]->m_iStr + m_pClientList[sAttackerH]->m_iAngelicStr) / 20));
			}
			// If target is Arrow reflexion effect, Attaker becomes target..
			if (cTargetType == DEF_OWNERTYPE_PLAYER)
				if (m_pClientList[sTargetH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_REFLEXION] == 1) 
				{	sTargetH    = sAttackerH;
					cTargetType = DEF_OWNERTYPE_PLAYER;
					tdX = m_pClientList[sTargetH]->m_sX;
					tdY = m_pClientList[sTargetH]->m_sY;
				}
		}
		if (m_pClientList[sAttackerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_METAMORPHOSIS ] > 0)
		{	switch (m_pClientList[sAttackerH]->m_cMagicEffectStatus[DEF_MAGICTYPE_METAMORPHOSIS_WEAPONTYPE]) {
			case 4:// as a GodBlade (247 str)
				iAP_SM = iDice(4,11); 
				iAP_L= iDice(4,12);	
				break;
			case 3:// as a Vampire (221 str)
				iAP_SM = iDice(3,11); iAP_SM += 1; 
				iAP_L= iDice(3,12);   iAP_L  += 2;	
				break;
			case 2: // as a Black Shadow (184 str)
				iAP_SM = iDice(2,13); iAP_SM += 3;
				iAP_L= iDice(2,14);   iAP_L  += 3;	
				break;
			default:
			case 1:	// As a GiS
				iAP_SM = iDice(2,11); iAP_SM += 3; 
				iAP_L = iDice(2,12);  iAP_L  += 3;
				break;		
			}
			dTmp1 = (double)iAP_SM;
			dTmp2 = (double)m_pClientList[sAttackerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_METAMORPHOSIS ];
			dTmp2 = dTmp2 * 2.0f;
			dTmp3 = dTmp1 + (dTmp1 * (dTmp2 / 100.0f));
			iAP_SM = (int)(dTmp3 +0.5f);
			dTmp1 = (double)iAP_L;
			dTmp2 = (double)m_pClientList[sAttackerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_METAMORPHOSIS ];
			dTmp2 = dTmp2 * 2.0f;
			dTmp3 = dTmp1 + (dTmp1 * (dTmp2 / 100.0f));
			iAP_L = (int)(dTmp3 +0.5f);		
			iAttackerHitRatio = m_pClientList[sAttackerH]->m_iHitRatio3 + 99; // Simulates 99 skill LS	
		}

		//SNOOPY: No free toHit Bonus !	
		// iAttackerHitRatio += 50;
		// But a free bonus to compensate for new armors ToHit malus
		// PLate  = -10
		// Hose   =  -3 ( Leggings = -6 )
		// Berk   =  -3
		// Helmet =  -7
		// Total  =  -23 ( or -26)
		iAttackerHitRatio += 25;

		if (iAP_SM <= 0) iAP_SM = 1;
		if (iAP_L  <= 0) iAP_L  = 1;
		// Compute minimal (or maximal) damage for  manuf weapons
		// ie: a BS Flamberge can deal 3 to 30 damage (with 130Str)
		//     a 160% completion Flam  6 to 30 damage
		if (m_pClientList[sAttackerH]->m_iCustomItemValue_Attack != 0) 
		{	if ((m_pClientList[sAttackerH]->m_iMinAP_SM != 0) && (iAP_SM < m_pClientList[sAttackerH]->m_iMinAP_SM)) 
			{	iAP_SM = m_pClientList[sAttackerH]->m_iMinAP_SM;
			}
			if ((m_pClientList[sAttackerH]->m_iMinAP_L != 0) && (iAP_L < m_pClientList[sAttackerH]->m_iMinAP_L)) 
			{	iAP_L = m_pClientList[sAttackerH]->m_iMinAP_L;
			}
			if ((m_pClientList[sAttackerH]->m_iMaxAP_SM != 0) && (iAP_SM > m_pClientList[sAttackerH]->m_iMaxAP_SM)) 
			{	iAP_SM = m_pClientList[sAttackerH]->m_iMaxAP_SM;
			}
			if ((m_pClientList[sAttackerH]->m_iMaxAP_L != 0) && (iAP_L > m_pClientList[sAttackerH]->m_iMaxAP_L)) 
			{	iAP_L = m_pClientList[sAttackerH]->m_iMaxAP_L;
			}
		}

		if (m_pClientList[sAttackerH]->m_cHeroArmourBonus == 1) 
		{	//SNOOPY: No big toHit Bonus !	// iAttackerHitRatio += 100;
			iAttackerHitRatio += 25;
			iAP_SM += 5;
			iAP_L += 5;
			iFlyingNpcAttack += 5;
		}else if (   (m_pClientList[sAttackerH]->m_iPriestDruidID == 5) // Chevalier
					&& (m_pClientList[sAttackerH]->m_bSpecialFeatureAllowed == TRUE) )
		{	iAttackerHitRatio += 25; // Same bonus for Chevalier
		}
		if (   (m_pClientList[sAttackerH]->m_iPriestDruidID == 6) // Barbarian
			&& (m_pClientList[sAttackerH]->m_bSpecialFeatureAllowed == TRUE) )
		{	iFlyingNpcAttack += 10; // Bonus to fly for Barbarians
		}	

		sItemIndex = m_pClientList[sAttackerH]->m_sItemEquipmentStatus[DEF_EQUIPPOS_RHAND];
		if ((sItemIndex != -1) && (m_pClientList[sAttackerH]->m_pItemList[sItemIndex] != NULL)) 
		{	if (   (m_pClientList[sAttackerH]->m_pItemList[sItemIndex]->m_sIDnum == 19) // Sting-Dart
				&& (cTargetType == DEF_OWNERTYPE_NPC))   // Hobbit Blade
			{	if ( (m_pNpcList[sTargetH]->m_sType == 14) // Orc
					|| (m_pNpcList[sTargetH]->m_sType == 77) )// MasterMageOrc					
				{	iAP_SM *= 2;
					iAP_L *= 2;
					// Berzerk the character and remove 10 from Blade's life if criting when not zerked
					if ((cIsAttackerBerserk == 0) && (iAttackMode >= 20))
					{	PlayerMagicHandler(sAttackerH, m_pClientList[sAttackerH]->m_sX, m_pClientList[sAttackerH]->m_sY, 50, TRUE, -1); 
						if (m_pClientList[sAttackerH]->m_pItemList[sItemIndex]->m_wCurLifeSpan < 10) 
							m_pClientList[sAttackerH]->m_pItemList[sItemIndex]->m_wCurLifeSpan = 0;
						else m_pClientList[sAttackerH]->m_pItemList[sItemIndex]->m_wCurLifeSpan -= 10;			
			}	}	}			
			// Rigth-Hand Magic-using weapons
			if (   (iAttackMode >= 20)
				&& (m_pClientList[sAttackerH]->m_iSpecialWeaponEffectSpell != -1))
			{	if (cTargetType == DEF_OWNERTYPE_NPC)
				{	PlayerMagicHandler(sAttackerH, m_pNpcList[sTargetH]->m_sX, m_pNpcList[sTargetH]->m_sY, m_pClientList[sAttackerH]->m_iSpecialWeaponEffectSpell, TRUE, -1); 
				}else if (cTargetType == DEF_OWNERTYPE_PLAYER)
				{	PlayerMagicHandler(sAttackerH, m_pClientList[sTargetH]->m_sX, m_pClientList[sTargetH]->m_sY, m_pClientList[sAttackerH]->m_iSpecialWeaponEffectSpell, TRUE, -1); 
				}
				if (m_pClientList[sAttackerH]->m_pItemList[sItemIndex]->m_wCurLifeSpan < 10) 
					m_pClientList[sAttackerH]->m_pItemList[sItemIndex]->m_wCurLifeSpan = 0;
				else m_pClientList[sAttackerH]->m_pItemList[sItemIndex]->m_wCurLifeSpan -= 9;	
		}	}	
		sItemIndex = m_pClientList[sAttackerH]->m_sItemEquipmentStatus[DEF_EQUIPPOS_TWOHAND];
		if ((sItemIndex != -1) && (m_pClientList[sAttackerH]->m_pItemList[sItemIndex] != NULL)) 
	// SNOOPY Added extra damage, and 100 ToHit Bonus, for DemonSlayer vs Demons
		{	if (   (m_pClientList[sAttackerH]->m_pItemList[sItemIndex]->m_sIDnum == 616) // DemonSlayer	
				&& (cTargetType == DEF_OWNERTYPE_NPC)) 
			{	if ( m_pNpcList[sTargetH]->m_sType == 31) 
				{	iAttackerHitRatio += 100;
					iAP_L += iDice(1,((2*iAP_L)/3));							
					// Berzerk the character and remove 10 from Blade's life if criting when not zerked
					if ((cIsAttackerBerserk == 0) && (iAttackMode >= 20))
					{	PlayerMagicHandler(sAttackerH, m_pClientList[sAttackerH]->m_sX, m_pClientList[sAttackerH]->m_sY, 50, TRUE, -1); 
						if (m_pClientList[sAttackerH]->m_pItemList[sItemIndex]->m_wCurLifeSpan < 20) 
							m_pClientList[sAttackerH]->m_pItemList[sItemIndex]->m_wCurLifeSpan = 0;
						else m_pClientList[sAttackerH]->m_pItemList[sItemIndex]->m_wCurLifeSpan -= 19;
			}	}	}
			if (   (m_pClientList[sAttackerH]->m_pItemList[sItemIndex]->m_sIDnum == 985) // Revival crystal Axe
				&& (iAttackMode >= 20)
				&& (cTargetType == DEF_OWNERTYPE_NPC)
				&& (m_pNpcList[sTargetH] != NULL) )//iItemID = 985; break; // RevivalAxe
			{	if (m_pNpcList[sTargetH]->m_cSize != 0)	
				{	iAttackerHitRatio += 100;
					iAP_L += 15;
					// Non-possible spell (n°9) just used to show effect on target
					PlayerMagicHandler(sAttackerH, m_pNpcList[sTargetH]->m_sX, m_pNpcList[sTargetH]->m_sY, 9, TRUE, -1);
			}	}
			if (   (m_pClientList[sAttackerH]->m_pItemList[sItemIndex]->m_sIDnum == 847) // DarkExecutor
				&& (m_cDayOrNight == 2)) 
			{	iAP_SM += 4;
				iAP_L += 4;sTargetH;
			}
			if (   (m_pClientList[sAttackerH]->m_pItemList[sItemIndex]->m_sIDnum == 848) // LightingBlade
				&& (m_cDayOrNight == 1)) 
			{	iAP_SM += 4;
				iAP_L += 4;
			}
			// TwoHands Magic-using weapons
			if (   (iAttackMode >= 20)
				&& (m_pClientList[sAttackerH]->m_iSpecialWeaponEffectSpell != -1))
			{	if (cTargetType == DEF_OWNERTYPE_NPC)
				{	PlayerMagicHandler(sAttackerH, m_pNpcList[sTargetH]->m_sX, m_pNpcList[sTargetH]->m_sY, m_pClientList[sAttackerH]->m_iSpecialWeaponEffectSpell, TRUE, -1); 
				}else if (cTargetType == DEF_OWNERTYPE_PLAYER)
				{	PlayerMagicHandler(sAttackerH, m_pClientList[sTargetH]->m_sX, m_pClientList[sTargetH]->m_sY, m_pClientList[sAttackerH]->m_iSpecialWeaponEffectSpell, TRUE, -1); 
				}
				if (m_pClientList[sAttackerH]->m_pItemList[sItemIndex]->m_wCurLifeSpan < 10) 
					m_pClientList[sAttackerH]->m_pItemList[sItemIndex]->m_wCurLifeSpan = 0;
				else m_pClientList[sAttackerH]->m_pItemList[sItemIndex]->m_wCurLifeSpan -= 9;
		}	}

		// Kloness Weapons wands computed in CalcTotalItemEffect (Berserk wand=-1, LichWand= -2)
		if (m_pClientList[sAttackerH]->m_cKlonessMiscDamageBonus > 0)
		{	iAP_SM += m_pClientList[sAttackerH]->m_cKlonessMiscDamageBonus;
			iAP_L  += m_pClientList[sAttackerH]->m_cKlonessMiscDamageBonus;
		}
		// Kloness Necklace
		if (m_pClientList[sAttackerH]->m_cKlonessNeckDamageBonus > 0)
		{	if (cTargetType == DEF_OWNERTYPE_PLAYER)
			{	if (m_pClientList[sTargetH] != NULL)
				{	iRepDamage = m_pClientList[sAttackerH]->m_cKlonessNeckDamageBonus - (m_pClientList[sTargetH]->m_iRating / 100);
					if (iRepDamage >5) iRepDamage = 5;
					if (iRepDamage >0) iAP_SM += iRepDamage;
		}	}	}
		cAttackerDir = m_pClientList[sAttackerH]->m_cDir;
		strcpy(cAttackerName, m_pClientList[sAttackerH]->m_cCharName);
		
		if ((bDontDepleteArrow != TRUE) && (m_pClientList[sAttackerH]->m_iSuperAttackLeft > 0) && (iAttackMode >= 20)) 
		{	// if bDontDepleteArrow no crit effect
			dTmp1 = (double)iAP_SM;
			dTmp2 = (double)m_pClientList[sAttackerH]->m_iLevel;
			dTmp3 = dTmp2 / 100.0f;
			dTmp2 = dTmp1 * dTmp3;
			iTemp = (int)(dTmp2 +0.5f);
			iAP_SM += iTemp;

			dTmp1 = (double)iAP_L;
			dTmp2 = (double)m_pClientList[sAttackerH]->m_iLevel;
			dTmp3 = dTmp2 / 100.0f;
			dTmp2 = dTmp1 * dTmp3;
			iTemp = (int)(dTmp2 +0.5f);
			iAP_L += iTemp;


			// SNOOPY: Support for HIGH pvp-tohit-mode if not Bow Attack
			// in this case, the +100 bonus apply as -100 to defender
			if ((m_bPVPHPMode == TRUE) && (wWeaponType < 40) && (cTargetType == DEF_OWNERTYPE_PLAYER)) 
				//	iTargetDefenseRatio -= 50;	Later on !
			{	bPvPCritAttack = TRUE;
			}else iAttackerHitRatio += 100;		

			switch (m_pClientList[sAttackerH]->m_sUsingWeaponSkill) {
			//SNOOPY: Reducing Crit damage for bows against SM to avoid too easy PvP for bowmen
			case 6:  iAP_SM -= (iAP_SM/10); iAP_L += (iAP_L/10); iAttackerHitRatio += 30 ; break; // Archery
			case 7:  iAP_SM *= 2; iAP_L *= 2; break; // Short Sword				
			case 8:  iAP_SM += (iAP_SM/10); iAP_L += (iAP_L/10); iAttackerHitRatio += 30 ; break; // Long Sword
			case 9:  break; // Fencing				
			case 10:  iAP_SM += (iAP_SM/10);iAP_L += (iAP_L/5) ;						   break; // Axe
			case 14:  iAP_SM += (iAP_SM/10);iAP_L += (iAP_L/5) ; iAttackerHitRatio += 20 ; break; // Hammer
			case 21:  iAP_SM += (iAP_SM/5); iAP_L += (iAP_L/5) ; iAttackerHitRatio += 50 ; break; // Staff
			default: break;
			}	
			// SNOOPY: Monks have a chance of super extra hit on 4th consecutive hit, if it is a critical
			// Specially efficient against big monsters
			if (bIsMonkAttack)
			{	if (m_pClientList[sAttackerH]->m_iComboAttackCount == 4) 
				{	iAttackerHitRatio += 10;
					iAP_SM += (iAP_SM/5); // + 20% damage on small monsters
					iAP_L += iAP_L; // + 100% damage on big monsters
					iFlyingNpcAttack += 140; // The Monk's extra hit is sure to fly and stun..
					iFlyerMaxPossibleHD = m_pClientList[sAttackerH]->m_iVit;			
			}	}
			iFlyingNpcAttack += 20; // Cancel -20 malus when it's a critical attack.
		}
		if (bIsDash == TRUE) 
		{	iAttackerHitRatio += 20;
			switch (m_pClientList[sAttackerH]->m_sUsingWeaponSkill) {
			case 8:  iAP_SM += (iAP_SM/10); iAP_L += (iAP_L/10); break; // Long Sword
			case 10: iAP_SM += (iAP_SM/5);  iAP_L += (iAP_L/5);  break; // Axe
			case 14: iAP_SM += (iAP_SM/5);  iAP_L += (iAP_L/5);  break; // Hammer
			default: break;
			}
		}
		iAttackerHitRatio += m_pClientList[sAttackerH]->m_iCustomItemValue_Attack; // Completion bonus as added HP
		if ((m_bPVPHPMode == TRUE) && (cTargetType == DEF_OWNERTYPE_PLAYER)) 
			iAttackerHitRatio += m_pClientList[sAttackerH]->m_iAddAR/2;
		else iAttackerHitRatio += m_pClientList[sAttackerH]->m_iAddAR;
		sAtkX = m_pClientList[sAttackerH]->m_sX;
		sAtkY = m_pClientList[sAttackerH]->m_sY;
		iPartyID = m_pClientList[sAttackerH]->m_iPartyID;
		// If target is Physical reflexion effect, Attaker becomes target..
		if (   (cTargetType == DEF_OWNERTYPE_PLAYER) 
			&& (bNormalMissileAttack == FALSE))
			if (   (m_pClientList[sTargetH]->m_cMagicEffectStatus[DEF_MAGICTYPE_REFLEXION] == 2) 
				&& (iDice(2,20) > m_pClientList[sTargetH]->m_cMagicEffectStatus[DEF_MAGICTYPE_REFLEXION_COUNT]))
			{	if (iAttackMode < 20) m_pClientList[sTargetH]->m_cMagicEffectStatus[DEF_MAGICTYPE_REFLEXION_COUNT] +=1;
				sTargetH    = sAttackerH;
				cTargetType = DEF_OWNERTYPE_PLAYER;
				tdX = m_pClientList[sTargetH]->m_sX;
				tdY = m_pClientList[sTargetH]->m_sY;
			}
		break;

	case DEF_OWNERTYPE_NPC: // Attacker is npc
		if (m_pNpcList[sAttackerH] == NULL) return 0;
		if (m_pMapList[m_pNpcList[sAttackerH]->m_cMapIndex]->m_bIsAttackEnabled == FALSE) return 0;
		if ((m_pNpcList[sAttackerH]->m_iStatus & 0x10) != 0) 
		{	SetInvisibilityFlag(sAttackerH, DEF_OWNERTYPE_NPC, FALSE);
			bRemoveFromDelayEventList(sAttackerH, DEF_OWNERTYPE_NPC, DEF_MAGICTYPE_INVISIBILITY);
			m_pNpcList[sAttackerH]->m_cMagicEffectStatus[DEF_MAGICTYPE_INVISIBILITY] = NULL;
		}
		cAttackerSide = m_pNpcList[sAttackerH]->m_cSide;
		iAP_SM = 0;
		iAP_L  = 0;
		if (m_pNpcList[sAttackerH]->m_cAttackDiceThrow != 0) 
			iAP_L = iAP_SM = iDice(m_pNpcList[sAttackerH]->m_cAttackDiceThrow, m_pNpcList[sAttackerH]->m_cAttackDiceRange);

		iAttackerHitRatio = m_pNpcList[sAttackerH]->m_iHitRatio;
		cAttackerDir = m_pNpcList[sAttackerH]->m_cDir;
		memcpy(cAttackerName, m_pNpcList[sAttackerH]->m_cNpcName, 20);

		if (m_pNpcList[sAttackerH]->m_cMagicEffectStatus[DEF_MAGICTYPE_BERSERK] != 0)
			cIsAttackerBerserk = m_pNpcList[sAttackerH]->m_cMagicEffectStatus[DEF_MAGICTYPE_BERSERK];
		else cIsAttackerBerserk = 0;

		cAttackerSA = m_pNpcList[sAttackerH]->m_cSpecialAbility;
		sAtkX = m_pNpcList[sAttackerH]->m_sX;
		sAtkY = m_pNpcList[sAttackerH]->m_sY;
		// Check for arrow attack
		switch (m_pNpcList[sAttackerH]->m_sType) {
		case 54: // Dark-Elf			
		case 84: // MasterElf // Added Master Elf to PFA 	
				// No more "not arrow attack if close" (was buggy)
			bNormalMissileAttack = TRUE; 	
			// If target is Arrow reflexion effect, Attaker becomes target..
			if (cTargetType == DEF_OWNERTYPE_PLAYER)
				if (m_pClientList[sTargetH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_REFLEXION] == 1) 
				{	sTargetH    = sAttackerH;
					cTargetType = DEF_OWNERTYPE_NPC;
					tdX = m_pNpcList[sTargetH]->m_sX;
					tdY = m_pNpcList[sTargetH]->m_sY;
				}
			break;
		default:		
			// If target is Physical reflexion effect, Attaker becomes target..
			if (cTargetType == DEF_OWNERTYPE_PLAYER)
				if (   (m_pClientList[sTargetH]->m_cMagicEffectStatus[DEF_MAGICTYPE_REFLEXION] == 2) 
					&& (iDice(3,20) > m_pClientList[sTargetH]->m_cMagicEffectStatus[DEF_MAGICTYPE_REFLEXION_COUNT]))
				{	m_pClientList[sTargetH]->m_cMagicEffectStatus[DEF_MAGICTYPE_REFLEXION_COUNT] +=1;
					sTargetH    = sAttackerH;
					cTargetType = DEF_OWNERTYPE_NPC;
					tdX = m_pNpcList[sTargetH]->m_sX;
					tdY = m_pNpcList[sTargetH]->m_sY;
				}
			break;
		}	
		iPartyID = 0;
		break;
	}
	switch (cTargetType) {
	case DEF_OWNERTYPE_PLAYER:
		if (m_pClientList[sTargetH] == NULL) return 0;
		if (m_pClientList[sTargetH]->m_bIsKilled		== TRUE) return 0;
		if (m_pClientList[sTargetH]->m_bInvincibleSlate == TRUE) return 0;
		if (m_pClientList[sTargetH]->m_bAntiTPLameEK	== TRUE) return 0;
		if (cAttackerType == DEF_OWNERTYPE_NPC) 
		{	if (   ( m_pClientList[sTargetH]->m_bSkillUsingStatus[22] == TRUE )
				&& (iDice(1,100) <= m_pClientList[sTargetH]->m_cSkillMastery[22]) )
				return 0;// SNOOPY, do not attack while Taming in progress
		}
		if (   (cAttackerType == DEF_OWNERTYPE_PLAYER) 
			&& (sTargetH == sAttackerH)) return 0; // Cant attack self. (was possible with critical Direction bow)

		if (   (cAttackerType == DEF_OWNERTYPE_PLAYER) 
			&& (m_bIsCrusadeMode == FALSE) 
			&& (m_pClientList[sTargetH]->m_iPKCount == 0) 
			&& (m_pClientList[sTargetH]->m_bIsPlayerCivil == TRUE)) return 0;				
		// Only Travellers can attack Travellers unless they are crim.
		if (   (cAttackerType == DEF_OWNERTYPE_PLAYER) 
			&& (m_pClientList[sTargetH]->m_bIsNeutral == TRUE) 
			&& (m_pClientList[sAttackerH]->m_bIsNeutral == FALSE) 
			&& (m_pClientList[sTargetH]->m_iPKCount == 0)) return 0;
		
		if ((m_pClientList[sTargetH]->m_sX != tdX) || (m_pClientList[sTargetH]->m_sY != tdY)) return 0;
		if (m_pClientList[sTargetH]->m_iAdminUserLevel > 0) return 0;

		// SNOOPY: Implementation of pk-mode
		if (cAttackerType == DEF_OWNERTYPE_PLAYER) 
		{	if (m_bIsCrusadeMode == FALSE) 
			/*&& (m_pClientList[sAttackerH]->m_iPKCount == 0) 
			&& (m_pClientList[sTargetH]->m_iPKCount == 0)*/
			switch (m_pMapList[m_pClientList[sTargetH]->m_cMapIndex]->m_iPKmode) {
			case -5: // no EK, but PK possible, crim treated as "normal citizens"
				if (m_pClientList[sTargetH]->m_cSide != m_pClientList[sAttackerH]->m_cSide) return 0;
				break;
			case -4: // Evil side can be victim but not attack, crim treated as "normal citizens"
				if (m_pClientList[sTargetH]->m_cSide != 4) return 0;
				break;
			case -3: // No PK or EK allowed, crim treated as "normal citizens"
				return 0;
				break;
			case -2: // No PK and EK allowed only against Evil side (m_cSide =4), crim treated as "normal citizens"
				if (m_pClientList[sTargetH]->m_cSide + m_pClientList[sAttackerH]->m_cSide <5) return 0;
				break;
			case -1: // No PK, EK allowed, crim treated as "normal citizens"
				if (m_pClientList[sTargetH]->m_cSide + m_pClientList[sAttackerH]->m_cSide == 2) return 0;
				if (m_pClientList[sTargetH]->m_cSide + m_pClientList[sAttackerH]->m_cSide == 4) return 0;
				break;
			case 5: // no EK, but PK possible... 
				if (   (m_pClientList[sTargetH]->m_cSide != m_pClientList[sAttackerH]->m_cSide) 
					&& (m_pClientList[sAttackerH]->m_iPKCount == 0) 
					&& (m_pClientList[sTargetH]->m_iPKCount == 0)) return 0;
				break;
			case 4: // Evil side can be victim but not attack
				if (   (m_pClientList[sTargetH]->m_cSide != 4) 					
					&& (m_pClientList[sAttackerH]->m_iPKCount == 0) 
					&& (m_pClientList[sTargetH]->m_iPKCount == 0)) return 0;
				break;
			case 3: // No PK or EK allowed
				if (   (m_pClientList[sAttackerH]->m_iPKCount == 0) 
					&& (m_pClientList[sTargetH]->m_iPKCount == 0)) return 0;
				break;
			case 2: // No PK and EK allowed only against Evil side (m_cSide =4)
				if (   (m_pClientList[sTargetH]->m_cSide + m_pClientList[sAttackerH]->m_cSide <5)					
					&& (m_pClientList[sAttackerH]->m_iPKCount == 0) 
					&& (m_pClientList[sTargetH]->m_iPKCount == 0))  return 0;
				break;
			case 1: // No PK, EK allowed				
				if (   (m_pClientList[sAttackerH]->m_iPKCount == 0) 
					&& (m_pClientList[sTargetH]->m_iPKCount == 0))  
				{	if (m_pClientList[sTargetH]->m_cSide + m_pClientList[sAttackerH]->m_cSide == 2) return 0;
					if (m_pClientList[sTargetH]->m_cSide + m_pClientList[sAttackerH]->m_cSide == 4) return 0;
				}
				break;
			case 0:  // All EK allowed
				break;
			}else // PvP forbiden if limited cast, Was allowed because crusade ignores PKmode
			{	if (m_pMapList[m_pClientList[sTargetH]->m_cMapIndex]->m_bInsideBuildingLimitedCast == TRUE) return 0;
			}
		} 

		if (   (m_pClientList[sTargetH]->m_iPartyID != NULL)
			&& (iPartyID == m_pClientList[sTargetH]->m_iPartyID)
			&& (sTargetH != sAttackerH)) return 0; // Need to be different from self for reflected attacks.

		cTargetDir = m_pClientList[sTargetH]->m_cDir;
		iTargetDefenseRatio = m_pClientList[sTargetH]->m_iDefenseRatio;
		iTargetDefenseRatio += m_pClientList[sTargetH]->m_iAddDR;

		// SNOOPY: Support for HIGH pvp-tohit-mode  to close combat (not Bows)
		// ]->m_iDefenseRatio = Dext x2 + Normal armors +  Items Defence (Rings, Necks....)
		// ]->m_iAddDR        = DefRatio % of enchanted items
		if ((m_bPVPHPMode == TRUE) && (wWeaponType < 40)) 
		{	if (cAttackerType == DEF_OWNERTYPE_PLAYER) 
			{	iTargetDefenseRatio = m_pClientList[sTargetH]->m_iDefenseRatio2;
				iTargetDefenseRatio += m_pClientList[sTargetH]->m_iAddDR/2;	
				if (bPvPCritAttack) iTargetDefenseRatio -= 50;
				if (iTargetDefenseRatio < 10) iTargetDefenseRatio = 10;
			}
		}
		if (m_pClientList[sTargetH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_METAMORPHOSIS ] > 0)
		{	if ((m_bPVPHPMode == TRUE) && (cAttackerType == DEF_OWNERTYPE_PLAYER))
			{	iTargetDefenseRatio = m_pClientList[sTargetH]->m_iDefenseRatio3;	
				iTargetDefenseRatio += (10 * m_pClientList[sTargetH]->m_cMagicEffectStatus[DEF_MAGICTYPE_METAMORPHOSIS_TEMP_DEXT]);
				iTargetDefenseRatio += m_pClientList[sTargetH]->m_iAddDR/2;
				iTargetDefenseRatio += 92; // represents armor improvements for D/R
			}else
			{	iTargetDefenseRatio = m_pClientList[sTargetH]->m_iDefenseRatio3;	
				iTargetDefenseRatio += (20 * (m_pClientList[sTargetH]->m_cMagicEffectStatus[DEF_MAGICTYPE_METAMORPHOSIS_TEMP_DEXT]));
				iTargetDefenseRatio += m_pClientList[sTargetH]->m_iAddDR;
				iTargetDefenseRatio += 92; // represents armor improvements			
			}
		}
		if ((cAttackerType == DEF_OWNERTYPE_PLAYER) && (m_pClientList[sAttackerH]->m_bIsSafeAttackMode == TRUE))  
		{	iSideCondition = iGetPlayerRelationship(sAttackerH, sTargetH);
			switch (iSideCondition) {
			case 0: // Friendly, same guild: No damage.
				return 0;
				break;
			case 1: // Friendly: 1/2 damage in arena or no damage elsewhere
				if (m_pMapList[m_pClientList[sAttackerH]->m_cMapIndex]->m_bIsFightZone == TRUE)
				{	iAP_SM = iAP_SM / 2; // Safe mode deals 1/2 damage (not 0) in Fight zone
					iAP_L  = iAP_L / 2;  // execpt if we are from same guild
				}else return 0;
				break;
			case 2: // Normal damage
				break;	
		}	}
		sTgtX = m_pClientList[sTargetH]->m_sX;
		sTgtY = m_pClientList[sTargetH]->m_sY;
		break;

	case DEF_OWNERTYPE_NPC:
		if (m_pNpcList[sTargetH] == NULL) return 0;
		if (m_pNpcList[sTargetH]->m_iHP <= 0) return 0;
		if ((m_pNpcList[sTargetH]->m_sX != tdX) || (m_pNpcList[sTargetH]->m_sY != tdY)) return 0;

		cTargetDir = m_pNpcList[sTargetH]->m_cDir;
		iTargetDefenseRatio = m_pNpcList[sTargetH]->m_iDefenseRatio;

		if (cAttackerType == DEF_OWNERTYPE_PLAYER) 
		{	switch (m_pNpcList[sTargetH]->m_sType) {
			case 40: // ESG
			case 41: // GMG
				if ((m_pClientList[sAttackerH]->m_cSide == 0) || (m_pNpcList[sTargetH]->m_cSide == m_pClientList[sAttackerH]->m_cSide)) return 0;
				//break;
			case 36: // AGT
			case 37: // CGT
			case 38: // MS
			case 39: // DT		
				// Snoopy added Tile where you can't stay (behind crusade structures) 
				// If you try to stay behind and accept normal punition, damage is worse and at each attack...
				if (   (m_bIsCrusadeMode == TRUE)
					&& (m_pClientList[sAttackerH]->m_iAdminUserLevel == 0)
					&& (m_pMapList[m_pClientList[sAttackerH]->m_cMapIndex]->bGetIsStayAllowedTile(m_pClientList[sAttackerH]->m_sX, m_pClientList[sAttackerH]->m_sY) == FALSE))
				{	char iDir = (char)iDice(1,7);
					if (iDir >= 5) iDir += 1;
					int iDamage = m_pClientList[sAttackerH]->m_iHP/8 + iDice(1,20) + iAP_SM;					
					if (iDamage < 40) iDamage = 30 + iDice(1,20);
					if (iDamage > m_pClientList[sAttackerH]->m_iHP) iDamage = m_pClientList[sAttackerH]->m_iHP -1;
					m_pClientList[sAttackerH]->m_iHP -= iDamage;					
					m_pClientList[sAttackerH]->m_iLastDamage = iDamage;		
					m_pClientList[sAttackerH]->m_dwLastDamageMoveTime = dwTime;
					m_pClientList[sAttackerH]->m_dwDamageMoveCounter ++;
					SendNotifyMsg(NULL, sAttackerH, DEF_NOTIFY_DAMAGEMOVE, iDir, iDamage, 0, NULL);					
					iAP_SM = iAP_SM/2; 
					iAP_L = iAP_L/2;
				}
				break;
			}
			// Not "in the back" attack for some npcs 
			if (m_pNpcList[sTargetH]->m_iNpcBossType != 0) cTargetDir = -1; 

			if (   (wWeaponType == 25) && (m_pNpcList[sTargetH]->m_cActionLimit == 5) 
				&& (m_pNpcList[sTargetH]->m_iBuildCount > 0)) 
			{	if ((m_pClientList[sAttackerH]->m_iCrusadeDuty != 2) && (m_pClientList[sAttackerH]->m_iAdminUserLevel == 0)) break;
				switch (m_pNpcList[sTargetH]->m_sType) {
				case 36: // AGT
				case 37: // CGT
				case 38: // MS
				case 39: // DT
					// administrators instantly build crusade structures
					// SNOOPY: was buugy because those structure woundn't Attack due to a m_iBuildCount = 0 value....
					if (m_pClientList[sAttackerH]->m_iAdminUserLevel > 0) 
					{	m_pNpcList[sTargetH]->m_sAppr2 = 0;
						m_pNpcList[sTargetH]->m_iBuildCount = 1;
						SendEventToNearClient_TypeA(sTargetH, DEF_OWNERTYPE_NPC, MSGID_EVENT_MOTION, DEF_OBJECTNULLACTION, NULL, NULL, NULL);
					}				
					switch (m_pNpcList[sTargetH]->m_iBuildCount) {
					case 1:
						m_pNpcList[sTargetH]->m_sAppr2 = 0;
						SendEventToNearClient_TypeA(sTargetH, DEF_OWNERTYPE_NPC, MSGID_EVENT_MOTION, DEF_OBJECTNULLACTION, NULL, NULL, NULL);
						// SNOOPY: Will not send those message outside crusades...
						if (m_bIsCrusadeMode == TRUE) 
						{	switch (m_pNpcList[sTargetH]->m_sType) {
							case 36: iConstructionPoint = 700; iWarContribution = 700; break;
							case 37: iConstructionPoint = 700; iWarContribution = 700; break;
							case 38: iConstructionPoint = 500; iWarContribution = 500; break;
							case 39: iConstructionPoint = 500; iWarContribution = 500; break;
							}
							// Snoopy: Forbid Tile behind finished crusade structure
							m_pMapList[m_pNpcList[sTargetH]->m_cMapIndex]->SetStayAllowedFlag(m_pNpcList[sTargetH]->m_sX, m_pNpcList[sTargetH]->m_sY-1, FALSE);
							m_pClientList[sAttackerH]->m_iWarContribution   += iWarContribution;
							if (m_pClientList[sAttackerH]->m_iWarContribution > DEF_MAXWARCONTRIBUTION)
								m_pClientList[sAttackerH]->m_iWarContribution = DEF_MAXWARCONTRIBUTION;
							if (m_pClientList[sAttackerH]->m_iWarContribution >= 256*128)
								SendNotifyMsg(NULL, sAttackerH, DEF_NOTIFY_CONSTRUCTIONPOINT, m_pClientList[sAttackerH]->m_iConstructionPoint, (m_pClientList[sAttackerH]->m_iWarContribution %(256*128)), 1, NULL);

							wsprintf(G_cTxt, "Construction Complete: PC(%s) - WarContribution +%d"
								, m_pClientList[sAttackerH]->m_cCharName
								, iWarContribution);
							PutLogList(G_cTxt);
							PutLogEventFileList(G_cTxt);
							SendNotifyMsg(NULL, sAttackerH, DEF_NOTIFY_CONSTRUCTIONPOINT, m_pClientList[sAttackerH]->m_iConstructionPoint, m_pClientList[sAttackerH]->m_iWarContribution, NULL, NULL);
						}
						break;
					case 5:
						m_pNpcList[sTargetH]->m_sAppr2 = 1;
						SendEventToNearClient_TypeA(sTargetH, DEF_OWNERTYPE_NPC, MSGID_EVENT_MOTION, DEF_OBJECTNULLACTION, NULL, NULL, NULL);
						break;
					case 10:
						m_pNpcList[sTargetH]->m_sAppr2 = 2;
						SendEventToNearClient_TypeA(sTargetH, DEF_OWNERTYPE_NPC, MSGID_EVENT_MOTION, DEF_OBJECTNULLACTION, NULL, NULL, NULL);
						break;
					}
					break;
				}
				
				m_pNpcList[sTargetH]->m_iBuildCount--;
				if (m_pNpcList[sTargetH]->m_iBuildCount <= 0) {
					m_pNpcList[sTargetH]->m_iBuildCount = 0;
				}
				return 0;
			}
			if (   (wWeaponType == 27) && (m_pNpcList[sTargetH]->m_cCropType != 0) 
				&& (m_pNpcList[sTargetH]->m_cActionLimit == 5) && (m_pNpcList[sTargetH]->m_iBuildCount > 0)) 
			{	cFarmingSkill = m_pClientList[sAttackerH]->m_cSkillMastery[2];
				cCropSkill = m_pNpcList[sTargetH]->m_cCropSkill;
				if (cFarmingSkill < 20) return 0;
				if (m_pClientList[sAttackerH]->m_iLevel < 20) return 0;
				switch(m_pNpcList[sTargetH]->m_sType) {
				case 64:
					// There skill increase only if needed skill is less than 10% over the minimum skill for such crop
					// Only count once per seedbag if over mimi Skill +10%
					iFarmingSSN = 1;
					if (cFarmingSkill <= (cCropSkill + 10)) 
					{	iFarmingSSN = 1;
					}else 
					{	iFarmingSSN = 0;					
					}
					switch(m_pNpcList[sTargetH]->m_iBuildCount) {
					case 1:	
						m_pNpcList[sTargetH]->m_sAppr2 = 3;
						SendEventToNearClient_TypeA(sTargetH, DEF_OWNERTYPE_NPC, MSGID_EVENT_MOTION, DEF_OBJECTNULLACTION, NULL, NULL, NULL);
						//sub_4B67E0
						CalculateSSN_SkillIndex(sAttackerH, 2, 1); 
						_CheckFarmingAction(sAttackerH, sTargetH, 1);
						DeleteNpc(sTargetH);
						return 0;
					case 8:	
						m_pNpcList[sTargetH]->m_sAppr2 = 3;
						SendEventToNearClient_TypeA(sTargetH, DEF_OWNERTYPE_NPC, MSGID_EVENT_MOTION, DEF_OBJECTNULLACTION, NULL, NULL, NULL);
						CalculateSSN_SkillIndex(sAttackerH, 2, iFarmingSSN);
						_CheckFarmingAction(sAttackerH, sTargetH, 0);
						m_pNpcList[sTargetH]->m_iBuildCount--;
						break;
					case 18:
						m_pNpcList[sTargetH]->m_sAppr2 = 2;
						SendEventToNearClient_TypeA(sTargetH, DEF_OWNERTYPE_NPC, MSGID_EVENT_MOTION, DEF_OBJECTNULLACTION, NULL, NULL, NULL);
						CalculateSSN_SkillIndex(sAttackerH, 2, iFarmingSSN);
						_CheckFarmingAction(sAttackerH, sTargetH, 0);
						// 1/20 chance to have 4 crops
						if (iDice(1,20) != 2)  m_pNpcList[sTargetH]->m_iBuildCount--;
						break;
					default:
						// SNOOPY Added a Skill Check to slow down a bit the process.
						// With minima Skill will cost twice the time
						if (   ((iDice(1,100) <= ((50+cFarmingSkill)-(cCropSkill)))// Chance off succes depends on skill
							|| (iDice(1,100)) <6 )) { // 1/20 chace of succes  ever skill you have
							m_pNpcList[sTargetH]->m_iBuildCount--;
						}
						break;
					}
					break;
				}
				// Useless? safety check !			
				if (m_pNpcList[sTargetH]->m_iBuildCount <= 0) 
				{	m_pNpcList[sTargetH]->m_iBuildCount = 0;
				}
				// They forgot to put Hoe deplession here..
				// Weapon's wep life off				
				sWeaponIndex = m_pClientList[sAttackerH]->m_sItemEquipmentStatus[DEF_EQUIPPOS_RHAND];
				if ( sWeaponIndex != -1)
				{	m_pClientList[sAttackerH]->m_pItemList[sWeaponIndex]->m_wCurLifeSpan -=1;
					if (m_pClientList[sAttackerH]->m_pItemList[sWeaponIndex]->m_wCurLifeSpan < 1)
						m_pClientList[sAttackerH]->m_pItemList[sWeaponIndex]->m_wCurLifeSpan = 0;
					// then notify the client...
					if (m_pClientList[sAttackerH]->m_pItemList[sWeaponIndex]->m_wCurLifeSpan == 0)
					{	SendNotifyMsg(NULL, sAttackerH, DEF_NOTIFY_ITEMLIFESPANEND, m_pClientList[sAttackerH]->m_pItemList[sWeaponIndex]->m_cEquipPos, sWeaponIndex, NULL, NULL);
						ReleaseItemHandler(sAttackerH, sWeaponIndex, TRUE);
					}
				}
				return 0;
			}
		}
		sTgtX = m_pNpcList[sTargetH]->m_sX;
		sTgtY = m_pNpcList[sTargetH]->m_sY;
		break;
	} // End of switch Target type

	if ( (cAttackerType == DEF_OWNERTYPE_PLAYER) && (cTargetType == DEF_OWNERTYPE_PLAYER) ) 
	{	sX = m_pClientList[sAttackerH]->m_sX;
		sY = m_pClientList[sAttackerH]->m_sY;
		dX = m_pClientList[sTargetH]->m_sX;
		dY = m_pClientList[sTargetH]->m_sY;
		if (m_pMapList[m_pClientList[sTargetH]->m_cMapIndex]->iGetAttribute(sX, sY, 0x00000006) != 0) return 0;
		if (m_pMapList[m_pClientList[sTargetH]->m_cMapIndex]->iGetAttribute(dX, dY, 0x00000006) != 0) return 0;
	}

	if (cAttackerType == DEF_OWNERTYPE_PLAYER)  // Metamorphosis effect
	{	if (m_pClientList[sAttackerH]->m_cMagicEffectStatus[DEF_MAGICTYPE_METAMORPHOSIS_TEMP_DEXT] > m_pClientList[sAttackerH]->m_iDex)
		{	iAttackerHitRatio += ( 10 * m_pClientList[sAttackerH]->m_cMagicEffectStatus[DEF_MAGICTYPE_METAMORPHOSIS_TEMP_DEXT]);
			iAttackerHitRatio -= 50; // For dex above 50 only
			if ( cTargetType == DEF_OWNERTYPE_NPC) 
			{	if (m_pNpcList[sTargetH]->m_cSize != 0) 	
				{	iAttackerHitRatio += 20; //Big sword have bonusses to Hit Big monsters
			}	}
		}else if ((m_pClientList[sAttackerH]->m_iDex + m_pClientList[sAttackerH]->m_iAngelicDex) > 50) 
		{	iAttackerHitRatio += ((m_pClientList[sAttackerH]->m_iDex + m_pClientList[sAttackerH]->m_iAngelicDex) - 50); 	
		}
	}
	//SNOOPY: Found a bug here, cause server hang if attacker is npc and Weapontype >40
	if (cAttackerType == DEF_OWNERTYPE_PLAYER) 
	{	if (wWeaponType >= 40) 
		{	switch (m_pMapList[m_pClientList[sAttackerH]->m_cMapIndex]->m_cWhetherStatus) {
			case 0:	break;
			case 1:	iAttackerHitRatio -= (iAttackerHitRatio / 20); break;
			case 2:	iAttackerHitRatio -= (iAttackerHitRatio / 10); break;
			case 3:	iAttackerHitRatio -= (iAttackerHitRatio / 4);  break;
			// SNOOPY: Added same malus for snow weather
			case 4:	iAttackerHitRatio -= (iAttackerHitRatio / 40); break;
			case 5:	iAttackerHitRatio -= (iAttackerHitRatio / 20); break;
			case 6:	iAttackerHitRatio -= (iAttackerHitRatio / 8);  break;
			default: break;
			}	
	}	}
	// SNOOPY: Added adjustment for hidden Weapons/armors ToHit bonusses against npcs
	if (   (cAttackerType == DEF_OWNERTYPE_PLAYER) 
		&& (cTargetType == DEF_OWNERTYPE_NPC)
		&& (m_pClientList[sAttackerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_METAMORPHOSIS ] == 0) ) 
	{	if (m_pNpcList[sTargetH]->m_cSize != 0) {	
			iAttackerHitRatio +=m_pClientList[sAttackerH]->m_iHitRatio_ItemEffect_L;
		}else
		{	iAttackerHitRatio +=m_pClientList[sAttackerH]->m_iHitRatio_ItemEffect_SM;
	}	}
	
	// SNOOPY: Added adjustment for hidden Weapons/armors ToHit bonusses against players
	if (   (cAttackerType == DEF_OWNERTYPE_PLAYER) 
		&& (cTargetType == DEF_OWNERTYPE_PLAYER)) 
	{	iAttackerHitRatio +=m_pClientList[sAttackerH]->m_iHitRatio_ItemEffect_SM;
	}
	if (iAttackerHitRatio < 0)   iAttackerHitRatio = 0;    
	switch (cTargetType) {
	case DEF_OWNERTYPE_PLAYER:
		cProtect = m_pClientList[sTargetH]->m_cMagicEffectStatus[DEF_MAGICTYPE_PROTECT];
		iProtectDR = m_pClientList[sTargetH]->m_cMagicEffectStatus[DEF_MAGICTYPE_DEFENCESHIELD_VALUE];
		break;

	case DEF_OWNERTYPE_NPC:
		cProtect = m_pNpcList[sTargetH]->m_cMagicEffectStatus[DEF_MAGICTYPE_PROTECT];
		iProtectDR = m_pNpcList[sTargetH]->m_cMagicEffectStatus[DEF_MAGICTYPE_DEFENCESHIELD_VALUE]; 
		break;
	}
	
	if (cAttackerType == DEF_OWNERTYPE_PLAYER) 
	{	if (m_pClientList[sAttackerH]->m_sItemEquipmentStatus[DEF_EQUIPPOS_TWOHAND] != -1) 
		{	if (m_pClientList[sAttackerH]->m_pItemList[m_pClientList[sAttackerH]->m_sItemEquipmentStatus[DEF_EQUIPPOS_TWOHAND]] == NULL) 
			{	m_pClientList[sAttackerH]->m_bIsItemEquipped[m_pClientList[sAttackerH]->m_sItemEquipmentStatus[DEF_EQUIPPOS_TWOHAND]] = FALSE;
				DeleteClient(sAttackerH, TRUE, TRUE);
				return 0;
			} // Strange ?  anti-Hack?	
			// Archery
			if (m_pClientList[sAttackerH]->m_pItemList[m_pClientList[sAttackerH]->m_sItemEquipmentStatus[DEF_EQUIPPOS_TWOHAND]]->m_sItemEffectType == DEF_ITEMEFFECTTYPE_ATTACK_ARROW) 
			{	if (m_pClientList[sAttackerH]->m_cArrowIndex == -1) 
				{	return 0;
				}else 
				{	if (m_pClientList[sAttackerH]->m_pItemList[m_pClientList[sAttackerH]->m_cArrowIndex] == NULL) return 0;
					if (bDontDepleteArrow != TRUE)
						m_pClientList[sAttackerH]->m_pItemList[m_pClientList[sAttackerH]->m_cArrowIndex]->m_dwCount--;
					if (m_pClientList[sAttackerH]->m_pItemList[ m_pClientList[sAttackerH]->m_cArrowIndex ]->m_dwCount <= 0) 
					{	ItemDepleteHandler(sAttackerH, m_pClientList[sAttackerH]->m_cArrowIndex, FALSE);
						m_pClientList[sAttackerH]->m_cArrowIndex = _iGetArrowItemIndex(sAttackerH);
					}else 
					{	SendNotifyMsg(NULL, sAttackerH, DEF_NOTIFY_SETITEMCOUNT, m_pClientList[sAttackerH]->m_cArrowIndex, m_pClientList[sAttackerH]->m_pItemList[ m_pClientList[sAttackerH]->m_cArrowIndex ]->m_dwCount, FALSE, NULL);
						iCalcTotalWeight(sAttackerH);				
				}	}
				if (cProtect == 1) return 0;
			}else  // so Defense shield have no effect against arrows...
			{	switch (cProtect) {
				case 3: iTargetDefenseRatio += iProtectDR; break;
				case 4: iTargetDefenseRatio += iProtectDR; break;
				}
				if (iTargetDefenseRatio < 0) iTargetDefenseRatio = 1;
				if ((cProtect == 1) && (bNormalMissileAttack)) return 0; 
			}
		}
	}else  // Attacker = npc
	{	switch (cProtect) {
		case 1:  // PFA
			if (bNormalMissileAttack) return 0; 
			break;
		case 3: iTargetDefenseRatio += iProtectDR; break;
		case 4: iTargetDefenseRatio += iProtectDR; break;
		}
		if (iTargetDefenseRatio < 0) iTargetDefenseRatio = 1;
	}
	if (cAttackerDir == cTargetDir) iTargetDefenseRatio = iTargetDefenseRatio / 2;
	if (iTargetDefenseRatio < 1)   iTargetDefenseRatio = 1;	
	dTmp1 = (double)(iAttackerHitRatio);
	dTmp2 = (double)(iTargetDefenseRatio);
	dTmp3 = (dTmp1 / dTmp2) * 50.0f;
	iDestHitRatio = (int)(dTmp3); 

	if (iDestHitRatio < DEF_MINIMUMHITRATIO) iDestHitRatio = DEF_MINIMUMHITRATIO;
	if (iDestHitRatio > DEF_MAXIMUMHITRATIO) iDestHitRatio = DEF_MAXIMUMHITRATIO;
	// Snoopy: No zerk bonus if bDontDepleteArrow (Direction Bow Path)
	if ((cIsAttackerBerserk != 0) && (iAttackMode < 20) && (bDontDepleteArrow == FALSE)) 
	{	iAP_SM += (iAP_SM * cIsAttackerBerserk)/10;
		iAP_L  += (iAP_L  * cIsAttackerBerserk)/10;
		// 1 gives 10% damage bonus. Normal Zerk is 10
		iFlyingNpcAttack -= 10; // To prevent too easy flys if zerked
	}
	if (cAttackerType == DEF_OWNERTYPE_PLAYER) 
	{	iAP_SM += m_pClientList[sAttackerH]->m_iAddPhysicalDamage;
		iAP_L  += m_pClientList[sAttackerH]->m_iAddPhysicalDamage;
	}
	if (bNearAttack == TRUE) 
	{	iAP_SM = iAP_SM / 2;
		iAP_L  = iAP_L / 2;
	}
	if (cTargetType == DEF_OWNERTYPE_PLAYER) 
	{	iAP_SM -= (iDice(1, m_pClientList[sTargetH]->m_iVit/10) - 1);
		iAP_L  -= (iDice(1, m_pClientList[sTargetH]->m_iVit/10) - 1);
	}
	if (cAttackerType == DEF_OWNERTYPE_PLAYER) 
	{	if (iAP_SM <= 1) iAP_SM = 1;
		if (iAP_L  <= 1) iAP_L  = 1;
	}else 
	{	if (iAP_SM <= 0) iAP_SM = 0;
		if (iAP_L  <= 0) iAP_L  = 0;
	}

	iResult = iDice(1, 100);
	//------------
	if (iResult <= iDestHitRatio) 
	{	if (cAttackerType == DEF_OWNERTYPE_PLAYER) 
		{	if (((m_pClientList[sAttackerH]->m_iHungerStatus <= 10) || (m_pClientList[sAttackerH]->m_iSP <= 0)) && (iDice(1,10) == 5)) return FALSE;	
			m_pClientList[sAttackerH]->m_iComboAttackCount++;
			if (m_pClientList[sAttackerH]->m_iComboAttackCount < 0) m_pClientList[sAttackerH]->m_iComboAttackCount = 0;
			if (m_pClientList[sAttackerH]->m_iComboAttackCount > 4) m_pClientList[sAttackerH]->m_iComboAttackCount = 1;
			iWeaponSkill = _iGetWeaponSkillType(sAttackerH);
			iComboBonus = iGetComboAttackBonus(iWeaponSkill, m_pClientList[sAttackerH]->m_iComboAttackCount);

			if ((m_pClientList[sAttackerH]->m_iComboAttackCount > 1) && (m_pClientList[sAttackerH]->m_iAddCD != NULL))
				iComboBonus += m_pClientList[sAttackerH]->m_iAddCD;
			iAP_SM += iComboBonus;
			iAP_L  += iComboBonus;
			switch (m_pClientList[sAttackerH]->m_iSpecialWeaponEffectType) {
			case 0: break;
			case 1: // Critical damage added
				if ((m_pClientList[sAttackerH]->m_iSuperAttackLeft > 0) && (iAttackMode >= 20)) 
				{	iAP_SM += m_pClientList[sAttackerH]->m_iSpecialWeaponEffectValue;
					iAP_L  += m_pClientList[sAttackerH]->m_iSpecialWeaponEffectValue;
					if (iDice(1,100) <= m_pClientList[sAttackerH]->m_iSpecialWeaponEffectValue)
						iAP_L *=2;	// Snoopy: Crit 5 gives 5% chance of double damage...
				}
				break;
			case 2: // Poison
				cAttackerSA = 61;
				iAttackerSAvalue = m_pClientList[sAttackerH]->m_iSpecialWeaponEffectValue*5; 
				break;
			case 3: // Righteous
				cAttackerSA = 62;
				iRepDamage = m_pClientList[sAttackerH]->m_iRating/50;
				if (iRepDamage > 20) iRepDamage = 20;
				break;
			}
			if (m_pMapList[m_pClientList[sAttackerH]->m_cMapIndex]->m_bIsFightZone == TRUE) 
			{	iAP_SM += iAP_SM/3;
				iAP_L  += iAP_L/3;
			}		
			if ((cTargetType == DEF_OWNERTYPE_PLAYER) && (m_bIsCrusadeMode == TRUE)	&& (m_pClientList[sAttackerH]->m_iCrusadeDuty == 1)) 
			{	if (m_pClientList[sAttackerH]->m_iLevel <= 80) 
				{	iAP_SM += iAP_SM;
					iAP_L += iAP_L;
				}else if (m_pClientList[sAttackerH]->m_iLevel <= 100) 
				{	iAP_SM += (iAP_SM* 7)/10;
					iAP_L += (iAP_L* 7)/10;
				} else 
				{	iAP_SM += iAP_SM/3;
					iAP_L += iAP_L/3;
				}
			}
			// SNOOPY Added Ice GBH here, freezes without need for activation
			sItemIndex = m_pClientList[sAttackerH]->m_sItemEquipmentStatus[DEF_EQUIPPOS_TWOHAND];
			if ((sItemIndex != -1) && (m_pClientList[sAttackerH]->m_pItemList[sItemIndex] != NULL)) 
			{	// SNOOPY Added icing, all the time
				if (m_pClientList[sAttackerH]->m_pItemList[sItemIndex]->m_sIDnum == 766)// IceGBH
				{	// SNOOPY Added icing, all the time
					switch (cTargetType) {
					case DEF_OWNERTYPE_PLAYER:	
						if (   (bCheckResistingIceSuccess(0, sTargetH, DEF_OWNERTYPE_PLAYER, 50) == FALSE) 
							&& (m_pClientList[sTargetH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_ICE ] == 0)) 
						{	m_pClientList[sTargetH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_ICE ] = 1;
							SetIceFlag(sTargetH, DEF_OWNERTYPE_PLAYER, TRUE);
						bRegisterDelayEvent(DEF_DELAYEVENTTYPE_MAGICRELEASE, DEF_MAGICTYPE_ICE, dwTime + 10000, 
								sTargetH, DEF_OWNERTYPE_PLAYER, NULL, NULL, NULL, 1, NULL, NULL);
							SendNotifyMsg(NULL, sTargetH, DEF_NOTIFY_MAGICEFFECTON, DEF_MAGICTYPE_ICE, 1, NULL, NULL);
						}
						break;
					case DEF_OWNERTYPE_NPC:	
						if (   (bCheckResistingIceSuccess(0, sTargetH, DEF_OWNERTYPE_NPC, 50) == FALSE) 
							&& (m_pNpcList[sTargetH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_ICE ] == 0)) 					
						{	m_pNpcList[sTargetH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_ICE ] = 2;
							SetIceFlag(sTargetH, DEF_OWNERTYPE_NPC, TRUE);
							bRegisterDelayEvent(DEF_DELAYEVENTTYPE_MAGICRELEASE, DEF_MAGICTYPE_ICE, dwTime + 5000, 
								sTargetH, DEF_OWNERTYPE_NPC, NULL, NULL, NULL, 1, NULL, NULL);
						}
						break;
			}	}	}
		} // End of if (AttackerType == DEF_OWNERTYPE_PLAYER)
		if (   (m_bHeldenianWarInitiated == TRUE)
			&& (bCheckHeldenianMap(sAttackerH, cAttackerType) == TRUE))
		{	iAP_SM += iAP_SM/3;
			iAP_L  += iAP_L/3;
		}	
		switch (cTargetType) {
		case DEF_OWNERTYPE_PLAYER:
			ClearSkillUsingStatus(sTargetH);
			if ((dwTime - m_pClientList[sTargetH]->m_dwTime) > DEF_RAGPROTECTIONTIME) 
			{	return 0;
			}else 
			{	if  (cAttackerSA == 62) // rite becomes interesting specially on executors !
				{	iRepDamage -= m_pClientList[sTargetH]->m_iRating/50;
					if (iRepDamage > 30) iRepDamage = 30;
					if (iRepDamage > 0)  iAP_SM += iRepDamage;
				}
				iAP_Abs_Armor  = 0;
				iAP_Abs_Shield = 0;
				iAP_Abs_Cape   = 0;
				iTemp = iDice(1,10000);
				if ((iTemp >= 1) && (iTemp < 5000))           iHitPoint = 1; // torse
				else if ((iTemp >= 5000) && (iTemp < 7500))   iHitPoint = 2; // jambes
				else if ((iTemp >= 7500) && (iTemp < 9000))   iHitPoint = 3; // bras
				else if ((iTemp >= 9000) && (iTemp <= 10000)) iHitPoint = 4; // tête
				// iHitPoint = 5; // bottes
				// iHitPoint = 6; // bottes & jambes

				// PA: Armures
				if (iHitPoint == 2)
				{	if (cAttackerType == DEF_OWNERTYPE_NPC)
					{	switch (m_pNpcList[sAttackerH]->m_sType) {
						case 10: // Slime 
						case 16: // Ant
						case 22: // Snake
						case 55: // Rabbit
						case 56: // Cat
								iHitPoint = 5; // Only boots depleted
								break;
						case 17: // Scorpions 
						case 80: // Tentocle
								iHitPoint = 4 + iDice(1,2); // 5-boots (50%) or 6-both (50%)
								break;
						default: if (iDice(1,3) == 2) iHitPoint = 6; // 6-both (50%)
								break;					
						}
					}else if (cAttackerType == DEF_OWNERTYPE_PLAYER)
					{	if (iDice(1,3) == 2) iHitPoint = 6;
				}	}
				switch (iHitPoint) { // usure un peu + loin
				case 1: // torse
					iAP_Abs_Armor = (double)m_pClientList[sTargetH]->m_iDamageAbsorption_Armor[DEF_EQUIPPOS_BODY];
					break;
				case 2: // jambes
					iAP_Abs_Armor = (double)m_pClientList[sTargetH]->m_iDamageAbsorption_Armor[DEF_EQUIPPOS_PANTS];
					break;
				case 3:  // bras
					iAP_Abs_Armor = (double)m_pClientList[sTargetH]->m_iDamageAbsorption_Armor[DEF_EQUIPPOS_ARMS];
					break;
				case 4: // tête
					iAP_Abs_Armor = (double)m_pClientList[sTargetH]->m_iDamageAbsorption_Armor[DEF_EQUIPPOS_HEAD];
					break;	
				case 5: // Bottes
					iAP_Abs_Armor = (double)m_pClientList[sTargetH]->m_iDamageAbsorption_Armor[DEF_EQUIPPOS_FOOT];
					break;	
				case 6: // Bottes et jambes
					if ((m_pClientList[sTargetH]->m_iDamageAbsorption_Armor[DEF_EQUIPPOS_PANTS] +
						m_pClientList[sTargetH]->m_iDamageAbsorption_Armor[DEF_EQUIPPOS_FOOT]) > 0) 
					{	if ((m_pClientList[sTargetH]->m_iDamageAbsorption_Armor[DEF_EQUIPPOS_PANTS] +
							m_pClientList[sTargetH]->m_iDamageAbsorption_Armor[DEF_EQUIPPOS_FOOT]) >= 60)
							 iAP_Abs_Armor = 60.0f;
						else iAP_Abs_Armor = (double)(m_pClientList[sTargetH]->m_iDamageAbsorption_Armor[DEF_EQUIPPOS_PANTS] + m_pClientList[sTargetH]->m_iDamageAbsorption_Armor[DEF_EQUIPPOS_FOOT]);
					}
					break;		
				}
				// PA: Shields
				if (m_pClientList[sTargetH]->m_iDamageAbsorption_Shield > 0) 
				{	if (iDice(1,100) <= (m_pClientList[sTargetH]->m_cSkillMastery[11])) 
					{	CalculateSSN_SkillIndex(sTargetH, 11, 1);
						iAP_Abs_Shield = m_pClientList[sTargetH]->m_iDamageAbsorption_Shield;
						// Usure Shield
						iTemp = m_pClientList[sTargetH]->m_sItemEquipmentStatus[DEF_EQUIPPOS_LHAND];
						if ((iTemp != -1) && (m_pClientList[sTargetH]->m_pItemList[iTemp] != NULL)) 
						{	if ((m_pClientList[sTargetH]->m_cSide != 0) && (m_pClientList[sTargetH]->m_pItemList[iTemp]->m_wCurLifeSpan > 0))	
								m_pClientList[sTargetH]->m_pItemList[iTemp]->m_wCurLifeSpan--;
							if (m_pClientList[sTargetH]->m_pItemList[iTemp]->m_wCurLifeSpan == 0) 
							{	SendNotifyMsg(NULL, sTargetH, DEF_NOTIFY_ITEMLIFESPANEND, m_pClientList[sTargetH]->m_pItemList[iTemp]->m_cEquipPos, iTemp, NULL, NULL);
								ReleaseItemHandler(sTargetH, iTemp, TRUE);
				}	}	}	}
				if (m_pClientList[sTargetH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_METAMORPHOSIS ] > 0)
				{	iAP_Abs_Shield = 25; // Medium value of 25% PA...
				}

				// PA: Back (capes)  Added Damage absorbtion for enchanted capes  iAP_Abs_Cape
				if (   (cAttackerDir == cTargetDir) // Of course only when attacked from behind !
					&& (m_pClientList[sTargetH]->m_iDamageAbsorption_Armor[DEF_EQUIPPOS_BACK] > 0)) 
				{	iAP_Abs_Cape = m_pClientList[sTargetH]->m_iDamageAbsorption_Armor[DEF_EQUIPPOS_BACK];
					// Deplete Cape durability in this case	
					iTemp = m_pClientList[sTargetH]->m_sItemEquipmentStatus[DEF_EQUIPPOS_BACK];
					if ((iTemp != -1) && (m_pClientList[sTargetH]->m_pItemList[iTemp] != NULL)) 
					{	if ((m_pClientList[sTargetH]->m_cSide != 0) && (m_pClientList[sTargetH]->m_pItemList[iTemp]->m_wCurLifeSpan > 0))	
							m_pClientList[sTargetH]->m_pItemList[iTemp]->m_wCurLifeSpan--;
						if (m_pClientList[sTargetH]->m_pItemList[iTemp]->m_wCurLifeSpan == 0) 
						{	SendNotifyMsg(NULL, sTargetH, DEF_NOTIFY_ITEMLIFESPANEND, m_pClientList[sTargetH]->m_pItemList[iTemp]->m_cEquipPos, iTemp, NULL, NULL);
							ReleaseItemHandler(sTargetH, iTemp, TRUE);
				}	}	}
				// PA: Bonus for Knights vs mobs
				if (   (m_pClientList[sTargetH]->m_iPriestDruidID == 5)
					&& (cAttackerType == DEF_OWNERTYPE_NPC)
					&& (m_pClientList[sTargetH]->m_bSpecialFeatureAllowed == TRUE))
				{	iAP_Abs_Armor += 10;
					if (iAP_Abs_Armor > 80) iAP_Abs_Armor = 80;
				}
				// PA: Hammer reduces PA unless if robed...
				if (   (cAttackerType == DEF_OWNERTYPE_PLAYER) && (m_pClientList[sAttackerH] != NULL) 
					&& (m_pClientList[sAttackerH]->m_sUsingWeaponSkill == 14)) 	// PA counts for 3/4 vs Hammers
				{	iAP_Abs_Armor  = iAP_Abs_Armor  - iAP_Abs_Armor/4;
					iAP_Abs_Shield = iAP_Abs_Shield + iAP_Abs_Shield/4;
					// Robes have an extra PA vs hammers
					iAP_Abs_Cape   = iAP_Abs_Cape + m_pClientList[sTargetH]->m_iDamageAbsorption_Armor[DEF_EQUIPPOS_RELEASEALL];
				}

				// PA total: Calculer les dégâts restants.
				iAP_Abs_Armor = iAP_Abs_Armor + iAP_Abs_Shield + iAP_Abs_Cape;
				if (iAP_Abs_Armor >= 80) 
					dTmp1 = 80.0f;
				else dTmp1 = (double)iAP_Abs_Armor;
				dTmp2 = (double)iAP_SM;
				dTmp3 = (dTmp1 / 100.0f) * dTmp2;
				iAP_SM = iAP_SM - (int)dTmp3;
				if (iAP_SM <= 0) iAP_SM = 1;

				if (   (cAttackerType == DEF_OWNERTYPE_PLAYER) && (m_pClientList[sAttackerH] != NULL) 
					&& (m_pClientList[sAttackerH]->m_bIsSpecialAbilityEnabled == TRUE)) 
				{	switch (m_pClientList[sAttackerH]->m_iSpecialAbilityType) {
						case 0: break;
						case 1: // Xelima weapon
							iTemp = (m_pClientList[sTargetH]->m_iHP / 2);
							if (   (m_bIsCrusadeMode == FALSE) && (m_bHeldenianWarInitiated == FALSE)
								&& (m_pClientList[sTargetH]->m_iPriestDruidID == 3) // Monks
								&& (m_pClientList[sTargetH]->m_bSpecialFeatureAllowed == TRUE)
								&& (m_pClientList[sTargetH]->m_iLevel >= 140))
							{}else	if (iTemp > iAP_SM) iAP_SM = iTemp;
							if (iAP_SM <= 0) iAP_SM = 1;
							break;
						case 2: // Ice weapon
							if (   (bCheckResistingIceSuccess(0, sTargetH, DEF_OWNERTYPE_PLAYER, 50) == FALSE) 
								&& (m_pClientList[sTargetH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_ICE ] == 0)) 
							{	m_pClientList[sTargetH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_ICE ] = 1;
								SetIceFlag(sTargetH, DEF_OWNERTYPE_PLAYER, TRUE);
								bRegisterDelayEvent(DEF_DELAYEVENTTYPE_MAGICRELEASE, DEF_MAGICTYPE_ICE, dwTime + 30000, 
									sTargetH, DEF_OWNERTYPE_PLAYER, NULL, NULL, NULL, 1, NULL, NULL);
								SendNotifyMsg(NULL, sTargetH, DEF_NOTIFY_MAGICEFFECTON, DEF_MAGICTYPE_ICE, 1, NULL, NULL);
							}
							break;
						case 3: // Medusa sword
							if (m_pClientList[sTargetH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_HOLDOBJECT ] >= 5) break; 
							// Monks Druids 130+ Para invulnerables								
							if ((m_pClientList[sTargetH]->m_iPriestDruidID == 3) && (m_pClientList[sTargetH]->m_iLevel >129)) break; 
							if ((m_pClientList[sTargetH]->m_iPriestDruidID == 2) && (m_pClientList[sTargetH]->m_iLevel >129)) break; 
							// Medusa neck or very high PR gives invulnerability, unless having a Medusa Blade...
							if (   ((m_pClientList[sTargetH]->m_cSkillMastery[23] + m_pClientList[sTargetH]->m_iAddPR + iDice(1,100)) >= 250) 
								&& (m_pClientList[sTargetH]->m_iSpecialAbilityType != 3)) break; 
							m_pClientList[sTargetH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_HOLDOBJECT ] = 5;
							// Nota: The client was fixed to show "paralysed" for any 2+ value
							bRegisterDelayEvent(DEF_DELAYEVENTTYPE_MAGICRELEASE, DEF_MAGICTYPE_HOLDOBJECT, dwTime + 10000, 
								sTargetH, DEF_OWNERTYPE_PLAYER, NULL, NULL, NULL, 5, NULL, NULL);								
							SendNotifyMsg(NULL, sTargetH, DEF_NOTIFY_MAGICEFFECTON, DEF_MAGICTYPE_HOLDOBJECT, 5, NULL, NULL);		
							break;
						case 4: // Instant kill weapon
							iAP_SM = (m_pClientList[sTargetH]->m_iHP);
							break;
						case 5: // Vampiric weapon
							m_pClientList[sAttackerH]->m_iHP += iAP_SM;
							if (iGetMaxHP(sAttackerH, TRUE) < m_pClientList[sAttackerH]->m_iHP)  // BloodEffect limite le regen
								m_pClientList[sAttackerH]->m_iHP = iGetMaxHP(sAttackerH, TRUE);
							SendNotifyMsg(NULL, sAttackerH, DEF_NOTIFY_HP, NULL, NULL, NULL, NULL);
							break;
					}
				}
				if (m_pClientList[sTargetH]->m_bIsSpecialAbilityEnabled == TRUE)
				{	if (   (cAttackerType == DEF_OWNERTYPE_PLAYER) && (m_pClientList[sAttackerH] != NULL)) 
					{	switch (m_pClientList[sTargetH]->m_iSpecialAbilityType) {
						case 50: // Merien Plate
							if (m_pClientList[sAttackerH]->m_sItemEquipmentStatus[DEF_EQUIPPOS_TWOHAND] != -1)
								sWeaponIndex = m_pClientList[sAttackerH]->m_sItemEquipmentStatus[DEF_EQUIPPOS_TWOHAND];
							else sWeaponIndex = m_pClientList[sAttackerH]->m_sItemEquipmentStatus[DEF_EQUIPPOS_RHAND];
							if ((sWeaponIndex != -1) && (iWeaponSkill !=6)) // Don't break bows
								m_pClientList[sAttackerH]->m_pItemList[sWeaponIndex]->m_wCurLifeSpan = 0;
							break;
						case 51: // Merien Shield effect on armor piece
							if (iHitPoint == m_pClientList[sTargetH]->m_iSpecialAbilityEquipPos)
								iAP_SM = 0;
							break;
						case 52: // Merien Shield
							iAP_SM = 0;
							break;
						}
					}else if (cAttackerType == DEF_OWNERTYPE_NPC) 
					{	switch (m_pClientList[sTargetH]->m_iSpecialAbilityType) {
						case 50: // Merien Plate							
							if (m_pNpcList[sAttackerH]->m_cActionLimit < 2)
							{	m_pNpcList[sAttackerH]->m_sBehaviorTurnCount = 0;
								m_pNpcList[sAttackerH]->m_cBehavior = DEF_BEHAVIOR_FLEE;
								m_pNpcList[sAttackerH]->m_bIsPermAttackMode = FALSE;
								m_pNpcList[sAttackerH]->m_iTargetIndex = NULL;
							}
							break;
						case 51: // Merien Shield effect on armor piece
							if (iHitPoint == m_pClientList[sTargetH]->m_iSpecialAbilityEquipPos)
								iAP_SM = 0;
							break;
						case 52: // Merien Shield
							iAP_SM = iAP_SM/2;
							break;				
				}	}	}
				if ((m_pClientList[sTargetH]->m_bIsLuckyEffect > 0) && (iDice(1,100) <= m_pClientList[sTargetH]->m_bIsLuckyEffect) 
					&& (m_pClientList[sTargetH]->m_iHP <= iAP_SM)) 
				{	iAP_SM = m_pClientList[sTargetH]->m_iHP - 1;
				}
				// Usure de l'armure touchée
				switch (iHitPoint) {
				case 1:
					iTemp = m_pClientList[sTargetH]->m_sItemEquipmentStatus[DEF_EQUIPPOS_BODY];
					if ((iTemp != -1) && (m_pClientList[sTargetH]->m_pItemList[iTemp] != NULL)) 
					{	CalculateEnduranceDecrement(sTargetH, sAttackerH, cTargetType, cAttackerType, iTemp);
					}
					break;
				case 2:
					iTemp = m_pClientList[sTargetH]->m_sItemEquipmentStatus[DEF_EQUIPPOS_PANTS];
					if ((iTemp != -1) && (m_pClientList[sTargetH]->m_pItemList[iTemp] != NULL)) 
					{	CalculateEnduranceDecrement(sTargetH, sAttackerH, cTargetType, cAttackerType, iTemp);
					}
					break;
				case 3: // Hauberk
					iTemp = m_pClientList[sTargetH]->m_sItemEquipmentStatus[DEF_EQUIPPOS_ARMS];
					if ((iTemp != -1) && (m_pClientList[sTargetH]->m_pItemList[iTemp] != NULL)) 
					{	CalculateEnduranceDecrement(sTargetH, sAttackerH, cTargetType, cAttackerType, iTemp);
					}
					break;
				case 4: // Helmets
					iTemp = m_pClientList[sTargetH]->m_sItemEquipmentStatus[DEF_EQUIPPOS_HEAD];
					if ((iTemp != -1) && (m_pClientList[sTargetH]->m_pItemList[iTemp] != NULL)) 
					{	CalculateEnduranceDecrement(sTargetH, sAttackerH, cTargetType, cAttackerType, iTemp);
					}
					break;
				case 5: // Bottes
					iTemp = m_pClientList[sTargetH]->m_sItemEquipmentStatus[DEF_EQUIPPOS_FOOT];
					if ((iTemp != -1) && (m_pClientList[sTargetH]->m_pItemList[iTemp] != NULL)) 
					{	CalculateEnduranceDecrement(sTargetH, sAttackerH, cTargetType, cAttackerType, iTemp);
					}
					break;
				case 6: // Bottes et leggings
					iTemp = m_pClientList[sTargetH]->m_sItemEquipmentStatus[DEF_EQUIPPOS_FOOT];
					if ((iTemp != -1) && (m_pClientList[sTargetH]->m_pItemList[iTemp] != NULL)) 
					{	CalculateEnduranceDecrement(sTargetH, sAttackerH, cTargetType, cAttackerType, iTemp);
					}
					iTemp = m_pClientList[sTargetH]->m_sItemEquipmentStatus[DEF_EQUIPPOS_PANTS];
					if ((iTemp != -1) && (m_pClientList[sTargetH]->m_pItemList[iTemp] != NULL)) 
					{	CalculateEnduranceDecrement(sTargetH, sAttackerH, cTargetType, cAttackerType, iTemp);
					}
					break;
				} 
				
				// mobs Destruction of Magic protection	
				if ((cAttackerSA == 2) && (m_pClientList[sTargetH]->m_cMagicEffectStatus[DEF_MAGICTYPE_PROTECT] != 0))
				{	SendNotifyMsg(NULL, sTargetH, DEF_NOTIFY_MAGICEFFECTOFF, DEF_MAGICTYPE_PROTECT, m_pClientList[sTargetH]->m_cMagicEffectStatus[DEF_MAGICTYPE_PROTECT ], NULL, NULL);
					switch(m_pClientList[sTargetH]->m_cMagicEffectStatus[DEF_MAGICTYPE_PROTECT]) {
					case 1:
						SetProtectionFromArrowFlag(sTargetH, DEF_OWNERTYPE_PLAYER, FALSE);
						break;
					case 2:
					case 5:
						SetMagicProtectionFlag(sTargetH, DEF_OWNERTYPE_PLAYER, FALSE);
						break;
					case 3:
					case 4:
						SetDefenseShieldFlag(sTargetH, DEF_OWNERTYPE_PLAYER, FALSE);
						break;
					}
					m_pClientList[sTargetH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_PROTECT] = NULL;					
					m_pClientList[sTargetH]->m_cMagicEffectStatus[DEF_MAGICTYPE_DEFENCESHIELD_VALUE] = 0;
					bRemoveFromDelayEventList(sTargetH, DEF_OWNERTYPE_PLAYER, DEF_MAGICTYPE_PROTECT);								
					// Remove Reflexion spells 
					if (m_pClientList[sTargetH]->m_cMagicEffectStatus[DEF_MAGICTYPE_REFLEXION] != NULL)
					{	bRemoveFromDelayEventList(sTargetH, DEF_OWNERTYPE_PLAYER, DEF_MAGICTYPE_REFLEXION);
						SetReflexionFlag(sTargetH, DEF_OWNERTYPE_PLAYER, FALSE);
				}	}
				if ( (m_pClientList[sTargetH]->m_bIsPoisoned == FALSE) && 
					((cAttackerSA == 5) || (cAttackerSA == 6) || (cAttackerSA == 61)) ) 
				{	if (bCheckResistingPoisonSuccess(sTargetH, DEF_OWNERTYPE_PLAYER) == FALSE) 
					{	m_pClientList[sTargetH]->m_bIsPoisoned = TRUE;
						if (cAttackerSA == 5)		m_pClientList[sTargetH]->m_iPoisonLevel = 15;
						else if (cAttackerSA == 6)  m_pClientList[sTargetH]->m_iPoisonLevel = 40;
						else if (cAttackerSA == 61) m_pClientList[sTargetH]->m_iPoisonLevel = iAttackerSAvalue;
						m_pClientList[sTargetH]->m_dwPoisonTime = dwTime;
						SendNotifyMsg(NULL, sTargetH, DEF_NOTIFY_MAGICEFFECTON, DEF_MAGICTYPE_POISON, m_pClientList[sTargetH]->m_iPoisonLevel, NULL, NULL);
						SetPoisonFlag(sTargetH, DEF_OWNERTYPE_PLAYER, TRUE);
				}	}
				// SNOOPY: Added support for StormBringer (Elric's Vampiric blade)
				// When StormBringer is shinning, it'll give back to wielder
				// 1/2 of damage done on victim.
				// The blade will revert fix it self as well
				if (cAttackerType == DEF_OWNERTYPE_PLAYER)
				{	sItemIndex = m_pClientList[sAttackerH]->m_sItemEquipmentStatus[DEF_EQUIPPOS_TWOHAND];
					if (   (sItemIndex != -1) 
						&& (m_pClientList[sAttackerH]->m_pItemList[sItemIndex] != NULL) ) 
					{	if (m_pClientList[sAttackerH]->m_pItemList[sItemIndex]->m_sIDnum == 767)
						{	if ((m_pClientList[sAttackerH]->m_sAppr4 & 0x0004) != 0)
							{	// Extra damage for High HP enemys
								if (m_pClientList[sTargetH]->m_iHP > 399) iAP_SM += iAP_SM/2;
								// Berzerk the character and remove 10 from Blade's life if criting when not zerked
								if ((cIsAttackerBerserk == 0) && (iAttackMode >= 20))
								{	PlayerMagicHandler(sAttackerH, m_pClientList[sAttackerH]->m_sX, m_pClientList[sAttackerH]->m_sY, 50, TRUE, -1); 
									if (m_pClientList[sAttackerH]->m_pItemList[sItemIndex]->m_wCurLifeSpan < 10) 
									m_pClientList[sAttackerH]->m_pItemList[sItemIndex]->m_wCurLifeSpan = 0;
								else m_pClientList[sAttackerH]->m_pItemList[sItemIndex]->m_wCurLifeSpan -= 10;
								}
								// Give 1/2 of damage back to attacker as HPs...
								m_pClientList[sAttackerH]->m_iHP += (iAP_SM/2);								
								SendNotifyMsg(NULL, sAttackerH, DEF_NOTIFY_HP, NULL, NULL, NULL, NULL);								
								if (iGetMaxHP(sAttackerH, TRUE) < m_pClientList[sAttackerH]->m_iHP)  // BloodEffect limite le regen
									m_pClientList[sAttackerH]->m_iHP = iGetMaxHP(sAttackerH, TRUE);
								// Auto-repair
								m_pClientList[sAttackerH]->m_pItemList[sItemIndex]->m_wCurLifeSpan = m_pClientList[sAttackerH]->m_pItemList[sItemIndex]->m_wMaxLifeSpan;
				}	}	}	}
				// DS reduce Demon's Damage:  max 34-39 damage by DDs (Never fly by DDs)		
				sItemIndex = m_pClientList[sTargetH]->m_sItemEquipmentStatus[DEF_EQUIPPOS_TWOHAND];
				if ((sItemIndex != -1) && (m_pClientList[sTargetH]->m_pItemList[sItemIndex] != NULL)) 
				{	if (   (m_pClientList[sTargetH]->m_pItemList[sItemIndex]->m_sIDnum == 616) // DemonSlayer	
						&& (cAttackerType == DEF_OWNERTYPE_NPC)) 
					{	if ( m_pNpcList[sAttackerH]->m_sType == 31) 
						{	if (iAP_SM >= 40) iAP_SM = 33 + iDice(1,6);
				}	}	}

				if (   (m_pClientList[sTargetH]->m_iPriestDruidID == 6)	
					&& (m_pClientList[sTargetH]->m_bSpecialFeatureAllowed == TRUE)
					&& (m_pClientList[sTargetH]->m_iHP <= iAP_SM)
					&& (m_pClientList[sTargetH]->m_iMP >= iGetMaxMP(sTargetH))
					&& (m_pClientList[sTargetH]->m_iMP >= iAP_SM))
				{	m_pClientList[sTargetH]->m_iMP -= iAP_SM;
					iAP_SM = 1;						
					SendNotifyMsg(NULL, sTargetH, DEF_NOTIFY_MP, NULL, NULL, NULL, NULL);	
					iMaxSuperAttack = (m_pClientList[sTargetH]->m_iLevel / 10);
					if (m_pClientList[sTargetH]->m_iSuperAttackLeft < iMaxSuperAttack) m_pClientList[sTargetH]->m_iSuperAttackLeft++;
						SendNotifyMsg(NULL, sTargetH, DEF_NOTIFY_SUPERATTACKLEFT, NULL, NULL, NULL, NULL);
				}
				m_pClientList[sTargetH]->m_iHP -= iAP_SM;
				if (m_pClientList[sTargetH]->m_iHP <= 0) 
				{	if (cAttackerType == DEF_OWNERTYPE_PLAYER)
						bAnalyzeCriminalAction(sAttackerH, m_pClientList[sTargetH]->m_sX, m_pClientList[sTargetH]->m_sY);
					ClientKilledHandler(sTargetH, sAttackerH, cAttackerType, iAP_SM);	
					bKilled     = TRUE;
					iKilledDice = m_pClientList[sTargetH]->m_iLevel;
				}else 
				{	if (iAP_SM > 0) 
					{	if (m_pClientList[sTargetH]->m_iAddTransMana > 0) 
						{	// Mana converting items
							dTmp1 = (double)m_pClientList[sTargetH]->m_iAddTransMana;
							dTmp2 = (double)iAP_SM;
							dTmp3 = (dTmp1/100.0f)*dTmp2;
							iTemp = iGetMaxMP(sTargetH);
							m_pClientList[sTargetH]->m_iMP += (int)dTmp3;
							if (m_pClientList[sTargetH]->m_iMP > iTemp) m_pClientList[sTargetH]->m_iMP = iTemp;
						}
						if (m_pClientList[sTargetH]->m_iAddChargeCritical > 0) 
							// Crit increase items (bug < and not <= means CritIncrease 1% have no effect)
						{	if (iDice(1,100) <= (m_pClientList[sTargetH]->m_iAddChargeCritical)) 
							{	iMaxSuperAttack = (m_pClientList[sTargetH]->m_iLevel / 10);
								if (m_pClientList[sTargetH]->m_iSuperAttackLeft < iMaxSuperAttack) m_pClientList[sTargetH]->m_iSuperAttackLeft++;
									SendNotifyMsg(NULL, sTargetH, DEF_NOTIFY_SUPERATTACKLEFT, NULL, NULL, NULL, NULL);
						}	}
						m_pClientList[sTargetH]->m_dwLastDamageTime = dwTime;
						SendNotifyMsg(NULL, sTargetH, DEF_NOTIFY_HP, NULL, NULL, NULL, NULL);
						if (cAttackerType == DEF_OWNERTYPE_PLAYER) 
						sAttackerWeapon = ((m_pClientList[sAttackerH]->m_sAppr2 & 0x0FF0) >> 4);
						else sAttackerWeapon = 1;
						// 40 domages => FLY
						if ((cAttackerType == DEF_OWNERTYPE_PLAYER) && (m_pMapList[m_pClientList[sAttackerH]->m_cMapIndex]->m_bIsFightZone == TRUE)) 
							iMoveDamage = 60;
						else iMoveDamage = 40;
						if (iAP_SM >= iMoveDamage) // Fly PCs
						{	if (sTgtX == sAtkX) 
							{	if (sTgtY == sAtkY)     goto CAE_SKIPDAMAGEMOVE;
									else if (sTgtY > sAtkY) cDamageMoveDir = 5;
									else if (sTgtY < sAtkY) cDamageMoveDir = 1;
							}else if (sTgtX > sAtkX) 
							{	if (sTgtY == sAtkY)			cDamageMoveDir = 3;
								else if (sTgtY > sAtkY)		cDamageMoveDir = 4;
								else if (sTgtY < sAtkY)		cDamageMoveDir = 2;
							}else if (sTgtX < sAtkX)
							{	if (sTgtY == sAtkY)			cDamageMoveDir = 7;
								else if (sTgtY > sAtkY)		cDamageMoveDir = 6;
								else if (sTgtY < sAtkY)		cDamageMoveDir = 8;							
							}
							m_pClientList[sTargetH]->m_iLastDamage = iAP_SM;
							m_pClientList[sTargetH]->m_dwLastDamageMoveTime = dwTime;
							m_pClientList[sTargetH]->m_dwDamageMoveCounter ++;
							SendNotifyMsg(NULL, sTargetH, DEF_NOTIFY_DAMAGEMOVE, cDamageMoveDir, iAP_SM, sAttackerWeapon, NULL);
						}else 
						{
CAE_SKIPDAMAGEMOVE:;
							int iProb;
							if (cAttackerType == DEF_OWNERTYPE_PLAYER) 
							{	switch (m_pClientList[sAttackerH]->m_sUsingWeaponSkill) {
									case 6 : iProb = 3500; break; // archery
									case 8 : iProb = 1000; break; // LongSword
									case 9 : iProb = 2900; break; // Fencing
									case 10: iProb = 2500; break; // Axe
									case 14: iProb = 2000; break; // Hammer
									case 21: iProb = 2000; break; // Staff
									default: iProb = 1; break;
								}
							}else iProb = 1;							
							if (iDice(1,10000) >= iProb) // What's the utility here? Do not show damage everytimes?
								SendEventToNearClient_TypeA(sTargetH, DEF_OWNERTYPE_PLAYER, MSGID_EVENT_MOTION, DEF_OBJECTDAMAGE, iAP_SM, sAttackerWeapon, NULL);		
						}
						if (m_pClientList[sTargetH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_HOLDOBJECT ] == 20) // Medusa kiss
						{	SendNotifyMsg(NULL, sTargetH, DEF_NOTIFY_MAGICEFFECTOFF, DEF_MAGICTYPE_HOLDOBJECT, 20, NULL, NULL);
							m_pClientList[sTargetH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_HOLDOBJECT ] = NULL;
							bRemoveFromDelayEventList(sTargetH, DEF_OWNERTYPE_PLAYER, DEF_MAGICTYPE_HOLDOBJECT);
						}else if (m_pClientList[sTargetH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_HOLDOBJECT ] == 1) // hold person
						{	SendNotifyMsg(NULL, sTargetH, DEF_NOTIFY_MAGICEFFECTOFF, DEF_MAGICTYPE_HOLDOBJECT, 1, NULL, NULL);
							m_pClientList[sTargetH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_HOLDOBJECT ] = NULL;
							bRemoveFromDelayEventList(sTargetH, DEF_OWNERTYPE_PLAYER, DEF_MAGICTYPE_HOLDOBJECT);
						}else if ( (m_pClientList[sTargetH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_HOLDOBJECT ] != 0) // Para Entangle
								&& (m_pClientList[sTargetH]->m_iHP <= (iAP_SM*4) )
								&& (iDice(1, (m_pClientList[sTargetH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_HOLDOBJECT ]*4)) == 1))
						{	SendNotifyMsg(NULL, sTargetH, DEF_NOTIFY_MAGICEFFECTOFF, DEF_MAGICTYPE_HOLDOBJECT, 2, NULL, NULL);
							m_pClientList[sTargetH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_HOLDOBJECT ] = NULL;
							bRemoveFromDelayEventList(sTargetH, DEF_OWNERTYPE_PLAYER, DEF_MAGICTYPE_HOLDOBJECT);
						}
						// every 15 times you're hurt, increase Crits available by one....	// Not if you fly!
						m_pClientList[sTargetH]->m_iSuperAttackCount++;
						if (m_pClientList[sTargetH]->m_iSuperAttackCount > 14)  
						{	m_pClientList[sTargetH]->m_iSuperAttackCount = 0;
							iMaxSuperAttack = (m_pClientList[sTargetH]->m_iLevel / 10);
							if (m_pClientList[sTargetH]->m_iSuperAttackLeft < iMaxSuperAttack) m_pClientList[sTargetH]->m_iSuperAttackLeft++;
								SendNotifyMsg(NULL, sTargetH, DEF_NOTIFY_SUPERATTACKLEFT, NULL, NULL, NULL, NULL);
			}	}	}	}
			break;				   

		case DEF_OWNERTYPE_NPC: // Target is npc
			if (m_pNpcList[sTargetH]->m_cBehavior == DEF_BEHAVIOR_DEAD) return 0;
			if (m_pNpcList[sTargetH]->m_bIsKilled == TRUE) return 0;
			switch (m_pNpcList[sTargetH]->m_cActionLimit) { // Invulnerable npcs...
			case 2: // merchants
			//case 4: // Energy shere not here due to computing attraction later on...
			case 6: // moving merchants
				return 0;
				break;
			}
			if (m_bIsCrusadeMode == TRUE) 
			{	if (cAttackerSide == m_pNpcList[sTargetH]->m_cSide) 
				{	switch (m_pNpcList[sTargetH]->m_sType) {
					case 40: // ESG
					case 41: // GMG
					case 43: // LWB
					case 44: // GHK
					case 45: // GHK ABS
					case 46: // TK
					case 47: // BG
					case 51: // CP
						return 0;
					default: break;
					}
				}else 
				{	switch (m_pNpcList[sTargetH]->m_sType) {
					case 41: // GMG
						if (cAttackerSide != 0) {
							m_pNpcList[sTargetH]->m_iV1 += iAP_L;
							if (m_pNpcList[sTargetH]->m_iV1 > 500) {
								m_pNpcList[sTargetH]->m_iV1 = 0;
								m_pNpcList[sTargetH]->m_iManaStock--;
								if (m_pNpcList[sTargetH]->m_iManaStock <= 0) m_pNpcList[sTargetH]->m_iManaStock = 0;
								wsprintf(G_cTxt, "ManaStock down: %d (GMG attacked)", m_pNpcList[sTargetH]->m_iManaStock);
								PutLogList(G_cTxt);
						}	}
						break;
			}	}	}
			// Snoopy: Added possibility to poison npcs
			if ( (cAttackerSA == 5) || (cAttackerSA == 6) || (cAttackerSA == 61) ) 
			{	if (bCheckResistingPoisonSuccess(sTargetH, DEF_OWNERTYPE_NPC) == FALSE) 
				{	switch (cAttackerSA){
					case 5:if (m_pNpcList[sTargetH]->m_iPoisonLevel < 15) m_pNpcList[sTargetH]->m_iPoisonLevel = 15; 
						break;
					case 6:if (m_pNpcList[sTargetH]->m_iPoisonLevel < 40) m_pNpcList[sTargetH]->m_iPoisonLevel = 40; 
						break;
					case 61:if (m_pNpcList[sTargetH]->m_iPoisonLevel < iAttackerSAvalue) m_pNpcList[sTargetH]->m_iPoisonLevel = iAttackerSAvalue; 
						break;
					}					
					SetPoisonFlag(sTargetH, DEF_OWNERTYPE_NPC, TRUE);			
			}	}

			// Snoopy: Added possibilty of activated weapons effect on npcs
			if (   (cAttackerType == DEF_OWNERTYPE_PLAYER) 
				&& (m_pClientList[sAttackerH] != NULL) 
				&& (m_pClientList[sAttackerH]->m_bIsSpecialAbilityEnabled == TRUE)) 
			{	switch (m_pClientList[sAttackerH]->m_iSpecialAbilityType) {
				case 0: break;
				case 1: // Xelima weapon, deals double damage 1 in 3 times
					if (iDice(1,3)==2) 
					{	iAP_SM *= 2;
						iAP_L *= 2;
					}
					break;
				case 2: // Ice weapon, will ice npcs						
					if (   (bCheckResistingIceSuccess(0, sTargetH, DEF_OWNERTYPE_NPC, 50) == FALSE) 
							&& (m_pNpcList[sTargetH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_ICE ] == 0)) 
					{	m_pNpcList[sTargetH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_ICE ] = 2;
						SetIceFlag(sTargetH, DEF_OWNERTYPE_NPC, TRUE);
						bRegisterDelayEvent(DEF_DELAYEVENTTYPE_MAGICRELEASE, DEF_MAGICTYPE_ICE, dwTime + 20000, 
							sTargetH, DEF_OWNERTYPE_NPC, NULL, NULL, NULL, 1, NULL, NULL);
					}
					break;
				case 3: // Medusa sword - hold for 10 sec
					if (m_pNpcList[sTargetH]->m_cMagicLevel >= 6)
					{	// Not on magic npcs,
					}else  // para for 10 sec
					{	if (m_pNpcList[sTargetH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_HOLDOBJECT ] == 0) 
						{	m_pNpcList[sTargetH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_HOLDOBJECT ] = 3;
							bRegisterDelayEvent(DEF_DELAYEVENTTYPE_MAGICRELEASE, DEF_MAGICTYPE_HOLDOBJECT, dwTime + 10000, 
								sTargetH, DEF_OWNERTYPE_NPC, NULL, NULL, NULL, 3, NULL, NULL);
							// May be canceled due to damage later...					
					}	}
					break;
				case 4: // Instant kill weapon, deals Double damage
					iAP_SM *= 2;
					iAP_L *= 2;
					break;
				case 5: // Vampiric weapon 1/8 of given HP
					if (m_pNpcList[sTargetH]->m_cSize == 0)	
						 m_pClientList[sAttackerH]->m_iHP += iAP_SM/8;					
					else m_pClientList[sAttackerH]->m_iHP += iAP_L/8;
					if (iGetMaxHP(sAttackerH, TRUE) < m_pClientList[sAttackerH]->m_iHP) // BloodEffect limite le regen
						m_pClientList[sAttackerH]->m_iHP = iGetMaxHP(sAttackerH, TRUE);
					SendNotifyMsg(NULL, sAttackerH, DEF_NOTIFY_HP, NULL, NULL, NULL, NULL);
					break;
			}	}

			if (m_pNpcList[sTargetH]->m_cSize == 0)	
				iDamage = iAP_SM;					
			else iDamage = iAP_L;
			// PA monsters
			if (m_pNpcList[sTargetH]->m_iAbsDamage < 0) // negative value: PA mobs
			//if (m_pNpcList[sTargetH]->m_cSpecialAbility == 3) // "Absorbing Physical Damage" Mobs
			{	dTmp1 = (double)iDamage;
				dTmp2 = (double)(abs(m_pNpcList[sTargetH]->m_iAbsDamage))/100.0f;
				dTmp3 = dTmp1 * dTmp2;										
				if (   (cAttackerType == DEF_OWNERTYPE_PLAYER) && (m_pClientList[sAttackerH] != NULL) 
					&& (m_pNpcList[sTargetH]->m_cSpecialAbility == 3)
					&& (m_pClientList[sAttackerH]->m_sUsingWeaponSkill == 14)) 	// PA counts for 1/2 vs Hammers but not against natural PA
				{	dTmp2 = dTmp1 - (dTmp3/2);	
				}else dTmp2 = dTmp1 - dTmp3;	
				iDamage = (int)dTmp2;
				if (iDamage < 0) iDamage = 1;
			}

			// Drestruction of Magic Portection npcs attacking npc
			if ((cAttackerSA == 2) && (m_pNpcList[sTargetH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_PROTECT ] != 0)) 
			{	switch(m_pNpcList[sTargetH]->m_cMagicEffectStatus[DEF_MAGICTYPE_PROTECT]) {
				case 1:
					SetProtectionFromArrowFlag(sTargetH, DEF_OWNERTYPE_NPC, FALSE);
					break;
				case 2:
				case 5:
					SetMagicProtectionFlag(sTargetH, DEF_OWNERTYPE_NPC, FALSE);
					break;
				case 3:
				case 4:
					SetDefenseShieldFlag(sTargetH, DEF_OWNERTYPE_NPC, FALSE);
					break;
				}
				m_pNpcList[sTargetH]->m_cMagicEffectStatus[DEF_MAGICTYPE_PROTECT] = NULL;
				m_pNpcList[sTargetH]->m_cMagicEffectStatus[DEF_MAGICTYPE_DEFENCESHIELD_VALUE] = 0;
				bRemoveFromDelayEventList(sTargetH, DEF_OWNERTYPE_NPC, DEF_MAGICTYPE_PROTECT);	
				// Remove Reflexion spells are not available for mobs..
			}
			
			// Finally apply damage to npc if not Energy Shere
			if (m_pNpcList[sTargetH]->m_cActionLimit != 4) m_pNpcList[sTargetH]->m_iHP -= iDamage;
			if (m_pNpcList[sTargetH]->m_iHP <= 0) 
			{	NpcKilledHandler(sAttackerH, cAttackerType, sTargetH, iDamage);
				bKilled = TRUE;
				iKilledDice = m_pNpcList[sTargetH]->m_iHitDice;
			}else  // Guards, Cats, Rabbits, & Friendlly npcs 
			{	if ((m_pNpcList[sTargetH]->m_sType != 21)&& (m_pNpcList[sTargetH]->m_sType != 55) && (m_pNpcList[sTargetH]->m_sType != 56)
					&& (m_pNpcList[sTargetH]->m_cSide == cAttackerSide)) goto CAE_SKIPCOUNTERATTACK;

				if (m_pNpcList[sTargetH]->m_cActionLimit > 1) goto CAE_SKIPCOUNTERATTACK;
				if (m_pNpcList[sTargetH]->m_bIsPermAttackMode == TRUE) goto CAE_SKIPCOUNTERATTACK;
				if ((m_pNpcList[sTargetH]->m_bIsSummoned == TRUE) && (m_pNpcList[sTargetH]->m_iSummonControlMode == 1)) goto CAE_SKIPCOUNTERATTACK;				
				// Tammed mobs
				if ((m_pNpcList[sTargetH]->m_dwTamingTime != 0)   && (m_pNpcList[sTargetH]->m_iSummonControlMode == 1)) goto CAE_SKIPCOUNTERATTACK;
				
				if (m_pNpcList[sTargetH]->m_sType == 51) goto CAE_SKIPCOUNTERATTACK; // Catapult will not counter attack
				if (iDice(1,3) == 2) 
				{	if (m_pNpcList[sTargetH]->m_cBehavior == DEF_BEHAVIOR_ATTACK) 
					{	tX = tY = 0;
						switch (m_pNpcList[sTargetH]->m_cTargetType) {
						case DEF_OWNERTYPE_PLAYER:
							if (m_pClientList[m_pNpcList[sTargetH]->m_iTargetIndex] != NULL) 
							{	tX = m_pClientList[m_pNpcList[sTargetH]->m_iTargetIndex]->m_sX;
								tY = m_pClientList[m_pNpcList[sTargetH]->m_iTargetIndex]->m_sY;
							}
							break;
						case DEF_OWNERTYPE_NPC:
							if (m_pNpcList[m_pNpcList[sTargetH]->m_iTargetIndex] != NULL) 
							{	tX = m_pNpcList[m_pNpcList[sTargetH]->m_iTargetIndex]->m_sX;
								tY = m_pNpcList[m_pNpcList[sTargetH]->m_iTargetIndex]->m_sY;
							}
							break;
						} // iDst1: cible actuelle du mob frappé
						iDst1 = (m_pNpcList[sTargetH]->m_sX - tX)*(m_pNpcList[sTargetH]->m_sX - tX) + (m_pNpcList[sTargetH]->m_sY - tY)*(m_pNpcList[sTargetH]->m_sY - tY);
						tX = tY = 0;
						switch (cAttackerType) {
						case DEF_OWNERTYPE_PLAYER:
							if (m_pClientList[sAttackerH] != NULL) 
							{	tX = m_pClientList[sAttackerH]->m_sX;
								tY = m_pClientList[sAttackerH]->m_sY;
							}
							break;
						case DEF_OWNERTYPE_NPC:
							if (m_pNpcList[sAttackerH] != NULL) 
							{	tX = m_pNpcList[sAttackerH]->m_sX;
								tY = m_pNpcList[sAttackerH]->m_sY;
							}
							break;
						} // iDst2: attaquant actuel du mob frappé
						iDst2 = (m_pNpcList[sTargetH]->m_sX - tX)*(m_pNpcList[sTargetH]->m_sX - tX) + (m_pNpcList[sTargetH]->m_sY - tY)*(m_pNpcList[sTargetH]->m_sY - tY);
						switch (m_pNpcList[sTargetH]->m_iAttackStrategy) {
						case DEF_ATTACKAI_ANGLEATTACK:// Change target if it's 45°
							if (iDst2 == 2)
							{	m_pNpcList[sTargetH]->m_cBehavior			= DEF_BEHAVIOR_ATTACK;
								m_pNpcList[sTargetH]->m_sBehaviorTurnCount	= 0;		
								m_pNpcList[sTargetH]->m_iTargetIndex		= sAttackerH;
								m_pNpcList[sTargetH]->m_cTargetType			= cAttackerType;						
							}
							break;
						case DEF_ATTACKAI_CLOSEATTACK1: // Change target if it's near mob (45° or 90°)
						case DEF_ATTACKAI_CLOSEATTACK2: // Change target if it's near mob (45° or 90°)
							if (iDst2 <= 2) 
							{	m_pNpcList[sTargetH]->m_cBehavior			= DEF_BEHAVIOR_ATTACK;
								m_pNpcList[sTargetH]->m_sBehaviorTurnCount	= 0;		
								m_pNpcList[sTargetH]->m_iTargetIndex		= sAttackerH;
								m_pNpcList[sTargetH]->m_cTargetType			= cAttackerType;						
							}
							break;
						case DEF_ATTACKAI_FARATTACK: // Change for a far target
							if (   (iDst2 >= 2) 
								&& ((m_pNpcList[sTargetH]->m_sX - tX)  <= m_pNpcList[sTargetH]->m_iAttackRange)
								&& ((m_pNpcList[sTargetH]->m_sY - tY)  <= m_pNpcList[sTargetH]->m_iAttackRange))
							{	m_pNpcList[sTargetH]->m_cBehavior			= DEF_BEHAVIOR_ATTACK;
								m_pNpcList[sTargetH]->m_sBehaviorTurnCount	= 0;		
								m_pNpcList[sTargetH]->m_iTargetIndex		= sAttackerH;
								m_pNpcList[sTargetH]->m_cTargetType			= cAttackerType;						
							}
							break;
						case DEF_ATTACKAI_MAGEKILLER: // Will not change target
							break;
						default: // Prefers a target at 90°
							if (iDst2 <= iDst1)													// Prefers strike at 90°
							{	m_pNpcList[sTargetH]->m_cBehavior			= DEF_BEHAVIOR_ATTACK;
								m_pNpcList[sTargetH]->m_sBehaviorTurnCount	= 0;		
								m_pNpcList[sTargetH]->m_iTargetIndex		= sAttackerH;
								m_pNpcList[sTargetH]->m_cTargetType			= cAttackerType;
							}
							break;
				}	}	}

CAE_SKIPCOUNTERATTACK:;
				if ((iDice(1,3) == 2) && (m_pNpcList[sTargetH]->m_cActionLimit < 2))
					m_pNpcList[sTargetH]->m_dwTime = dwTime;
				if (cAttackerType == DEF_OWNERTYPE_PLAYER) 
					sAttackerWeapon = ((m_pClientList[sAttackerH]->m_sAppr2 & 0x0FF0) >> 4);
				else sAttackerWeapon = 1;
				switch (m_pNpcList[sTargetH]->m_cActionLimit){
				case 4: // Energy sphere here...
					iDamage = 0;
					if (wWeaponType < 40)
 					{	if (sTgtX == sAtkX) 
						{	if (sTgtY == sAtkY)     goto CAE_SKIPDAMAGEMOVE2;
							else 
								if (sTgtY > sAtkY) cDamageMoveDir = 5;
								else if (sTgtY < sAtkY) cDamageMoveDir = 1;
						}else 
						{	if (sTgtX > sAtkX) 					
							{	if (sTgtY == sAtkY)     cDamageMoveDir = 3;
								else 
									if (sTgtY > sAtkY) cDamageMoveDir = 4;
									else if (sTgtY < sAtkY) cDamageMoveDir = 2;
							}else 
							{	if (sTgtX < sAtkX) 
								{	if (sTgtY == sAtkY)     cDamageMoveDir = 7;
									else 
										if (sTgtY > sAtkY) cDamageMoveDir = 6;
										else if (sTgtY < sAtkY) cDamageMoveDir = 8;	
						}	}	}
						dX = m_pNpcList[sTargetH]->m_sX + _tmp_cTmpDirX[cDamageMoveDir];
						dY = m_pNpcList[sTargetH]->m_sY + _tmp_cTmpDirY[cDamageMoveDir];
						if (m_pMapList[m_pNpcList[sTargetH]->m_cMapIndex]->bGetMoveable(dX, dY, NULL) == FALSE) 
						{	cDamageMoveDir = iDice(1,8);
							dX = m_pNpcList[sTargetH]->m_sX + _tmp_cTmpDirX[cDamageMoveDir];
							dY = m_pNpcList[sTargetH]->m_sY + _tmp_cTmpDirY[cDamageMoveDir];
							if (m_pMapList[m_pNpcList[sTargetH]->m_cMapIndex]->bGetMoveable(dX, dY, NULL) == FALSE) goto CAE_SKIPDAMAGEMOVE2;
						}
						m_pMapList[m_pNpcList[sTargetH]->m_cMapIndex]->ClearOwner(5, sTargetH, DEF_OWNERTYPE_NPC, m_pNpcList[sTargetH]->m_sX, m_pNpcList[sTargetH]->m_sY);
						m_pMapList[m_pNpcList[sTargetH]->m_cMapIndex]->SetOwner(sTargetH, DEF_OWNERTYPE_NPC, dX, dY);
						m_pNpcList[sTargetH]->m_sX   = dX;
						m_pNpcList[sTargetH]->m_sY   = dY;
						m_pNpcList[sTargetH]->m_cDir = cDamageMoveDir;
						SendEventToNearClient_TypeA(sTargetH, DEF_OWNERTYPE_NPC, MSGID_EVENT_MOTION, DEF_OBJECTMOVE, NULL, NULL, NULL);
						dX = m_pNpcList[sTargetH]->m_sX + _tmp_cTmpDirX[cDamageMoveDir];
						dY = m_pNpcList[sTargetH]->m_sY + _tmp_cTmpDirY[cDamageMoveDir];
						if (m_pMapList[m_pNpcList[sTargetH]->m_cMapIndex]->bGetMoveable(dX, dY, NULL) == FALSE) 
						{	cDamageMoveDir = iDice(1,8);
							dX = m_pNpcList[sTargetH]->m_sX + _tmp_cTmpDirX[cDamageMoveDir];
							dY = m_pNpcList[sTargetH]->m_sY + _tmp_cTmpDirY[cDamageMoveDir];
							if (m_pMapList[m_pNpcList[sTargetH]->m_cMapIndex]->bGetMoveable(dX, dY, NULL) == FALSE) goto CAE_SKIPDAMAGEMOVE2;
						}
						m_pMapList[m_pNpcList[sTargetH]->m_cMapIndex]->ClearOwner(5, sTargetH, DEF_OWNERTYPE_NPC, m_pNpcList[sTargetH]->m_sX, m_pNpcList[sTargetH]->m_sY);
						m_pMapList[m_pNpcList[sTargetH]->m_cMapIndex]->SetOwner(sTargetH, DEF_OWNERTYPE_NPC, dX, dY);
						m_pNpcList[sTargetH]->m_sX   = dX;
						m_pNpcList[sTargetH]->m_sY   = dY;
						m_pNpcList[sTargetH]->m_cDir = cDamageMoveDir;
						SendEventToNearClient_TypeA(sTargetH, DEF_OWNERTYPE_NPC, MSGID_EVENT_MOTION, DEF_OBJECTMOVE, NULL, NULL, NULL);
						if (iAttackMode >= 20) // Longer shoot if crit attack
						{	dX = m_pNpcList[sTargetH]->m_sX + _tmp_cTmpDirX[cDamageMoveDir];
							dY = m_pNpcList[sTargetH]->m_sY + _tmp_cTmpDirY[cDamageMoveDir];
							if (m_pMapList[m_pNpcList[sTargetH]->m_cMapIndex]->bGetMoveable(dX, dY, NULL) == FALSE) 
							{	cDamageMoveDir = iDice(1,8);
								dX = m_pNpcList[sTargetH]->m_sX + _tmp_cTmpDirX[cDamageMoveDir];
								dY = m_pNpcList[sTargetH]->m_sY + _tmp_cTmpDirY[cDamageMoveDir];
								if (m_pMapList[m_pNpcList[sTargetH]->m_cMapIndex]->bGetMoveable(dX, dY, NULL) == FALSE) goto CAE_SKIPDAMAGEMOVE2;
							}
							m_pMapList[m_pNpcList[sTargetH]->m_cMapIndex]->ClearOwner(5, sTargetH, DEF_OWNERTYPE_NPC, m_pNpcList[sTargetH]->m_sX, m_pNpcList[sTargetH]->m_sY);
							m_pMapList[m_pNpcList[sTargetH]->m_cMapIndex]->SetOwner(sTargetH, DEF_OWNERTYPE_NPC, dX, dY);
							m_pNpcList[sTargetH]->m_sX   = dX;
							m_pNpcList[sTargetH]->m_sY   = dY;
							m_pNpcList[sTargetH]->m_cDir = cDamageMoveDir;
							SendEventToNearClient_TypeA(sTargetH, DEF_OWNERTYPE_NPC, MSGID_EVENT_MOTION, DEF_OBJECTMOVE, NULL, NULL, NULL);
						}
						if (bCheckEnergySphereDestination(sTargetH, sAttackerH, cAttackerType) == TRUE) 
						{	if (cAttackerType == DEF_OWNERTYPE_PLAYER) 
							{	iExp = (m_pNpcList[sTargetH]->m_iExp/3);
								// SNOOPY: Now Adding weapon bonus XP (20%) added after party bonus
								if ((m_pClientList[sAttackerH]->m_iAddExp != NULL) && ( m_iXPBonusType < 2))  
								{	dTmp1 = (double)m_pClientList[sAttackerH]->m_iAddExp;
									dTmp2 = (double)iExp;
									dTmp3 = (dTmp1/100.0f)*dTmp2;
									iExp += (int)dTmp3;
								}
								GetExp(sAttackerH, iExp);
							}
							NpcKilledHandler(sTargetH, DEF_OWNERTYPE_NPC, sTargetH, 0);					
					} 	}
					return 0;
					break;
// LS,    not crit will fly at 140, crit fly at 110
// Axe,   not crit will fly at 130, crit fly at 100
// Hammer not crit will fly at 100, crit fly at 80
// Other, not crit will fly at 150, crit fly at 170
// Monk,  not crit will fly at 80,  crit fly at 60 or always
// Needs 10 more damage if zerked
// Add 20 damage needed for big creatures
				case 0: // Snoopy: Normal npcs can fly..20% time.
				case 1: // Snoopy: Never runner npcs can fly..20% time.
					if ( (m_pNpcList[sTargetH]->m_iHP > iDamage) 
						&& ((iFlyingNpcAttack + iDamage) >= 20*(6+ m_pNpcList[sTargetH]->m_cSize)) 
						&& (iDice(1,m_pNpcList[sTargetH]->m_iHitDice) <= (iFlyingNpcAttack+50))
						&& (m_pNpcList[sTargetH]->m_iHitDice <= iFlyerMaxPossibleHD) )
						//PutLogList(" Fly npc");
 					{	if (sTgtX == sAtkX) 
						{	if (sTgtY == sAtkY)     goto CAE_SKIPDAMAGEMOVE2;
							else 
								if (sTgtY > sAtkY) cDamageMoveDir = 5;
								else if (sTgtY < sAtkY) cDamageMoveDir = 1;
						}else 
						{	if (sTgtX > sAtkX) 					
							{	if (sTgtY == sAtkY)     cDamageMoveDir = 3;
								else 
									if (sTgtY > sAtkY) cDamageMoveDir = 4;
									else if (sTgtY < sAtkY) cDamageMoveDir = 2;
							}else 
							{	if (sTgtX < sAtkX) 
								{	if (sTgtY == sAtkY)     cDamageMoveDir = 7;
									else 
										if (sTgtY > sAtkY) cDamageMoveDir = 6;
										else if (sTgtY < sAtkY) cDamageMoveDir = 8;	
						}	}	}
						dX = m_pNpcList[sTargetH]->m_sX + _tmp_cTmpDirX[cDamageMoveDir];
						dY = m_pNpcList[sTargetH]->m_sY + _tmp_cTmpDirY[cDamageMoveDir];
						if (m_pMapList[m_pNpcList[sTargetH]->m_cMapIndex]->bGetMoveable(dX, dY, NULL) == FALSE) 
						{	cDamageMoveDir = iDice(1,8);
							dX = m_pNpcList[sTargetH]->m_sX + _tmp_cTmpDirX[cDamageMoveDir];
							dY = m_pNpcList[sTargetH]->m_sY + _tmp_cTmpDirY[cDamageMoveDir];
							if (m_pMapList[m_pNpcList[sTargetH]->m_cMapIndex]->bGetMoveable(dX, dY, NULL) == FALSE) goto CAE_SKIPDAMAGEMOVE2;
						}
						m_pMapList[m_pNpcList[sTargetH]->m_cMapIndex]->ClearOwner(5, sTargetH, DEF_OWNERTYPE_NPC, m_pNpcList[sTargetH]->m_sX, m_pNpcList[sTargetH]->m_sY);
						m_pMapList[m_pNpcList[sTargetH]->m_cMapIndex]->SetOwner(sTargetH, DEF_OWNERTYPE_NPC, dX, dY);
						m_pNpcList[sTargetH]->m_sX   = dX;
						m_pNpcList[sTargetH]->m_sY   = dY;
						//m_pNpcList[sTargetH]->m_cDir = cDamageMoveDir;
						// Remove the npc and create it again to new place
						SendEventToNearClient_TypeA(sTargetH, DEF_OWNERTYPE_NPC, MSGID_EVENT_LOG, DEF_MSGTYPE_REJECT, NULL, NULL, NULL);
						SendEventToNearClient_TypeA(sTargetH, DEF_OWNERTYPE_NPC, MSGID_EVENT_LOG, DEF_MSGTYPE_CONFIRM, NULL, NULL, NULL);
						// Paralyse stunned npc
						if (   (iDice(1,m_pNpcList[sTargetH]->m_iHitDice) <= (iFlyingNpcAttack+30))
							&& (iDice(1,100) <= iFlyingNpcAttack)
							&& (m_pNpcList[sTargetH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_HOLDOBJECT ] == 0)) 
						{	m_pNpcList[sTargetH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_HOLDOBJECT ] = 3; // 20 sec monk, 5 sec mini
							bRegisterDelayEvent(DEF_DELAYEVENTTYPE_MAGICRELEASE, DEF_MAGICTYPE_HOLDOBJECT, dwTime + (iDice(2,(iFlyingNpcAttack+70))*80), 
								sTargetH, DEF_OWNERTYPE_NPC, NULL, NULL, NULL, 3, NULL, NULL);
						}else // npc stun for a while
						{	m_pNpcList[sTargetH]->m_dwTime = dwTime + m_pNpcList[sTargetH]->m_dwActionTime + 2000; 
						}
					}
					SendEventToNearClient_TypeA(sTargetH, DEF_OWNERTYPE_NPC, MSGID_EVENT_MOTION, DEF_OBJECTDAMAGE, iDamage, sAttackerWeapon, NULL);
					break;
				default: // all other
					SendEventToNearClient_TypeA(sTargetH, DEF_OWNERTYPE_NPC, MSGID_EVENT_MOTION, DEF_OBJECTDAMAGE, iDamage, sAttackerWeapon, NULL);
					break;				
				}
CAE_SKIPDAMAGEMOVE2:;
				// No more an Energy Shere or a flying npc
				if (   (m_pNpcList[sTargetH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_HOLDOBJECT ] == 1) 
					|| ((m_pNpcList[sTargetH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_HOLDOBJECT ] > 1) 
						&& (iDice(1, (m_pNpcList[sTargetH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_HOLDOBJECT ]*4)) == 1)))
				{	m_pNpcList[sTargetH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_HOLDOBJECT ] = NULL;
					bRemoveFromDelayEventList(sTargetH, DEF_OWNERTYPE_NPC, DEF_MAGICTYPE_HOLDOBJECT);
				}
				// SNOOPY: Add XP for ennemy summons 
				if (   (m_pNpcList[sTargetH]->m_iNoDieRemainExp > 0) 
					&& (cAttackerType == DEF_OWNERTYPE_PLAYER)
					&& (m_pClientList[sAttackerH] != NULL)  
					// Only ennemy or master get XP when killing tamed mobs
					&& (   (m_pNpcList[sTargetH]->m_dwTamingTime == 0) 
						|| (m_pClientList[sAttackerH]->m_cSide != m_pNpcList[sTargetH]->m_cSide)
						|| (m_pNpcList[sTargetH]->m_iFollowOwnerIndex == sAttackerH)) 
					// Snoopy: Added normal XP for killing ennemy summons
					&& (   (m_pNpcList[sTargetH]->m_bIsSummoned != TRUE) 
						|| (m_pClientList[sAttackerH]->m_cSide != m_pNpcList[sTargetH]->m_cSide)) ) 					
				{	if (m_pNpcList[sTargetH]->m_iNoDieRemainExp > iDamage) 
					{	iExp = iDamage;
						m_pNpcList[sTargetH]->m_iNoDieRemainExp -= iDamage;
					}else 
					{	iExp = m_pNpcList[sTargetH]->m_iNoDieRemainExp;
						m_pNpcList[sTargetH]->m_iNoDieRemainExp = 0;
					}
					if (m_pClientList[sAttackerH]->m_iLevel > 100 ) 
					{	switch (m_pNpcList[sTargetH]->m_sType) {
						case 55: // cat & rabbits
						case 56: iExp = 0; break;
						default: break;
					}	}
					if (m_bIsCrusadeMode == TRUE) iExp = iExp/3;
					// SNOOPY: Now Adding weapon bonus XP (20%) added after party bonus
					if ((m_pClientList[sAttackerH]->m_iAddExp != NULL) && ( m_iXPBonusType < 2))  
					{	dTmp1 = (double)m_pClientList[sAttackerH]->m_iAddExp;
						dTmp2 = (double)iExp;
						dTmp3 = (dTmp1/100.0f)*dTmp2;
						iExp += (int)dTmp3;
			}	}	}
			break;
		}
		if (cAttackerType == DEF_OWNERTYPE_PLAYER) 
		{	if (m_pClientList[sAttackerH]->m_sItemEquipmentStatus[DEF_EQUIPPOS_TWOHAND] != -1)
				sWeaponIndex = m_pClientList[sAttackerH]->m_sItemEquipmentStatus[DEF_EQUIPPOS_TWOHAND];
			else sWeaponIndex = m_pClientList[sAttackerH]->m_sItemEquipmentStatus[DEF_EQUIPPOS_RHAND];
// SNOOPY: ADDED support for Dual-Wielding on 4th Combo Attack
			// And add MainGauche Attack on succesfull 4th combo Attacks
			sItemIndex = m_pClientList[sAttackerH]->m_sItemEquipmentStatus[DEF_EQUIPPOS_LHAND];
			if ((bMainGaucheAttack == FALSE) // No 2nd MainGauche Attack
				&& (sItemIndex != -1)
				&& (m_pClientList[sAttackerH]->m_iComboAttackCount == 4)
				&& (m_pClientList[sAttackerH]->m_pItemList[sItemIndex] != NULL)) {				
				iWeaponSkill = _iGetWeaponSkillType(sAttackerH);
				if ((m_pClientList[sAttackerH]->m_pItemList[sItemIndex]->m_sIDnum == 10) // MainGauche
					&& ((iWeaponSkill==7)||(iWeaponSkill==9)) // Only SS or Fencers					
					&& (iDice(1,120) < m_pClientList[sAttackerH]->m_cSkillMastery[20]) )// Dual-Wielding skill					 
				{	iExp += iCalculateAttackEffect(sTargetH, cTargetType, sAttackerH, DEF_OWNERTYPE_PLAYER, tdX, tdY, 2, FALSE, FALSE, FALSE, TRUE);				
			}	}			
			//SNOOPY: Increase Dual-Wielding Skill if appropriate
			if (bMainGaucheAttack == TRUE) {
				CalculateSSN_SkillIndex(sAttackerH, 20, 1);
				if (bKilled == FALSE)
					CalculateSSN_SkillIndex(sAttackerH, 20, 1);
				else {
					if (m_pClientList[sAttackerH]->m_iHP <= 3)
						CalculateSSN_SkillIndex(sAttackerH, 20, iDice(1, iKilledDice));
					else CalculateSSN_SkillIndex(sAttackerH, 20, iDice(1, ((int)(iKilledDice/2))));
				}
			}else // Else compute normal weapons skill increase
			// Compute skill increase
			if ((sWeaponIndex != -1) && (bDontDepleteArrow != TRUE)) {
				// No skill increase if bDontDepleteArrow
				if (   (m_pClientList[sAttackerH]->m_pItemList[sWeaponIndex] != NULL) 
					&& (m_pClientList[sAttackerH]->m_pItemList[sWeaponIndex]->m_sIDnum != 231) )  //  Not for PickAxe
				{	if (bKilled == FALSE)
						CalculateSSN_ItemIndex(sAttackerH, sWeaponIndex, 1);
					else 
					{	if (m_pClientList[sAttackerH]->m_iHP <= 3)
							CalculateSSN_ItemIndex(sAttackerH, sWeaponIndex, iDice(1, iKilledDice)*2);
						else CalculateSSN_ItemIndex(sAttackerH, sWeaponIndex, iDice(1, iKilledDice));
				}	}
				// Weapon's wep life off
				if (   (m_pClientList[sAttackerH]->m_pItemList[sWeaponIndex] != NULL) 
					&& (m_pClientList[sAttackerH]->m_pItemList[sWeaponIndex]->m_wMaxLifeSpan != 0) ) 
				{	iWepLifeOff = 1;
					if ((wWeaponType >= 1) && (wWeaponType < 40)) 
					{	switch (m_pMapList[m_pClientList[sAttackerH]->m_cMapIndex]->m_cWhetherStatus) {
						case 0:	break;
						case 1:	if (iDice(1,3) == 1) iWepLifeOff++; break;
						case 2:	if (iDice(1,2) == 1) iWepLifeOff += iDice(1,2); break;
						case 3:	if (iDice(1,2) == 1) iWepLifeOff += iDice(1,3); break;
						}
					}
					if (m_pClientList[sAttackerH]->m_cSide != 0) {
						if (m_pClientList[sAttackerH]->m_pItemList[sWeaponIndex]->m_wCurLifeSpan < iWepLifeOff) 
							m_pClientList[sAttackerH]->m_pItemList[sWeaponIndex]->m_wCurLifeSpan = 0;
						else m_pClientList[sAttackerH]->m_pItemList[sWeaponIndex]->m_wCurLifeSpan -= iWepLifeOff;
					}
					if (m_pClientList[sAttackerH]->m_pItemList[sWeaponIndex]->m_wCurLifeSpan == 0) {
						SendNotifyMsg(NULL, sAttackerH, DEF_NOTIFY_ITEMLIFESPANEND, m_pClientList[sAttackerH]->m_pItemList[sWeaponIndex]->m_cEquipPos, sWeaponIndex, NULL, NULL);
						ReleaseItemHandler(sAttackerH, sWeaponIndex, TRUE);
				}	}
			}else 
			{	if (wWeaponType == 0)  // Open-Hand Skill increase
				{	CalculateSSN_SkillIndex(sAttackerH, 5, 1);
		}	}	}
	}else  // Missing the target !
	{	if (cAttackerType == DEF_OWNERTYPE_PLAYER) {	//bMainGaucheAttack
			m_pClientList[sAttackerH]->m_iComboAttackCount = 0;
			//SNOOPY: Adding MainGauche Attack
			sItemIndex = m_pClientList[sAttackerH]->m_sItemEquipmentStatus[DEF_EQUIPPOS_LHAND];
			if ((bMainGaucheAttack == FALSE) // Not if alreaddy a MainGauche Attack
				&& (sItemIndex != -1)
				&& (m_pClientList[sAttackerH]->m_pItemList[sItemIndex] != NULL)) {				
				iWeaponSkill = _iGetWeaponSkillType(sAttackerH);
				if ((m_pClientList[sAttackerH]->m_pItemList[sItemIndex]->m_sIDnum == 10) // MainGauche
					&& ((iWeaponSkill==7)||(iWeaponSkill==9)) // Only SS or Fencers					
					&& (iDice(1,150) < m_pClientList[sAttackerH]->m_cSkillMastery[20]) )// Dual-Wielding skill					 
				{	iExp = iCalculateAttackEffect(sTargetH, cTargetType, sAttackerH, DEF_OWNERTYPE_PLAYER, tdX, tdY, 2, FALSE, FALSE, FALSE, TRUE);
	}	}	}	}
	return iExp;
}

// October 19, 2004 - 3.51 translated
void CGame::_GrandMagicLaunchMsgSend(int iType, char cAttackerSide)
{
 char * cp, cBuff[120];
 WORD * wp;

	ZeroMemory(cBuff, sizeof(cBuff));
	cp = (char *)cBuff;
	*cp = GSM_GRANDMAGICLAUNCH;
	cp++;

	wp = (WORD *)cp;
	*wp = (WORD)iType;
	cp += 2;

	wp = (WORD *)cp;
	*wp = (WORD)cAttackerSide;
	cp += 2;
	
	bStockMsgToGateServer(cBuff, 5);
}

// October 19, 2004 - 3.51 translated
BOOL CGame::_bNpcBehavior_ManaCollector(int iNpcH)
{
 int dX, dY, iMaxMP, iTotal;
 short sOwnerH;
 char  cOwnerType;
 double dV1, dV2, dV3;
 BOOL bRet;

	if (m_pNpcList[iNpcH] == NULL) return FALSE;
	if (m_pNpcList[iNpcH]->m_sAppr2 != 0) return FALSE;

	bRet = FALSE;
	for (dX = m_pNpcList[iNpcH]->m_sX-5; dX <= m_pNpcList[iNpcH]->m_sX+5; dX++)
	for (dY = m_pNpcList[iNpcH]->m_sY-5; dY <= m_pNpcList[iNpcH]->m_sY+5; dY++) {
		m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, dX, dY);
		if (sOwnerH != NULL) {
			switch (cOwnerType) {
			case DEF_OWNERTYPE_PLAYER:
				if (m_pNpcList[iNpcH]->m_cSide == m_pClientList[sOwnerH]->m_cSide)
				{	iMaxMP = iGetMaxMP(sOwnerH);
					if (m_pClientList[sOwnerH]->m_iMP < iMaxMP) 
					{	iTotal = iDice(1, (m_pClientList[sOwnerH]->m_iMag + m_pClientList[sOwnerH]->m_iAngelicMag));
						if (m_pClientList[sOwnerH]->m_iAddMP != 0) 
						{	dV2 = (double)iTotal;
							dV3 = (double)m_pClientList[sOwnerH]->m_iAddMP;
							dV1 = (dV3 / 100.0f)*dV2;
							iTotal += (int)dV1;
						}
						if (m_iCollectedMana[m_pNpcList[iNpcH]->m_cSide] >=1) 
							m_pClientList[sOwnerH]->m_iMP += iTotal;

						// SNOOPY: And reduce collected Mana				
						m_iCollectedMana[m_pNpcList[iNpcH]->m_cSide] -= 1;					
						if (m_pClientList[sOwnerH]->m_iMP > iMaxMP) 
							m_pClientList[sOwnerH]->m_iMP = iMaxMP;
						SendNotifyMsg(NULL, sOwnerH, DEF_NOTIFY_MP, NULL, NULL, NULL, NULL);
				}	}
				break;

			case DEF_OWNERTYPE_NPC: // Mana stone refilling collector
				if ((m_pNpcList[sOwnerH]->m_sType == 42) && (m_pNpcList[sOwnerH]->m_iV1 > 0)) {
					if (m_pNpcList[sOwnerH]->m_iV1 >= 3) {
						m_iCollectedMana[m_pNpcList[iNpcH]->m_cSide] += 3;
						m_pNpcList[sOwnerH]->m_iV1 -= 3;
						bRet = TRUE;
					}
					else {
						m_iCollectedMana[m_pNpcList[iNpcH]->m_cSide] += m_pNpcList[sOwnerH]->m_iV1; 
						m_pNpcList[sOwnerH]->m_iV1 = 0;
						bRet = TRUE;
					}
				}
				break;
			}
		}
	}
	return bRet;
}

// October 19, 2004 - 3.51 translated
void CGame::MeteorStrikeMsgHandler(char cAttackerSide)
{
 int i;
 DWORD dwTime = timeGetTime();
	
	switch (cAttackerSide) {
	case 1:
		if (m_iElvineMapIndex != -1) {
			for (i = 1; i < DEF_MAXCLIENTS; i++)
			if ((m_pClientList[i] != NULL) && (m_pClientList[i]->m_bIsInitComplete == TRUE)) {
				if (strcmp(m_pMapList[m_pClientList[i]->m_cMapIndex]->m_cLocationName, "elvine") == 0) {
					SendNotifyMsg(NULL, i, DEF_NOTIFY_METEORSTRIKECOMING, 1, NULL, NULL, NULL);
				}
				else {
					SendNotifyMsg(NULL, i, DEF_NOTIFY_METEORSTRIKECOMING, 2, NULL, NULL, NULL);
				}
			}
			bRegisterDelayEvent(DEF_DELAYEVENTTYPE_METEORSTRIKE, NULL, dwTime + 5000, NULL, NULL, m_iElvineMapIndex, NULL, NULL, NULL, NULL, NULL);
		}
		else {
			for (i = 1; i < DEF_MAXCLIENTS; i++)
			if (m_pClientList[i] != NULL) {
				SendNotifyMsg(NULL, i, DEF_NOTIFY_METEORSTRIKECOMING, 2, NULL, NULL, NULL);
			}
		}
		break;

	case 2:
		if (m_iAresdenMapIndex != -1) {
			for (i = 1; i < DEF_MAXCLIENTS; i++)
			if ((m_pClientList[i] != NULL) && (m_pClientList[i]->m_bIsInitComplete == TRUE)) {
				if (strcmp(m_pMapList[m_pClientList[i]->m_cMapIndex]->m_cLocationName, "aresden") == 0) {
					SendNotifyMsg(NULL, i, DEF_NOTIFY_METEORSTRIKECOMING, 3, NULL, NULL, NULL);
				}
				else {
					SendNotifyMsg(NULL, i, DEF_NOTIFY_METEORSTRIKECOMING, 4, NULL, NULL, NULL);
				}
			}
			bRegisterDelayEvent(DEF_DELAYEVENTTYPE_METEORSTRIKE, NULL, dwTime + 1000*5, NULL, NULL, m_iAresdenMapIndex, NULL, NULL, NULL, NULL, NULL);
		}
		else {
			for (i = 1; i < DEF_MAXCLIENTS; i++)
			if (m_pClientList[i] != NULL) {
				SendNotifyMsg(NULL, i, DEF_NOTIFY_METEORSTRIKECOMING, 4, NULL, NULL, NULL);
			}
		}
		break;
	}
}

// October 19, 2004 - 3.51 translated
void CGame::_NpcBehavior_GrandMagicGenerator(int iNpcH)
{
	switch (m_pNpcList[iNpcH]->m_cSide) {
	case 1:
		if (m_iAresdenMana > DEF_GMGMANACONSUMEUNIT) {
			m_iAresdenMana = 0 ; 
			m_pNpcList[iNpcH]->m_iManaStock++;
			if (m_pNpcList[iNpcH]->m_iManaStock > m_pNpcList[iNpcH]->m_iMaxMana) {
				_GrandMagicLaunchMsgSend(1, 1);
				MeteorStrikeMsgHandler(1);
				m_pNpcList[iNpcH]->m_iManaStock = 0;
				m_iAresdenMana = 0;
			}
			wsprintf(G_cTxt, "(!) Aresden GMG %d/%d", m_pNpcList[iNpcH]->m_iManaStock, m_pNpcList[iNpcH]->m_iMaxMana);
			//PutLogList(G_cTxt);
			PutLogEventFileList(G_cTxt);
		}
		break;

	case 2:
		if (m_iElvineMana > DEF_GMGMANACONSUMEUNIT) {
			m_iElvineMana = 0 ; 
			m_pNpcList[iNpcH]->m_iManaStock++;
			if (m_pNpcList[iNpcH]->m_iManaStock > m_pNpcList[iNpcH]->m_iMaxMana) {
				_GrandMagicLaunchMsgSend(1, 2);
				MeteorStrikeMsgHandler(2);
				m_pNpcList[iNpcH]->m_iManaStock = 0;
				m_iElvineMana = 0;
			}			
			wsprintf(G_cTxt, "(!) Elvine GMG %d/%d", m_pNpcList[iNpcH]->m_iManaStock, m_pNpcList[iNpcH]->m_iMaxMana);
			//PutLogList(G_cTxt);
			PutLogEventFileList(G_cTxt);
		}
		break;
	}
	m_iCrusadeGMG = m_pNpcList[iNpcH]->m_iManaStock;
	m_iCrusadeGMGMax = m_pNpcList[iNpcH]->m_iMaxMana;
}

// October 19, 2004 - 3.51 translated
BOOL CGame::_bNpcBehavior_Detector(int iNpcH)
{int dX, dY;
 short sOwnerH;
 char  cOwnerType, cSide;
 BOOL  bFlag = FALSE;                       
	if (m_pNpcList[iNpcH] == NULL) return FALSE;
	if (m_pNpcList[iNpcH]->m_sAppr2 != 0) return FALSE;
	for (dX = m_pNpcList[iNpcH]->m_sX-10; dX <= m_pNpcList[iNpcH]->m_sX+10; dX++)
	for (dY = m_pNpcList[iNpcH]->m_sY-10; dY <= m_pNpcList[iNpcH]->m_sY+10; dY++) {
		m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, dX, dY);
		cSide = 0;
		if (sOwnerH != NULL) {
			switch (cOwnerType) {
			case DEF_OWNERTYPE_PLAYER:
				cSide = m_pClientList[sOwnerH]->m_cSide;
				break;
			case DEF_OWNERTYPE_NPC:
				cSide = m_pNpcList[sOwnerH]->m_cSide;
				break;
		}	}
		if ((cSide != 0) && (cSide != m_pNpcList[iNpcH]->m_cSide)) 
		{	switch (cOwnerType) {
			case DEF_OWNERTYPE_PLAYER:
				if (m_pClientList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_INVISIBILITY ] != NULL) 
				{	m_pClientList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_INVISIBILITY ] = NULL;
					SetInvisibilityFlag(sOwnerH, cOwnerType, FALSE);
					bRemoveFromDelayEventList(sOwnerH, cOwnerType, DEF_MAGICTYPE_INVISIBILITY);
				}
				break;

			case DEF_OWNERTYPE_NPC:
				if (m_pNpcList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_INVISIBILITY ] != NULL) 
				{	m_pNpcList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_INVISIBILITY ] = NULL;
					SetInvisibilityFlag(sOwnerH, cOwnerType, FALSE);
					bRemoveFromDelayEventList(sOwnerH, cOwnerType, DEF_MAGICTYPE_INVISIBILITY);						
				}
				break;
			}			
			bFlag = TRUE;	
	}	}
	return bFlag;
}

// October 19,2004 - 3.51 translated
void CGame::NpcBehavior_Dead(int iNpcH)			   
{	DWORD dwTime;
	if (m_pNpcList[iNpcH] == NULL) return; 
	dwTime = timeGetTime();
	m_pNpcList[iNpcH]->m_sBehaviorTurnCount++;
	if (m_pNpcList[iNpcH]->m_sBehaviorTurnCount > 5) 
	{	m_pNpcList[iNpcH]->m_sBehaviorTurnCount = 0;	
	}
	if ((dwTime - m_pNpcList[iNpcH]->m_dwDeadTime) > m_pNpcList[iNpcH]->m_dwRegenTime)
		DeleteNpc(iNpcH);
	else if (dwTime < m_pNpcList[iNpcH]->m_dwDeadTime) // Add by snoopy against lasting dead npcs
		DeleteNpc(iNpcH);
}

BOOL CGame::bGetItemNameWhenDeleteNpc(int & iItemID, short sNpcType)
{	int iResult; 
	switch (sNpcType) { 
		case 49: // Hellclaw 
			iResult = iDice(1,20000);
// Snoopy81 ->
/*			if ((iResult >= 1) && (iResult <=  5000)) iItemID = 308 ;		    // MagicNecklace(MS10)
			else if ((iResult > 5000) && (iResult <=  10000)) iItemID = 259 ;	// MagicWand(M.Shield)
			else if ((iResult > 10000) && (iResult <= 13000))  iItemID = 337 ;  // RubyRing
			else if ((iResult > 13000) && (iResult <= 15000))  iItemID = 335 ;  // EmeraldRing
			else if ((iResult > 15000) && (iResult <= 17500))  iItemID = 300 ;  // MagicNecklace(RM10)
			else if ((iResult > 17500) && (iResult <= 18750))  iItemID = 311 ;  // MagicNecklace(DF+10)
			else if ((iResult > 18750) && (iResult <= 19000))  iItemID = 305 ;  // MagicNecklace(DM+1)
			else if ((iResult > 19000) && (iResult <= 19700))  iItemID = 634 ;  // RingofWizard
			else if ((iResult > 19700) && (iResult <= 19844))  iItemID = 635 ;  // RingofMage
			else if ((iResult > 19844) && (iResult <= 19922))  iItemID = 643 ;  // KnecklaceOfIceEle	
			else if ((iResult > 19922) && (iResult <= 19961))  iItemID = 640 ;  // KnecklaceOfSufferent
			else if ((iResult > 19961) && (iResult <= 19981))  iItemID = 637 ;  // KnecklaceOfLightPro
			else if ((iResult > 19981) && (iResult <= 19991))  iItemID = 620 ;  // MerienShield	
			else if ((iResult > 19991) && (iResult <= 19996))  iItemID = 644 ;  // KnecklaceOfAirEle	
			else if ((iResult > 19996) && (iResult <= 19999))  iItemID = 614 ;  // SwordofIceElemental	
			else if ((iResult > 19999) && (iResult <= 20000))  iItemID = 636 ;	// RingofGrandMage
*/
// Table improved by Snoopy81
			if ((iResult >= 1) && (iResult <=  4000)) iItemID = 308 ;		    // MagicNecklace(MS10)
			else if ((iResult > 4000) && (iResult <=  7000))   iItemID = 259 ;	// MagicWand(M.Shield)
			else if ((iResult > 7000) && (iResult <= 10000))   iItemID = 337 ;  // RubyRing
			else if ((iResult > 10000) && (iResult <= 12000))  iItemID = 335 ;  // EmeraldRing
			else if ((iResult > 12000) && (iResult <= 14000))  iItemID = 300 ;  // MagicNecklace(RM10)
			else if ((iResult > 14000) && (iResult <= 15000))  iItemID = 311 ;  // MagicNecklace(DF+10)
			else if ((iResult > 15000) && (iResult <= 16000))  iItemID = 305 ;  // MagicNecklace(DM+1)
			else if ((iResult > 16000) && (iResult <= 17000))  iItemID = 634 ;  // RingofWizard
			else if ((iResult > 17000) && (iResult <= 18000))  iItemID = 635 ;  // RingofMage
			else if ((iResult > 18000) && (iResult <= 18300))  iItemID = 643 ;  // KnecklaceOfIceEle	
			else if ((iResult > 18300) && (iResult <= 18600))  iItemID = 640 ;  // KnecklaceOfSufferent
			else if ((iResult > 18600) && (iResult <= 18900))  iItemID = 637 ;  // KnecklaceOfLightPro
			else if ((iResult > 18900) && (iResult <= 19200))  iItemID = 620 ;  // MerienShield	
			else if ((iResult > 19200) && (iResult <= 19500))  iItemID = 644 ;  // KnecklaceOfAirEle	
			else if ((iResult > 19500) && (iResult <= 19800))  iItemID = 614 ;  // SwordofIceElemental	
			else if ((iResult > 19800) && (iResult <= 20000))  iItemID = 636 ;	// RingofGrandMage
// <- Snoopy			
			wsprintf(G_cTxt,"NpcType (%d), 2nd drop: item ID (%d)",sNpcType, iItemID);
			PutLogList(G_cTxt); // 
			return TRUE; 
			break;	

		case 52: // Gagoyle 1/28 more or less!
			switch (iDice(1,300)) {
				case 1: iItemID = 382 ; break;						// BloodyShockW.Manual	
				case 2: iItemID = 381 ; break;						// MassFireStrikeManual
				case 3: iItemID = 633 ; break;						// RingofDemonpower
				case 4: if (iDice(1,3) == 3) iItemID = 645 ; break; // KnecklaceOfEfreet
				case 5: if (iDice(1,8) == 3) iItemID = 630 ; break; // RingoftheXelima	
				case 6: if (iDice(1,3) == 3) iItemID = 735;  break; // RingOfDragonpower
				case 7: if (iDice(1,10) == 3) iItemID = 20 ; break; // Excalibur
				case 8: 
				case 9:
				case 10: iItemID = 950; break;// Xelima Egg
				case 11:
				case 12:
				case 13: // Will give 1/100 chance of TigerWorm table 
					break;
				default: 
					return FALSE;
					break;
			} 
			if (iItemID != 0) {
				wsprintf(G_cTxt,"NpcType (%d), 2nd drop: item ID (%d)",sNpcType, iItemID);
				PutLogList(G_cTxt);
				return TRUE; 
			}// 3 chances in TW table..

		case 50: // Tigerworm
			iResult = iDice(1,10000);
// Snoopy81 ->
/*			if ((iResult >= 1) && (iResult <=  5000)) iItemID = 308 ;		    // MagicNecklace(MS10)
				if ((iResult >= 1) && (iResult <= 4999)) {
				if (iDice(1,2) == 1) 
					 iItemID = 311 ;  // MagicNecklace(DF+10)
				else iItemID = 305 ;  // MagicNecklace(DM+1)
			}
			else if ((iResult > 5000) && (iResult <= 7499))  iItemID = 614 ;  // SwordofIceElemental	
			else if ((iResult > 7500) && (iResult <= 8749))  iItemID = 290 ;  // Flameberge+3(LLF)
			else if ((iResult > 8750) && (iResult <= 9374))  iItemID = 633 ;  // RingofDemonpower
			else if ((iResult > 9375) && (iResult <= 9687))  iItemID = 492 ;  // BloodRapier		
			else if ((iResult > 9688) && (iResult <= 9843))  iItemID = 490 ;  // BloodSword		
			else if ((iResult > 9844) && (iResult <= 9921))  iItemID = 491 ;  // BloodAxe		
			else if ((iResult > 9922) && (iResult <= 9960))  iItemID = 291 ;  // MagicWand(MS30-LLF)	
			else if ((iResult > 9961) && (iResult <= 9980))  iItemID = 630 ;  // RingoftheXelima	
			else if ((iResult > 9981) && (iResult <= 9990))  iItemID = 612 ;  // XelimaRapier	
			else if ((iResult > 9991) && (iResult <= 9996))  iItemID = 610 ;  // XelimaBlade	
			else if ((iResult > 9996) && (iResult <= 9998))  iItemID = 611 ;  // XelimaAxe	
			else if ((iResult > 9999) && (iResult <= 10000)) iItemID = 631 ;  // RingoftheAbaddon
*/
// Table improved by Snoopy81 for low People servers
			if ((iResult >= 1) && (iResult <=  1500)) iItemID = 311 ;		  // MagicNecklace(DF+10)
			else if ((iResult > 1500) && (iResult <= 3000))  iItemID = 305 ;  // MagicNecklace(DM+1)
			else if ((iResult > 3000) && (iResult <= 4000))  iItemID = 614 ;  // SwordofIceElemental	
			else if ((iResult > 4000) && (iResult <= 4500))  iItemID = 290 ;  // Flameberge+3(LLF)
			else if ((iResult > 4500) && (iResult <= 5000))  iItemID = 633 ;  // RingofDemonpower
			else if ((iResult > 5000) && (iResult <= 5800))  iItemID = 492 ;  // BloodRapier		
			else if ((iResult > 5800) && (iResult <= 6300))  iItemID = 490 ;  // BloodSword		
			else if ((iResult > 6300) && (iResult <= 7000))  iItemID = 491 ;  // BloodAxe		
			else if ((iResult > 7000) && (iResult <= 8000))  iItemID = 291 ;  // MagicWand(MS30-LLF)	
			else if ((iResult > 8000) && (iResult <= 8500))  iItemID = 630 ;  // RingoftheXelima	
			else if ((iResult > 8500) && (iResult <= 9000))  iItemID = 612 ;  // XelimaRapier	
			else if ((iResult > 9000) && (iResult <= 9300))  iItemID = 610 ;  // XelimaBlade	
			else if ((iResult > 9300) && (iResult <= 9700))  iItemID = 611 ;  // XelimaAxe	
			else if ((iResult > 9700) && (iResult <= 10000)) iItemID = 631 ;  // RingoftheAbaddon
// <- Snoopy

			wsprintf(G_cTxt,"NpcType (%d), 2nd drop: item ID (%d)",sNpcType, iItemID);
			PutLogList(G_cTxt);
			return TRUE; 

		default:
		   break; 
		}

// Table for rare items 2nd drops
	if (iDice(1,45) == 13) 
	{	switch (sNpcType) {
		case 11: if (iDice(1,550) != 11) return FALSE; break;	  // Skeleton   1/49500	chance of extra rare item
		case 12: if (iDice(1,400) != 11) return FALSE; break;	  // Stone-Golem 1/36000	
		case 13: if (iDice(1,100) != 11) return FALSE; break;	  // Cyclops	1/27000	
		case 14: if (iDice(1,700) != 11) return FALSE; break;	  // Orc		1/126000	
		case 17: if (iDice(1,600) != 11) return FALSE; break;	  // Scorpion   1/135000	
		case 18: if (iDice(1,850) != 11) return FALSE; break;	  // Zombie		1/38250	
		case 22: if (iDice(1,600) != 11) return FALSE; break;	  // Amphis		1/135000	
		case 23: if (iDice(1,400) != 11) return FALSE; break;	  // Clay-Golem 1/36000	
		case 27: if (iDice(1,100) != 11) return FALSE; break;	  // Hellhound  1/31500	
		case 28: if (iDice(1,100) != 11) return FALSE; break;	  // Troll		1/22500	
		case 29: if (iDice(1,150) != 11) return FALSE; break;	  // Ogre       1/47250	
		case 30: if (iDice(1,50) != 11)  return FALSE; break;	  // Liche		1/2250   
		case 31: if (iDice(1,3) != 2)    return FALSE; break;     // Demon		1/675	
		case 32: if (iDice(1,10) != 3)   return FALSE; break;	  // Unicorn    1/2250	
		case 33: if (iDice(1,50) != 11)  return FALSE; break;	  // WereWolf   1/15000 
		case 48: if (iDice(1,200) != 11) return FALSE; break;	  // Stalker	1/9000
		case 53: if (iDice(1,50) != 11)  return FALSE; break;	  // Beholder	1/4500 (with Beholder Eye drop)
		case 54: if (iDice(1,100) != 11) return FALSE; break;	  // Dark-Elf	1/4500
		case 57: if (iDice(1,400) != 11) return FALSE; break;	  // Frog		1/18000
		case 63: if (iDice(1,300) != 11) return FALSE; break;	  // Frost		1/13500
		case 79: if (iDice(1,22) != 11)  return FALSE; break;	  // Nizie		1/1000
		case 70: if (iDice(1,22) != 11)  return FALSE; break;	  // Dragon		1/1000
		case 71: if (iDice(1,22) != 11)  return FALSE; break;	  // Centaurus  1/1000
		
		case 60: //Plant
		case 61: //Rudolph
		case 62: //DireBoar
		case 65: //IceGolem
		case 72: //ClawTurtle
		case 74: //GiantCrayFish
		case 76: //Giant-Tree
				if (iDice(1,111) != 11)  return FALSE; break;	  // Mics. not too strong  1/5000

		case 58: //Mountain-Giant
		case 59: //Ettin
		case 66: //Wyvern
		case 75: //Giant-Lizard
		case 77: //MasterMageOrc
		case 78: //Minautors
				if (iDice(1,22) != 11)  return FALSE; break;	  // Misc Stronger  1/1000

		case 82: //Sorceress
		case 83: //Ancient Kinght
		case 84: //Master Elf
		case 85: //Dark Knight
		case 87: //Barbarian
		case 88: //DarkKnight
				if (iDice(1,22) != 3) return FALSE; break;	  // Event npcs  1/1000

		case 95: // Willowisp
		case 96: // Air Elemental
		case 97: // Fire Elemental
		case 98: // Earth Elemental
		case 99: // Ice Elemental
				if (iDice(1,4) != 3) return FALSE; break;	  // Event npcs  1/180 de 2nd drop

		default: return FALSE;
		}
	}
	else goto suite; // Chances for Eggs
//http://www.helbreath.com/down/d_patch_v2.htm

	switch (sNpcType) {
	case 11: // Skeleton
	case 17: // Scorpoin
	case 14: // Orc
	case 28: // Troll
	case 57: // Frog
		switch (iDice(1,7)) {
		case 1: iItemID = 334 ; break; // LuckyGoldRing
		case 2: iItemID = 336 ; break; // SapphireRing
		case 3: if (iDice(1,15) == 3) iItemID = 335 ; break; // EmeraldRing
		case 4: iItemID = 337 ; break; // RubyRing
		case 5: iItemID = 333 ; break; // PlatinumRing
		case 6: if (iDice(1,15) == 3) iItemID = 634 ; break; // RingofWizard
		case 7: if (iDice(1,25) == 3) iItemID = 635 ; break; // RingofMage
		}
		break;
	
	case 13: // Cyclops
	case 27: // Hellhound
	case 29: // Ogre
		switch (iDice(1,7)) {
		case 1: iItemID = 311 ; break; // MagicNecklace(DF+10)
		case 2: if (iDice(1,20) == 13) iItemID = 308 ; break; // NeckMS10
		case 3: if (iDice(1,10) == 13) iItemID = 305 ; break; // MagicNecklace(DM+1)
		case 4: iItemID = 300 ; break; // MagicNecklace(RM10)
		case 5: if (iDice(1,30) == 13) iItemID = 632 ; break; // RingofOgrepower
		case 6: if (iDice(1,30) == 13) iItemID = 637 ; break; // NecklaceOfLightPro
		case 7: if (iDice(1,30) == 13) iItemID = 638 ; break; // NecklaceOfFirePro
			}
		break;

	case 18: // Zombie
	case 22: // Amphis
		switch (iDice(1,4)) {
		case 1: if (iDice(1,75) == 13) iItemID = 613 ; break; // SwordofMedusa
		case 2: if (iDice(1,5) == 13)  iItemID = 639 ; break; // KnecklaceOfPoisonPro
		case 3: if (iDice(1,40) == 13) iItemID = 641 ; break; // KnecklaceOfMedusa
		case 4: if (iDice(1,10) == 13) iItemID = 640 ; break; // KnecklaceOfSufferent
		}
		break;

	case 12: // Stone-Golem
		switch (iDice(1,5)) {
		case 1: if (iDice(1,40) == 13) iItemID = 620 ; break; // MerienShield
		case 2: if (iDice(1,40) == 13) iItemID = 621 ; break; // MerienPlateMail(M)
		case 3: if (iDice(1,40) == 13) iItemID = 622 ; break; // MerienPlateMail(W)
		case 4: if (iDice(1,20) == 11) iItemID = 644 ; break; // KnecklaceOfAirEle
		case 5: if (iDice(1,20) == 11) iItemID = 647 ; break; // KnecklaceOfStoneGolem
		}
		break;

	case 23: // Clay-Golem
		switch (iDice(1,4)) {
		case 1: if (iDice(1,40) == 13) iItemID = 620 ; break; // MerienShield	
		case 2: if (iDice(1,40) == 13) iItemID = 621 ; break; // MerienPlateMail(M)
		case 3: if (iDice(1,40) == 13) iItemID = 622 ; break; // MerienPlateMail(W)
		case 4: if (iDice(1,20) == 11) iItemID = 644 ; break; // KnecklaceOfAirEle
		}
		break;

	case 32: // Unicorn
		switch (iDice(1,4)) {
		case 1: if (iDice(1,40) == 13) iItemID = 620 ; break; // MerienShield	
		case 2: if (iDice(1,40) == 13) iItemID = 621 ; break; // MerienPlateMail(M)
		case 3: if (iDice(1,40) == 13) iItemID = 622 ; break; // MerienPlateMail(W)
		case 4: if (iDice(1,20) == 11) iItemID = 644 ; break; // KnecklaceOfAirEle
		case 5: if (iDice(1,20) == 11) iItemID = 848 ; break; // Lighting Blade
		}
		break;
		
	case 33: // WereWolf
	case 48: // Stalker
		switch (iDice(1,4)) {
		case 1: if (iDice(1,15) == 3) iItemID = 290 ; break; // Flameberge+3(LLF)
		case 2: 
		case 3: iItemID = 74 ;  break; // GoldenAxe with no stats ....
		case 4: iItemID = 292 ; break; // GoldenAxe+1
		}
		break;

	case 30: // Liche
	case 66: // Wyvern (Wyvern has a multidrop as well)
		switch (iDice(1,8)) {
		case 1: if (iDice(1,3) == 2)  iItemID = 380 ; break; // IceStormManual
		case 2: iItemID = 259 ; break; // MagicWand(M.Shield)
		case 3: if (iDice(1,15) == 3) iItemID = 291 ; break; // WandMS30
		case 4: if (iDice(1,5) == 3)  iItemID = 614 ; break; // SwordofIceElemental	
		case 5: if (iDice(1,5) == 3)  iItemID = 642 ; break; // KnecklaceOfIcePro
		case 6: if (iDice(1,10) == 3) iItemID = 643 ; break; // KnecklaceOfIceEle	
		case 7: if (iDice(1,10) == 3) iItemID = 636 ; break; // RingofGrandMage
		case 8: if (iDice(1,20) == 3) iItemID = 734 ; break; // RingOfArcmage
		}
		break;

	case 31: // Demon 
		switch (iDice(1,8)) {
		case 1: if (iDice(1,3) == 2) iItemID = 382 ; break; // BloodyShockW.Manual
		case 2: iItemID = 491 ; break; // BloodAxe
		case 3: if (iDice(1,5) == 3) iItemID = 490 ; break; // BloodSword
		case 4: iItemID = 492 ; break; // BloodRapier
		case 5: if (iDice(1,3) == 2) iItemID = 381 ; break; // MassFireStrikeManual
		case 6: if (iDice(1,5) == 3) iItemID = 633 ; break; // RingofDemonpower
		case 7: if (iDice(1,10) == 3) iItemID = 645 ; break; // NecklaceOfEfreet
		case 8: if (iDice(1,20) == 3) iItemID = 616 ; break; // DemonSlayer
		}
		break;
/* // SNOOPY GG has far better drop rate above as TW.. 1/28
	case 52: // Gagoyle
		switch (iDice(1,11)) {
		case 1: iItemID = 382 ; break;						// BloodyShockW.Manual	
		case 2: if (iDice(1,2) == 1) iItemID = 610 ; break; // XelimaBlade	
		case 3: if (iDice(1,2) == 1) iItemID = 611 ; break; // XelimaAxe	
		case 4: iItemID = 612 ; break;						// XelimaRapier
		case 5: iItemID = 381 ; break;						// MassFireStrikeManual
		case 6: iItemID = 633 ; break;						// RingofDemonpower
		case 7: if (iDice(1,3) == 3) iItemID = 645 ; break; // KnecklaceOfEfreet
		case 8: if (iDice(1,5) == 3) iItemID = 630 ; break; // RingoftheXelima	
		case 9: if (iDice(1,10) == 3) iItemID = 631 ; break; // RingoftheAbaddon
		case 10: if (iDice(1,3) == 3) iItemID = 735; break;  // RingOfDragonpower
		case 11: if (iDice(1,10) == 3) iItemID = 20 ; break; // Excalibur
		}
		break; */
	case 53: // Beholder
		if (iDice(1,4) == 2) iItemID = 646; break; // NecklaceOfBeholder 1/18k Beholders	
		break;

	case 54: // Dark-Elf
		switch (iDice(1,7)) {		
			case 1: iItemID = 618; break; // DarkElfBow
			case 2: if (iDice(1,6) == 2) iItemID = 847; break; // DarkExecutor
			case 3: if (iDice(1,3) == 2) iItemID = 991; break; // DrowBlade
			case 4: if (iDice(1,5) == 3) iItemID = 992; break; // DrowHelmM
			case 5: if (iDice(1,5) == 3) iItemID = 993; break; // DrowChainM
			case 6: if (iDice(1,5) == 3) iItemID = 994; break; // DrowChainW
			case 7: if (iDice(1,10) == 3) iItemID = 995; break; // DrowBoots
		}
		break;

	case 63: // Frost
		if (iDice(1,40) == 11) iItemID = 848; break; // LightBlade	
		break;

	case 79: // Nizie
		if (iDice(1,5) == 2) iItemID = 849; break; // KlonessBlade	
		if (iDice(1,3) == 2) iItemID = 851; break; // KlonessEsterk
		break;

	case 70: // Dragon
		switch (iDice(1,15)) {
			case 1: if (iDice(1,3) == 2)  iItemID = 852 ; break; // CancelManual
			case 2: if (iDice(1,3) == 2)  iItemID = 853 ; break; // E.S.W.Manual
			case 3: if (iDice(1,3) == 2)  iItemID = 854 ; break; // I.M.CManual
			case 4: if (iDice(1,15) == 2) iItemID = 861 ; break; // BerserkWand 
			case 5: if (iDice(1,3) == 2)  iItemID = 381 ; break; // MassFireStrikeManual
			case 6: if (iDice(1,8) == 2)  iItemID = 848;  break; // LightBlade
			case 7: if (iDice(1,8) == 2)  iItemID = 847;  break; // DarkExecutor
			case 8: iItemID = 735;  break; // RingOfDragonpower
			case 9:  if (iDice(1,5) == 2)  iItemID = 863;  break; // KlonessMS20
			case 10: if (iDice(1,15) == 2) iItemID = 864;  break; // KlonessMS28
			case 11: if (iDice(1,15) == 2) iItemID = 865;  break; // ResurWandMS20
			case 12: iItemID = 866;  break; // 	ResurWandMS0
			case 13: if (iDice(1,10) == 2) iItemID = 982;  break; // BloodWandMS40
			case 14: if (iDice(1,3) == 2)  iItemID = 985;  break; // RevivalAxe
			case 15: if (iDice(1,2) == 2)  iItemID = 382 ; break; // BloodyShockW.Manual	
		}
		break;


	case 58: if (iDice(1,10) > 2) break;//Mountain-Giant
	case 59: //Ettin
	case 78: //Minautors
		if (iDice(1,3) == 2) iItemID = 985;  // 	RevivalAxe
		break; 

	case 75: //Giant-Lizard
	case 77: //MasterMageOrc
	switch (iDice(1,6)) {
			case 1: if (iDice(1,5) == 2)  iItemID = 852 ; break; // CancelManual
			case 2: if (iDice(1,4) == 2)  iItemID = 853 ; break; // E.S.W.Manual
			case 3: if (iDice(1,3) == 2)  iItemID = 854 ; break; // I.M.CManual
			case 4: if (iDice(1,4) == 2)  iItemID = 381 ; break; // MassFireStrikeManual
			case 5: if (iDice(1,3) == 2)  iItemID = 382 ; break; // BloodyShockW.Manual
			case 6: if (iDice(1,2) == 2)  iItemID = 380 ; break; // IceStormManual
		}
		break;

	case 71: // Centaurus
		if (iDice(1,20) == 11) iItemID = 848; break; // Lighting Blade
		break;
		
	case 95: // willowisp
	case 96: // Air Elemental
		switch (iDice(1,5)) {
		case 1: iItemID = 637 ; break;						 // NecklaceOfLightPro
		case 2: if (iDice(1,5) == 11) iItemID = 644 ; break; // KnecklaceOfAirEle
		case 3: if (iDice(1,5) == 2)  iItemID = 852 ; break; // CancelManual
		case 4: if (iDice(1,5) == 2)  iItemID = 125 ; break; // WarManual
		case 5: if (iDice(1,5) == 5)  iItemID = 848;  break; // Lighting Blade
		}
		break;

	case 97: // Fire Elemental
		switch (iDice(1,6)) {
		case 1: iItemID = 638 ; break;						 // NecklaceOfFirePro
		case 2: if (iDice(1,5) == 3)  iItemID = 645 ; break; // KnecklaceOfEfreet
		case 3: iItemID = 381 ; break;						 // MassFireStrikeManual
		case 4: iItemID = 382 ; break;						 // BloodyShockW.Manual
		case 5: if (iDice(1,5) == 2)  iItemID = 127 ; break; // ExplosionManual
		}
		break;

	case 98: // Earth Elemental
		switch (iDice(1,4)) {
		case 2: if (iDice(1,5) == 3)  iItemID = 647 ; break; // KnecklaceOfStoneGolem
		case 1: if (iDice(1,5) == 2)  iItemID = 853 ; break; // E.S.W.Manual
		case 3: if (iDice(1,5) == 2)  iItemID = 854 ; break; // I.M.CManual
		case 4: if (iDice(1,5) == 2)  iItemID = 126 ; break; // BMManual
		}
		break;

	case 99: // Ice Elemental
		switch (iDice(1,8)) {
		case 1: iItemID = 642 ; break;						 // KnecklaceOfIcePro
		case 2: if (iDice(1,5) == 3)  iItemID = 643 ; break; // KnecklaceOfIceEle	
		case 3: if (iDice(1,5) == 2)  iItemID = 380 ; break; // IceStormManual
		case 4: if (iDice(1,5) == 2)  iItemID = 130 ; break; // MedusaManual
		case 5: iItemID = 614 ; break;						 // SwordofIceElemental	
		case 6: if (iDice(1,20) == 3) iItemID = 625 ; break; // IceElementalBow	
		case 7: if (iDice(1,10) == 3) iItemID = 988 ; break; // IceAxe	
		case 8: if (iDice(1,20) == 3) iItemID = 768 ; break; // IceHammer
		}
		break;

	} 
	if (iItemID != 0)
	{	wsprintf(G_cTxt,"NpcType (%d), 2nd drop: item ID (%d)",sNpcType, iItemID);
		PutLogList(G_cTxt);
		return TRUE; 
	}
suite: 
// Snoopy: Table for Eggs when no rare item could was dropped
	if (iDice(1,10) == 3) {
		switch (sNpcType) {
		// 950 Xelima
		case 31: break; 									  	  // Demon 5 * 100     1/50
		//useless! //case 52: if (iDice(1,5) != 1)    return FALSE; break;     // Gagoyle           1/50
		case 98: if (iDice(1,5) != 1)    return FALSE; break;     // Fire Elemental    1/250
		
		// 951 Living dead		
		case 30: if (iDice(1,10) != 2)   return FALSE; break;	  // Liche 1 * 100     1/100 
		case 63: if (iDice(1,50) != 11)  return FALSE; break;	  // Frost	           1/500
		case 66: if (iDice(1,10) != 11)  return FALSE; break;	  // Wyvern	           1/100	
		case 99: if (iDice(1,5) != 1)    return FALSE; break;     // Ice Elemental     1/250

		// 952 Infame
		case 32: if (iDice(1,2) != 1)    return FALSE; break;	  // Unicorn 5 * 20    1/100			
		case 95: if (iDice(1,3) != 1)    return FALSE; break;     // Willowisp		   1/150
		case 97: if (iDice(1,5) != 1)    return FALSE; break;     // Earth Elemental   1/250

		// 953 Strange
		case 11: if (iDice(1,400) != 11) return FALSE; break;	  // Skeleton 2 * 4000 1/8k	
		case 17: if (iDice(1,400) != 11) return FALSE; break;	  // Scorpion 5 * 4000 1/20k	
		case 14: if (iDice(1,500) != 11) return FALSE; break;	  // Orc 4 * 5000      1/20k		
		case 28: if (iDice(1,15) != 3)   return FALSE; break;     // Troll 5 * 150=    1/750	
		case 77: if (iDice(1,5) != 11)   return FALSE; break;	  // MasterMage-Orc    1/50

		// 954 Mysterious
		case 29: if (iDice(1,10) != 3)	 return FALSE; break;	  // Ogre  7 * 100     1/700	
		case 13: if (iDice(1,25) != 11)  return FALSE; break;	  // Cyclops  6 * 250  1/1500	
		case 27: if (iDice(1,20) != 11)  return FALSE; break;	  // Hellhound 7 * 200 1/1400
		case 79: if (iDice(1,5) != 3)    return FALSE; break;	  // Nizie             1/50

		// 955 Full Moon
		case 33: if (iDice(1,20) != 11)  return FALSE; break;	  // WereWolf 7 * 200  1/1400
		case 48: if (iDice(1,40) != 11)  return FALSE; break;	  // Stalker 1 * 400   1/400 
		case 96: if (iDice(1,4) != 1)    return FALSE; break;     // Air Elemental     1/200

		// 956 Venom
		case 18: if (iDice(1,600) != 11) return FALSE; break;	  // Zombie 1 * 6000   1/6k	
		case 22: if (iDice(1,600) != 11) return FALSE; break;	  // Amphis 5 * 6000   1/30k
		case 80: if (iDice(1,100) != 11) return FALSE; break;	  // Tentocle	       1/1000

		// 957 Sun
		case 53: if (iDice(1,60) != 11)  return FALSE; break;	  // Beholder          1/600
		case 57: if (iDice(1,150) != 11) return FALSE; break;	  // Frog			   1/1500
		case 58: if (iDice(1,100) != 11) return FALSE; break;	  // Mountain-Giant    1/1000
		case 60: if (iDice(1,120) != 11) return FALSE; break;	  // Plant			   1/1200
		case 61: if (iDice(1,150) != 11) return FALSE; break;	  // Rudolph           1/1500  
		case 62: if (iDice(1,120) != 11) return FALSE; break;	  // DireBoar          1/1200
		case 76: if (iDice(1,100) != 11) return FALSE; break;	  // Giant-Tree        1/1000
		case 71: if (iDice(1,5) != 1)    return FALSE; break;	  // Centaurus (+-DD)  1/50

		// 958 Ultimate Darkness
		case 54: if (iDice(1,30) != 11)  return FALSE; break;	  // Dark-Elf          1/300

		// 959 Merien
		case 12: if (iDice(1,200) != 11) return FALSE; break;	  // Stone-Golem 2*100 1/4k
		case 23: if (iDice(1,200) != 11) return FALSE; break;	  // Clay-Golem 2*100  1/4k
		case 65: if (iDice(1,200) != 11) return FALSE; break;	  // Ice-Golem 1*200   1/2k

		// 960 Abaddon
		case 59: if (iDice(1,15) != 11) return FALSE; break;	  // Ettin	           1/150
		case 70: if (iDice(1,15) != 11) return FALSE; break;	  // Dragon	           1/150
		case 78: if (iDice(1,7) != 3)   return FALSE; break;	  // Minotaurs         1/70
			
		//961 Ancient Egg (submarine creatures)
		case 74: if (iDice(1,200) != 11) return FALSE; break;	  // Giant-Crayfish 1/2000
		case 72: if (iDice(1,100) != 11) return FALSE; break;	  // Claw-Turtle    1/1000
		case 75: if (iDice(1,5) != 1)    return FALSE; break;	  // Giant-Lizard   1/50
		default: return FALSE;
		}
	}
	else return FALSE;

//Give the Egg to the right creature

	switch (sNpcType) {
	case 31: // Demon 
	case 52: // GG 
		iItemID = 950; // Xelima Egg
		break;

	case 30: // Liche
	case 63: // Frost
		iItemID = 951; // Living Egg
		break;

	case 32: // Unicorn
		iItemID = 952; // Infame Egg
		break;

	case 11: // Skeleton
	case 17: // Scorpion
	case 14: // Orc
	case 28: // Troll
	case 77: // MasterMageOrc
	case 80: // Tentocle
		iItemID = 953; //Strange Egg
		break;
	
	case 13: // Cyclops
	case 27: // Hellhound
	case 29: // Ogre
	case 79: // Nizie
		iItemID = 954; // Mysterious Egg
		break;
		
	case 33: // WereWolf
	case 48: // Stalker
		iItemID = 955; // FullMoon Egg
		break;

	case 18: // Zombie
	case 22: // Amphis
		iItemID = 956; // Venom Egg
		break;
	case 53: // Beholder          1/600
	case 57: // Frog			  1/1500
	case 58: // Mountain-Giant    1/1000
	case 60: // Plant             1/1200
	case 61: // Rudolph           1/1500  
	case 62: // DireBoar          1/1200
	case 76: // Giant-Tree        1/1000
	case 71: // Centaurus (+-DD)  1/50
		iItemID = 957; // Sun Egg
		break;

	case 54: // Dark-Elf
		iItemID = 958; // Darkness Egg
		break;

	case 12: // Stone-Golem
	case 23: // Clay-Golem
	case 65: // Ice-Golem
		iItemID = 959; // Merien Egg
		break;

	case 59: // Ettin
	case 70: // Dragon	
	case 78: // Minotaurs
		iItemID = 960; // Abaddon Egg
		break;

	case 74: // Giant-Crayfish 1/2000
	case 72: // Claw-Turtle    1/1000
	case 75: // Giant-Lizard   1/50
		iItemID = 961; // Ancient Egg
		break;
	} 
	if (iItemID == 0) 
		return FALSE; 
	else {
		wsprintf(G_cTxt,"NpcType (%d), 2nd drop: item ID (%d)",sNpcType, iItemID);
		PutLogList(G_cTxt);
		return TRUE; 
	}
}
// Snoopy: Add delayed damage for StormBlade yellow storms
void CGame::StormBlade(int iClientH, int iMapIndex, short dX, short dY)
{char cOwnerType;
 short sOwner;
 int  iDamage;
 double dTmp1, dTmp2, dTmp3;
	if (iClientH == NULL) return;
	if (m_pClientList[iClientH] == NULL) return;
	if (m_pClientList[iClientH]->m_cMapIndex != iMapIndex) return;
	short sItemIndex = m_pClientList[iClientH]->m_sItemEquipmentStatus[ DEF_EQUIPPOS_TWOHAND ];
	if (sItemIndex == -1) sItemIndex = m_pClientList[iClientH]->m_sItemEquipmentStatus[ DEF_EQUIPPOS_RHAND ];

	if ((sItemIndex != -1) && (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sIDnum == 845)) 
	{	m_pMapList[iMapIndex]->GetOwner(&sOwner, &cOwnerType, dX, dY);	
		switch (cOwnerType) {
		case DEF_OWNERTYPE_PLAYER:
			if (m_pClientList[sOwner]->m_iAdminUserLevel < 1) 
			{	if (m_pClientList[sOwner]->m_cMagicEffectStatus[ DEF_MAGICTYPE_PROTECT ] == 5)
					return;
				switch (m_pMapList[iMapIndex]->m_iPKmode) {
				case -5: // no EK, but PK possible, crim treated as "normal citizens"
					if (m_pClientList[sOwner]->m_cSide != m_pClientList[iClientH]->m_cSide) return;
					break;
				case -4: // Evil side can be victim but not attack, crim treated as "normal citizens"
					if (m_pClientList[sOwner]->m_cSide != 4) return;
					break;
				case -3: // No PK or EK allowed, crim treated as "normal citizens"
					return;
					break;
				case -2: // No PK and EK allowed only against Evil side (m_cSide =4), crim treated as "normal citizens"
					if (m_pClientList[sOwner]->m_cSide + m_pClientList[iClientH]->m_cSide <5) return;
					break;
				case -1: // No PK, EK allowed, crim treated as "normal citizens"
					if (m_pClientList[sOwner]->m_cSide + m_pClientList[iClientH]->m_cSide == 2) return;
					if (m_pClientList[sOwner]->m_cSide + m_pClientList[iClientH]->m_cSide == 4) return;
					break;
				case 5: // no EK, but PK possible... 
					if (   (m_pClientList[sOwner]->m_cSide != m_pClientList[iClientH]->m_cSide) 
						&& (m_pClientList[iClientH]->m_iPKCount == 0) 
						&& (m_pClientList[sOwner]->m_iPKCount == 0)) return;
					break;
					case 4: // Evil side can be victim but not attack
					if (   (m_pClientList[sOwner]->m_cSide != 4) 					
						&& (m_pClientList[iClientH]->m_iPKCount == 0) 
						&& (m_pClientList[sOwner]->m_iPKCount == 0)) return;
					break;
				case 3: // No PK or EK allowed
					if (   (m_pClientList[iClientH]->m_iPKCount == 0) 
						&& (m_pClientList[sOwner]->m_iPKCount == 0)) return;
					break;
				case 2: // No PK and EK allowed only against Evil side (m_cSide =4)
					if (   (m_pClientList[sOwner]->m_cSide + m_pClientList[iClientH]->m_cSide <5)					
						&& (m_pClientList[iClientH]->m_iPKCount == 0) 
						&& (m_pClientList[sOwner]->m_iPKCount == 0))  return;
					break;
				case 1: // No PK, EK allowed				
					if (   (m_pClientList[iClientH]->m_iPKCount == 0) 
						&& (m_pClientList[sOwner]->m_iPKCount == 0))  
					{	if (m_pClientList[sOwner]->m_cSide + m_pClientList[iClientH]->m_cSide == 2) return;
						if (m_pClientList[sOwner]->m_cSide + m_pClientList[iClientH]->m_cSide == 4) return;
					}
					break;
				case 0:  // All EK allowed
					break;
				}
				iDamage = iDice(m_pClientList[iClientH]->m_cAttackDiceThrow_SM, m_pClientList[iClientH]->m_cAttackDiceRange_SM)+m_pClientList[iClientH]->m_cAttackBonus_SM;
				iDamage += m_pClientList[iClientH]->m_iAddMagicalDamage;//m_iAddPhysicalDamage
				if (m_pClientList[sOwner]->m_iAddAbsAir != 0) 
				{	dTmp1 = (double)iDamage;
					dTmp2 = (double)m_pClientList[sOwner]->m_iAddAbsAir;
					dTmp3 = (dTmp2/100.0f)*dTmp1;
					iDamage = iDamage - (int)(dTmp3);
					if (iDamage < 1) return;
				}
				if (m_pClientList[sOwner]->m_cMagicEffectStatus[ DEF_MAGICTYPE_PROTECT ] == 2)
					iDamage = (iDamage+1) / 2;					
				m_pClientList[sOwner]->m_iHP -= iDamage;
				if (m_pClientList[sOwner]->m_iHP <= 0)
				{	ClientKilledHandler(sOwner, iClientH, DEF_OWNERTYPE_PLAYER, (short)iDamage);					
				}else 
				{	m_pClientList[sOwner]->m_dwLastDamageTime = timeGetTime();
					SendNotifyMsg(NULL, sOwner, DEF_NOTIFY_HP, NULL, NULL, NULL, NULL);	
					SendEventToNearClient_TypeA(sOwner, DEF_OWNERTYPE_PLAYER, MSGID_EVENT_MOTION, DEF_OBJECTDAMAGE, iDamage, NULL, NULL);
				}
			}
			break;

		case DEF_OWNERTYPE_NPC:
			if (m_pNpcList[sOwner]->m_cMagicEffectStatus[ DEF_MAGICTYPE_PROTECT ] == 5)
				return;
			if (m_pNpcList[sOwner]->m_cSize == 0)	
				iDamage = iDice(m_pClientList[iClientH]->m_cAttackDiceThrow_SM, m_pClientList[iClientH]->m_cAttackDiceRange_SM)+m_pClientList[iClientH]->m_cAttackBonus_SM;
			else 
				iDamage = iDice(m_pClientList[iClientH]->m_cAttackDiceThrow_L, m_pClientList[iClientH]->m_cAttackDiceRange_L)+m_pClientList[iClientH]->m_cAttackBonus_L;
			iDamage += m_pClientList[iClientH]->m_iAddMagicalDamage;
			if (m_pNpcList[sOwner]->m_iAbsDamage > 0) 
			{	dTmp1 = (double)iDamage;
				dTmp2 = (double)(m_pNpcList[sOwner]->m_iAbsDamage)/100.0f;
				dTmp3 = dTmp1 * dTmp2;
				dTmp2 = dTmp1 - dTmp3;
				iDamage = (int)dTmp2;
				if (iDamage < 0) return;
			}
			if (m_pNpcList[sOwner]->m_cMagicEffectStatus[ DEF_MAGICTYPE_PROTECT ] == 2)
				iDamage = (iDamage+1) / 2;		
			switch (m_pNpcList[sOwner]->m_cActionLimit) {
			case 2: // merchant
			case 4:	// Energy Sphere
			case 5: // struct sade crops
			case 6: // Moving talking npc
			case 8: // Heldenian gates	
				return;
				break;
			default:
			case 0:	// Snoopy: Fly npcs ...	
			case 1: // Never runner npc
			case 3: // dummy
				m_pNpcList[sOwner]->m_iHP -= iDamage;
				if (m_pNpcList[sOwner]->m_iHP <= 0)
				{	NpcKilledHandler(iClientH, DEF_OWNERTYPE_PLAYER, sOwner, (short) iDamage);			
				}else 
				{	SendEventToNearClient_TypeA(sOwner, DEF_OWNERTYPE_NPC, MSGID_EVENT_MOTION, DEF_OBJECTDAMAGE, iDamage, NULL, NULL);
				}
				break;
			}	
			break;
		}
	}
}

BOOL CGame::_bCheckCharacterData(int iClientH)
{ register int i;
// SNOOPY Special values here because of gizon levels, server migration, and gizon characteristics change
//int maxHP = (m_pClientList[iClientH]->m_iVit+1)*3 + (m_pClientList[iClientH]->m_iLevel+1)*2 + (m_pClientList[iClientH]->m_iStr+3)/2;
// New formula to stick to the clients patch approximations

int maxHP = (m_pClientList[iClientH]->m_iVit+1)*3 + ((m_pClientList[iClientH]->m_iLevel+1)*4 
					+ (m_pClientList[iClientH]->m_iStr + 3 + m_pClientList[iClientH]->m_iAngelicStr))/2;
int maxMP = (2*(m_pClientList[iClientH]->m_iMag + 3 + m_pClientList[iClientH]->m_iAngelicMag)) + (2*(m_pClientList[iClientH]->m_iLevel+1)) 
					+ ((m_pClientList[iClientH]->m_iInt + 3 + m_pClientList[iClientH]->m_iAngelicInt)/2);
int maxSP = (2*(m_pClientList[iClientH]->m_iStr + 3 + m_pClientList[iClientH]->m_iAngelicStr )) 
					+ (2*(m_pClientList[iClientH]->m_iLevel+1));

	if ((m_pClientList[iClientH]->m_iStr > m_sCharStatLimit) || (m_pClientList[iClientH]->m_iVit > m_sCharStatLimit) || (m_pClientList[iClientH]->m_iDex > m_sCharStatLimit) ||
        (m_pClientList[iClientH]->m_iMag > m_sCharStatLimit) || (m_pClientList[iClientH]->m_iInt > m_sCharStatLimit) || (m_pClientList[iClientH]->m_iCharisma > m_sCharStatLimit)) 
	{	wsprintf(G_cTxt, "Packet Editing:    PC(%s) - Stat points are greater then server accepts.(Disc.) \tIP(%s)"
			, m_pClientList[iClientH]->m_cCharName
			, m_pClientList[iClientH]->m_cIPaddress);
		PutHackLogFileList(G_cTxt);
		return FALSE;
	}
	// SNOOPY: 
	// m_iPlayerMaxLevel (npc.cfg) is max Level using XP levelup
	// m_sAbsoluteMaxPlayerLevel (settings.cfg) is absolute max level
	if ((m_pClientList[iClientH]->m_iLevel > m_sAbsoluteMaxPlayerLevel)
		&& (m_pClientList[iClientH]->m_iAdminUserLevel == 0)
		&& (m_pClientList[iClientH]->m_cSide != 4)) {
		wsprintf(G_cTxt, "Packet Editing:    PC(%s) - Level above max server level.(Disc.) \tIP(%s)"
			, m_pClientList[iClientH]->m_cCharName
			, m_pClientList[iClientH]->m_cIPaddress);
		PutHackLogFileList(G_cTxt);
		return FALSE;
	}
	// Same for evil side
	if (   (m_pClientList[iClientH]->m_cSide == 4) 
		&& (m_pClientList[iClientH]->m_iLevel > m_sEvilMaxPlayerLevel)
		&& (m_pClientList[iClientH]->m_iAdminUserLevel == 0)) 
	{	wsprintf(G_cTxt, "Packet Editing:    PC(%s) - Level above evil max server level.(Disc.) \tIP(%s)"
			, m_pClientList[iClientH]->m_cCharName
			, m_pClientList[iClientH]->m_cIPaddress);
		PutHackLogFileList(G_cTxt);
		return FALSE;
	}
	if (m_pClientList[iClientH]->m_iExp < 0) 
	{	wsprintf(G_cTxt, "Packet Editing:    PC(%s) - Experience is below 0 - (Exp:%d).(Disc.) \tIP(%s)"
		, m_pClientList[iClientH]->m_cCharName
		, m_pClientList[iClientH]->m_iExp
		, m_pClientList[iClientH]->m_cIPaddress);
		PutHackLogFileList(G_cTxt);
		return FALSE;
	}
	// SNOOPY: Edited because of migration from nivx2+ vitx3 + strx0.5 to niv x1.5
	if ((m_pClientList[iClientH]->m_iHP > maxHP) && (m_pClientList[iClientH]->m_iAdminUserLevel == 0)) 
	{	wsprintf(G_cTxt, "Packet Editing:    PC(%s) - HP: current/maximum (%d/%d).(Disc.) \tIP(%s)"
			, m_pClientList[iClientH]->m_cCharName
			, m_pClientList[iClientH]->m_iHP
			, iGetMaxHP(iClientH)
			, m_pClientList[iClientH]->m_cIPaddress);
		PutHackLogFileList(G_cTxt);
		return FALSE;
	}
	if ((m_pClientList[iClientH]->m_iMP > maxMP) && (m_pClientList[iClientH]->m_iAdminUserLevel == 0)) 
	{	//printf(G_cTxt, "351 Run Speeder:   PC(%s) - Run difference: %d. Speed Hack? \tIP(%s)"
		wsprintf(G_cTxt, "Packet Editing:    PC(%s) - MP: current/maximum (%d/%d).(Disc.) \tIP(%s)"
			, m_pClientList[iClientH]->m_cCharName
			, m_pClientList[iClientH]->m_iMP
			, iGetMaxMP(iClientH)
			, m_pClientList[iClientH]->m_cIPaddress);
		PutHackLogFileList(G_cTxt);
		return FALSE;
	}
	if ((m_pClientList[iClientH]->m_iSP > maxSP) && (m_pClientList[iClientH]->m_iAdminUserLevel == 0)) 
	{	wsprintf(G_cTxt, "Packet Editing:    PC(%s) - SP: current/maximum (%d/%d).(Disc.) \tIP(%s)"
			, m_pClientList[iClientH]->m_cCharName
			, m_pClientList[iClientH]->m_iSP
			, iGetMaxSP(iClientH)
			, m_pClientList[iClientH]->m_cIPaddress);
		PutHackLogFileList(G_cTxt);
		return FALSE;
	}

	if (m_pClientList[iClientH]->m_iAdminUserLevel != 0) // Check for a possible Buffer Overflow GM
	{	BOOL bIsValidAdmin = FALSE;
		for (i = 0; i < DEF_MAXADMINS; i++) 
		{	if(strlen(m_stAdminList[i].m_cGMName) == 0) break; //No more GM's on list
			if ((strlen(m_stAdminList[i].m_cGMName)) == (strlen(m_pClientList[iClientH]->m_cCharName))) 
			{	if(memcmp(m_stAdminList[i].m_cGMName, m_pClientList[iClientH]->m_cCharName, strlen(m_pClientList[iClientH]->m_cCharName)) == 0)
				{	bIsValidAdmin = TRUE;  // good admin...				
					m_pClientList[iClientH]->m_iBeholderPower = 1; // will see all invis
					break;
		}	}	}
		if (bIsValidAdmin == FALSE)
		{	  wsprintf(G_cTxt, "UsurpedAdmin Hack: PC(%s) - AdminUserLevel >%d, but not on AdminList.cfg. \tIP(%s)"
				, m_pClientList[iClientH]->m_cCharName
				, m_pClientList[iClientH]->m_iAdminUserLevel
				, m_pClientList[iClientH]->m_cIPaddress);
			PutHackLogFileList(G_cTxt);
			//	Show in red on client!
			ZeroMemory(m_cBugText, sizeof(m_cBugText));
			wsprintf(m_cBugText, "HACK SUSPICTION:  %s pretends being an Admin!"
				, m_pClientList[iClientH]->m_cCharName);
			m_iBugWarning = 1;
			return FALSE;	
	}	}
	for (i = 0; i < DEF_MAXBANNED; i++) 
	{	if(strlen(m_stBannedList[i].m_cBannedIPaddress) == 0) break; //No more GM's on list
		if ((strlen(m_stBannedList[i].m_cBannedIPaddress)) == (strlen(m_pClientList[iClientH]->m_cIPaddress))) 
		{	if(memcmp(m_stBannedList[i].m_cBannedIPaddress, m_pClientList[iClientH]->m_cIPaddress, strlen(m_pClientList[iClientH]->m_cIPaddress)) == 0)
			{	wsprintf(G_cTxt, "Banned Client:     PC(%s) - Connects from a banned IP.(Disc.) \tIP(%s)"
					, m_pClientList[iClientH]->m_cCharName
					, m_pClientList[iClientH]->m_cIPaddress);
				PutHackLogFileList(G_cTxt);
				PutLogList(G_cTxt);
				//	Show in red on client!
				ZeroMemory(m_cBugText, sizeof(m_cBugText));
				wsprintf(m_cBugText, "BANNED IP      :  %s tried to connect from IP(%s)!"
					, m_pClientList[iClientH]->m_cCharName
					, m_pClientList[iClientH]->m_cIPaddress);
				m_iBugWarning = 1;
				return FALSE;
	}	}	}
	return TRUE;
}



void CGame::HeldenianWarStarter()
{SYSTEMTIME SysTime;
 int i;	
	GetLocalTime(&SysTime);
	if (var_89C == TRUE) return;
	if (var_8A0 == FALSE) return;
	for (i = 0; i < DEF_MAXSCHEDULE; i++) 
		if (m_bIsApocalypseMode == TRUE) return;
		if (m_bIsCrusadeMode == TRUE) return;
		if ((m_stHeldenianSchedule[i].iDay != SysTime.wDayOfWeek) &&
			(m_stHeldenianSchedule[i].StartiHour != SysTime.wHour) &&
			(m_stHeldenianSchedule[i].StartiMinute != SysTime.wMinute)) {
			wsprintf(G_cTxt,"Heldenian Start : time(%d %d:%d), index(%d)",SysTime.wDayOfWeek, SysTime.wHour, SysTime.wMinute, i);
			PutLogList(G_cTxt);
			PutLogFileList(G_cTxt);
			PutLogEventFileList(G_cTxt);
			var_8A0 = TRUE;
			GlobalStartHeldenianMode();
		}
}
void CGame::HeldenianWarEnder() //unused
{/*SYSTEMTIME SysTime;
 int i;	
	GetLocalTime(&SysTime);
	for (i = 0; i < DEF_MAXSCHEDULE; i++) 
		if (var_89C != TRUE) return;
		if (var_8A0 != TRUE) return;
		if ((m_stHeldenianSchedule[i].iDay != SysTime.wDayOfWeek) &&
			(m_stHeldenianSchedule[i].EndiHour != SysTime.wHour) &&
			(m_stHeldenianSchedule[i].EndiMinute != SysTime.wMinute)) {
			wsprintf(G_cTxt,"Heldenian End : time(%d %d:%d), index(%d)",SysTime.wDayOfWeek, SysTime.wHour, SysTime.wMinute, i);
			PutLogList(G_cTxt);
			PutLogFileList(G_cTxt);
			PutLogEventFileList(G_cTxt);
			if (m_cHeldenianType == 2) {
				m_cHeldenianWinner = m_sLastHeldenianWinner;
			}
			GlobalEndHeldenianMode();
		}*/
}
/*
DEF_NOTIFY_HELDENIANTELEPORT	0BE6: Event commencé, TP dispo, mais bataille pas encore commencee	
DEF_NOTIFY_HELDENIANEND			0BE7: Event terminé
DEF_NOTIFY_0BE8					0BE8: Averti le joueur qu'il va etre renvoyé de la carte Heldenian.
DEF_NOTIFY_HELDENIANSTART		0BEA: Debut de la bataille
DEF_NOTIFY_HELDENIANVICTORY		0BEB: Le client montre l'écran de victoire
DEF_NOTIFY_HELDENIANCOUNT		0BEC: Informe le joueur du score actuel (UpdateHeldenianStatus)

MSGID_REQUEST_HELDENIAN_WINNER
MSGID_REQUEST_HELDENIAN_TP_LIST
GSM_ENDHELDENIAN
GSM_STARTHELDENIAN
*/
/*********************************************************************************************************************
**  void CGame::_CreateHeldenianGUID(DWORD dwHeldenianGUID, int iWinnerSide)										**
**  description		:: Create GUID file at event's strating, & finishing for each server	              			**
**             		:: Used when server starts																		**
**																													**
*********************************************************************************************************************/
void CGame::_CreateHeldenianGUID(DWORD dwHeldenianGUID, int iWinnerSide)
{char * cp, cTxt[256], cFn[256], cTemp[1024];	
 FILE * pFile;		
	_mkdir("GameData");
	ZeroMemory(cFn, sizeof(cFn));	
	strcat(cFn,"GameData");
	strcat(cFn,"\\");
	strcat(cFn,"\\");					  
	strcat(cFn,"HeldenianGUID.Txt");		
	pFile = fopen(cFn, "wt");
	if (pFile == NULL) 
	{	wsprintf(G_cTxt, "(!) Cannot create HeldenianGUID (%s) file.", dwHeldenianGUID);
		PutLogList(G_cTxt);
	}else 
	{	ZeroMemory(cTemp, sizeof(cTemp));		
		ZeroMemory(cTxt, sizeof(cTxt));
		wsprintf(cTxt, "HeldenianGUID = %d\n", dwHeldenianGUID);
		strcat(cTemp, cTxt);
		ZeroMemory(cTxt, sizeof(cTxt));
		wsprintf(cTxt, "winner-side = %d\n", iWinnerSide);
		strcat(cTemp, cTxt);		
		cp = (char *)cTemp;
		fwrite(cp, strlen(cp), 1, pFile);		
		wsprintf(G_cTxt, "(_) HeldenianGUID (%d) file created. (Winner %d)", dwHeldenianGUID, iWinnerSide);
		PutLogList(G_cTxt);
	}
	if (pFile != NULL) fclose(pFile);
}
/*********************************************************************************************************************
**  BOOL CGame::bReadHeldenianGUIDFile(char * cFn)																	**
**  description		:: Read thee GUID file for each server						                        			**
**             		:: Used when server starts																		**
**																													**
*********************************************************************************************************************/
BOOL CGame::bReadHeldenianGUIDFile(char * cFn)
{FILE * pFile;
 HANDLE hFile;
 DWORD  dwFileSize;
 char * cp, * token, cReadMode;
 char seps[] = "= \t\n";
 class CStrTok * pStrTok;
	cReadMode = 0;
	hFile = CreateFile(cFn, GENERIC_READ, NULL, NULL, OPEN_EXISTING, NULL, NULL);
	dwFileSize = GetFileSize(hFile, NULL);
	if (hFile != INVALID_HANDLE_VALUE) CloseHandle(hFile);
	pFile = fopen(cFn, "rt");
	if (pFile == NULL) 
	{	PutLogList("(!) Cannot open HeldenianGUID file.");
		return FALSE;
	}else 
	{	PutLogList("(_) Reading HeldenianGUID file...");
		cp = new char[dwFileSize+2];
		ZeroMemory(cp, dwFileSize+2);
		fread(cp, dwFileSize, 1, pFile);
		pStrTok = new class CStrTok(cp, seps);
		token = pStrTok->pGet();
		while( token != NULL )   			
		{	if (cReadMode != 0) 
			{	switch (cReadMode) {
				case 1:
					m_dwHeldenianGUID = _atoi64(token);
					cReadMode = 0;
					break;
				case 2:
					m_sLastHeldenianWinner = atoi(token);
					cReadMode = 0;
					break;
				}
			}else 
			{	if (memcmp(token, "HeldenianGUID", 13) == 0) cReadMode = 1;
				if (memcmp(token, "winner-side", 11) == 0) cReadMode = 2;
			}			
			token = pStrTok->pGet();
		}
		delete pStrTok;
		delete cp;
	}
	if (pFile != NULL) fclose(pFile);
	switch (m_sLastHeldenianWinner) {
	case 1:	wsprintf(G_cTxt, "(_) Read HeldenianGUID (%d) file: Aresden owns BtField (%d).", m_dwHeldenianGUID, m_sLastHeldenianWinner);
		break;
	case 2: wsprintf(G_cTxt, "(_) Read HeldenianGUID (%d) file: Elvine owns BtField (%d).", m_dwHeldenianGUID, m_sLastHeldenianWinner);
		break;		
	default:wsprintf(G_cTxt, "(_) Read HeldenianGUID (%d) file: Nobody owns BtField (%d).", m_dwHeldenianGUID, m_sLastHeldenianWinner);
		break;
	}
	PutLogList(G_cTxt);
	return TRUE;
}
/*********************************************************************************************************************
**  void CGame::ManualStartHeldenianMode(int iClientH, char *pData, DWORD dwMsgSize)								**
**  description		:: Admin order to star Heldenian, starts heldenian			                        			**
**             		:: "/beginheldenian 1" or "/beginheldenian 2"													**
**	Called by Amin order																							**
*********************************************************************************************************************/
void CGame::ManualStartHeldenianMode(int iClientH, char *pData, DWORD dwMsgSize)
{char cBuff[256], * token, seps[] = "= \t\n";
 class CStrTok * pStrTok;
	if (m_bIsHeldenianMode == TRUE) return;
	if (m_bIsApocalypseMode == TRUE) return;
	if (m_bIsCrusadeMode == TRUE) return;
	if (m_bIsAvatarMode == TRUE) return;
	if (m_pClientList[iClientH]->m_iAdminUserLevel < m_iAdminLevelSpecialEvents )
	{	SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_ADMINUSERLEVELLOW, NULL, NULL, NULL, NULL);
		return;
	}
	if (m_pClientList[iClientH]->m_bIsAdminCommandEnabled == FALSE) return;

	ZeroMemory(cBuff, sizeof(cBuff));
	memcpy(cBuff, pData, dwMsgSize);
	pStrTok = new class CStrTok(cBuff, seps);
	token = pStrTok->pGet();
	token = pStrTok->pGet();
	m_cHeldenianType = 1;
	if (token != NULL) 
	{	switch (atoi(token)) {
		case 2:
			m_cHeldenianType = 2;
			break;
		default:
			m_cHeldenianType = 1;
			break;
	}	}
	if (m_sLastHeldenianWinner == 0) m_cHeldenianType = 1;
	delete pStrTok;
	wsprintf(G_cTxt,"Admin Order(%s): begin Heldenian", m_pClientList[iClientH]->m_cCharName);
	PutAdminLogFileList(G_cTxt);
	PutLogList(G_cTxt);
	PutLogEventFileList(G_cTxt);
	GlobalStartHeldenianMode();
}
/*********************************************************************************************************************
**  void CGame::GlobalStartHeldenianMode()																			**
**  description		:: Tell Gate server to ask all gservers to start Heldenian                           			**
**             		:: and starts Heldenian localy																	**
**	Called by ManualStartHeldenianMode																				**
*********************************************************************************************************************/
void CGame::GlobalStartHeldenianMode()
{char cData[120], * cp;
 DWORD dwNewHeldenianGUID, *dwp;
 WORD * wp;
	dwNewHeldenianGUID = timeGetTime();
	ZeroMemory(cData,sizeof(cData));
	cp = (char *)cData;
	*cp = GSM_STARTHELDENIAN; // 21
	cp++;	
	wp  = (WORD *)cp;
	*wp = m_cHeldenianType;
	cp += 2;
	wp  = (WORD *)cp;
	*wp = m_sLastHeldenianWinner;
	cp += 2;
	dwp = (DWORD *)cp;
	*dwp = dwNewHeldenianGUID;
	cp += 4;
	bStockMsgToGateServer(cData, 9);
	switch (m_sLastHeldenianWinner) {
	case 0:
		_bCrusadeLog(DEF_CRUSADELOG_STARTHELDENIAN, NULL, (int)m_cHeldenianType, "nobody");
		break;
	case 1:
		_bCrusadeLog(DEF_CRUSADELOG_STARTHELDENIAN, NULL, (int)m_cHeldenianType, "Aresden");
		break;
	case 2:
		_bCrusadeLog(DEF_CRUSADELOG_STARTHELDENIAN, NULL, (int)m_cHeldenianType, "Elvine");
		break;
	}		
	LocalStartHeldenianMode(m_cHeldenianType, m_sLastHeldenianWinner, dwNewHeldenianGUID);				
}
/*********************************************************************************************************************
**  void CGame::LocalStartHeldenianMode(short sV1, short sV2, DWORD dwHeldenianGUID)								**
**  description		:: localy performs all required tasks upon recieving heldenian initiate message					**
**					::																								**
**	Called locally if Heldenian started from this serger, or called by gate message									**
*********************************************************************************************************************/
void CGame::LocalStartHeldenianMode(short sV1, short sV2, DWORD dwHeldenianGUID)
{int i, x, iNamingValue;
 char cName[11], cTmp[21], cNpcWaypointIndex[10], cSide, cOwnerType;
 short sOwnerH;
 BOOL bRet;
 int dX, dY;
	if (m_bIsHeldenianMode == TRUE) return;
	m_cHeldenianType		= sV1;
	m_sLastHeldenianWinner	= sV2;
	m_cHeldenianWinner		= -1;
	m_dwHeldenianGUID		= dwHeldenianGUID;
	m_bHeldenianWarInitiated = FALSE;
	_CreateHeldenianGUID(m_dwHeldenianGUID, m_sLastHeldenianWinner);
	m_iHeldenianAresdenLeftTower = 0;
	m_iHeldenianElvineLeftTower = 0;
	m_iHeldenianAresdenDead = 0;
	m_iHeldenianElvineDead = 0;
	
	// Tell that you can TP to battlefield, and about construction points
	for (i = 0; i < DEF_MAXCLIENTS; i++) 
	{	if (m_pClientList[i] != NULL) 
		{	if (m_pClientList[i]->m_bIsInitComplete != TRUE) break;
			m_pClientList[i]->m_cVar = 2;
			SendNotifyMsg(NULL, i, DEF_NOTIFY_HELDENIANTELEPORT,  NULL , NULL, NULL, NULL); // You can now, go to the battle field
			m_pClientList[i]->m_dwHeldenianGUID    = m_dwHeldenianGUID;				
			m_pClientList[i]->m_iWarContribution   = 0;
			m_pClientList[i]->m_iConstructionPoint = 10000 + (m_pClientList[i]->m_iCharisma * 100);
			if (m_pClientList[i]->m_iConstructionPoint > DEF_MAXHELDENIANSUMMONPOINT) m_pClientList[i]->m_iConstructionPoint = DEF_MAXHELDENIANSUMMONPOINT;
			m_pClientList[i]->m_cVar = 2;// character have been informed of heldenian starting...
			SendNotifyMsg(NULL, i, DEF_NOTIFY_CONSTRUCTIONPOINT, m_pClientList[i]->m_iConstructionPoint, m_pClientList[i]->m_iWarContribution, 0, NULL); //0: Tell player of acquired points
			UpdateHeldenianStatus(i);
	}	}
	// Recall clients already on battlefield; remove any Heldenian mob, and create current war towers/gates
	for (x = 0; x < DEF_MAXMAPS; x++) 
	{	if (m_pMapList[x] == NULL) break;
		if (m_pMapList[x]->m_bIsHeldenianMap == TRUE) 
		{	RemoveOccupyFlags(x);
			for (i = 0; i < DEF_MAXCLIENTS; i++) // Tell everybody on Heldenian map and recall them
			{	if (   (m_pClientList[i] != NULL) && (m_pClientList[i]->m_bIsInitComplete == TRUE) 
					&& (m_pClientList[i]->m_cMapIndex == x)	)
				{	SendNotifyMsg(NULL, i, DEF_NOTIFY_0BE8, NULL , NULL, NULL, NULL);
					RequestTeleportHandler(i, "1   ", NULL, -1, -1);
			}	}
			for (i = 0; i < DEF_MAXNPCS; i++) // Remove summons from last Heldenian
			{	if (   (m_pNpcList[i] != NULL) && (m_pNpcList[i]->m_bIsKilled == FALSE) 
					&& (m_pNpcList[i]->m_cMapIndex == x))
				{	if (m_pNpcList[i]->m_bIsSummoned == TRUE) 
					{	NpcKilledHandler(NULL, NULL, i, NULL);
					}else
					{	// Remove most mobs, and other Mobs become neutral
						// All mobs become neutral as players don't have spells or attacks...
						if (iDice(1,10)!= 5)
						{	m_pNpcList[i]->m_bIsUnsummoned = TRUE; 	
							NpcKilledHandler(i, DEF_OWNERTYPE_NPC, i, 0);
							DeleteNpc(i);
						}else m_pNpcList[i]->m_cSide = 0; 
			}	}	}		
			if (m_cHeldenianType == 1) 
			{	if (strcmp(m_pMapList[x]->m_cName, "BtField") == 0) 
				{	// REloadmap info
					if (__bReadMapCrusadeInfo(x, TRUE))
					{	m_pMapList[x]->m_bChangedForCrusade = TRUE;
					}				
					for (i = 0; i < MAX_HELDENIANTOWER; i++) 
					{	iNamingValue = m_pMapList[x]->iGetEmptyNamingValue();
						if (m_pMapList[x]->m_stHeldenianTower[i].sTypeID < 1)  break;
						if (m_pMapList[x]->m_stHeldenianTower[i].sTypeID > DEF_MAXNPCTYPES) break;
						if (iNamingValue != -1) 
						{	dX = m_pMapList[x]->m_stHeldenianTower[i].dX;
							dY = m_pMapList[x]->m_stHeldenianTower[i].dY;
 							cSide = m_pMapList[x]->m_stHeldenianTower[i].cSide;
							ZeroMemory(cTmp, sizeof(cTmp));
							if ((m_pMapList[x]->m_stHeldenianTower[i].sTypeID == 87)&&(cSide == 1)) strcpy(cTmp, "CT-Aresden"); 
							if ((m_pMapList[x]->m_stHeldenianTower[i].sTypeID == 87)&&(cSide == 2)) strcpy(cTmp, "CT-Elvine"); 
							if ((m_pMapList[x]->m_stHeldenianTower[i].sTypeID == 89)&&(cSide == 1)) strcpy(cTmp, "AGC-Aresden"); 
							if ((m_pMapList[x]->m_stHeldenianTower[i].sTypeID == 89)&&(cSide == 2)) strcpy(cTmp, "AGC-Elvine"); 
							if ((m_pMapList[x]->m_stHeldenianTower[i].sTypeID == 36)&&(cSide == 1)) strcpy(cTmp, "AGT-Aresden"); 
							if ((m_pMapList[x]->m_stHeldenianTower[i].sTypeID == 36)&&(cSide == 2)) strcpy(cTmp, "AGT-Elvine"); 
							if ((m_pMapList[x]->m_stHeldenianTower[i].sTypeID == 37)&&(cSide == 1)) strcpy(cTmp, "CGT-Aresden"); 
							if ((m_pMapList[x]->m_stHeldenianTower[i].sTypeID == 37)&&(cSide == 2)) strcpy(cTmp, "CGT-Elvine"); 
							if ((m_pMapList[x]->m_stHeldenianTower[i].sTypeID == 39)&&(cSide == 1)) strcpy(cTmp, "DT-Aresden"); 
							if ((m_pMapList[x]->m_stHeldenianTower[i].sTypeID == 39)&&(cSide == 2)) strcpy(cTmp, "DT-Elvine"); 
							ZeroMemory(cName, sizeof(cName));
							wsprintf(cName, "XX%d", iNamingValue);
							cName[0] = 95;
							cName[1] = i + 65;
							bRet = bCreateNewNpc(cTmp, cName, m_pMapList[x]->m_cName, (rand() % 3), 0, DEF_MOVETYPE_RANDOM, &dX, &dY, cNpcWaypointIndex, NULL, NULL, cSide, FALSE, TRUE, FALSE, TRUE, NULL);
							if (bRet == FALSE) 
							{	m_pMapList[x]->SetNamingValueEmpty(iNamingValue);
							}else 
							{	m_pMapList[x]->GetOwner(&sOwnerH, &cOwnerType, dX, dY);
								if ((m_pNpcList[sOwnerH] != NULL) && (sOwnerH > 0) && (sOwnerH < DEF_MAXNPCS)) 
								{	m_pNpcList[sOwnerH]->m_iBuildCount = 0;								
									m_pNpcList[sOwnerH]->m_sAppr2 = 0;
									m_pNpcList[sOwnerH]->m_cSide = cSide;
								}
								if (cSide == 1)	m_iHeldenianAresdenLeftTower += 1;
								if (cSide == 2) m_iHeldenianElvineLeftTower += 1;
					}	}	}
					wsprintf(G_cTxt,"HeldenianAresdenLeftTower : %d , HeldenianElvineLeftTower : %d", m_iHeldenianAresdenLeftTower, m_iHeldenianElvineLeftTower);
					PutLogList(G_cTxt);
					PutLogEventFileList(G_cTxt);
					UpdateHeldenianStatus(-1);
				}
			}else if (m_cHeldenianType == 2) 
			{	// Set master flag
				if (strcmp(m_pMapList[x]->m_cName, "GodH") == 0) //	if (m_iGodHMapIndex == x) 
				{	__bSetOccupyFlag(x, m_pMapList[x]->m_sHeldenianWinningZoneX, m_pMapList[x]->m_sHeldenianWinningZoneY
							, m_sLastHeldenianWinner, 616, -1, TRUE); 
				}
				// Possibilty to set towers, detectors etc....
				if (strcmp(m_pMapList[x]->m_cName, "HRampart") == 0) 
				{	for (i = 0; i < MAX_HELDENIANTOWER; i++) 
					{	if (m_pMapList[x]->m_stHeldenianTower[i].sTypeID < 1)  break;
						if (m_pMapList[x]->m_stHeldenianTower[i].sTypeID > DEF_MAXNPCTYPES) break;
						iNamingValue = m_pMapList[x]->iGetEmptyNamingValue();						
						if (iNamingValue != -1) 
						{	dX = m_pMapList[x]->m_stHeldenianTower[i].dX;
							dY = m_pMapList[x]->m_stHeldenianTower[i].dY;
							cSide = m_sLastHeldenianWinner;
							ZeroMemory(cTmp, sizeof(cTmp));
							if ((m_pMapList[x]->m_stHeldenianTower[i].sTypeID == 87)&&(cSide == 1)) strcpy(cTmp, "CT-Aresden"); 
							if ((m_pMapList[x]->m_stHeldenianTower[i].sTypeID == 87)&&(cSide == 2)) strcpy(cTmp, "CT-Elvine"); 
							if ((m_pMapList[x]->m_stHeldenianTower[i].sTypeID == 89)&&(cSide == 1)) strcpy(cTmp, "AGC-Aresden"); 
							if ((m_pMapList[x]->m_stHeldenianTower[i].sTypeID == 89)&&(cSide == 2)) strcpy(cTmp, "AGC-Elvine"); 
							if ((m_pMapList[x]->m_stHeldenianTower[i].sTypeID == 36)&&(cSide == 1)) strcpy(cTmp, "AGT-Aresden"); 
							if ((m_pMapList[x]->m_stHeldenianTower[i].sTypeID == 36)&&(cSide == 2)) strcpy(cTmp, "AGT-Elvine"); 
							if ((m_pMapList[x]->m_stHeldenianTower[i].sTypeID == 37)&&(cSide == 1)) strcpy(cTmp, "CGT-Aresden"); 
							if ((m_pMapList[x]->m_stHeldenianTower[i].sTypeID == 37)&&(cSide == 2)) strcpy(cTmp, "CGT-Elvine"); 
							if ((m_pMapList[x]->m_stHeldenianTower[i].sTypeID == 39)&&(cSide == 1)) strcpy(cTmp, "DT-Aresden"); 
							if ((m_pMapList[x]->m_stHeldenianTower[i].sTypeID == 39)&&(cSide == 2)) strcpy(cTmp, "DT-Elvine"); 
							ZeroMemory(cName, sizeof(cName));
							wsprintf(cName, "XX%d", iNamingValue);
							cName[0] = 95;
							cName[1] = i + 65;
							bRet = bCreateNewNpc(cTmp, cName, m_pMapList[x]->m_cName, (rand() % 3), 0, DEF_MOVETYPE_RANDOM, &dX, &dY, cNpcWaypointIndex, NULL, NULL, cSide, FALSE, TRUE, FALSE, TRUE, NULL);
							if (bRet == FALSE) 
							{	m_pMapList[x]->SetNamingValueEmpty(iNamingValue);
							}else 
							{	m_pMapList[x]->GetOwner(&sOwnerH, &cOwnerType, dX, dY);
								if ((m_pNpcList[sOwnerH] != NULL) && (sOwnerH > 0) && (sOwnerH < DEF_MAXNPCS)) 
								{	m_pNpcList[sOwnerH]->m_iBuildCount = 0;							
									m_pNpcList[sOwnerH]->m_sAppr2 = 0;
									m_pNpcList[sOwnerH]->m_cSide = cSide;
				}	}	}	}	}
				// Set Gates
				if (strcmp(m_pMapList[x]->m_cName, "HRampart") == 0) 
				{	for (i = 0; i < DEF_MAXHELDENIANDOOR; i++) 
					{	if (m_pMapList[x]->m_stHeldenianGateDoor[i].dX < 1)  break;
						iNamingValue = m_pMapList[x]->iGetEmptyNamingValue();
						if (iNamingValue != -1) 
						{	dX = m_pMapList[x]->m_stHeldenianGateDoor[i].dX;
							dY = m_pMapList[x]->m_stHeldenianGateDoor[i].dY;
							ZeroMemory(cTmp, sizeof(cTmp));
							if (m_sLastHeldenianWinner == 1) strcpy(cTmp, "gate-a"); 
							else							 strcpy(cTmp, "gate-e"); 
							cSide = m_sLastHeldenianWinner;
							ZeroMemory(cName, sizeof(cName));
							wsprintf(cName, "XX%d", iNamingValue);
							cName[0] = 95;
							cName[1] = i + 65;
							bRet = bCreateNewNpc(cTmp, cName, m_pMapList[x]->m_cName, (rand() % 3), 0, DEF_MOVETYPE_RANDOM, &dX, &dY, cNpcWaypointIndex, NULL, NULL, m_sLastHeldenianWinner, FALSE, TRUE, FALSE, TRUE, NULL);
							if (bRet == FALSE) 
							{	m_pMapList[x]->SetNamingValueEmpty(iNamingValue);
							}else 
							{	m_pMapList[x]->GetOwner(&sOwnerH, &cOwnerType, dX, dY);
								if ((m_pNpcList[sOwnerH] != NULL) && (sOwnerH > 0) && (sOwnerH < DEF_MAXNPCS)) 
								{	m_pNpcList[sOwnerH]->m_iBuildCount = 0;
									m_pNpcList[sOwnerH]->m_cSide = cSide;
									m_pNpcList[sOwnerH]->m_cDir = m_pMapList[x]->m_stHeldenianGateDoor[i].cDir;
									wsprintf(G_cTxt,"(_) Gate installed at %d,%d", dX, dY);
									PutLogList(G_cTxt);
	}	}	}	}	}	}	}	}
	m_bIsHeldenianMode = TRUE;	
	m_dwHeldenianFinishTime   = timeGetTime() + m_dwHeldenianEndTime;  // war will end   in 1h45 
	m_dwHeldenianWarStartTime = timeGetTime() + m_dwHeldenianWarTime;  // war will start in 0h15
	wsprintf(G_cTxt,"(_) Heldenian mode ON. (type %d, last winner:%d)", m_cHeldenianType, m_sLastHeldenianWinner);
	PutLogList(G_cTxt);
	PutLogList(" ");
	PutLogEventFileList(G_cTxt);
	PutLogEventFileList(" ");
}
/*********************************************************************************************************************
**  void CGame::HeldenianStartWarNow()																				**
**  description		:: War will start 15 min after event beginning for players to prepare themselves       			**
**             		:: This function will start war																	**
**	Called on timer, by OnTimer																												**
*********************************************************************************************************************/
void CGame::HeldenianStartWarNow() 
{//PutLogList("Entree HeldenianStartWarNow");	
	if (m_bHeldenianWarInitiated == TRUE)	return; // Already started
	if (m_cHeldenianWinner != -1)			return; // Battle is already won
	DWORD dwTime = timeGetTime();
	if (dwTime < m_dwHeldenianWarStartTime) return;	// Not yet time to start battle
	m_bHeldenianWarInitiated = TRUE;	
	wsprintf(G_cTxt,"(!) HELDENIAN Start: Fighting starting now...");
	PutLogList(G_cTxt);
	PutLogEventFileList(G_cTxt);
register int i;
	// Tell clients that war has begun
	for (i = 0; i < DEF_MAXCLIENTS; i++) 
	{	if ((m_pClientList[i] != NULL) && (m_pClientList[i]->m_bIsInitComplete == TRUE))
		{	m_pClientList[i]->m_cVar = 2;
			SendNotifyMsg(NULL, i, DEF_NOTIFY_HELDENIANSTART,  NULL , NULL, NULL, NULL); // You can now, fight on the battle field
			UpdateHeldenianStatus(i);
	}	}
	for (i = 0; i < DEF_MAXNPCS; i++) // Remove summons from last Heldenian
	{	if (   (m_pNpcList[i] != NULL) && (m_pNpcList[i]->m_bIsKilled == FALSE) 
			&& (m_pMapList[m_pNpcList[i]->m_cMapIndex]->m_bIsHeldenianMap == TRUE) )
		{	if (m_pNpcList[i]->m_bIsSummoned == FALSE)
			{	m_pNpcList[i]->m_cSide = m_pNpcList[i]->m_cOriginalSide; // All mobs become aggressive again
	}	}	}
	if (m_iBTFieldMapIndex != -1)		
		_bCrusadeLog(DEF_CRUSADELOG_HELDENIANWARNOW, NULL, 0, NULL);
}
/*********************************************************************************************************************
**  void CGame::HeldenianVictoryNow(int iSide) 																		**
**  description		:: Called by meating a victory condition before maximum time					      			**
**             		:: Called when all tower destroyed (type 1) or when flag set (type 2)							**
**					:: Will recall all defeated characters, others can stay until normal end time					**
*********************************************************************************************************************/
void CGame::HeldenianVictoryNow(int iSide) 
{	if (m_bHeldenianWarInitiated == FALSE) return;
	DWORD dwTime = timeGetTime();
	m_bHeldenianWarInitiated = FALSE;	
	m_cHeldenianWinner = iSide;
	switch(m_cHeldenianWinner) {
	case 1: 
		wsprintf(G_cTxt, "Heldenian victory before allowed time, Aresden victory.");
		_bCrusadeLog(DEF_CRUSADELOG_HELDENIANVICTORY, NULL, (int)m_cHeldenianType, "Aresden victory.");		
		break;
	case 2: 
		wsprintf(G_cTxt, "Heldenian victory before allowed time, Elvine victory.");
		_bCrusadeLog(DEF_CRUSADELOG_HELDENIANVICTORY, NULL, (int)m_cHeldenianType, "Elvine victory.");
		break;
	default: 
		wsprintf(G_cTxt, "Heldenian victory before allowed time, Draw.");
		_bCrusadeLog(DEF_CRUSADELOG_HELDENIANVICTORY, NULL, (int)m_cHeldenianType, "Draw.");
		break;
	}
	PutLogList(G_cTxt);
	PutLogEventFileList(G_cTxt);	
	m_dwHeldenianFinishTime   = timeGetTime() + 5*60*1000;  // war will end in 5 minutes
	int m;	
register int j, n;
	for (m = 0; m < DEF_MAXMAPS; m++)
	{	if (m_pMapList[m] == NULL) break;
		if (m_pMapList[m]->m_bIsHeldenianMap == TRUE) 
		{	for (j = 0; j < DEF_MAXCLIENTS; j++)
			{	if (   (m_pClientList[j] != NULL)
					&& (m_pClientList[j]->m_bIsInitComplete == TRUE)
					&& (m_pClientList[j]->m_cMapIndex == m))
				{	UpdateHeldenianStatus(j);
					SendNotifyMsg(NULL, j, DEF_NOTIFY_HELDENIANVICTORY,  m_cHeldenianWinner, NULL, NULL, NULL); // Victory defeat screen
					if (   (m_pClientList[j]->m_cSide != iSide)// recall loosers only
						&& (m_pClientList[j]->m_iAdminUserLevel == 0))
					{	SendNotifyMsg(NULL, j, DEF_NOTIFY_0BE8, NULL , NULL, NULL, NULL);
						m_pClientList[j]->m_bIsWarLocation = TRUE;
						m_pClientList[j]->m_iTimeLeft_ForceRecall = 3;
						//RequestTeleportHandler(j, "1   ", NULL, -1, -1);
			}	}	}
			for (n = 0; n < DEF_MAXNPCS; n++)
			{	if (   (m_pNpcList[n] != NULL) 
					&& (m_pNpcList[n]->m_cMapIndex == m)
					&& (m_pNpcList[n]->m_cSide != iSide))
				{	if (m_pNpcList[n]->m_bIsSummoned == TRUE) 
					{	NpcKilledHandler(NULL, NULL, n, NULL);
					}else
					{	m_pNpcList[n]->m_cSide = 0; // All mobs become neutral as players no more have spells or attacks...
	}	}	}	}	}
}
/*********************************************************************************************************************
**  void CGame::HeldenianEndWarNow()																				**
**  description		:: Checks if Heldenian should be finished, and victory conditions                      			**
**             		:: used only on Heldenian server																**
**																													**
*********************************************************************************************************************/
void CGame::HeldenianEndWarNow()
{	if (m_bIsHeldenianMode == FALSE) return;
	DWORD dwTime = timeGetTime();
	if (dwTime < m_dwHeldenianFinishTime) return;
	if (m_cHeldenianType == 1) 
	{	if (m_iBTFieldMapIndex == -1) return;		
		// Type 1: BtField, victory depends on Tower destroyed...
		if (m_cHeldenianWinner == -1)
		{	if (m_iHeldenianAresdenLeftTower > m_iHeldenianElvineLeftTower) 
			{	m_cHeldenianWinner = 1;
			}else if (m_iHeldenianAresdenLeftTower < m_iHeldenianElvineLeftTower) 
			{	m_cHeldenianWinner = 2;
			}else if (m_iHeldenianAresdenFlags < m_iHeldenianElvineFlags)
			{	m_cHeldenianWinner = 1;
			}else if (m_iHeldenianAresdenFlags > m_iHeldenianElvineFlags) 
			{	m_cHeldenianWinner = 2;
			}else // 1st destroyed tower wins...
			{	m_cHeldenianWinner = m_cHeldenianFirstDestroyedTowerWinner;
		}	}		
	}else if (m_cHeldenianType == 2)
	{	if (m_iGodHMapIndex == -1) return;
		// Type 2: Victory for defenders if no victory before
		if (m_cHeldenianWinner == -1)
		{	m_cHeldenianWinner = m_sLastHeldenianWinner;
	}	}
	//bSendMsgToLS(MSGID_REQUEST_HELDENIAN_WINNER, NULL, 1, NULL);
	switch(m_cHeldenianWinner) {
	case 1: 
		wsprintf(G_cTxt, "Heldenian Terminated, Aresden victory.");
		_bCrusadeLog(DEF_CRUSADELOG_ENDHELDENIAN, NULL, (int)m_cHeldenianType, "Aresden victory.");
		break;
	case 2: 
		wsprintf(G_cTxt, "Heldenian Terminated, Elvine victory.");
		_bCrusadeLog(DEF_CRUSADELOG_ENDHELDENIAN, NULL, (int)m_cHeldenianType, "Elvine victory.");
		break;
	default: 
		wsprintf(G_cTxt, "Heldenian Terminated, Draw.");
		_bCrusadeLog(DEF_CRUSADELOG_ENDHELDENIAN, NULL, (int)m_cHeldenianType, "Draw.");
		break;
	}
	PutLogEventFileList(G_cTxt);
	PutLogList(G_cTxt);
	GlobalEndHeldenianMode();
}
/*********************************************************************************************************************
**  void CGame::ManualEndHeldenianMode(int iClientH, char *pData, DWORD dwMsgSize)									**
**  description		:: Called by Amin order, stops heldenian					                        			**
**             		:: "/endheldenian 0" or"/endheldenian 1" or "/endheldenian 2"									**
**																													**
*********************************************************************************************************************/
void CGame::ManualEndHeldenianMode(int iClientH, char *pData, DWORD dwMsgSize)
{char	seps[] = "= \t\n";
 char	* token, cBuff[256];
 class	CStrTok * pStrTok;
	if ((dwMsgSize)	<= 0) return;	
	if (iClientH == NULL) return;	
	if (m_bIsHeldenianMode == FALSE) return;
	if (m_pClientList[iClientH] == NULL) return;
	if (m_pClientList[iClientH]->m_iAdminUserLevel < m_iAdminLevelSpecialEvents)
	{	SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_ADMINUSERLEVELLOW, NULL, NULL, NULL, NULL);
		return;
	}
	if (m_pClientList[iClientH]->m_bIsAdminCommandEnabled == FALSE) return;

	ZeroMemory(cBuff, sizeof(cBuff));
	memcpy(cBuff, pData, dwMsgSize);
	pStrTok = new class CStrTok(cBuff, seps);
	token = pStrTok->pGet();
	token = pStrTok->pGet();
	if (token == NULL) // draw
	{	m_cHeldenianWinner = 0;
		wsprintf(G_cTxt,"GM Order(%s): Heldenian terminated, Draw", m_pClientList[iClientH]->m_cCharName);
	}else if (token != NULL) 
	{	if (_bGetIsStringIsNumber(token) == TRUE) 
		{	switch(atoi(token)) {
			case 1:
				m_cHeldenianWinner = 1;
				wsprintf(G_cTxt,"GM Order(%s): Heldenian terminated, Aresden victory", m_pClientList[iClientH]->m_cCharName);
				break;
			case 2:
				m_cHeldenianWinner = 2;
				wsprintf(G_cTxt,"GM Order(%s): Heldenian terminated, Elvine victory", m_pClientList[iClientH]->m_cCharName);
				break;
			default:	
				m_cHeldenianWinner = 0;
				wsprintf(G_cTxt,"GM Order(%s): Heldenian terminated, Draw", m_pClientList[iClientH]->m_cCharName);
				break;
			}
		}else 
		{	m_cHeldenianWinner = 0;	
			wsprintf(G_cTxt,"GM Order(%s): Heldenian terminated, Draw", m_pClientList[iClientH]->m_cCharName);
		}
	}
	PutAdminLogFileList(G_cTxt);
	PutLogEventFileList(G_cTxt);
	PutLogList(G_cTxt);
	GlobalEndHeldenianMode();
	delete pStrTok;
}
/*********************************************************************************************************************
**  void CGame::GlobalEndHeldenianMode()																			**
**  description		:: Called by admin command, or winning condition			                        			**
**             		:: Type 1: Last Tower destroyed																	**
**					:: Type 2: ???																					**
*********************************************************************************************************************/
void CGame::GlobalEndHeldenianMode()
{char * cp, cData[32];
	DWORD * dwp;
	if (m_cHeldenianWinner == -1) return;
	if (m_bIsHeldenianMode == FALSE) return;
	ZeroMemory(cData, sizeof(cData));
	cp = (char *)cData;
	*cp = GSM_ENDHELDENIAN;
	cp++;
	dwp = (DWORD *)cp;
	*dwp = m_dwHeldenianGUID;
	cp += 4;
	dwp = (DWORD *)cp;
	*dwp = (int)m_cHeldenianWinner;
	cp += 4;
	bStockMsgToGateServer(cData, 9);
	LocalEndHeldenianMode(m_dwHeldenianGUID, (int)m_cHeldenianWinner);
}
/*********************************************************************************************************************
**  void CGame::LocalEndHeldenianMode(DWORD dwHeldenianGUID, int iWinner)											**
**  description		:: Called by global end or Gate if global end commes from another gserver             			**
**             		:: & writes the GUID file																		**
**					::																								**
*********************************************************************************************************************/
void CGame::LocalEndHeldenianMode(DWORD dwHeldenianGUID, int iWinner)
{	if (m_bIsHeldenianMode == FALSE) return;
	wsprintf(G_cTxt, "(!) Received LocalEndHeldenian. (Winner %d)", iWinner);
	PutLogList(G_cTxt);
	m_bIsHeldenianMode		 = FALSE;
	m_bHeldenianWarInitiated = FALSE;	
	m_cHeldenianWinner		 = iWinner;
	m_sLastHeldenianWinner	 = iWinner;	
	m_dwHeldenianFinishTime   = 0;
	m_dwHeldenianWarStartTime = 0; 
	_CreateHeldenianGUID(m_dwHeldenianGUID, m_cHeldenianWinner);
	//bSendMsgToLS(MSGID_REQUEST_HELDENIAN_WINNER, NULL, 1, NULL);
int m;	
register int j, n;
	for (j = 0; j < DEF_MAXCLIENTS; j++)
	{	if (m_pClientList[j] == NULL)					 continue;
		if (m_pClientList[j]->m_bIsInitComplete != TRUE) continue;
		SendNotifyMsg(NULL, j, DEF_NOTIFY_HELDENIANEND, NULL, NULL, NULL, NULL);
		// DEF_NOTIFY_HELDENIANVICTORY used at XP time
		m_pClientList[j]->m_cVar = 0; // Client has been informed, he'll get XP
	}
	for (m = 0; m < DEF_MAXMAPS; m++)
	{	if (m_pMapList[m] == NULL) break;		
		if (m_pMapList[m]->m_bIsHeldenianMap == TRUE) 
		{	if (   (m_pMapList[m] != NULL) 
				&& (m_pMapList[m]->m_bChangedForCrusade == TRUE)
				&& (strcmp(m_pMapList[m]->m_cName, "BtField") == 0) )
			{	__bReadMapCrusadeInfo(m, FALSE);
			}			
			for (j = 0; j < DEF_MAXCLIENTS; j++)
			{	if (m_pClientList[j] == NULL)					 continue;
				if (m_pClientList[j]->m_bIsInitComplete != TRUE) continue;
				if (m_pClientList[j]->m_cMapIndex != m)			 continue;
				SendNotifyMsg(NULL, j, DEF_NOTIFY_0BE8, NULL , NULL, NULL, NULL);
				RequestTeleportHandler(j, "1   ", NULL, -1, -1);
			}
			for (n = 0; n < DEF_MAXNPCS; n++)
			{	if (   (m_pNpcList[n] != NULL) && (m_pMapList[m_pNpcList[n]->m_cMapIndex] != NULL) 
					&& (m_pNpcList[n]->m_cMapIndex == m))
				{	if (m_pNpcList[n]->m_bIsSummoned == TRUE) 
					{	NpcKilledHandler(NULL, NULL, n, NULL);
					}else
					{	m_pNpcList[n]->m_cSide = m_pNpcList[n]->m_cOriginalSide; // All mobs become agressive again
			}	}	}
			RemoveOccupyFlags(m);
	}	}
	wsprintf(G_cTxt,"(_) Heldenian Mode OFF.");
	PutLogList(G_cTxt);
	PutLogList(" ");
	PutLogEventFileList(G_cTxt);
	PutLogEventFileList(" ");
}
/*********************************************************************************************************************
**  BOOL CGame::CheckHeldenianResultCalculation(int iClientH)														**
**  description		:: Gives the XP to character, a few seconds after Heldenian has been closed	       				**
**             		:: 																								**
**	Called  by CheckClientResponseTime	( every 20 seconds)															**
*********************************************************************************************************************/
void CGame::CheckHeldenianResultCalculation(int iClientH)
{	if (m_pClientList[iClientH] == NULL) return;
	if (m_pClientList[iClientH]->m_cVar == 2) return; // Client must have been informed of heldenian end before getting XP
	if (   (m_bIsHeldenianMode == FALSE) 
		//&& (m_bIsCrusadeMode == FALSE)
		&& (m_pClientList[iClientH]->m_dwHeldenianGUID != 0))
	{	if (m_pClientList[iClientH]->m_iWarContribution > 0) //Character must have participated
		{	if (m_pClientList[iClientH]->m_iWarContribution > 100*1000) m_pClientList[iClientH]->m_iWarContribution = 100*1000;		
			// Inform client but not the player
			SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_CONSTRUCTIONPOINT, 0, 0, 1, NULL); 
			if (m_pClientList[iClientH]->m_dwHeldenianGUID == m_dwHeldenianGUID) 
			{	// Inform about victory:  Victory defeat screen
				SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_HELDENIANVICTORY,  m_cHeldenianWinner, NULL, NULL, NULL); 		
				if (m_pClientList[iClientH]->m_iLevel < 180)
				{	m_pClientList[iClientH]->m_iWarContribution += (200 - m_pClientList[iClientH]->m_iLevel)*100;
				}else m_pClientList[iClientH]->m_iWarContribution += 2000; // +2000..+19500	
// Draw: XP = WC
				if (m_cHeldenianWinner == 0) // Result = Draw
				{	// no XP: m_pClientList[iClientH]->m_iExpStock += (m_pClientList[iClientH]->m_iWarContribution);
				}else 
				{	if (m_cHeldenianWinner == m_pClientList[iClientH]->m_cSide) 
// Victory: XP = WCx3 	
					{	m_pClientList[iClientH]->m_iExpStock += m_pClientList[iClientH]->m_iWarContribution*3;
						//_bCrusadeLog(DEF_CRUSADELOG_GETHELDENIANEXP, iClientH, (m_pClientList[iClientH]->m_iWarContribution*3), NULL) ;
						wsprintf(G_cTxt, "Heldenian Exp:     PC(%s) Got %d xp."
							, m_pClientList[iClientH]->m_cCharName
							, m_pClientList[iClientH]->m_iWarContribution*3 );	
						PutLogList(G_cTxt);
						PutLogEventFileList(G_cTxt);
					}else if (m_cHeldenianWinner != m_pClientList[iClientH]->m_cSide)
// Defeat: XP = WC	
					{	m_pClientList[iClientH]->m_iExpStock += m_pClientList[iClientH]->m_iWarContribution;							
						//_bCrusadeLog(DEF_CRUSADELOG_GETHELDENIANEXP, iClientH, (m_pClientList[iClientH]->m_iWarContribution), NULL) ;
						wsprintf(G_cTxt, "Heldenian Exp:     PC(%s) Got %d xp."
							, m_pClientList[iClientH]->m_cCharName
							, m_pClientList[iClientH]->m_iWarContribution );	
						PutLogList(G_cTxt);
						PutLogEventFileList(G_cTxt);
		}	}	}	}
		m_pClientList[iClientH]->m_dwHeldenianGUID    = 0;
		m_pClientList[iClientH]->m_iWarContribution   = 0;
		m_pClientList[iClientH]->m_iConstructionPoint = 0;
		m_pClientList[iClientH]->m_dwXPHackCheckTime  = timeGetTime();
		m_pClientList[iClientH]->m_iXPHackCheckExp    = m_pClientList[iClientH]->m_iExp;
	}
}
/*********************************************************************************************************************
**  BOOL CGame::UpdateHeldenianStatus(int iClientH)																	**
**  description		:: Informs every client of the progression of the battle (Type 1 Heldenian)	           			**
**             		:: give -1 as parameter to inform everybody on BtField.											**
**					:: give iClientH to inform only one client														**
*********************************************************************************************************************/
BOOL CGame::UpdateHeldenianStatus(int iClientH)
{	if (m_bIsHeldenianMode == FALSE)  return FALSE;
	if (m_cHeldenianType != 1)		  return FALSE; 
	if (iClientH != -1) 
	{	if (   (m_pClientList[iClientH] != NULL) 
		//	&& (m_pClientList[iClientH]->m_bIsInitComplete == TRUE)
			&& (m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_bIsHeldenianMap == TRUE) 
			&& (m_pClientList[iClientH]->m_cMapIndex == m_iBTFieldMapIndex)) 
		{	SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_HELDENIANCOUNT, m_iHeldenianAresdenLeftTower
							, m_iHeldenianElvineLeftTower, m_iHeldenianAresdenFlags, NULL, m_iHeldenianElvineFlags, NULL);
			return TRUE;
		}
	}else // Update for everybody
	{
BOOL bFlag = TRUE;
int iShortCutIndex = 0;
int i;
		while(bFlag)
		{	i = m_iClientShortCut[iShortCutIndex];
			iShortCutIndex++;
			if (i == 0) 
			{	bFlag = FALSE;	
			}else
			{	if (   (m_pClientList[i] != NULL) 
					&& (m_pClientList[i]->m_bIsInitComplete == TRUE)
					&& (m_pMapList[m_pClientList[i]->m_cMapIndex]->m_bIsHeldenianMap == TRUE) 
					&& (m_pClientList[i]->m_cMapIndex == m_iBTFieldMapIndex)) 
				{	SendNotifyMsg(NULL, i, DEF_NOTIFY_HELDENIANCOUNT, m_iHeldenianAresdenLeftTower
								, m_iHeldenianElvineLeftTower, m_iHeldenianAresdenFlags, NULL, m_iHeldenianElvineFlags, NULL);
	}	}	}	}
	return TRUE;
}
/*********************************************************************************************************************
**  BOOL CGame::bCheckHeldenianMap(int sAttackerH, char cType)														**
**  description			:: checks if the player is in the specified map, and allowed for extra damage				**
**  commentary			::	-	translated from scratch using IDA Pro												**
**						::	-	changed pTile->m_cOwner to m_iOccupyStatus											**
**						::	-	added check to prevent access violation if pTile == NULL							**
**						::	-	removed 4 return(s) after "iRet = 1;" and placed at end								**
*********************************************************************************************************************/
BOOL CGame::bCheckHeldenianMap(int sAttackerH, char cType) 
{	if (m_bHeldenianWarInitiated == FALSE) return FALSE;
 short tX, tY;
 BOOL iRet;
 int  iMapIndex;
 class CTile * pTile;
	iRet = FALSE;
	if (cType == DEF_OWNERTYPE_PLAYER) 
	{	if (m_pClientList[sAttackerH] == NULL)					return FALSE;
		if (m_pClientList[sAttackerH]->m_cSide < 1)				return FALSE;
		if (m_pClientList[sAttackerH]->m_cSide > 2)				return FALSE;
		iMapIndex = m_pClientList[sAttackerH]->m_cMapIndex;
		if (m_pMapList[iMapIndex]->m_bIsHeldenianMap != TRUE)	return FALSE;
		if (m_iGodHMapIndex  == iMapIndex)						return FALSE;
		tX = m_pClientList[sAttackerH]->m_sX;
		tY = m_pClientList[sAttackerH]->m_sY;
		if (   (tX <= 0) || (tX >= m_pMapList[iMapIndex]->m_sSizeX) 
			|| (tY <= 0) || (tY >= m_pMapList[iMapIndex]->m_sSizeY)) return FALSE;
		pTile = (class CTile *)(m_pMapList[iMapIndex]->m_pTile + tX + tY*m_pMapList[iMapIndex]->m_sSizeY);
		if (pTile == NULL) return FALSE;
		if (pTile->m_iOccupyStatus != NULL) 
		{	if (pTile->m_iOccupyStatus < 0) 
			{	if (m_pClientList[sAttackerH]->m_cSide == 1) 
				{	iRet = TRUE;
				}
			}else if (pTile->m_iOccupyStatus > 0) 
			{	if (m_pClientList[sAttackerH]->m_cSide == 2) 
				{	iRet = TRUE;
		}	}	}		
	}else if (cType == DEF_OWNERTYPE_NPC) 
	{	if (m_pNpcList[sAttackerH] == NULL)						return FALSE;
		if (m_pNpcList[sAttackerH]->m_cSide < 1)				return FALSE;
		if (m_pNpcList[sAttackerH]->m_cSide > 2)				return FALSE;
		iMapIndex = m_pNpcList[sAttackerH]->m_cMapIndex;
		if (m_pMapList[iMapIndex]->m_bIsHeldenianMap != TRUE)	return FALSE;	
		if (m_iGodHMapIndex  == iMapIndex)						return FALSE;
		tX = m_pNpcList[sAttackerH]->m_sX;
		tY = m_pNpcList[sAttackerH]->m_sY;
		if (   (tX <= 0) || (tX >= m_pMapList[iMapIndex]->m_sSizeX) 
			|| (tY <= 0) || (tY >= m_pMapList[iMapIndex]->m_sSizeY)) return FALSE;
		pTile = (class CTile *)(m_pMapList[iMapIndex]->m_pTile + tX + tY*m_pMapList[iMapIndex]->m_sSizeY);
		if (pTile == NULL) return FALSE;
		if (pTile->m_iOccupyStatus != NULL) 
		{	if (pTile->m_iOccupyStatus < 0) 
			{	if (m_pNpcList[sAttackerH]->m_cSide == 1) 
				{	iRet = TRUE;
				}
			}else if (pTile->m_iOccupyStatus > 0) 
				{	if (m_pNpcList[sAttackerH]->m_cSide == 2) 
				{	iRet = TRUE;
	}	}	}	}
	return iRet;
}
/*********************************************************************************************************************
**  BOOL CGame::RequestHeldenianTeleportList(int iClientH, char * pData, DWORD dwMsgSize)								**
**  description		:: A player requested to go Heldenian maps...										 			**
**             		:: 																								**
**					::																								**
*********************************************************************************************************************/
void CGame::RequestHeldenianTeleportList(int iClientH, char * pData, DWORD dwMsgSize)
{	if (m_pClientList[iClientH] == NULL) return;
	if (m_pClientList[iClientH]->m_bIsInitComplete == FALSE) return;
	if (m_pClientList[iClientH]->m_bIsKilled == TRUE) return;
	if (m_pClientList[iClientH]->m_bIsOnWaitingProcess == TRUE) return;
	if (m_pClientList[iClientH]->m_iLockedMapTime != NULL) 
	{	SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_LOCKEDMAP, m_pClientList[iClientH]->m_iLockedMapTime, NULL, NULL, m_pClientList[iClientH]->m_cLockedMapName);
		return;
	}
	// Prevent hack use in target maps
//	if ((m_iMiddlelandMapIndex != -1) && (m_pClientList[iClientH]->m_cMapIndex == m_iMiddlelandMapIndex)) return;
	if ((m_iBTFieldMapIndex != -1)    && (m_pClientList[iClientH]->m_cMapIndex == m_iBTFieldMapIndex)   ) return;
	if ((m_iGodHMapIndex != -1)       && (m_pClientList[iClientH]->m_cMapIndex == m_iGodHMapIndex)      ) return;
char	*cp, cData[512];
int		iRet;
DWORD	*dwp;
WORD	*wp;
int		*listCount;
char	cNpcName[21];
int		*ip;
int		index = 0;
int		m_iDestinationX, m_iDestinationY, m_iCost;
char	m_cTargetMap[11];
	cp = (char *)(pData + DEF_INDEX2_MSGTYPE + 2);
	ZeroMemory(cNpcName, sizeof(cNpcName));
	strncpy(cNpcName, cp, 20);
	cp += 20;
	ZeroMemory(cData, sizeof(cData));
	dwp  = (DWORD *)(cData + DEF_INDEX4_MSGID);
	*dwp = MSGID_RESPONSE_HELDENIAN_TP_LIST;
	wp   = (WORD *)(cData + DEF_INDEX2_MSGTYPE);
	*wp  = DEF_MSGTYPE_CONFIRM;
	cp = cData + 6;
	listCount = (int*) cp; 
	*listCount = 0;
	cp += 4; // sizeof(int)
	// Message must be sent by Gail...
	if (strcmp(cNpcName, "Gail") != 0) return;
	if (   (m_bIsHeldenianMode == TRUE) 
		&& (m_pClientList[iClientH]->m_bIsPlayerCivil != TRUE) 
		&& (m_cHeldenianWinner == -1) // Not possible to TP if already won
		&& ((m_pClientList[iClientH]->m_cSide == 2) || (m_pClientList[iClientH]->m_cSide ==1) )) 
	{	if (m_cHeldenianType == 2) 
		{	ZeroMemory(m_cTargetMap, sizeof(m_cTargetMap));	
			memcpy(m_cTargetMap, "HRampart", 8);
			if (m_pClientList[iClientH]->m_cSide == m_sLastHeldenianWinner) 
			{	m_iDestinationX = 81;
				m_iDestinationY = 42;
				m_iCost			= 0;	
				index			= 3;			
			}else 
			{	m_iDestinationX = 156;
				m_iDestinationY = 153;
				m_iCost			= 0;	
				index			= 4;	
			}
		}else //if (m_cHeldenianType == 1) // Players can go fight Heldenian
		{	ZeroMemory(m_cTargetMap, sizeof(m_cTargetMap));	
			memcpy(m_cTargetMap, "BtField", 7);
			if (m_pClientList[iClientH]->m_cSide == 1) 
			{	m_iDestinationX = 68;
				m_iDestinationY = 225;
				m_iCost = 0;
				index = 1;
			}else 
			{	m_iDestinationX = 202;
				m_iDestinationY = 70;
				m_iCost = 0;
				index = 2;		
		} 	}
		ip = (int*) cp;
		*ip = index;
		cp += 4;
		memcpy(cp, m_cTargetMap, 10);
		cp += 10;
		ip = (int*) cp;
		*ip = m_iDestinationX;
		cp += 4;
		ip = (int*) cp;
		*ip = m_iDestinationY;
		cp += 4;
		ip = (int*) cp;
		*ip = m_iCost;
		cp += 4;
		(*listCount) ++;
	}
	if (   (m_bIsHeldenianMode == FALSE) 
		&& (m_pClientList[iClientH]->m_bIsPlayerCivil != TRUE) 
		&& (m_sLastHeldenianWinner ==  m_pClientList[iClientH]->m_cSide)) 
// Winners of previous Heldenian can go to BattleField all the time
	{	ZeroMemory(m_cTargetMap, sizeof(m_cTargetMap));			
		memcpy(m_cTargetMap, "BtField", 7);
		if (m_pClientList[iClientH]->m_cSide == 1) 
		{	m_iDestinationX = -1;
			m_iDestinationY = -1;
			m_iCost			= 4000;	
			index			= 11;
		}else //if (m_pClientList[iClientH]->m_cSide == 2) 
		{	m_iDestinationX = -1;
			m_iDestinationY = -1;
			m_iCost			= 4000;
			index			= 12;
		}
		ip = (int*) cp;
		*ip = index;
		cp += 4;
		memcpy(cp, m_cTargetMap, 10);
		cp += 10;
		ip = (int*) cp;
		*ip = m_iDestinationX;
		cp += 4;
		ip = (int*) cp;
		*ip = m_iDestinationY;
		cp += 4;
		ip = (int*) cp;
		*ip = m_iCost;
		cp += 4;
		(*listCount) ++;
		ZeroMemory(m_cTargetMap, sizeof(m_cTargetMap));			
		memcpy(m_cTargetMap, "middleland", 10);
		m_iDestinationX = 388+iDice(1,10);
		m_iDestinationY = 262+iDice(1,10);
		m_iCost			= 1000;
		index			= 10;
		ip = (int*) cp;
		*ip = index;
		cp += 4;
		memcpy(cp, m_cTargetMap, 10);
		cp += 10;
		ip = (int*) cp;
		*ip = m_iDestinationX;
		cp += 4;
		ip = (int*) cp;
		*ip = m_iDestinationY;
		cp += 4;
		ip = (int*) cp;
		*ip = m_iCost;
		cp += 4;
		(*listCount) ++;
	}
	if ( (*listCount) == 0 )*wp  = DEF_MSGTYPE_REJECT;
	iRet = m_pClientList[iClientH]->m_pXSock->iSendMsg(cData, 10 + (*listCount) * 26 );
	switch (iRet) {
	case DEF_XSOCKEVENT_QUENEFULL:
	case DEF_XSOCKEVENT_SOCKETERROR:
	case DEF_XSOCKEVENT_CRITICALERROR:
	case DEF_XSOCKEVENT_SOCKETCLOSED:
		DeleteClient(iClientH, TRUE, TRUE);
		return;
	}
}
/*********************************************************************************************************************
**  BOOL CGame::RequestHeldenianTeleportNow(int iClientH, char * pData, DWORD dwMsgSize)							**
**  description		:: Suposed to be free TP to ML for heldenian winners								 			**
**  TP is available from Gail, here, but winner TP is also available at CH for higher price							**
*********************************************************************************************************************/
void CGame::RequestHeldenianTeleportNow(int iClientH, char * pData, DWORD dwMsgSize)
{	if (m_pClientList[iClientH] == NULL) return;
	if (m_pClientList[iClientH]->m_bIsInitComplete == FALSE) return;
	if (m_pClientList[iClientH]->m_bIsKilled == TRUE) return;
	if (m_pClientList[iClientH]->m_bIsOnWaitingProcess == TRUE) return;
int		m_iDestinationX, m_iDestinationY, m_iCost;
char	m_cTargetMap[11];
ZeroMemory(m_cTargetMap, sizeof(m_cTargetMap));	
	char	*cp, cData[64];
	int		iRet;
	DWORD	*dwp;
	WORD	*wp;
	int		index;
	WORD	wConfirm = DEF_MSGTYPE_CONFIRM;
	short	sError = 0;
	// CHARGED_TELEPORT index
	cp = (char *)(pData + DEF_INDEX2_MSGTYPE + 2);
	index = (int) (*cp);
	cp += 4;
	switch (index) {
	default: // Other Heldenian TP  (hack?)
		wConfirm = DEF_MSGTYPE_REJECT;
		sError = 7;
		break;
	case 1: // Ares TP to BtField, Heldenian time	
		if ((m_bIsHeldenianMode == FALSE) || (m_cHeldenianType != 1))			
		{	wConfirm = DEF_MSGTYPE_REJECT;
			sError = 7;
		}else
		{	memcpy(m_cTargetMap, "BtField", 7);
			m_iDestinationX = 68;
			m_iDestinationY = 225;
			m_iCost = 0;
		}
		break;
	case 2: // Elvi TP to BtField, Heldenian time	
		if ((m_bIsHeldenianMode == FALSE) || (m_cHeldenianType != 1))	
		{	wConfirm = DEF_MSGTYPE_REJECT;
			sError = 7;
		}else
		{	memcpy(m_cTargetMap, "BtField", 7);
			m_iDestinationX = 202;
			m_iDestinationY = 70;
			m_iCost = 0;
		}		
		break;
	case 3: // Winners TP to Rampart, Heldenian time
	case 4: // Loosers TP to Rampart, Heldenian time	
		if ((m_bIsHeldenianMode == FALSE) || (m_cHeldenianType != 2))
		{	wConfirm = DEF_MSGTYPE_REJECT;
			sError = 7;
		}else
		{	memcpy(m_cTargetMap, "HRampart", 8);				
			if (m_pClientList[iClientH]->m_cSide == m_sLastHeldenianWinner) 
			{	m_iDestinationX = 81;
				m_iDestinationY = 42;
				m_iCost			= 0;			
			}else 
			{	m_iDestinationX = 156;
				m_iDestinationY = 153;
				m_iCost			= 0;		
		}	}
		break;	
	case 10: // Winner TP to ML (near TOH)		
		if (   (m_bIsHeldenianMode == TRUE) 
			|| (m_pClientList[iClientH]->m_bIsPlayerCivil == TRUE) 
			|| (m_sLastHeldenianWinner !=  m_pClientList[iClientH]->m_cSide)) 
		{	wConfirm = DEF_MSGTYPE_REJECT;
			sError = 7;
		}else
		{	memcpy(m_cTargetMap, "middleland", 10);				
			m_iDestinationX = 388 + iDice(1,10);
			m_iDestinationY = 262 + iDice(1,10);
			m_iCost			= 1000;			
		}
		break;
	case 11: // Winner Ares TP to BtField	
	case 12: // Winner Elvi TP to BtField
		if (   (m_bIsHeldenianMode == TRUE) 
			|| (m_pClientList[iClientH]->m_bIsPlayerCivil == TRUE) 
			|| (m_sLastHeldenianWinner !=  m_pClientList[iClientH]->m_cSide)) 	
		{	wConfirm = DEF_MSGTYPE_REJECT;
			sError = 7;
		}else
		{	memcpy(m_cTargetMap, "BtField", 7);
			if (m_pClientList[iClientH]->m_cSide == 1) 
			{	m_iDestinationX = -1;
				m_iDestinationY = -1;
				m_iCost			= 4000;	
			}else if (m_pClientList[iClientH]->m_cSide == 2) 
			{	m_iDestinationX = -1;
				m_iDestinationY = -1;
				m_iCost			= 4000;
			}else
			{	wConfirm = DEF_MSGTYPE_REJECT;
				sError = 7;
		}	}
		break;
	}
	if (wConfirm == DEF_MSGTYPE_CONFIRM )
	{	DWORD dwGoldCount = dwGetItemCount(iClientH, "Gold");
		if( dwGoldCount >= m_iCost )
		{	int iGoldWeight = SetItemCount(iClientH, "Gold", dwGoldCount - m_iCost);
			iCalcTotalWeight(iClientH);
			m_stCityStatus[m_pClientList[iClientH]->m_cSide].iFunds += m_iCost;
		}else
		{	wConfirm = DEF_MSGTYPE_REJECT;
			sError = 6;
	}	}
	// Invalid Charged-teleport
	if ( wConfirm == DEF_MSGTYPE_REJECT )
	{	ZeroMemory(cData, sizeof(cData));
		dwp  = (DWORD *)(cData + DEF_INDEX4_MSGID);
		*dwp = MSGID_RESPONSE_CHARGED_TELEPORT;
		wp   = (WORD *)(cData + DEF_INDEX2_MSGTYPE);
		*wp  = wConfirm;
		cp = cData + DEF_INDEX2_MSGTYPE + 2;
		short	*sp;
		sp	= (short*) cp;
		*sp	= sError;
		cp += 2;
		// Teleport List
		iRet = m_pClientList[iClientH]->m_pXSock->iSendMsg(cData, 6 + 2 );
		switch (iRet) {
		case DEF_XSOCKEVENT_QUENEFULL:
		case DEF_XSOCKEVENT_SOCKETERROR:
		case DEF_XSOCKEVENT_CRITICALERROR:
		case DEF_XSOCKEVENT_SOCKETCLOSED:
			DeleteClient(iClientH, TRUE, TRUE);
			return;
		}
		return;
	}
	// teleport
	RequestTeleportHandler(iClientH, "2   ", m_cTargetMap, m_iDestinationX, m_iDestinationY);	
}
/*********************************************************************************************************************
**  BOOL CGame::RequestHeldenianScroll(int iClientH, char * pData, DWORD dwMsgSize)									**
**  description		:: A player requested some scroll										 						**
**  Scrolls are only available for current battle, and usable only by the player that brought it					**					::																								**
*********************************************************************************************************************/
void CGame::RequestHeldenianScroll(int iClientH, char * pData, DWORD dwMsgSize)
{char  *cp, cData[256], cTmpName[21];
 int   iItemNbe;
 class CItem * pItem;
 int   iRet, iEraseReq, iNeededPts;
 short * sp;
 WORD  * wp;
// int   * ip;
 DWORD * dwp;
	if (m_pClientList[iClientH] == NULL)					 return;
	if (m_pClientList[iClientH]->m_bIsInitComplete == FALSE) return;
	if (m_bIsHeldenianMode == FALSE)						 return;
	if (_iGetItemSpaceLeft(iClientH) == 0) 
	{	SendItemNotifyMsg(iClientH,	DEF_NOTIFY_CANNOTCARRYMOREITEM, NULL, NULL);
		return;
	}
	cp = (char *)(pData + DEF_INDEX2_MSGTYPE + 2);
	ZeroMemory(cTmpName, sizeof(cTmpName));
	strcpy(cTmpName, cp);
	cp += 20;
	wp = (WORD *)cp;
	iItemNbe = (int) *wp; // 0x00 l a i
	cp += 2;
	wsprintf(G_cTxt, "PC(%s) obtained a summon scroll (%d).   %s(%d %d)"
			, m_pClientList[iClientH]->m_cCharName
			, iItemNbe
			, m_pClientList[iClientH]->m_cMapName
			, m_pClientList[iClientH]->m_sX
			, m_pClientList[iClientH]->m_sY);	
	PutLogList(G_cTxt);	
	switch (iItemNbe) {
	case 875: // Sorceress
		iNeededPts = 2000;
		break;
	case 876: // Ancient Temple Knight
		iNeededPts = 3000;
		break;
	case 877: // Elf Master
		iNeededPts = 1500;
		break;
	case 878: // DarkShadow Knight
		iNeededPts = 3000;
		break;
	case 879: // Heavy Battle Tank
		iNeededPts = 4000;
		break;
	case 880: // Barbarian
		iNeededPts = 3000;
		break;
	default:
		iNeededPts = 999999;
		PutLogList("Gail asked to create a wrong item!");	
		break;
	}
	if (m_pClientList[iClientH]->m_iConstructionPoint < iNeededPts)
	{	// Unable to get item...
	}else
	{	// Get the scroll
		m_pClientList[iClientH]->m_iConstructionPoint -= iNeededPts;
		SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_CONSTRUCTIONPOINT, m_pClientList[iClientH]->m_iConstructionPoint, m_pClientList[iClientH]->m_iWarContribution, 0, NULL); // 0:tell client
	}
	// Them create the summonScroll
	pItem = NULL;
	pItem = new class CItem;
	if (pItem == NULL) return;
	if ((_bInitItemAttr(pItem, iItemNbe) == TRUE)) 
	{	pItem->m_sTouchEffectType = DEF_ITET_UNIQUE_OWNER;
		pItem->m_sTouchEffectValue1 = m_pClientList[iClientH]->m_sCharIDnum1;
		pItem->m_sTouchEffectValue2 = m_pClientList[iClientH]->m_sCharIDnum2;
		pItem->m_sTouchEffectValue3 = m_pClientList[iClientH]->m_sCharIDnum3;
		//pItem->m_dwAttribute        = m_dwHeldenianGUID;
		memcpy(&pItem->m_sItemSpecEffectValue1, &m_dwHeldenianGUID, 4);
		//	pItem->m_sItemSpecEffectValue1  && pItem->m_sItemSpecEffectValue2

		if (_bAddClientItemList(iClientH, pItem, &iEraseReq) == TRUE) 
		{	ZeroMemory(cData, sizeof(cData));
			dwp  = (DWORD *)(cData + DEF_INDEX4_MSGID);
			*dwp = MSGID_NOTIFY;
			wp   = (WORD *)(cData + DEF_INDEX2_MSGTYPE);
			*wp  = DEF_NOTIFY_ITEMOBTAINED;				
			cp = (char *)(cData + DEF_INDEX2_MSGTYPE + 2);				
			*cp = 1;
			cp++;				
			memcpy(cp, pItem->m_cName, 20);
			cp += 20;				
			dwp  = (DWORD *)cp;
			*dwp = pItem->m_dwCount;
			cp += 4;				
			*cp = pItem->m_cItemType;
			cp++;				
			*cp = pItem->m_cEquipPos;
			cp++;				
			*cp = (char)0; 
			cp++;				
			sp  = (short *)cp;
			*sp = pItem->m_sLevelLimit;
			cp += 2;				
			*cp = pItem->m_cGenderLimit;
			cp++;				
			wp = (WORD *)cp;
			*wp = pItem->m_wCurLifeSpan;
			cp += 2;				
			wp = (WORD *)cp;
			*wp = pItem->m_wWeight;
			cp += 2;				
			sp  = (short *)cp;
			*sp = pItem->m_sSprite;
			cp += 2;				
			sp  = (short *)cp;
			*sp = pItem->m_sSpriteFrame;
			cp += 2;
			*cp = pItem->m_cItemColor;
			cp++;
			*cp = (char)pItem->m_sItemSpecEffectValue2; // v1.41 
			cp++;				
			dwp = (DWORD *)cp;
			*dwp = pItem->m_dwAttribute;
			cp += 4;
			if (iEraseReq == 1) delete pItem;				
			iRet = m_pClientList[iClientH]->m_pXSock->iSendMsg(cData, 53);
			switch (iRet) {
			case DEF_XSOCKEVENT_QUENEFULL:
			case DEF_XSOCKEVENT_SOCKETERROR:
			case DEF_XSOCKEVENT_CRITICALERROR:
			case DEF_XSOCKEVENT_SOCKETCLOSED:
				DeleteClient(iClientH, TRUE, TRUE);
				break;
			}
		}else 
		{	m_pMapList[ m_pClientList[iClientH]->m_cMapIndex ]->bSetItem(m_pClientList[iClientH]->m_sX, 
				                                                         m_pClientList[iClientH]->m_sY, pItem);			
			SendEventToNearClient_TypeB(MSGID_EVENT_COMMON, DEF_COMMONTYPE_ITEMDROP, m_pClientList[iClientH]->m_cMapIndex,
				                        m_pClientList[iClientH]->m_sX, m_pClientList[iClientH]->m_sY,  
				                        pItem->m_sSprite, pItem->m_sSpriteFrame, pItem->m_cItemColor); // v1.4			
			dwp  = (DWORD *)(cData + DEF_INDEX4_MSGID);
			*dwp = MSGID_NOTIFY;
			wp   = (WORD *)(cData + DEF_INDEX2_MSGTYPE);
			*wp  = DEF_NOTIFY_CANNOTCARRYMOREITEM;				
			iRet = m_pClientList[iClientH]->m_pXSock->iSendMsg(cData, 6);
			switch (iRet) {
			case DEF_XSOCKEVENT_QUENEFULL:
			case DEF_XSOCKEVENT_SOCKETERROR:
			case DEF_XSOCKEVENT_CRITICALERROR:
			case DEF_XSOCKEVENT_SOCKETCLOSED:
				DeleteClient(iClientH, TRUE, TRUE);
				break;
		}	}
	}else 
	{	delete pItem;
		pItem = NULL;
	}
}

/*********************************************************************************************************************
**  BOOL CGame::__bSetOccupyFlag(char cMapIndex,int dX,int dY,int iSide,int iEKNum,int iClientH,BOOL bAutoFlag)		**
**  description		:: A player has used a Flag during Heldenian event...        									**
**             		:: 																								**
**	Called when player sets a flag, or at Heldenian Type 2 beginning												**
*********************************************************************************************************************/
BOOL CGame::__bSetOccupyFlag(char cMapIndex, int dX, int dY, int iSide, int iEKNum, int iClientH, BOOL bAutoFlag)
{register int ix,iy;
 int   iDynamicObjectIndex, iIndex;
 class CTile * pTile;
 DWORD dwTime = timeGetTime();	
	if (m_pMapList[cMapIndex] == NULL)									return FALSE;
	if ((m_bHeldenianWarInitiated == FALSE)&&(bAutoFlag == FALSE))		return FALSE; // War must be started is player flag
	if (m_cHeldenianWinner != -1)										return FALSE; // War must not be finished
	if ((m_cHeldenianType == 1) && (m_iBTFieldMapIndex != cMapIndex))	return FALSE; // Type 1: only on BattleField
	if (   (m_cHeldenianType == 2) && (m_iRampartMapIndex != cMapIndex)				  // Type 2: 
		&& (m_iGodHMapIndex  != cMapIndex))                             return FALSE; // allowed only in HRampart / GodH
	if (   (m_cHeldenianType == 2) 										   			  // Type 2: 
		&& (m_iGodHMapIndex  == cMapIndex)											  // on GodH, allowed only
		&& (bAutoFlag == FALSE)														  // as autoflag
		&& (m_pClientList[iClientH] != NULL))									
	{	if (m_pClientList[iClientH]->m_cSide == m_sLastHeldenianWinner) return FALSE; // for attackers only
		if (m_pClientList[iClientH]->m_iGuildRank != 0)					return FALSE; // for a gm only
		if (   (abs(m_pMapList[cMapIndex]->m_sHeldenianWinningZoneX - dX) > 2)
			|| (abs(m_pMapList[cMapIndex]->m_sHeldenianWinningZoneY - dY) > 2)) return FALSE; // and in wining zone only
	}	
	if (   (dX < 25) || (dX >= m_pMapList[cMapIndex]->m_sSizeX - 25)
		|| (dY < 25) || (dY >= m_pMapList[cMapIndex]->m_sSizeY - 25))	return FALSE;

	pTile = (class CTile *)(m_pMapList[cMapIndex]->m_pTile + dX + dY*m_pMapList[cMapIndex]->m_sSizeY);
	if (pTile->m_iAttribute != NULL)									return FALSE;
	if (pTile->m_iOccupyFlagIndex != NULL)								return FALSE;
	if (pTile->m_bIsMoveAllowed == FALSE)								return FALSE;
	if (m_pMapList[cMapIndex]->m_iTotalOccupyFlags >= DEF_MAXOCCUPYFLAG) 
	{	return FALSE;
	}
	if (bAutoFlag == FALSE) // Flag set by a character
	{	if (m_pClientList[iClientH] == NULL) return FALSE;	
		switch (m_pClientList[iClientH]->m_cSide) {
		case 1:	// Aresden
			iDynamicObjectIndex = iAddDynamicObjectList(NULL, NULL, DEF_DYNAMICOBJECT_ARESDENFLAG1, cMapIndex, dX, dY, NULL, NULL);	
			break;
		case 2: // Elvine	
			iDynamicObjectIndex = iAddDynamicObjectList(NULL, NULL, DEF_DYNAMICOBJECT_ELVINEFLAG1, cMapIndex, dX, dY, NULL, NULL);	
			break;
		default: // Others
			return FALSE;
			break;
		}	
		if (iDynamicObjectIndex == NULL) return FALSE;
		iIndex = m_pMapList[cMapIndex]->iRegisterOccupyFlag(dX, dY, iSide, iEKNum, iDynamicObjectIndex);
		if (iIndex == -1) PutLogList("Error registering OccupyFlag.");	
		for (ix = dX-iEKNum; ix <= dX+iEKNum; ix++) 
		for (iy = dY-iEKNum; iy <= dY+iEKNum; iy++) 
		{	if ((ix == dX) && (iy == dY)) 
			{}else 
			{	pTile = (class CTile *)(m_pMapList[cMapIndex]->m_pTile + ix + iy*m_pMapList[cMapIndex]->m_sSizeY);			
				if (pTile->m_iOccupyFlagIndex == NULL) 
				{	switch (m_pClientList[iClientH]->m_cSide) {
					case 1:	// Aresden 
						pTile->m_iOccupyStatus -= iEKNum; 
						break;
					case 2: // Elvine	
						pTile->m_iOccupyStatus += iEKNum; 
						break;
					default:
						pTile->m_iOccupyStatus = 0;
						break;
		}	}	}	}
		switch (m_pClientList[iClientH]->m_cSide) {
		case 1:	// Aresden 
			m_iHeldenianAresdenFlags ++;
			break;
		case 2: // Elvine	
			m_iHeldenianElvineFlags ++;				
			break;
		}
		wsprintf(G_cTxt, "PC(%s) \tused Flag...\t%s(%d %d)"
			, m_pClientList[iClientH]->m_cCharName
			, m_pClientList[iClientH]->m_cMapName
			, dX
			, dY);
		PutItemLogFileList(G_cTxt);
		PutLogEventFileList(G_cTxt);
		PutLogList(G_cTxt);	
		// Heldenian type 2 is won !
		if (   (m_pClientList[iClientH]->m_iGuildRank == 0)					// only by GuildMaster
			&& (m_pClientList[iClientH]->m_cSide != m_sLastHeldenianWinner) // only by attacker side
			&& (m_iGodHMapIndex == cMapIndex))								// only on GodHMap
		{	m_pClientList[iClientH]->m_iWarContribution   += (1000 * iEKNum); // double bonus for gm putting the flag...
			HeldenianVictoryNow(m_pClientList[iClientH]->m_cSide);
		}
		// give some Summon points in case the character was killed, he will be able to catch more scrolls..
		m_pClientList[iClientH]->m_iConstructionPoint += (1000 * iEKNum);
		m_pClientList[iClientH]->m_iWarContribution   += (100 * iEKNum);
		UpdateHeldenianStatus(-1);
		if (m_pClientList[iClientH]->m_iConstructionPoint > DEF_MAXHELDENIANSUMMONPOINT) m_pClientList[iClientH]->m_iConstructionPoint = DEF_MAXHELDENIANSUMMONPOINT;
	}else // bAutoFlag Flag set by server at Heldenian type 2 beginning
	{	if (m_cHeldenianType != 2) return FALSE;	
		switch (m_sLastHeldenianWinner) {
		case 1:	// Aresden:
			iDynamicObjectIndex = iAddDynamicObjectList(NULL, NULL, DEF_DYNAMICOBJECT_ARESDENFLAG1, cMapIndex, dX, dY, NULL, NULL);	
			break;
		case 2: // Elvine	
			iDynamicObjectIndex = iAddDynamicObjectList(NULL, NULL, DEF_DYNAMICOBJECT_ELVINEFLAG1, cMapIndex, dX, dY, NULL, NULL);	
			break;
		default: // Others
			return FALSE;
			break;
		}
		if (iDynamicObjectIndex == NULL) return FALSE;
		iIndex = m_pMapList[cMapIndex]->iRegisterOccupyFlag(dX, dY, iSide, 615, iDynamicObjectIndex);
		if (iIndex == -1) PutLogList("Error registering MasterOccupyFlag.");	
		for (ix = dX-20; ix <= dX+35; ix++) 
		for (iy = dY-20; iy <= dY+25; iy++) 
		{	if ((ix == dX) && (iy == dY)) 
			{}else 
			{	pTile = (class CTile *)(m_pMapList[cMapIndex]->m_pTile + ix + iy*m_pMapList[cMapIndex]->m_sSizeY);			
				if (pTile->m_iOccupyFlagIndex == NULL) 
				{	switch (m_sLastHeldenianWinner) {
					case 1:	// Aresden 
						pTile->m_iOccupyStatus -= 15; 
						break;
					case 2: // Elvine	
						pTile->m_iOccupyStatus += 15; 
						break;
					default:
						pTile->m_iOccupyStatus = 0;
						break;
		}	}	}	}	
		wsprintf(G_cTxt, "Server set Master Flag\t %s(%d %d)"
			, m_pMapList[cMapIndex]->m_cName
			, dX
			, dY);
		PutItemLogFileList(G_cTxt);
		PutLogEventFileList(G_cTxt);
		PutLogList(G_cTxt);	
	}
	return TRUE;
}
/*********************************************************************************************************************
**  BOOL CGame::RemoveOccupyFlags(int iMapIndex)																	**
**  description		:: Removes all occupy flags from given map										       			**
**             		:: 																								**
**	Called at Heldenian begin and Heldenian end...																	**
*********************************************************************************************************************/
void CGame::RemoveOccupyFlags(int iMapIndex)
{DWORD dwTime = timeGetTime();
 register int i;
 short dX, dY;
 int iDynamicObjectIndex;
 class CTile * pTile;
 int iy, ix;
	if (m_pMapList[iMapIndex] == NULL) return;
	for (i = 1; i < DEF_MAXOCCUPYFLAG; i++) 
	{	if (m_pMapList[iMapIndex]->m_pOccupyFlag[i] == NULL)
		{	continue;
		}else // remove this OccupyFlag
		{	dX = m_pMapList[iMapIndex]->m_pOccupyFlag[i]->m_sX;
			dY = m_pMapList[iMapIndex]->m_pOccupyFlag[i]->m_sY;
			iDynamicObjectIndex = m_pMapList[iMapIndex]->m_pOccupyFlag[i]->m_iDynamicObjectIndex;
			m_pMapList[iMapIndex]->m_pOccupyFlag[i] = NULL;			
			m_pMapList[iMapIndex]->m_iTotalOccupyFlags--;

			pTile = (class CTile *)(m_pMapList[iMapIndex]->m_pTile + dX + dY*m_pMapList[iMapIndex]->m_sSizeY);
			if (m_pDynamicObjectList[iDynamicObjectIndex] == NULL) continue;
			SendEventToNearClient_TypeB(MSGID_DYNAMICOBJECT, DEF_MSGTYPE_REJECT
				, iMapIndex, dX, dY, m_pDynamicObjectList[iDynamicObjectIndex]->m_sType
				, iDynamicObjectIndex, NULL);
			m_pMapList[iMapIndex]->SetDynamicObject(NULL, NULL, dX, dY, dwTime);

			if (m_pDynamicObjectList[iDynamicObjectIndex] == NULL) 
			{	for (ix = dX - 2; ix <= dX + 2; ix++)
				for (iy = dY - 2; iy <= dY + 2; iy++) 
				{	pTile = (class CTile *)(m_pMapList[iMapIndex]->m_pTile + ix + iy*m_pMapList[iMapIndex]->m_sSizeY);
					pTile->m_sOwner = NULL;
	}	}	}	}
register int j;
	for (i = 0; i < m_pMapList[iMapIndex]->m_sSizeX; i++) // Then remove all m_iOccupyStatus
	for (j = 0; j < m_pMapList[iMapIndex]->m_sSizeY; j++)  	
	{	pTile = (class CTile *)(m_pMapList[iMapIndex]->m_pTile + i + j*m_pMapList[iMapIndex]->m_sSizeY);
		pTile->m_iOccupyStatus = 0; 
	}
}
/*********************************************************************************************************************
**  BOOL CGame::GetOccupyFlagHandler(int iClientH)																	**
**  description		:: Buy the occupy Flag from commander										       				**
**             		:: 																								**
**					::																								**
*********************************************************************************************************************/
void CGame::GetOccupyFlagHandler(int iClientH)
{int   i, iNum, iRet, iEraseReq, iEKNum;
 char  * cp, cData[256], cItemName[21];
 class CItem * pItem;
 DWORD * dwp;
 short * sp;
 WORD  * wp;
	if (m_pClientList[iClientH] == NULL) return;
	if (m_pClientList[iClientH]->m_iEnemyKillCount < 3) return;
	if (m_pClientList[iClientH]->m_cSide < 0) return;
	if (m_pClientList[iClientH]->m_cSide > 2) return;

	ZeroMemory(cItemName, sizeof(cItemName));
	switch (m_pClientList[iClientH]->m_cSide) {
	case 1: strcpy(cItemName, "AresdenFlag"); break;
	case 2: strcpy(cItemName, "ElvineFlag");  break;
	}
	// ReqPurchaseItemHandler
	iNum = 1;
	for (i = 1; i <= iNum; i++) 
	{	pItem = new class CItem;
		if (_bInitItemAttr(pItem, cItemName) == FALSE) 
		{	delete pItem;
		}else 
		{	if (_bAddClientItemList(iClientH, pItem, &iEraseReq) == TRUE) 
			{	if (m_pClientList[iClientH]->m_iCurWeightLoad < 0) m_pClientList[iClientH]->m_iCurWeightLoad = 0;
				if (m_pClientList[iClientH]->m_iEnemyKillCount > 10) 
				{	iEKNum = 10;
					m_pClientList[iClientH]->m_iEnemyKillCount -= 10;
				}else
				{	iEKNum = m_pClientList[iClientH]->m_iEnemyKillCount;
					m_pClientList[iClientH]->m_iEnemyKillCount = 0;
				}								
				// EKNum
				pItem->m_sItemSpecEffectValue2 = iEKNum;
				pItem->m_sTouchEffectType = DEF_ITET_UNIQUE_OWNER; 
				pItem->m_sTouchEffectValue1 = m_pClientList[iClientH]->m_sCharIDnum1; 
				pItem->m_sTouchEffectValue2 = m_pClientList[iClientH]->m_sCharIDnum2; 
				pItem->m_sTouchEffectValue3 = m_pClientList[iClientH]->m_sCharIDnum3; 
				//testcode 
				wsprintf(G_cTxt, "(*) Get Flag : Char(%s) Flag-EK(%d) Player-EK(%d)"
					, m_pClientList[iClientH]->m_cCharName
					, iEKNum
					, m_pClientList[iClientH]->m_iEnemyKillCount);
				PutLogList(G_cTxt);
				//PutLogFileList(G_cTxt);
				PutItemLogFileList(G_cTxt);	
				PutLogEventFileList(G_cTxt); 
				dwp  = (DWORD *)(cData + DEF_INDEX4_MSGID);
				*dwp = MSGID_NOTIFY;
				wp   = (WORD *)(cData + DEF_INDEX2_MSGTYPE);
				*wp  = DEF_NOTIFY_ITEMOBTAINED;
				cp = (char *)(cData + DEF_INDEX2_MSGTYPE + 2);
				*cp = 1;
				cp++;				
				memcpy(cp, pItem->m_cName, 20);
				cp += 20;				
				dwp  = (DWORD *)cp;
				*dwp = pItem->m_dwCount;
				cp += 4;				
				*cp = pItem->m_cItemType;
				cp++;				
				*cp = pItem->m_cEquipPos;
				cp++;				
				*cp = (char)0;  
				cp++;				
				sp  = (short *)cp;
				*sp = pItem->m_sLevelLimit;
				cp += 2;				
				*cp = pItem->m_cGenderLimit;
				cp++;				
				wp = (WORD *)cp;
				*wp = pItem->m_wCurLifeSpan;
				cp += 2;				
				wp = (WORD *)cp;
				*wp = pItem->m_wWeight;
				cp += 2;				
				sp  = (short *)cp;
				*sp = pItem->m_sSprite;
				cp += 2;				
				sp  = (short *)cp;
				*sp = pItem->m_sSpriteFrame;
				cp += 2;
				*cp = pItem->m_cItemColor;
				cp++;
				*cp = (char)pItem->m_sItemSpecEffectValue2;
				cp++;					
				dwp = (DWORD *)cp;
				*dwp = pItem->m_dwAttribute;
				cp += 4;
				/*
				*cp = (char)(pItem->m_dwAttribute & 0x00000001); // Custom-Item
				cp++;
				*/											
				if (iEraseReq == 1) delete pItem;				
				iRet = m_pClientList[iClientH]->m_pXSock->iSendMsg(cData, 53);
				iCalcTotalWeight(iClientH);				
				switch (iRet) {
				case DEF_XSOCKEVENT_QUENEFULL:
				case DEF_XSOCKEVENT_SOCKETERROR:
				case DEF_XSOCKEVENT_CRITICALERROR:
				case DEF_XSOCKEVENT_SOCKETCLOSED:
					DeleteClient(iClientH, TRUE, TRUE);
					return;
				}
				SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_ENEMYKILLS, m_pClientList[iClientH]->m_iEnemyKillCount, NULL, NULL, NULL);
			}else 
			{	delete pItem;
				iCalcTotalWeight(iClientH);
				dwp  = (DWORD *)(cData + DEF_INDEX4_MSGID);
				*dwp = MSGID_NOTIFY;
				wp   = (WORD *)(cData + DEF_INDEX2_MSGTYPE);
				*wp  = DEF_NOTIFY_CANNOTCARRYMOREITEM;				
				iRet = m_pClientList[iClientH]->m_pXSock->iSendMsg(cData, 6);
				switch (iRet) {
				case DEF_XSOCKEVENT_QUENEFULL:
				case DEF_XSOCKEVENT_SOCKETERROR:
				case DEF_XSOCKEVENT_CRITICALERROR:
				case DEF_XSOCKEVENT_SOCKETCLOSED:
					DeleteClient(iClientH, TRUE, TRUE);
					return;
 	}	}	}	}
}
/*********************************************************************************************************************
**   																												**
**									    END OF HELDENIAN FUNCTIONS								       				**
**             		   																								**
*********************************************************************************************************************/


// Crusade XP is sent later than crusade end...
void CGame::CheckCrusadeResultCalculation(int iClientH)
{	if (m_pClientList[iClientH] == NULL) return;
	if (m_pClientList[iClientH]->m_cVar == 1) return; // Client must have been informed of crusade end before getting XP
	if ((m_bIsCrusadeMode == FALSE) && (m_pClientList[iClientH]->m_dwCrusadeGUID != 0)) 
	{	// Snoopy: reset points, client side
		SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_CONSTRUCTIONPOINT, 0, 0, 1, NULL); // Dont tell player
		if (m_pClientList[iClientH]->m_iWarContribution > DEF_MAXWARCONTRIBUTION) m_pClientList[iClientH]->m_iWarContribution = DEF_MAXWARCONTRIBUTION;	
		if (m_pClientList[iClientH]->m_dwCrusadeGUID == m_dwCrusadeGUID) 
		{	if (m_pClientList[iClientH]->m_iLevel < 180)
			{	if (m_pClientList[iClientH]->m_iWarContribution !=0) 
					 m_pClientList[iClientH]->m_iWarContribution += (200 - m_pClientList[iClientH]->m_iLevel)*100;
				else m_pClientList[iClientH]->m_iWarContribution += (200 - m_pClientList[iClientH]->m_iLevel)*50;
			}else if (m_pClientList[iClientH]->m_iWarContribution !=0) 
				m_pClientList[iClientH]->m_iWarContribution += 2000; // +2000..+19500	
// Draw: XP = WC/2 (Siementec: XP = WC/6) Very low because most likelly a test or bug if draw...
			if (m_iCrusadeWinnerSide == 0) // Result = Draw
			{	m_pClientList[iClientH]->m_iExpStock += (m_pClientList[iClientH]->m_iWarContribution/2);
				SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_CRUSADE, (DWORD)FALSE, NULL, 0, NULL);		
				wsprintf(G_cTxt, "Crusade Exp:       PC(%s) Got %d xp."
					, m_pClientList[iClientH]->m_cCharName
					, m_pClientList[iClientH]->m_iWarContribution/2 );	
				PutLogList(G_cTxt);
				PutLogEventFileList(G_cTxt);
			}else 
			{	if (m_iCrusadeWinnerSide == m_pClientList[iClientH]->m_cSide) 
// Victory: XP = WCx6 (Siementec: XP = WCx1.2)	
				{	m_pClientList[iClientH]->m_iExpStock += m_pClientList[iClientH]->m_iWarContribution*6;
					SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_CRUSADE, (DWORD)FALSE, 0, m_pClientList[iClientH]->m_iWarContribution*5, NULL);
					wsprintf(G_cTxt, "Crusade Exp:       PC(%s) Got %d xp."
						, m_pClientList[iClientH]->m_cCharName
						, m_pClientList[iClientH]->m_iWarContribution*5 );	
					PutLogList(G_cTxt);
					PutLogEventFileList(G_cTxt);
				}else if (m_iCrusadeWinnerSide != m_pClientList[iClientH]->m_cSide)
// Defeat: XP = WCx2 (Siementec: XP = WC/6)		
				{	m_pClientList[iClientH]->m_iExpStock += m_pClientList[iClientH]->m_iWarContribution*2 ;
					SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_CRUSADE, (DWORD)FALSE, 0, m_pClientList[iClientH]->m_iWarContribution*(-2), NULL);						
					wsprintf(G_cTxt, "Crusade Exp:       PC(%s) Got %d xp."
						, m_pClientList[iClientH]->m_cCharName
						, m_pClientList[iClientH]->m_iWarContribution*2 );	
					PutLogList(G_cTxt);
					PutLogEventFileList(G_cTxt);
			}	}
		}else 
		{	SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_CRUSADE, (DWORD)m_bIsCrusadeMode, NULL, 0, NULL, -1);		
		}
		m_pClientList[iClientH]->m_iCrusadeDuty     = 0;
		m_pClientList[iClientH]->m_iWarContribution = 0;
		m_pClientList[iClientH]->m_dwCrusadeGUID    = 0; // reset means XP was given...
		m_pClientList[iClientH]->m_dwXPHackCheckTime = timeGetTime();
		m_pClientList[iClientH]->m_iXPHackCheckExp = m_pClientList[iClientH]->m_iExp;
	}
}

void CGame::AdminOrder_GetFightzoneTicket(int iClientH)
{ int iReserveTime, iFightzoneTN, iFightzoneN;
 char cTemp[21];
 SYSTEMTIME SysTime;
	if (m_pClientList[iClientH] == NULL) return;
		if (m_pClientList[iClientH]->m_iAdminUserLevel < m_iAdminLevelReserveFightzone) {
		SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_ADMINUSERLEVELLOW, NULL, NULL, NULL, NULL);
		return;
	}
	if (memcmp(m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cName, "fightzone", 9) == 0) 		
	{	iReserveTime = m_pClientList[iClientH]->m_iReserveTime;
		GetLocalTime(&SysTime);
		m_pClientList[iClientH]->m_iReserveTime = SysTime.wMonth*10000 + SysTime.wDay*100 + (SysTime.wHour +3);  		
		ZeroMemory(cTemp, sizeof(cTemp));
		strcpy(cTemp, (m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cName +9));
		iFightzoneN  = m_pClientList[iClientH]->m_iFightzoneNumber;
		iFightzoneTN = m_pClientList[iClientH]->m_iFightZoneTicketNumber;
		m_pClientList[iClientH]->m_iFightZoneTicketNumber = 10;
		m_pClientList[iClientH]->m_iFightzoneNumber = atoi(cTemp);		
		GetFightzoneTicketHandler(iClientH);
		GetFightzoneTicketHandler(iClientH);
		GetFightzoneTicketHandler(iClientH);		
		m_pClientList[iClientH]->m_iFightzoneNumber = iFightzoneN;
		m_pClientList[iClientH]->m_iFightZoneTicketNumber = iFightzoneTN;
		m_pClientList[iClientH]->m_iReserveTime = iReserveTime;
	}else 
	{	iReserveTime = m_pClientList[iClientH]->m_iReserveTime;
		GetLocalTime(&SysTime);
		m_pClientList[iClientH]->m_iReserveTime = SysTime.wMonth*10000 + SysTime.wDay*100 + (SysTime.wHour +2);  		
		ZeroMemory(cTemp, sizeof(cTemp));
		strcpy(cTemp, (m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cName +9));
		iFightzoneN  = m_pClientList[iClientH]->m_iFightzoneNumber;
		iFightzoneTN = m_pClientList[iClientH]->m_iFightZoneTicketNumber;
		m_pClientList[iClientH]->m_iFightZoneTicketNumber = 10;
		m_pClientList[iClientH]->m_iFightzoneNumber = 1;		
		GetFightzoneTicketHandler(iClientH);
		GetFightzoneTicketHandler(iClientH);
		GetFightzoneTicketHandler(iClientH);
		m_pClientList[iClientH]->m_iFightzoneNumber = iFightzoneN;
		m_pClientList[iClientH]->m_iFightZoneTicketNumber = iFightzoneTN;
		m_pClientList[iClientH]->m_iReserveTime = iReserveTime;
	}	
	wsprintf(G_cTxt,"Admin Order(%s): Get Figthzone tickets\tAdminIP(%s)"
		, m_pClientList[iClientH]->m_cCharName
		, m_pClientList[iClientH]->m_cIPaddress);
	//PutLogEventFileList(G_cTxt);
	PutAdminLogFileList(G_cTxt);	
	wsprintf(G_cTxt, "GM Order(%-10s): /getticket (done)", m_pClientList[iClientH]->m_cCharName);
	bSendMsgToLS(MSGID_GAMEMASTERLOG, iClientH, FALSE, G_cTxt);	
}
// SNOOPY: Added priest or Druid checking
void CGame::Set_PriestDruid(int iClientH)
{	
	if (iClientH <= 0) return;	
	if (m_pClientList[iClientH] == NULL) return;	
	
	//SNOOPY: Set Priest, Druid or special condition
	m_pClientList[iClientH]->m_iPriestDruidID = 0;
	if (   (m_pClientList[iClientH]->m_iAdminUserLevel == 0) 
		&& ((m_pClientList[iClientH]->m_cSide == 1)||(m_pClientList[iClientH]->m_cSide == 2)) 
		&& (m_pClientList[iClientH]->m_iLevel > 49) )			
	{	// 4: Paladin 
		if (   (m_pClientList[iClientH]->m_iCharisma > 29) 
			&& (m_pClientList[iClientH]->m_iStr > 29) ) 
		{	m_pClientList[iClientH]->m_iPriestDruidID = 4;
		}
		// 5: Knight 
		if (   (m_pClientList[iClientH]->m_iLevel > 129)
			&& (m_pClientList[iClientH]->m_iInt <= 10)
			&& (m_pClientList[iClientH]->m_cSkillMastery[8]  == 100)  // LS 100%
			&& (m_pClientList[iClientH]->m_cSkillMastery[9]  == 0)    // Fencing
			&& (m_pClientList[iClientH]->m_cSkillMastery[10] == 0)    // Axe
			&& (m_pClientList[iClientH]->m_cSkillMastery[14] == 0)    // Hammer
			&& (m_pClientList[iClientH]->m_cSkillMastery[21] == 0) )  // Staff
		{	m_pClientList[iClientH]->m_iPriestDruidID = 5;
			m_pClientList[iClientH]->m_bSpecialFeatureAllowed = TRUE;
		}
		// 6: Barbarian
		if (   (m_pClientList[iClientH]->m_iLevel > 129)
			&& (m_pClientList[iClientH]->m_iCharisma < 30) 
			&& (m_pClientList[iClientH]->m_iInt <= 10)
			&& (m_pClientList[iClientH]->m_iStr >= 156) 
			&& ((m_pClientList[iClientH]->m_cSkillMastery[10] >= 100)||(m_pClientList[iClientH]->m_cSkillMastery[14] >= 100)) 
			&& (m_pClientList[iClientH]->m_cSkillMastery[7] == 0)   // SS
			&& (m_pClientList[iClientH]->m_cSkillMastery[8] == 0)   // LS
			&& (m_pClientList[iClientH]->m_cSkillMastery[9] == 0)   // Fencing
			&& (m_pClientList[iClientH]->m_cSkillMastery[11] == 0) )// Shield
		{	m_pClientList[iClientH]->m_iPriestDruidID = 6;	
			m_pClientList[iClientH]->m_bSpecialFeatureAllowed = TRUE;
		}
		// 1: Priest
		if (   (m_pClientList[iClientH]->m_iCharisma > 29) 
			&& (m_pClientList[iClientH]->m_iStr > 29) 
			&& (m_pClientList[iClientH]->m_cSkillMastery[6] == 0) // bow
			&& (m_pClientList[iClientH]->m_cSkillMastery[7] == 0) // SS
			&& (m_pClientList[iClientH]->m_cSkillMastery[8] == 0) // LS
			&& (m_pClientList[iClientH]->m_cSkillMastery[9] == 0) // Fencing
			&& (m_pClientList[iClientH]->m_cSkillMastery[10] == 0) ) // Axe
		{	m_pClientList[iClientH]->m_iPriestDruidID = 1;
			m_pClientList[iClientH]->m_bSpecialFeatureAllowed = TRUE;	
		}
		// 2: Druid
		if (   (m_pClientList[iClientH]->m_iCharisma > 29) 
			&& (m_pClientList[iClientH]->m_iDex > 29)
			&& (m_pClientList[iClientH]->m_iStr < 90) 
			&& (m_pClientList[iClientH]->m_iDex > m_pClientList[iClientH]->m_iStr)
			&& ((m_pClientList[iClientH]->m_cSkillMastery[7] != 0)||(m_pClientList[iClientH]->m_cSkillMastery[8] != 0)) 
			&& (m_pClientList[iClientH]->m_cSkillMastery[6] == 0)    // bow
			&& (m_pClientList[iClientH]->m_cSkillMastery[9] == 0)    // Fencing
			&& (m_pClientList[iClientH]->m_cSkillMastery[10] == 0)   // Axe
			&& (m_pClientList[iClientH]->m_cSkillMastery[14] == 0) ) // Hammer
		{	m_pClientList[iClientH]->m_iPriestDruidID = 2;	
			m_pClientList[iClientH]->m_bSpecialFeatureAllowed = TRUE;
		}
		// 3: Monk
		if (   (m_pClientList[iClientH]->m_iStr      < m_pClientList[iClientH]->m_iVit)
			&& (m_pClientList[iClientH]->m_iInt      < m_pClientList[iClientH]->m_iVit)
			&& (m_pClientList[iClientH]->m_iCharisma < m_pClientList[iClientH]->m_iVit)
			&& (m_pClientList[iClientH]->m_iStr<41))
		{	m_pClientList[iClientH]->m_iPriestDruidID = 3;
			m_pClientList[iClientH]->m_bSpecialFeatureAllowed = TRUE;		
	}	}
}

// SNOOPY: Added priest or Druid transformation
void CGame::Become_PriestDruid(int iClientH)
{	if (iClientH <= 0) return;	
	if (m_pClientList[iClientH] == NULL) return;		
	//SNOOPY: Set Priest or Druid condition
	m_pClientList[iClientH]->m_iPriestDruidID = 0;
	// If character goes to Temple with Holy Symbol, reset skills then....
	// Priests are only Elvines/Ares
	// You need to be in a Temple or Church to become Priest
	if ((m_pClientList[iClientH]->m_iAdminUserLevel == 0) 
		&& (m_pClientList[iClientH]->m_iCharisma > 29) 
		&& (m_pClientList[iClientH]->m_iLevel > 49)
		&& (m_pClientList[iClientH]->m_iStr > 29)
		&& ((m_pClientList[iClientH]->m_cSide == 1)||(m_pClientList[iClientH]->m_cSide == 2)) 
		&& (   (strcmp(m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cName, "cath_1") == 0)
			|| (strcmp(m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cName, "cath_2") == 0)))
	{	// He wants to become Priest, so reset skills!
		m_pClientList[iClientH]->m_cSkillMastery[6] = 0;
		m_pClientList[iClientH]->m_cSkillMastery[7] = 0;
		m_pClientList[iClientH]->m_cSkillMastery[8] = 0;
		m_pClientList[iClientH]->m_cSkillMastery[9] = 0;
		m_pClientList[iClientH]->m_cSkillMastery[10] = 0;

		// Character is a Priest
		m_pClientList[iClientH]->m_iPriestDruidID = 1;			
		// Then Give him spells
		bCheckMagicInt(iClientH);

		// Say to client he became priest.	
		char cInfoString[500];
		ZeroMemory(cInfoString, sizeof(cInfoString));
		if (m_pClientList[iClientH]->m_cSide == 1)
			wsprintf(cInfoString, "You choose to dedicate your life to Aresien. You're now Aresien's PRIEST.");
		if (m_pClientList[iClientH]->m_cSide == 2)
			wsprintf(cInfoString, "You choose to dedicate your life to Eldiniel. You're now Eldiniel's PRIEST.");
		SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_IPACCOUNTINFO, NULL, NULL, NULL, cInfoString);				
		// Logging the new Priest
		wsprintf(G_cTxt, "PC(%s)\tUsing Holy Symbol. All bloody weapons skills to 0.\t%s(%d %d)\tIP(%s)"
			, m_pClientList[iClientH]->m_cCharName
			, m_pClientList[iClientH]->m_cMapName
			, m_pClientList[iClientH]->m_sX
			, m_pClientList[iClientH]->m_sY
			, m_pClientList[iClientH]->m_cIPaddress);
		PutItemLogFileList(G_cTxt);
		PutLogFileList(G_cTxt);
	}
	// Character wants to become druid, equip Druid's cape in Garden
	if ((m_pClientList[iClientH]->m_iAdminUserLevel == 0) 
		&& (m_pClientList[iClientH]->m_iCharisma > 29) 
		&& (m_pClientList[iClientH]->m_iLevel > 49)
		&& (m_pClientList[iClientH]->m_iDex > 29)
		&& ((m_pClientList[iClientH]->m_cSide == 1)||(m_pClientList[iClientH]->m_cSide == 2)) 
		&& (   (strcmp(m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cName, "areuni") == 0)
			|| (strcmp(m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cName, "elvuni") == 0)) ) 
	{	// He wants to become Druid, so reset skills!
		m_pClientList[iClientH]->m_cSkillMastery[6] = 0;  // Bow
		m_pClientList[iClientH]->m_cSkillMastery[9] = 0;  // Fencing
		m_pClientList[iClientH]->m_cSkillMastery[10] = 0; // Axe
		m_pClientList[iClientH]->m_cSkillMastery[14] = 0; // Hammer
		// Character is a Druid
		m_pClientList[iClientH]->m_iPriestDruidID = 2;			
		// Then Give him spells
		bCheckMagicInt(iClientH);

		// Say to client he became druid.	
		char cInfoString[500];
		ZeroMemory(cInfoString, sizeof(cInfoString));
		wsprintf(cInfoString, "You choose to dedicate your life to woodlands. You're now a Druid.");
		SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_IPACCOUNTINFO, NULL, NULL, NULL, cInfoString);				
		// Logging the new Druid
		wsprintf(G_cTxt, "PC(%s)\tUsing Druid cape. All forbidden weapons skills to 0.\t%s(%d %d)\tIP(%s)"
			, m_pClientList[iClientH]->m_cCharName
			, m_pClientList[iClientH]->m_cMapName
			, m_pClientList[iClientH]->m_sX
			, m_pClientList[iClientH]->m_sY
			, m_pClientList[iClientH]->m_cIPaddress);
		PutItemLogFileList(G_cTxt);
		PutLogFileList(G_cTxt);
	}
}

// Snoopy: Added this function to see relative strenth of cities on the server
int CGame::CalcCityStr(int iSide, char cMapIndex, bool bWantNumber, bool bIncludeAFK)
{	register int i;
	int iTotal = 0;	
	DWORD dwTimeNow = timeGetTime();
	for (i = 1; i < DEF_MAXCLIENTS; i++)
		if (m_pClientList[i] != NULL) 
		{	if (   (m_pClientList[i]->m_cMapIndex == cMapIndex)
				&& (m_pClientList[i]->m_cSide == (char) iSide))
			{	if (   (bIncludeAFK == FALSE)
					&& ((dwTimeNow - m_pClientList[i]->m_dwAFKCheckTime) > DEF_AFKTIME)) continue;			
				iTotal +=1;											// +1: lvl 99- 
				if (bWantNumber == FALSE)
				{	if (m_pClientList[i]->m_iLevel >= 100) iTotal +=1;// +2: lvl 100..119 
					if (m_pClientList[i]->m_iLevel >= 120) iTotal +=1;// +3: lvl 120..139 
					if (m_pClientList[i]->m_iLevel >= 140) iTotal +=1;// +4: lvl 140..149 
					if (m_pClientList[i]->m_iLevel >= 150) iTotal +=1;// +5: lvl 150+ 
		}	}	}
	return(iTotal);
}

void CGame::SendThunder(int iClient, short sX, short sY, short sV3, short sV4)
{	char  * cp, cData[100];
	DWORD * dwp;
	WORD * wp;
	short * sp;
	int iRet;
	ZeroMemory(cData, sizeof(cData));	
	dwp  = (DWORD *)(cData + DEF_INDEX4_MSGID);
	*dwp = MSGID_EVENT_COMMON;
	wp   = (WORD *)(cData + DEF_INDEX2_MSGTYPE);
	*wp  = DEF_COMMONTYPE_MAGIC;	
	cp = (char *)(cData + DEF_INDEX2_MSGTYPE + 2);
	sp  = (short *)cp;
	*sp = sX;
	cp += 2;
	sp  = (short *)cp;
	*sp = sY;
	cp += 2;
	sp  = (short *)cp;
	*sp = sX;
	cp += 2;
	sp  = (short *)cp;
	*sp = sY;
	cp += 2;
	sp  = (short *)cp;
	*sp = sV3;
	cp += 2;
	sp  = (short *)cp;
	*sp = sV4;
	cp += 2;
	iRet = m_pClientList[iClient]->m_pXSock->iSendMsg(cData, 18);
}
void CGame::DoAbaddonThunderDamageHandler(char cMapIndex)
{	int iResult;
	register int i;
	//if (m_bIsApocalypseMode != TRUE) return;
	if (iDice(1, 15) != 13) return;
	DWORD dwTime = timeGetTime();
	for (i = 0; i < DEF_MAXCLIENTS; i++) 
	{	if (m_pClientList[i] != NULL) 
		{	//if (m_pClientList[i]->m_iAdminUserLevel > 0) return;
			if ((memcmp(m_pClientList[i]->m_cMapName, "abaddon", 7) == 0) 
				|| (m_pClientList[i]->m_cMapIndex == cMapIndex))
			{	switch (iDice(1,4)) {
				case 1:
					SendThunder(i, m_pClientList[i]->m_sX, m_pClientList[i]->m_sY, 203, m_pClientList[i]->m_sType);
					SendThunder(i, m_pClientList[i]->m_sX-iDice(1,7), m_pClientList[i]->m_sY+iDice(1,5), 161, m_pClientList[i]->m_sType);
					break;
				case 2:
					SendThunder(i, m_pClientList[i]->m_sX, m_pClientList[i]->m_sY, 202, m_pClientList[i]->m_sType);
					SendThunder(i, m_pClientList[i]->m_sX+iDice(1,7), m_pClientList[i]->m_sY-iDice(1,5), 161, m_pClientList[i]->m_sType);
					break;
				case 3:
					SendThunder(i, m_pClientList[i]->m_sX, m_pClientList[i]->m_sY, 201, m_pClientList[i]->m_sType);
					SendThunder(i, m_pClientList[i]->m_sX+iDice(1,7), m_pClientList[i]->m_sY+5-iDice(1,9), 161, m_pClientList[i]->m_sType);
					break;
				case 4:
					SendThunder(i, m_pClientList[i]->m_sX, m_pClientList[i]->m_sY, 200, m_pClientList[i]->m_sType);
					SendThunder(i, m_pClientList[i]->m_sX+5-iDice(1,9), m_pClientList[i]->m_sY+7-iDice(1,4), 161, m_pClientList[i]->m_sType);
					break;
				}				
				if (m_pClientList[i]->m_iAdminUserLevel > 0) continue;	
				if (m_pClientList[i]->m_cSide == 4) continue;	// Don't hurt executors....				
				iResult = iDice(1,20) + 100;
				 if (  (m_pClientList[i]->m_cMagicEffectStatus[DEF_MAGICTYPE_PROTECT] == 2)
					|| (m_pClientList[i]->m_cMagicEffectStatus[DEF_MAGICTYPE_PROTECT] == 5)) 
				{   iResult /= 2;
				}
				// Not for v3.51: SendNotifyMsg(NULL, i, DEF_NOTIFY_0BE5, NULL, NULL, NULL, NULL);
				m_pClientList[i]->m_iHP -= iResult;
				if (m_pClientList[i]->m_iHP <= 0) 
				{	ClientKilledHandler(i, NULL, NULL, iResult);
				}else if (iResult > 0) 
				{	m_pClientList[i]->m_dwLastDamageTime = dwTime;					
					SendNotifyMsg(NULL, i, DEF_NOTIFY_HP, NULL, NULL, NULL, NULL);
					SendEventToNearClient_TypeA(i, DEF_OWNERTYPE_PLAYER, MSGID_EVENT_MOTION, DEF_OBJECTDAMAGE, iResult, NULL, NULL);
					if (m_pClientList[i]->m_bSkillUsingStatus[19] != TRUE) 
					{	m_pMapList[m_pClientList[i]->m_cMapIndex]->ClearOwner(0, i, DEF_OWNERTYPE_PLAYER, m_pClientList[i]->m_sX, m_pClientList[i]->m_sY);
						m_pMapList[m_pClientList[i]->m_cMapIndex]->SetOwner(i, DEF_OWNERTYPE_PLAYER, m_pClientList[i]->m_sX, m_pClientList[i]->m_sY);
					}
					if (m_pClientList[i]->m_cMagicEffectStatus[DEF_MAGICTYPE_HOLDOBJECT] == 20)			// Medusa kiss
					{   SendNotifyMsg(NULL, i, DEF_NOTIFY_MAGICEFFECTOFF, DEF_MAGICTYPE_HOLDOBJECT, 20, NULL, NULL);
						bRemoveFromDelayEventList(i, DEF_OWNERTYPE_PLAYER, DEF_MAGICTYPE_HOLDOBJECT);						
						m_pClientList[i]->m_cMagicEffectStatus[ DEF_MAGICTYPE_HOLDOBJECT ] = NULL;
					}else if (m_pClientList[i]->m_cMagicEffectStatus[DEF_MAGICTYPE_HOLDOBJECT] == 1)	// Hold person
					{   SendNotifyMsg(NULL, i, DEF_NOTIFY_MAGICEFFECTOFF, DEF_MAGICTYPE_HOLDOBJECT, 1, NULL, NULL);
						bRemoveFromDelayEventList(i, DEF_OWNERTYPE_PLAYER, DEF_MAGICTYPE_HOLDOBJECT);						
						m_pClientList[i]->m_cMagicEffectStatus[ DEF_MAGICTYPE_HOLDOBJECT ] = NULL;
					}else if (m_pClientList[i]->m_cMagicEffectStatus[DEF_MAGICTYPE_HOLDOBJECT] != 0)	// Para entangle
					{   SendNotifyMsg(NULL, i, DEF_NOTIFY_MAGICEFFECTOFF, DEF_MAGICTYPE_HOLDOBJECT, 2, NULL, NULL);
						bRemoveFromDelayEventList(i, DEF_OWNERTYPE_PLAYER, DEF_MAGICTYPE_HOLDOBJECT);						
						m_pClientList[i]->m_cMagicEffectStatus[ DEF_MAGICTYPE_HOLDOBJECT ] = NULL;
	}	}	}	}	}
}/*
#define MSGID_REQUEST_TELEPORT_LIST			0x0EA03202
#define MSGID_RESPONSE_TELEPORT_LIST		0x0EA03203
#define MSGID_REQUEST_CHARGED_TELEPORT		0x0EA03204
#define MSGID_RESPONSE_CHARGED_TELEPORT		0x0EA03205

#define MSGID_REQUEST_HELDENIAN_TP_LIST		0x0EA03206
#define MSGID_RESPONSE_HELDENIAN_TP_LIST	0x0EA03207
#define MSGID_REQUEST_HELDENIAN_TP			0x0EA03208*/

// RequestTeleportListHandler
void CGame::RequestTeleportListHandler(int iClientH, char * pData, DWORD dwMsgSize)
{	if (m_pClientList[iClientH] == NULL) return;
	if (m_pClientList[iClientH]->m_bIsInitComplete == FALSE) return;
	if (m_pClientList[iClientH]->m_bIsKilled == TRUE) return;
	if (m_pClientList[iClientH]->m_bIsOnWaitingProcess == TRUE) return;
	if (m_pClientList[iClientH]->m_iLockedMapTime != NULL) 
	{	SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_LOCKEDMAP, m_pClientList[iClientH]->m_iLockedMapTime, NULL, NULL, m_pClientList[iClientH]->m_cLockedMapName);
		return;
	}
char	*cp, cData[512];
int		iRet;
DWORD	*dwp;
WORD	*wp;
int		*listCount;
char	cNpcName[21];
int		*ip;
	cp = (char *)(pData + DEF_INDEX2_MSGTYPE + 2);
	ZeroMemory(cNpcName, sizeof(cNpcName));
	strncpy(cNpcName, cp, 20);
	cp += 20;
	ZeroMemory(cData, sizeof(cData));
	dwp  = (DWORD *)(cData + DEF_INDEX4_MSGID);
	*dwp = MSGID_RESPONSE_TELEPORT_LIST;
	wp   = (WORD *)(cData + DEF_INDEX2_MSGTYPE);
	*wp  = DEF_MSGTYPE_CONFIRM;
	cp = cData + 6;
	listCount = (int*) cp; 
	*listCount = 0;
	cp += 4; // sizeof(int)
	int		index;
	for(index = 0; index < DEF_MAXTELEPORTLIST; index++)
	{	if( m_pTeleportConfigList[index] == NULL )
			continue;
		if( strncmp( m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cLocationName, m_pTeleportConfigList[index]->m_cSourceMap, 10) != 0 )
			continue;
		if( strncmp( m_pTeleportConfigList[index]->m_cTeleportNpcName, cNpcName, 20) != 0 )
			continue;
		if(    (m_pTeleportConfigList[index]->m_sMinLevel > m_pClientList[iClientH]->m_iLevel)
			|| (m_pTeleportConfigList[index]->m_sMaxLevel <= m_pClientList[iClientH]->m_iLevel))
			continue;
		if (   (m_pTeleportConfigList[index]->m_bHunter == FALSE)
			&& (m_pClientList[iClientH]->m_bIsPlayerCivil == TRUE))
			continue;
		if (   (m_pTeleportConfigList[index]->m_bNetural == FALSE)
			&& (m_pClientList[iClientH]->m_cSide == 0))
			continue;
		if (   (m_pTeleportConfigList[index]->m_bCriminal == FALSE) 
			&& (m_pClientList[iClientH]->m_iPKCount > 0 ))
			continue;
		// Side
		switch (m_pTeleportConfigList[index]->m_iSide) {
		default:
			break;
		case 1:
			if (m_pClientList[iClientH]->m_cSide == 1) goto LabelCorrrectTP;
			break;
		case 2:
			if (m_pClientList[iClientH]->m_cSide == 2) goto LabelCorrrectTP;
			break;
		case 4:
			if (m_pClientList[iClientH]->m_cSide == 4) goto LabelCorrrectTP;
			break;
		case 66: // For Heldenian winner...
			if (   (m_sLastHeldenianWinner ==  m_pClientList[iClientH]->m_cSide)
				&& (m_pClientList[iClientH]->m_bIsPlayerCivil != TRUE) 
				&& (m_bIsHeldenianMode == FALSE) )	   goto LabelCorrrectTP;
			break;
		case 12:
			if (m_pClientList[iClientH]->m_cSide == 1) goto LabelCorrrectTP;
			if (m_pClientList[iClientH]->m_cSide == 2) goto LabelCorrrectTP;
			break;
		case 124:
			if (m_pClientList[iClientH]->m_cSide == 1) goto LabelCorrrectTP;
			if (m_pClientList[iClientH]->m_cSide == 2) goto LabelCorrrectTP;
			if (m_pClientList[iClientH]->m_cSide == 4) goto LabelCorrrectTP;
			break;
LabelCorrrectTP:;	
			ip = (int*) cp;
			*ip = index;
			cp += 4;
			memcpy(cp, m_pTeleportConfigList[index]->m_cTargetMap, 10);
			cp += 10;
			ip = (int*) cp;
			*ip = m_pTeleportConfigList[index]->m_iDestinationX;
			cp += 4;
			ip = (int*) cp;
			*ip = m_pTeleportConfigList[index]->m_iDestinationY;
			cp += 4;
			ip = (int*) cp;
			*ip = m_pTeleportConfigList[index]->m_iCost;
			cp += 4;
			(*listCount) ++;
		}
	} // for
	if ( (*listCount) == 0 )*wp  = DEF_MSGTYPE_REJECT;
	// Teleport List
	iRet = m_pClientList[iClientH]->m_pXSock->iSendMsg(cData, 10 + (*listCount) * 26 );
	switch (iRet) {
	case DEF_XSOCKEVENT_QUENEFULL:
	case DEF_XSOCKEVENT_SOCKETERROR:
	case DEF_XSOCKEVENT_CRITICALERROR:
	case DEF_XSOCKEVENT_SOCKETCLOSED:
		DeleteClient(iClientH, TRUE, TRUE);
		return;
	}
} // RequestTeleportListHandler

// RequestChargedTeleportHandler
void CGame::RequestChargedTeleportHandler(int iClientH, char *pData, DWORD dwMsgSize)
{	if (m_pClientList[iClientH] == NULL) return;
	if (m_pClientList[iClientH]->m_bIsInitComplete == FALSE) return;
	if (m_pClientList[iClientH]->m_bIsKilled == TRUE) return;
	if (m_pClientList[iClientH]->m_bIsOnWaitingProcess == TRUE) return;
	char	*cp, cData[64];
	int		iRet;
	DWORD	*dwp;
	WORD	*wp;
	int		index;
	WORD	wConfirm = DEF_MSGTYPE_CONFIRM;
	short	sError = 0;
	// CHARGED_TELEPORT index
	cp = (char *)(pData + DEF_INDEX2_MSGTYPE + 2);
	index = (int) (*cp);
	cp += 4;
	if ((index < 0) || (index >= DEF_MAXTELEPORTLIST))	return;
	if (m_pTeleportConfigList[index] == NULL )		return;
	if (strncmp( m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cLocationName, m_pTeleportConfigList[index]->m_cSourceMap, 10) != 0 )
		return;
	if (   (m_pTeleportConfigList[index]->m_sMinLevel > m_pClientList[iClientH]->m_iLevel)
		|| (m_pTeleportConfigList[index]->m_sMaxLevel <= m_pClientList[iClientH]->m_iLevel))
	{	wConfirm = DEF_MSGTYPE_REJECT;
		sError = 1;
	}
	if (   (wConfirm == DEF_MSGTYPE_CONFIRM)
		&& (m_pTeleportConfigList[index]->m_bHunter == FALSE)
		&& (m_pClientList[iClientH]->m_bIsPlayerCivil == TRUE))
	{	wConfirm = DEF_MSGTYPE_REJECT;
		sError = 2;
	}
	if (   (wConfirm == DEF_MSGTYPE_CONFIRM)
		&& (m_pTeleportConfigList[index]->m_bNetural == FALSE)
		&& (m_pClientList[iClientH]->m_cSide == 0))
	{	wConfirm = DEF_MSGTYPE_REJECT;
		sError = 3;
	}
	if (   (wConfirm == DEF_MSGTYPE_CONFIRM)
		&& (m_pTeleportConfigList[index]->m_bCriminal == FALSE)
		&& (m_pClientList[iClientH]->m_iPKCount > 0 ))
	{ 	wConfirm = DEF_MSGTYPE_REJECT;
		sError = 4;
	}
	if (wConfirm == DEF_MSGTYPE_CONFIRM )
	{	switch (m_pTeleportConfigList[index]->m_iSide) {
		default:
			break;
		case 1:
		case 2:
		case 4:
			if (m_pClientList[iClientH]->m_cSide != m_pTeleportConfigList[index]->m_iSide)
			{	wConfirm = DEF_MSGTYPE_REJECT;
				sError = 5;
			}
			break;
		case 12:
			if (m_pClientList[iClientH]->m_cSide > 2)
			{	wConfirm = DEF_MSGTYPE_REJECT;
				sError = 5;
			}
			break;
		case 66: // For Heldenian winners only...
			if (   (m_sLastHeldenianWinner !=  m_pClientList[iClientH]->m_cSide)
				|| (m_pClientList[iClientH]->m_bIsPlayerCivil == TRUE) 
				|| (m_bIsHeldenianMode == TRUE) )
			{	wConfirm = DEF_MSGTYPE_REJECT;
				sError = 7;
			}
			break;
		case 124:// Everybody
			break;
		}
	}
	if (wConfirm == DEF_MSGTYPE_CONFIRM )
	{	DWORD dwGoldCount = dwGetItemCount(iClientH, "Gold");
		if( dwGoldCount >= m_pTeleportConfigList[index]->m_iCost )
		{	int iGoldWeight = SetItemCount(iClientH, "Gold", dwGoldCount - m_pTeleportConfigList[index]->m_iCost);
			iCalcTotalWeight(iClientH);
			m_stCityStatus[m_pClientList[iClientH]->m_cSide].iFunds += m_pTeleportConfigList[index]->m_iCost;
		}else
		{	wConfirm = DEF_MSGTYPE_REJECT;
			sError = 6;
		}
	}
	// Invalid Charged-teleport
	if ( wConfirm == DEF_MSGTYPE_REJECT )
	{	ZeroMemory(cData, sizeof(cData));
		dwp  = (DWORD *)(cData + DEF_INDEX4_MSGID);
		*dwp = MSGID_RESPONSE_CHARGED_TELEPORT;
		wp   = (WORD *)(cData + DEF_INDEX2_MSGTYPE);
		*wp  = wConfirm;
		cp = cData + DEF_INDEX2_MSGTYPE + 2;
		short	*sp;
		sp	= (short*) cp;
		*sp	= sError;
		cp += 2;
		// Teleport List
		iRet = m_pClientList[iClientH]->m_pXSock->iSendMsg(cData, 6 + 2 );
		switch (iRet) {
		case DEF_XSOCKEVENT_QUENEFULL:
		case DEF_XSOCKEVENT_SOCKETERROR:
		case DEF_XSOCKEVENT_CRITICALERROR:
		case DEF_XSOCKEVENT_SOCKETCLOSED:
			DeleteClient(iClientH, TRUE, TRUE);
			return;
		}
		return;
	}
	// teleport
	RequestTeleportHandler(iClientH, "2   ",
		m_pTeleportConfigList[index]->m_cTargetMap,
		m_pTeleportConfigList[index]->m_iDestinationX,
		m_pTeleportConfigList[index]->m_iDestinationY);

} // RequestChargedTeleportHandler
// Snoopy: Teleport List
BOOL CGame::bDecodeTeleportList(char *pFn)
{FILE * pFile;
 HANDLE hFile;
 DWORD  dwFileSize;
 char * cp, * token, cReadModeA, cReadModeB;
 char seps[] = "= \t\n";
 class CStrTok * pStrTok;
 int   iIndex;
 int iTeleportConfigListIndex; 
	for (int i = 0; i <  DEF_MAXTELEPORTLIST; i++)
	if (m_pTeleportConfigList[i] != NULL) 
	{	delete m_pTeleportConfigList[i];
		m_pTeleportConfigList[i] = NULL;
	}
	cReadModeA = 0;
	cReadModeB = 0;
	iIndex = 0;
	hFile = CreateFile(pFn, GENERIC_READ, NULL, NULL, OPEN_EXISTING, NULL, NULL);
	dwFileSize = GetFileSize(hFile, NULL);
	if (hFile != INVALID_HANDLE_VALUE) CloseHandle(hFile);
	pFile = fopen(pFn, "rt");
	if (pFile == NULL)
	{	PutLogList("(!) Cannot open Teleport.cfg file.");
		return FALSE;
	}else
	{	PutLogList("(!) Reading TeleportList.cfg...");
		cp = new char[dwFileSize+2];
		ZeroMemory(cp, dwFileSize+2);
		fread(cp, dwFileSize, 1, pFile);
		pStrTok = new class CStrTok(cp, seps);
		token = pStrTok->pGet();
		while( token != NULL ) 
		{	if (cReadModeA != 0) 
			{	switch (cReadModeA) {
				case 1:
					switch (cReadModeB) {
					case 1: // Teleport n°
						if (_bGetIsStringIsNumber(token) == FALSE)
						{	PutLogList("(!!!) CRITICAL ERROR! TELEPORT-LIST configuration file error - Wrong Data format.");
							delete pStrTok;	delete cp; return FALSE;
						}
						iTeleportConfigListIndex = atoi(token);
						if ((iTeleportConfigListIndex < 0) || (iTeleportConfigListIndex >= DEF_MAXTELEPORTLIST))
						{	PutLogList("(!!!) CRITICAL ERROR! TELEPORT-LIST configuration file error - Wrong TeleportList number.");
							return FALSE;
						}
						if (m_pTeleportConfigList[iTeleportConfigListIndex] != NULL)
						{	PutLogList("(!!!) CRITICAL ERROR! TELEPORT-LIST configuration file error - Duplicate TeleportList number.");
							return FALSE;
						}
						m_pTeleportConfigList[iTeleportConfigListIndex] = new class CTeleport;
						cReadModeB = 2;
						break;
					case 2: // NPC name
						memcpy(m_pTeleportConfigList[iTeleportConfigListIndex]->m_cTeleportNpcName, token, strlen(token));
						cReadModeB = 3;
						break;
					case 3: // SOURCE MAP
						memcpy(m_pTeleportConfigList[iTeleportConfigListIndex]->m_cSourceMap, token, strlen(token));
						cReadModeB = 4;
						break;
					case 4: // TARGET MAP
						memcpy(m_pTeleportConfigList[iTeleportConfigListIndex]->m_cTargetMap, token, strlen(token));
						cReadModeB = 5;
							break;
					case 5: // TARGET MAP X
						if (_bGetIsStringIsNumber(token) == FALSE)
						{	PutLogList("(!!!) CRITICAL ERROR! TELEPORT-LIST configuration file error - X - Wrong Data format.");
							delete cp; delete pStrTok; return FALSE;
						}
						m_pTeleportConfigList[iTeleportConfigListIndex]->m_iDestinationX = atoi(token);
						cReadModeB = 6;
						break;
					case 6: // TARGET MAP Y
						if (_bGetIsStringIsNumber(token) == FALSE)
						{	PutLogList("(!!!) CRITICAL ERROR! TELEPORT-LIST configuration file error - Y - Wrong Data format.");
							delete cp; delete pStrTok; return FALSE;
						}
						m_pTeleportConfigList[iTeleportConfigListIndex]->m_iDestinationY = atoi(token);
						cReadModeB = 7;
						break;
					case 7: // COST
						if (_bGetIsStringIsNumber(token) == FALSE)
						{	PutLogList("(!!!) CRITICAL ERROR! TELEPORT-LIST configuration file error - Cost - Wrong Data format.");
							delete cp; delete pStrTok; return FALSE;
						}
						m_pTeleportConfigList[iTeleportConfigListIndex]->m_iCost = atoi(token);
						cReadModeB = 8;
						break;
					case 8: // Minimum Level
						if (_bGetIsStringIsNumber(token) == FALSE)
						{	PutLogList("(!!!) CRITICAL ERROR! TELEPORT-LIST configuration file error - MinLvl - Wrong Data format.");
							delete cp; delete pStrTok; return FALSE;
						}
						m_pTeleportConfigList[iTeleportConfigListIndex]->m_sMinLevel = atoi(token);
						cReadModeB = 9;
						break;
					case 9: // Maximum Level
						if (_bGetIsStringIsNumber(token) == FALSE)
						{	PutLogList("(!!!) CRITICAL ERROR! TELEPORT-LIST configuration file error - MaxLvl- Wrong Data format.");
							delete cp; delete pStrTok; return FALSE;
						}
						m_pTeleportConfigList[iTeleportConfigListIndex]->m_sMaxLevel = atoi(token);
						cReadModeB = 10;
						break;
					case 10: // Side (aresden, elvein)
						if( memcmp(token, "aresden", 7) == 0 )
						{	m_pTeleportConfigList[iTeleportConfigListIndex]->m_iSide = 1;
						}else if( memcmp(token, "elvine", 6) == 0 )
						{	m_pTeleportConfigList[iTeleportConfigListIndex]->m_iSide = 2;
						}else if( memcmp(token, "both", 4) == 0 )
						{	m_pTeleportConfigList[iTeleportConfigListIndex]->m_iSide = 12;
						}else if( memcmp(token, "evil", 4) == 0 )
						{	m_pTeleportConfigList[iTeleportConfigListIndex]->m_iSide = 4;
						}else if( memcmp(token, "all", 3) == 0 )
						{	m_pTeleportConfigList[iTeleportConfigListIndex]->m_iSide = 124;
						}else if( memcmp(token, "heldenian", 9) == 0 )
						{	m_pTeleportConfigList[iTeleportConfigListIndex]->m_iSide = 66;
						}else
						{	PutLogList("(!!!) CRITICAL ERROR! TELEPORT-LIST configuration file error - Side - Wrong Data format.");
							delete cp; delete pStrTok; return FALSE;
						}
						cReadModeB = 11;
						break;
					case 11: // HuntMode (0,1)
						if (_bGetIsStringIsNumber(token) == FALSE) {
							PutLogList("(!!!) CRITICAL ERROR! TELEPORT-LIST configuration file error - Hunter - Wrong Data format.");
							delete cp; delete pStrTok; return FALSE;
						}
						if( memcmp(token,"0",1) == 0 )
							m_pTeleportConfigList[iTeleportConfigListIndex]->m_bHunter = FALSE;
						else if( memcmp(token,"1",1) == 0 )
							m_pTeleportConfigList[iTeleportConfigListIndex]->m_bHunter = TRUE;
						else
						{	PutLogList("(!!!) CRITICAL ERROR! TELEPORT-LIST configuration file error - Hunter - Wrong Data format.");
							delete cp; delete pStrTok; return FALSE;
						}
						cReadModeB = 12;
						break;
					case 12: // Netural (0,1)
						if (_bGetIsStringIsNumber(token) == FALSE)
						{	PutLogList("(!!!) CRITICAL ERROR! TELEPORT-LIST configuration file error - Neutral - Wrong Data format.");
							delete cp; delete pStrTok; return FALSE;
						}
						if( memcmp(token,"0",1) == 0 )
							m_pTeleportConfigList[iTeleportConfigListIndex]->m_bNetural = FALSE;
						else if( memcmp(token,"1",1) == 0 )
							m_pTeleportConfigList[iTeleportConfigListIndex]->m_bNetural = TRUE;
						else
						{	PutLogList("(!!!) CRITICAL ERROR! TELEPORT-LIST configuration file error - Neutral - Wrong Data format.");
							delete cp; delete pStrTok; return FALSE;
						}
						cReadModeB = 13;
						break;
					case 13: // Criminal (0,1)
						if (_bGetIsStringIsNumber(token) == FALSE)
						{	PutLogList("(!!!) CRITICAL ERROR! TELEPORT-LIST configuration file error - Crim - Wrong Data format.");
							delete cp; delete pStrTok; return FALSE;
						}
						if ( memcmp(token,"0",1) == 0 )
							m_pTeleportConfigList[iTeleportConfigListIndex]->m_bCriminal = FALSE;
						else if( memcmp(token,"1",1) == 0 )
							m_pTeleportConfigList[iTeleportConfigListIndex]->m_bCriminal = TRUE;
						else
						{	PutLogList("(!!!) CRITICAL ERROR! TELEPORT-LIST configuration file error - Crim - Wrong Data format.");
							delete cp; delete pStrTok; return FALSE;
						}
						cReadModeA = 0;
						cReadModeB = 0;
						break;
					}
					break;
				default:
					break;
				}
			}else
			{	if (memcmp(token, "teleport", 8) == 0)
				{	cReadModeA = 1;
					cReadModeB = 1;
				}else if (memcmp(token, "[END]", 5) == 0)
				{	cReadModeA = 0;
					cReadModeB = 0;
					break; // Stop While Loop
				}
			}
			token = pStrTok->pGet();
		} // while
		delete pStrTok;	delete cp;
		if ((cReadModeA != 0) || (cReadModeB != 0)||(iTeleportConfigListIndex < 0)||(iTeleportConfigListIndex >= DEF_MAXTELEPORTLIST))
		{	PutLogList("(!!!) CRITICAL ERROR! TELEPORT-LIST configuration file contents error!");
			return FALSE;
		}
		if (pFile != NULL) fclose(pFile);
		wsprintf(G_cTxt, "(!) TELEPORT-LIST(Total:%d) configuration - success!", iTeleportConfigListIndex);
		PutLogList(G_cTxt);
		return TRUE;
	}
}
void CGame::SendNewInitMapData(int iClientH)
{	register int ix, iy, sX, sY;
	short sOwnerH; 	
	char cOwnerType;
	if (m_pClientList[iClientH] == NULL) return;
	sX = m_pClientList[iClientH]->m_sX;
	sY = m_pClientList[iClientH]->m_sY;
	for (ix = sX - 10; ix <= sX + 10; ix++)
	for (iy = sY - 8; iy <= sY + 8; iy++)
	{	m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, ix, iy);				
		switch (cOwnerType) {
		case DEF_OWNERTYPE_PLAYER:
			if (   (sOwnerH != NULL) 
				&& (m_pClientList[sOwnerH] != NULL) )// Send new info about this player		
			{	SendNearClientToChar(sOwnerH, iClientH);			
			}
			break;
		case DEF_OWNERTYPE_NPC:
			if (   (sOwnerH != NULL) 
				&& (m_pNpcList[sOwnerH] != NULL) )// Send new info about this mob		
			{	SendNearMobToChar(sOwnerH, iClientH);			
			}
			break;
	}	}
}
void CGame::AdjustClientDropRate(int iClientH)
{	if (m_pClientList[iClientH] == NULL) return;
	// SNOOPY Reputation was used only for 2nd drop rate and very high adjustement was possible
	// up to 4 times more items drops ! (with 3000 reputation)
	// SNOOPY: Reputation is now used here for overall drop rate, but with lesser advantage
	double dTmp1;
	dTmp1 = m_pClientList[iClientH]->m_iRating * m_cRepDropModifier;
	if (dTmp1 > 1000) dTmp1 = 1000;
	if (dTmp1 < 0) dTmp1 -= 500; // Negative reputation has drop rate malus
	if (dTmp1 < -1000) dTmp1 = -1000;
	m_pClientList[iClientH]->m_iClientPrimaryDropRate = ( m_iPrimaryDropRate - (dTmp1/2));
}

/*********************************************************************************************************************
**  void CGame::AFKChecker()																						**
**  description		:: Check all client to see if they're afk, then sends them Pseudo Magic 247 to show ZzZz		**
**					:: Client side effect 247 must be coded of course !												**
*********************************************************************************************************************/
void CGame::AFKChecker()
{	register int i;
	int sX, sY;
	DWORD dwTimeNow = timeGetTime();
	for (i = 1; i < DEF_MAXCLIENTS; i++)
	{	if (m_pClientList[i] != NULL)
		{	if (   (m_pClientList[i]->m_bIsInitComplete == TRUE) 
				&& ((dwTimeNow - m_pClientList[i]->m_dwAFKCheckTime) > DEF_AFKTIME)
				&& (m_pClientList[i]->m_iHP > 0)
				&& ((m_pClientList[i]->m_iStatus & 0x00000010) == 0) // if not invi
				&& (iDice(1,5) == 3))
			{	sX = m_pClientList[i]->m_sX;
				if (m_pClientList[i]->m_bSkillUsingStatus[19] == TRUE) // Pretend corpse
					 sY = m_pClientList[i]->m_sY +1;					
				else sY = m_pClientList[i]->m_sY;		
				SendEventToNearClient_TypeB(MSGID_EVENT_COMMON, DEF_COMMONTYPE_MAGIC, m_pClientList[i]->m_cMapIndex
					, sX, sY, sX, sY, 247, m_pClientList[i]->m_sType);
	}	}	}
}

/*********************************************************************************************************************
**  BOOL CGame::GetAngelHandler(int iClientH, char * pData, DWORD dwMsgSize)										**	
** description	  :: Reversed and coded by Snoopy																	**
*********************************************************************************************************************/
void CGame::GetAngelHandler(int iClientH, char * pData, DWORD dwMsgSize)
{char  *cp, cData[256], cTmpName[21];
 int   iAngel;
 class CItem * pItem;
 int   iRet, iEraseReq;
 char  cItemName[21];
 short * sp;
 WORD  * wp;
 int   * ip;
 DWORD * dwp;
	if (m_pClientList[iClientH] == NULL)					 return;
	if (m_pClientList[iClientH]->m_bIsInitComplete == FALSE) return;
	if (_iGetItemSpaceLeft(iClientH) == 0) 
	{	SendItemNotifyMsg(iClientH,	DEF_NOTIFY_CANNOTCARRYMOREITEM, NULL, NULL);
		return;
	}
	cp = (char *)(pData + DEF_INDEX2_MSGTYPE + 2);
	ZeroMemory(cTmpName, sizeof(cTmpName));
	strcpy(cTmpName, cp);
	cp += 20;
	ip = (int *)cp;
	iAngel = (int) *ip; // 0x00 l a i
	cp += 2;
	wsprintf(G_cTxt, "PC(%s) obtained an Angel (%d).   %s(%d %d)"
			, m_pClientList[iClientH]->m_cCharName
			, iAngel
			, m_pClientList[iClientH]->m_cMapName
			, m_pClientList[iClientH]->m_sX
			, m_pClientList[iClientH]->m_sY);	
	PutLogList(G_cTxt);	
	switch (iAngel) {
	case 1: // STR
		//iItemNbe = 1108;
		wsprintf(cItemName, "AngelicPandent(STR)");
		break;
	case 2: // DEX
		//iItemNbe = 1109;
		wsprintf(cItemName, "AngelicPandent(DEX)");
		break;
	case 3: // INT
		//iItemNbe = 1110;
		wsprintf(cItemName, "AngelicPandent(INT)");
		break;
	case 4: // MAG
		//iItemNbe = 1111;
		wsprintf(cItemName, "AngelicPandent(MAG)");
		break;
	default:
		PutLogList("Gail asked to create a wrong item!");	
		break;
	}
	// Them create the summonScroll
	pItem = NULL;
	pItem = new class CItem;
	if (pItem == NULL) return;
	if ((_bInitItemAttr(pItem, cItemName) == TRUE)) 
	{	pItem->m_sTouchEffectType = DEF_ITET_UNIQUE_OWNER;
		pItem->m_sTouchEffectValue1 = m_pClientList[iClientH]->m_sCharIDnum1;
		pItem->m_sTouchEffectValue2 = m_pClientList[iClientH]->m_sCharIDnum2;
		pItem->m_sTouchEffectValue3 = m_pClientList[iClientH]->m_sCharIDnum3;
		if (_bAddClientItemList(iClientH, pItem, &iEraseReq) == TRUE) 
		{	ZeroMemory(cData, sizeof(cData));
			dwp  = (DWORD *)(cData + DEF_INDEX4_MSGID);
			*dwp = MSGID_NOTIFY;
			wp   = (WORD *)(cData + DEF_INDEX2_MSGTYPE);
			*wp  = DEF_NOTIFY_ITEMOBTAINED;				
			cp = (char *)(cData + DEF_INDEX2_MSGTYPE + 2);				
			*cp = 1;
			cp++;				
			memcpy(cp, pItem->m_cName, 20);
			cp += 20;				
			dwp  = (DWORD *)cp;
			*dwp = pItem->m_dwCount;
			cp += 4;				
			*cp = pItem->m_cItemType;
			cp++;				
			*cp = pItem->m_cEquipPos;
			cp++;				
			*cp = (char)0; 
			cp++;				
			sp  = (short *)cp;
			*sp = pItem->m_sLevelLimit;
			cp += 2;				
			*cp = pItem->m_cGenderLimit;
			cp++;				
			wp = (WORD *)cp;
			*wp = pItem->m_wCurLifeSpan;
			cp += 2;				
			wp = (WORD *)cp;
			*wp = pItem->m_wWeight;
			cp += 2;				
			sp  = (short *)cp;
			*sp = pItem->m_sSprite;
			cp += 2;				
			sp  = (short *)cp;
			*sp = pItem->m_sSpriteFrame;
			cp += 2;
			*cp = pItem->m_cItemColor;
			cp++;
			*cp = (char)pItem->m_sItemSpecEffectValue2; // v1.41 
			cp++;				
			dwp = (DWORD *)cp;
			*dwp = pItem->m_dwAttribute;
			cp += 4;
			if (iEraseReq == 1) delete pItem;				
			iRet = m_pClientList[iClientH]->m_pXSock->iSendMsg(cData, 53);
			switch (iRet) {
			case DEF_XSOCKEVENT_QUENEFULL:
			case DEF_XSOCKEVENT_SOCKETERROR:
			case DEF_XSOCKEVENT_CRITICALERROR:
			case DEF_XSOCKEVENT_SOCKETCLOSED:
				DeleteClient(iClientH, TRUE, TRUE);
				break;
			}
		}else 
		{	m_pMapList[ m_pClientList[iClientH]->m_cMapIndex ]->bSetItem(m_pClientList[iClientH]->m_sX, 
				                                                         m_pClientList[iClientH]->m_sY, pItem);			
			SendEventToNearClient_TypeB(MSGID_EVENT_COMMON, DEF_COMMONTYPE_ITEMDROP, m_pClientList[iClientH]->m_cMapIndex,
				                        m_pClientList[iClientH]->m_sX, m_pClientList[iClientH]->m_sY,  
				                        pItem->m_sSprite, pItem->m_sSpriteFrame, pItem->m_cItemColor); // v1.4			
			dwp  = (DWORD *)(cData + DEF_INDEX4_MSGID);
			*dwp = MSGID_NOTIFY;
			wp   = (WORD *)(cData + DEF_INDEX2_MSGTYPE);
			*wp  = DEF_NOTIFY_CANNOTCARRYMOREITEM;				
			iRet = m_pClientList[iClientH]->m_pXSock->iSendMsg(cData, 6);
			switch (iRet) {
			case DEF_XSOCKEVENT_QUENEFULL:
			case DEF_XSOCKEVENT_SOCKETERROR:
			case DEF_XSOCKEVENT_CRITICALERROR:
			case DEF_XSOCKEVENT_SOCKETCLOSED:
				DeleteClient(iClientH, TRUE, TRUE);
				break;
		}	}
	}else 
	{	delete pItem;
		pItem = NULL;
	}
}
//#include "Game2.cpp"

//************************************* THE END *******************************************************

/*********************************************************************************************************************
/*********************************************************************************************************************
/******																											******
/******											Avatar event													******
/******																											******
/******																											******
/******																											******
/*********************************************************************************************************************
/*********************************************************************************************************************
/********************************************************************************************************************/

//#define GSM_BEGINAVATAR							0x20   // To Gate for other servers
//#define GSM_ENDAVATAR								0x21   // To Gate for other servers
//#define GSM_INFOAVATAR							0x22   // To Gate for other servers
//#define DEF_NOTIFY_AVATAR							0x0BFE // Sends client the Avatar info

/*********************************************************************************************************************
**  BOOL CGame::bReadAvatarStructureConfigFile(char * cFn)															**	
** description	  :: Loads the avatar.cfg  when server starts														**
** called		  :: OnStartGameSignal()																			**
*********************************************************************************************************************/
BOOL CGame::bReadAvatarStructureConfigFile(char * cFn)
{FILE * pFile;
 HANDLE hFile;
 DWORD  dwFileSize;
 char * cp, * token, cReadModeA, cReadModeB;
 char seps[] = "= \t\n";
 int   i, iIndex;
 class CStrTok * pStrTok;
	cReadModeA = 0;
	cReadModeB = 0;
	hFile = CreateFile(cFn, GENERIC_READ, NULL, NULL, OPEN_EXISTING, NULL, NULL);
	dwFileSize = GetFileSize(hFile, NULL);
	if (hFile != INVALID_HANDLE_VALUE) CloseHandle(hFile);
	pFile = fopen(cFn, "rt");
	if (pFile == NULL) 
	{	PutLogList("(!) Cannot open Avatar configuration file.");
		return FALSE;
	}else 
	{	PutLogList("(!) Reading Avatar configuration file...");
		cp = new char[dwFileSize+2];
		ZeroMemory(cp, dwFileSize+2);
		fread(cp, dwFileSize, 1, pFile);

		iIndex = 0;
		pStrTok = new class CStrTok(cp, seps);
		token = pStrTok->pGet();
		while( token != NULL ) {
			if (cReadModeA != 0) {
				switch (cReadModeA) {
				case 1: // crusade-structure
					switch (cReadModeB) {
					case 1:	// m_stAvatarStructures index
						if (_bGetIsStringIsNumber(token) == FALSE) 
						{	PutLogList("(!!!) CRITICAL ERROR!  Avatar configuration file error - Wrong Data format.");
							delete cp; delete pStrTok; return FALSE;
						}
						iIndex = atoi(token);
						if ((iIndex >= DEF_MAX_STATUE_LOCATIONS)||(m_stAvatarStructures[iIndex].cType != NULL)) 
						{	PutLogList("(!!!) CRITICAL ERROR!  Avatar configuration file error - Duplicate or big index.");
							delete cp; delete pStrTok; return FALSE;
						}						
						cReadModeB = 2;
						break;
					case 2: // Map name & index
						ZeroMemory(m_stAvatarStructures[iIndex].cMapName, sizeof(m_stAvatarStructures[iIndex].cMapName));
						memcpy(m_stAvatarStructures[iIndex].cMapName, token, strlen(token));
						for (i = 0; i < DEF_MAXMAPS; i++)// Retrieve MapIndex
						{	if (m_pMapList[i] != NULL) 
							{	if (memcmp(m_pMapList[i]->m_cName, token, strlen(token)) == 0) 
								{	m_stAvatarStructures[iIndex].cMapIndex = i;
						}	}	}
						cReadModeB = 3;
						break;						
					case 3: // Type
						if (_bGetIsStringIsNumber(token) == FALSE) 
						{	PutLogList("(!!!) CRITICAL ERROR!  Avatar configuration file error - Wrong mob type.");
							delete cp; delete pStrTok; return FALSE;
						}
						m_stAvatarStructures[iIndex].cType = atoi(token);	
						cReadModeB = 4;
						break;
					case 4:	// X
						if (_bGetIsStringIsNumber(token) == FALSE) 
						{	PutLogList("(!!!) CRITICAL ERROR! Avatar  configuration file error - Wrong mob x.");
							delete cp; delete pStrTok; return FALSE;
						}
						m_stAvatarStructures[iIndex].dX = atoi(token);
						cReadModeB = 5;
						break;	
					case 5:	// Y
						if (_bGetIsStringIsNumber(token) == FALSE) 
						{	PutLogList("(!!!) CRITICAL ERROR!  Avatar configuration file error - Wrong mob y.");
							delete cp; delete pStrTok; return FALSE;
						}
						m_stAvatarStructures[iIndex].dY = atoi(token);
						cReadModeB = 6;
						break;
					case 6:	// cMobSide
						if (_bGetIsStringIsNumber(token) == FALSE) 
						{	PutLogList("(!!!) CRITICAL ERROR!  Avatar configuration file error - Wrong mob side.");
							delete cp; delete pStrTok; return FALSE;
						}
						m_stAvatarStructures[iIndex].cMobSide = atoi(token);
						cReadModeA = 0;
						cReadModeB = 0;
						break;
					}
					break;

				case 2: // avatar-statue
					switch (cReadModeB) {
					case 1:	// m_stAvatarStatues index
						if (_bGetIsStringIsNumber(token) == FALSE) 
						{	PutLogList("(!!!) CRITICAL ERROR!  Avatar configuration file error - Wrong Data format.");
							delete cp; delete pStrTok; return FALSE;
						}
						iIndex = atoi(token);
						if ((iIndex>=DEF_MAX_STATUE_LOCATIONS)||(m_stAvatarStatues[iIndex].cType != NULL) )
						{	PutLogList("(!!!) CRITICAL ERROR!  Avatar configuration file error - Duplicate or big index.");
							delete cp; delete pStrTok; return FALSE;
						}
						m_stAvatarStatues[iIndex].cStatueRank	= -1; // -1: Statue not yet at PL...
						m_stAvatarStatues[iIndex].cType			= NULL;
						cReadModeB = 2;
						break;
					case 2: // Map name & index					
						ZeroMemory(m_stAvatarStatues[iIndex].cMapName, sizeof(m_stAvatarStatues[iIndex].cMapName));
						memcpy(m_stAvatarStatues[iIndex].cMapName, token, strlen(token));
						for (i = 0; i < DEF_MAXMAPS; i++)// Retrieve MapIndex
						{	if (m_pMapList[i] != NULL) 
							{	if (memcmp(m_pMapList[i]->m_cName, token, strlen(token)) == 0) 
								{	m_stAvatarStatues[iIndex].cMapIndex = i;
						}	}	}
						cReadModeB = 3;
						break;		
					case 3:	// X
						if (_bGetIsStringIsNumber(token) == FALSE) 
						{	PutLogList("(!!!) CRITICAL ERROR! Avatar  configuration file error - Wrong statue x.");
							delete cp; delete pStrTok; return FALSE;
						}
						m_stAvatarStatues[iIndex].dX = atoi(token);
						cReadModeB = 4;
						break;	
					case 4:	// Y
						if (_bGetIsStringIsNumber(token) == FALSE) 
						{	PutLogList("(!!!) CRITICAL ERROR!  Avatar configuration file error - Wrong statue y.");
							delete cp; delete pStrTok; return FALSE;
						}
						m_stAvatarStatues[iIndex].dY = atoi(token);
						cReadModeA = 0;
						cReadModeB = 0;
						break;
					}
					break;

				default: 
					break;
				}
			}else 
			{	if (memcmp(token, "crusade-structure", 17) == 0) 
				{	cReadModeA = 1;
					cReadModeB = 1;
				}
				if (memcmp(token, "avatar-statue", 13) == 0) 
				{	cReadModeA = 2;
					cReadModeB = 1;						
			}	}
			token = pStrTok->pGet();
		}	
		delete pStrTok;		delete cp;
		if ((cReadModeA != 0) || (cReadModeB != 0)) 
		{	PutLogList("(!!!) CRITICAL ERROR! Avatar Structure configuration file contents error!");
			if (pFile != NULL) fclose(pFile);
			return FALSE;
		}
	}	
	if (pFile != NULL) fclose(pFile);
	return TRUE;
}

/*********************************************************************************************************************
** void CGame::_CreateAvatarGUID(DWORD dwAvatarGUID, int iWinnerSide) 												**	
** description	  :: Create the GUID file at the event beginning and Event end										**
** called		  :: by LocalBeginAvatar() & LocalEndAvatarMode()													**
*********************************************************************************************************************/
void CGame::_CreateAvatarGUID(DWORD dwAvatarGUID, int iWinnerSide)
{char * cp, cTxt[256], cFn[256], cTemp[1024];	
 FILE * pFile;		
	_mkdir("GameData");
	ZeroMemory(cFn, sizeof(cFn));	
	strcat(cFn,"GameData");
	strcat(cFn,"\\");
	strcat(cFn,"\\");					  
	strcat(cFn,"AvatarGUID.Txt");		
	pFile = fopen(cFn, "wt");
	if (pFile == NULL) 
	{	wsprintf(cTxt, "(!) Cannot create AvatarGUID (%d) file. ", dwAvatarGUID);
		PutLogList(cTxt);
	}else 
	{	ZeroMemory(cTemp, sizeof(cTemp));		
		ZeroMemory(cTxt, sizeof(cTxt));
		wsprintf(cTxt, "AvatarGUID = %d\n", dwAvatarGUID);
		strcat(cTemp, cTxt);
		ZeroMemory(cTxt, sizeof(cTxt));
		wsprintf(cTxt, "winner-side = %d\n", iWinnerSide);
		strcat(cTemp, cTxt);	
		cp = (char *)cTemp;
		fwrite(cp, strlen(cp), 1, pFile);
		switch (iWinnerSide) {
		case 1:	wsprintf(G_cTxt, "(_) AvatarGUID (%d) file created - Aresden  victory.", dwAvatarGUID);
			break;
		case 2: wsprintf(G_cTxt, "(_) AvatarGUID (%d) file created - Elvine victory.", dwAvatarGUID);
			break;		
		default:wsprintf(G_cTxt, "(_) AvatarGUID (%d) file created - Draw.", dwAvatarGUID);
			break;
		}
		PutLogList(G_cTxt);
		PutLogEventFileList(G_cTxt);
	}
	if (pFile != NULL) fclose(pFile);
}

/*********************************************************************************************************************
** void CGame::bReadAvatarGUIDFile(char * cFn)																		**	
** description	  :: Reads the GUID file																			**
** called		  :: by OnStartGameSignal()																			**
*********************************************************************************************************************/
BOOL CGame::bReadAvatarGUIDFile(char * cFn)
{FILE * pFile;
 HANDLE hFile;
 DWORD  dwFileSize;
 char * cp, * token, cReadMode;
 char seps[] = "= \t\n";
 class CStrTok * pStrTok;
 char cTxt[256];
	ZeroMemory(cTxt, sizeof(cTxt));
	cReadMode = 0;
	hFile = CreateFile(cFn, GENERIC_READ, NULL, NULL, OPEN_EXISTING, NULL, NULL);
	dwFileSize = GetFileSize(hFile, NULL);
	if (hFile != INVALID_HANDLE_VALUE) CloseHandle(hFile);
	pFile = fopen(cFn, "rt");
	if (pFile == NULL) 
	{	PutLogList("(!) Cannot open AvatarGUID file.");
		return FALSE;
	}else 
	{	PutLogList("(_) Reading AvatarGUID file...");
		cp = new char[dwFileSize+2];
		ZeroMemory(cp, dwFileSize+2);
		fread(cp, dwFileSize, 1, pFile);
		pStrTok = new class CStrTok(cp, seps);
		token = pStrTok->pGet();
		while( token != NULL )   			
		{	if (cReadMode != 0) 
			{	switch (cReadMode) {
				case 1:
					m_dwAvatarGUID = _atoi64(token);
					cReadMode = 0;
					break;
				case 2:	
					m_iAvatarWinnerSide = atoi(token);					
					cReadMode = 0;
					break;
				}
			}else 
			{	if (memcmp(token, "AvatarGUID", 11) == 0)		cReadMode = 1;
				if (memcmp(token, "winner-side", 11) == 0)		cReadMode = 2;
			}			
			token = pStrTok->pGet();
		}
		delete pStrTok;
		delete cp;
	}
	if (pFile != NULL) fclose(pFile);
	switch (m_iLastCrusadeWinner) {
	case 1:	wsprintf(G_cTxt, "(_) Read AvatarGUID (%d) file: Last Avatar was Aresden.", m_dwAvatarGUID);
		break;
	case 2: wsprintf(G_cTxt, "(_) Read AvatarGUID (%d) file: Last Avatar was Elvine." , m_dwAvatarGUID);
		break;		
	default:wsprintf(G_cTxt, "(_) Read AvatarGUID (%d) file: Last Avatar quest was a draw .", m_dwAvatarGUID);
		break;
	}
	PutLogList(G_cTxt);
	if (sizeof(cTxt)>7) PutLogList(cTxt);
	return TRUE;
}

/*********************************************************************************************************************
** void CGame::GlobalStartAvatarMode() 																				**	
** description	  :: Starts the event and send info to all gservers													**
** called		  :: by GM command																					**
*********************************************************************************************************************/
void CGame::GlobalStartAvatarMode()
{char * cp, cData[120];
 DWORD * dwp, dwAvatarGUID;	
	if (m_bIsApocalypseMode == TRUE) return;
	if (m_bIsHeldenianMode == TRUE) return;
	if (m_bIsCrusadeMode == TRUE) return;
	if (m_bIsAvatarMode == TRUE) return;
	dwAvatarGUID = timeGetTime();
	ZeroMemory(cData, sizeof(cData));
	cp = (char *)cData;
	*cp = GSM_BEGINAVATAR;
	cp++;
	dwp = (DWORD *)cp;
	*dwp = dwAvatarGUID;
	cp += 4;
	bStockMsgToGateServer(cData, 5);
	LocalStartAvatarMode(dwAvatarGUID);
	_bCrusadeLog(DEF_CRUSADELOG_BEGINAVATAR, NULL, NULL, NULL);
}

/*********************************************************************************************************************
** void CGame::LocalStartAvatarMode(DWORD dwAvatarGUID) 															**	
** description	  :: Starts the Avatar event																		**
** called		  :: by Global Start, or by Gate															**
*********************************************************************************************************************/
void CGame::LocalStartAvatarMode(DWORD dwAvatarGUID)
{int i;
 int iTemp = 0;
	m_bIsAvatarMode	 = TRUE;	
	m_iAvatarWinnerSide = -1;
	m_dwAvatarStartTime = timeGetTime();
	m_iAvatarMessenger	= -1;	
	m_iStatueCount		= 0;	// Rank of next Statue
	m_iStatueIndex		= 0;	// Index of next Statue
	ZeroMemory(m_cAvatarMessenger, sizeof(m_cAvatarMessenger));	

	// erase previous AvatarGUID.
	if (dwAvatarGUID != NULL)
	{	_CreateAvatarGUID(dwAvatarGUID, NULL);
		m_dwAvatarGUID = dwAvatarGUID;
	}
	// Change the map definition if necessary 	
	if ((m_iPLmapIndex != -1) && (m_pMapList[m_iPLmapIndex] != NULL))
	{	if (__bReadMapCrusadeInfo(m_iPLmapIndex, TRUE))
		{	m_pMapList[m_iPLmapIndex]->m_bChangedForCrusade = TRUE;
	}	}

	CreateAvatarStructures();	

	for (i = 1; i < DEF_MAXCLIENTS; i++)
	if ((m_pClientList[i] != NULL) && (m_pClientList[i]->m_bIsInitComplete == TRUE))
	{	// Cancel AncientSlates effects.
		SetSlateFlag(i, DEF_NOTIFY_SLATECLEAR, FALSE);	
		m_pClientList[i]->m_iConstructionPoint  = -1; // Not the messenger
		m_pClientList[i]->m_iWarContribution	= 0;  // Store the event's XP
		m_pClientList[i]->m_dwAvatarGUID = m_dwAvatarGUID;
		// Recall from PL as the event begins
		if (m_pClientList[i]->m_iAdminUserLevel == 0)
		{	if ( m_pClientList[i]->m_cMapIndex == m_iPLmapIndex) 		
			{	m_pClientList[i]->m_bIsWarLocation = TRUE;
				m_pClientList[i]->m_iTimeLeft_ForceRecall = 0;
		}	} 	
		// Notify Avatar start
		SendNotifyMsg(NULL, i, DEF_NOTIFY_AVATAR, 1, 0, 0, NULL, 0);
	}
	wsprintf(G_cTxt,"(_)Avatar Mode ON.");
	PutLogList(G_cTxt);
	PutLogList(" ");
	PutLogEventFileList(G_cTxt);
	PutLogEventFileList(" ");
}

/*********************************************************************************************************************
** void CGame::SendGlobalAvatarInfo(int sV1, int sV2, int sV3, char * pString,  int sV4) 							**	
** description	  :: Starts the event and send info to all gservers													**
** called		  :: 																	**
*********************************************************************************************************************/
void CGame::SendGlobalAvatarInfo(int sV1, int sV2, int sV3, char * pString,  int sV4)
{char * cp, cData[256];
 int * ip;
	ZeroMemory(cData, sizeof(cData));	
	cp = (char *)cData;
	*cp = GSM_INFOAVATAR;
	cp++;
	ip = (int *)cp;
	*ip = sV1;
	cp += 4;
	ip = (int *)cp;
	*ip = sV2;
	cp += 4;
	ip = (int *)cp;
	*ip = sV3;
	cp += 4;
	memcpy(cp, m_cAvatarMessenger, 10);
	cp += 10;
	ip = (int *)cp;
	*ip = sV4;
	cp += 4;
	bStockMsgToGateServer(cData, 27);
}

/*********************************************************************************************************************
** void CGame::GetGlobalAvatarInfo(int sV1, int sV2,  int sV3, char * pString,  int sV4) 							**	
** description	  :: Starts the event and send info to all gservers													**
** called		  :: 																	**
*********************************************************************************************************************/
void CGame::GetGlobalAvatarInfo(int sV1, int sV2, int sV3, char * pString,  int sV4)
{register int i;
	// Notify all clients	
	for (i = 1; i < DEF_MAXCLIENTS; i++)
	if ((m_pClientList[i] != NULL) && (m_pClientList[i]->m_bIsInitComplete == TRUE)) 
	{	SendNotifyMsg(NULL, i, DEF_NOTIFY_AVATAR, (DWORD)sV1, (DWORD)sV2, (DWORD)sV3, pString, (DWORD)sV4);
	}
}

/*********************************************************************************************************************
** void CGame::RelicGet(int iClientH, class CItem * pItem) 															**	
** description	  :: Ajuste tout quand la relique est ramassée														**
** called		  ::																								**
*********************************************************************************************************************/
void CGame::RelicGet(int iClientH, class CItem * pItem)
{register int i;
	if (pItem->m_sItemEffectType != DEF_ITEMEFFECTTYPE_EVENT_ITEMDROP) return;
	if (strcmp(pItem->m_cName, "AvatarRelic") == 0) return;

	// If not avatar mode, delete the item
	if (m_bIsAvatarMode == FALSE) // Event finished, remove item
	{	for (i = 0; i < DEF_MAXITEMS; i++)
		{	if (   (m_pClientList[iClientH]->m_pItemList[i] != NULL) 
				&& (strcmp(m_pClientList[iClientH]->m_pItemList[i]->m_cName, "AvatarRelic") == 0)) 
			{	ItemDepleteHandler(iClientH, i, FALSE);
				return;
	}	}	}
	// Check if it's at PL
	if (m_iPLmapIndex == -1) return;
	if (m_iPLmapIndex != m_pClientList[iClientH]->m_cMapIndex) return;	

	// Check if it is the right relic
	DWORD dwGUID;
	memcpy(& dwGUID, &pItem->m_sItemSpecEffectValue1, 4);
	if (dwGUID != m_dwAvatarGUID) // Wrong item, remove
	{	for (i = 0; i < DEF_MAXITEMS; i++)
		{	if (   (m_pClientList[iClientH]->m_pItemList[i] != NULL) 
				&& (strcmp(m_pClientList[iClientH]->m_pItemList[i]->m_cName, "AvatarRelic") == 0)) 
			{	ItemDepleteHandler(iClientH, i, FALSE);
				return;
	}	}	}

	m_iAvatarMessenger = iClientH;	
	ZeroMemory(m_cAvatarMessenger, sizeof(m_cAvatarMessenger));	
	memcpy(m_cAvatarMessenger, m_pClientList[iClientH]->m_cCharName, 10);
	m_pClientList[m_iAvatarMessenger]->m_iWarContribution += 1000;	// + 1000xp
	m_pClientList[m_iAvatarMessenger]->m_iConstructionPoint = 1;	// 
	m_pClientList[m_iAvatarMessenger]->m_iTimeLeft_FirmStaminar = 0; // No more PG / SPG effect

	// Log
	wsprintf(G_cTxt, "Avatar relic seized by %s", m_cAvatarMessenger);
	PutLogList(G_cTxt);
	PutLogEventFileList(G_cTxt);

	pItem->m_sItemEffectValue1	= 1;	// Rank of next Statue
	m_iStatueCount				= 1;	// Rank of next Statue
	for (i = 0; i < DEF_MAX_STATUE_LOCATIONS; i++) 
	{	if (m_stAvatarStatues[i].cStatueRank == m_iStatueCount)
		{	m_iStatueIndex		= i;	// Index of next Statue
			break;
	}	}
	switch (m_iStatueCount) {
	case 1:SetAngelFlag(m_iAvatarMessenger, DEF_OWNERTYPE_PLAYER, 3, 1);	break;// Dragon: blue Angel
	case 2:SetAngelFlag(m_iAvatarMessenger, DEF_OWNERTYPE_PLAYER, 2, 5);	break;// Demon: red Angel
	case 3:SetAngelFlag(m_iAvatarMessenger, DEF_OWNERTYPE_PLAYER, 4, 6);	break;// Faery, green Angel
	case 4:SetAngelFlag(m_iAvatarMessenger, DEF_OWNERTYPE_PLAYER, 1, 8);	break;// Allien Yellowangel
	case 5:SetAngelFlag(m_iAvatarMessenger, DEF_OWNERTYPE_PLAYER, 1, 9);	break;// priest; yellow angel
	case 6:SetAngelFlag(m_iAvatarMessenger, DEF_OWNERTYPE_PLAYER, 2, 10);	break;// Aresien red angel
	case 7:SetAngelFlag(m_iAvatarMessenger, DEF_OWNERTYPE_PLAYER, 3, 15);	break;// Eldiniel blue angel
	}

	// Notify all clients	
	for (i = 1; i < DEF_MAXCLIENTS; i++)
	if ((m_pClientList[i] != NULL) && (m_pClientList[i]->m_bIsInitComplete == TRUE)) 
	{	SendNotifyMsg(NULL, i, DEF_NOTIFY_AVATAR, (DWORD)2, m_iStatueCount, m_pClientList[m_iAvatarMessenger]->m_cSide, m_cAvatarMessenger, 0);
	}
	SendGlobalAvatarInfo(2, m_iStatueCount, m_pClientList[m_iAvatarMessenger]->m_cSide, m_cAvatarMessenger, 0);
}

/*********************************************************************************************************************
** void CGame::RelicDrop(int iClientH, class CItem * pItem) 														**	
** description	  :: Adjust Avatar when relic is dropped															**
** called		  :: by DropItemHandler, GiveItemHandler												**
*********************************************************************************************************************/
void CGame::RelicDrop(int iClientH, class CItem * pItem)
{	if (m_bIsAvatarMode == FALSE) return;
	if (m_iPLmapIndex == -1) return;
	if (m_iPLmapIndex != m_pClientList[iClientH]->m_cMapIndex) return;
register int i;
	//Log
	wsprintf(G_cTxt, "Avatar relic droped by %s", m_cAvatarMessenger);
	PutLogList(G_cTxt);
	PutLogEventFileList(G_cTxt);
	// Reset Statue counts
	m_iStatueCount		= 1;			// Rank of next Statue
	for (i = 0; i < DEF_MAX_STATUE_LOCATIONS; i++) 
	{	if (m_stAvatarStatues[i].cStatueRank == m_iStatueCount)
		{	m_iStatueIndex		= i;	// Index of next Statue
			break;
	}	}
	// Notify all clients	
	for (i = 1; i < DEF_MAXCLIENTS; i++)
	if ((m_pClientList[i] != NULL) && (m_pClientList[i]->m_bIsInitComplete == TRUE)) 
	{	SendNotifyMsg(NULL, i, DEF_NOTIFY_AVATAR, (DWORD)3, m_iStatueCount, 0, m_cAvatarMessenger, 0);
	}
	SendGlobalAvatarInfo(3, m_iStatueCount, 0, m_cAvatarMessenger, 0);
	// Reset m_cAvatarMessenger
	ZeroMemory(m_cAvatarMessenger, sizeof(m_cAvatarMessenger));
	m_iAvatarMessenger = -1;
	SetAngelFlag(iClientH, DEF_OWNERTYPE_PLAYER, 0, -1);
	CalcTotalItemEffect(iClientH, -1, FALSE);
}
/*********************************************************************************************************************
** void CGame::CheckIfRelicDrop(int iClientH)																		**	
** description	  :: If situation may drop the relic, Ask to drop it !												**
** called		  :: DeleteClient & RequestTeleportHandler															**
*********************************************************************************************************************/
void CGame::CheckIfRelicDrop(int iClientH)
{	if (m_bIsAvatarMode == FALSE) return;
	if (m_iPLmapIndex == -1) return;
	if (m_iAvatarMessenger != iClientH) return;
short sItemIndex;
	for (sItemIndex = 0; sItemIndex < DEF_MAXITEMS; sItemIndex++) 
	{	if (m_pClientList[iClientH]->m_pItemList[sItemIndex] != NULL) 
		{	DWORD dwGUID;
			memcpy(& dwGUID, &m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemSpecEffectValue1, 4);
			if (   (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectType == DEF_ITEMEFFECTTYPE_EVENT_ITEMDROP)
				&& (dwGUID == m_dwAvatarGUID) )
			{	// Cett fonction va dropper la relique et avertir tout le monde...
				DropItemHandler(iClientH, sItemIndex, -1, m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cName, TRUE);
				break;
	}	}	}
}
/*********************************************************************************************************************
** void CGame::CheckRelicGoal() 																					**	
** description	  :: Checks if relic reached the right statue, then inform of next statue.							**
** called		  :: OnTimer																						**
*********************************************************************************************************************/
void CGame::CheckRelicGoal()
{	if (m_bIsAvatarMode == FALSE) return;
	if (m_iPLmapIndex == -1) return;
	if (m_pMapList[m_iPLmapIndex] == NULL) return;
	if (m_iAvatarMessenger == -1)  return;
	if (m_pClientList[m_iAvatarMessenger] == NULL) return;
	if (m_pClientList[m_iAvatarMessenger]->m_cMapIndex != m_iPLmapIndex) return;
	if (m_pClientList[m_iAvatarMessenger]->m_bIsInitComplete == FALSE) return;
register int i;
	if (   (abs(m_stAvatarStatues[m_iStatueIndex].dX - m_pClientList[m_iAvatarMessenger]->m_sX) <2)
		&& (abs(m_stAvatarStatues[m_iStatueIndex].dY - m_pClientList[m_iAvatarMessenger]->m_sY) <2))
	{	//reached this statue
		if (m_iStatueCount > 5)	// Victory....
		{	// remove relic
			for (i = 0; i < DEF_MAXITEMS; i++)
			if (   (m_pClientList[m_iAvatarMessenger]->m_pItemList[i] != NULL) 
				&& (memcmp(m_pClientList[m_iAvatarMessenger]->m_pItemList[i]->m_cName, "AvatarRelic", 20) == 0)) 
			{	ItemDepleteHandler(m_iAvatarMessenger, i, FALSE);
			}
			SetAngelFlag(m_iAvatarMessenger, DEF_OWNERTYPE_PLAYER, 0, -1);	
			GlobalEndAvatarMode(m_pClientList[m_iAvatarMessenger]->m_cSide);
		}else					// One more statue
		{	if (m_iStatueCount < 5)
			{	m_iStatueCount ++;
			}else 
			{	switch (m_pClientList[m_iAvatarMessenger]->m_cSide ) {
				case 1: // Aresden
					m_iStatueCount = 6;
					break;
				case 2: // Elvine
					m_iStatueCount = 7;
					break;
			}	}
			for (i = 0; i < DEF_MAX_STATUE_LOCATIONS; i++) 
			{	if (m_stAvatarStatues[i].cStatueRank == m_iStatueCount)
				{	m_iStatueIndex		= i;	// Index of next Statue
					break;
			}	}
			m_pClientList[m_iAvatarMessenger]->m_iConstructionPoint = m_iStatueIndex;
			m_pClientList[m_iAvatarMessenger]->m_iWarContribution += 2000; // + 1000xp

			// Notify all clients	
			for (i = 1; i < DEF_MAXCLIENTS; i++)
			if ((m_pClientList[i] != NULL) && (m_pClientList[i]->m_bIsInitComplete == TRUE)) 
			{	SendNotifyMsg(NULL, i, DEF_NOTIFY_AVATAR, (DWORD)4, m_iStatueCount, m_pClientList[m_iAvatarMessenger]->m_cSide, m_cAvatarMessenger, 0);
			}
			
			switch (m_iStatueCount) {
			case 1:SetAngelFlag(m_iAvatarMessenger, DEF_OWNERTYPE_PLAYER, 3, 1);	break;// Dragon: blue Angel
			case 2:SetAngelFlag(m_iAvatarMessenger, DEF_OWNERTYPE_PLAYER, 2, 5);	break;// Demon: red Angel
			case 3:SetAngelFlag(m_iAvatarMessenger, DEF_OWNERTYPE_PLAYER, 4, 6);	break;// Faery, green Angel
			case 4:SetAngelFlag(m_iAvatarMessenger, DEF_OWNERTYPE_PLAYER, 1, 8);	break;// Allien Yellowangel
			case 5:SetAngelFlag(m_iAvatarMessenger, DEF_OWNERTYPE_PLAYER, 1, 9);	break;// priest; yellow angel
			case 6:SetAngelFlag(m_iAvatarMessenger, DEF_OWNERTYPE_PLAYER, 2, 10);	break;// Aresien red angel
			case 7:SetAngelFlag(m_iAvatarMessenger, DEF_OWNERTYPE_PLAYER, 3, 15);	break;// Eldiniel blue angel
			}
			SendGlobalAvatarInfo(4, m_iStatueCount, m_pClientList[m_iAvatarMessenger]->m_cSide, m_cAvatarMessenger, 0);
			wsprintf(G_cTxt, "Relic blessed by statue %d, PC(%s)."
				, m_iStatueCount -1
				, m_pClientList[m_iAvatarMessenger]->m_cCharName);	
			PutLogList(G_cTxt);
			PutLogEventFileList(G_cTxt);
	}	}	
}

/*********************************************************************************************************************
** void CGame::ManualEndAvatarMode(int iWinnerSide) 																**	
** description	  :: LUsed when Avatar finished by a GM order														**
** called		  :: 																								**
*********************************************************************************************************************/
void CGame::ManualEndAvatarMode(int iWinnerSide)
{char * cp, cData[256];
 int * ip;
	if (m_bIsAvatarMode == FALSE) return;
	ZeroMemory(cData, sizeof(cData));	
	cp = (char *)cData;
	*cp = GSM_ENDAVATAR;
	cp++;
	ip = (int *)cp;
	*ip = iWinnerSide;
	cp += 4;
	memcpy(cp, m_cAvatarMessenger, 10);
	cp += 10;
	bStockMsgToGateServer(cData, 18);
	if (iWinnerSide == 2) 
	{	_bCrusadeLog(DEF_CRUSADELOG_ENDAVATAR, FALSE, FALSE, "Elvine Wictory! (Manual end)");
	}else if (iWinnerSide == 1) 
	{	_bCrusadeLog(DEF_CRUSADELOG_ENDAVATAR, FALSE, FALSE, "Aresden Wictory! (Manual end)");
	}else
	{	_bCrusadeLog(DEF_CRUSADELOG_ENDAVATAR, FALSE, FALSE, "Draw! (Manual) end)");
	}
	LocalEndAvatarMode(iWinnerSide, m_cAvatarMessenger);
}

/*********************************************************************************************************************
** void CGame::GlobalEndAvatarMode(int iWinnerSide) 																**	
** description	  :: The Relic reached the last statue ==> VICTORY													**
** called		  :: CheckRelicGoal																					**
*********************************************************************************************************************/
void CGame::GlobalEndAvatarMode(int iWinnerSide)
{char * cp, cData[256];
 int * ip;
	if (m_bIsAvatarMode == FALSE) return;
	ZeroMemory(cData, sizeof(cData));	
	cp = (char *)cData;
	*cp = GSM_ENDAVATAR;
	cp++;
	ip = (int *)cp;
	*ip = iWinnerSide;
	cp += 4;
	memcpy(cp, m_cAvatarMessenger, 10);
	cp += 10;
	bStockMsgToGateServer(cData, 18);
	if (iWinnerSide == 2) 
	{	_bCrusadeLog(DEF_CRUSADELOG_ENDAVATAR, FALSE, FALSE, "Elvine Wictory!");
	}else if (iWinnerSide == 1) 
	{	_bCrusadeLog(DEF_CRUSADELOG_ENDAVATAR, FALSE, FALSE, "Aresden Wictory!");
	}else
	{	_bCrusadeLog(DEF_CRUSADELOG_ENDAVATAR, FALSE, FALSE, "Draw!)");
	}
	LocalEndAvatarMode(iWinnerSide, m_cAvatarMessenger);
}
/*********************************************************************************************************************
** void CGame::LocalEndAvatarMode(int iWinnerSide, char * cAvatarMessenger) 										**	
** description	  :: Finishes the Avatar event																		**
** called		  :: Called by Gate msg, ManualEndAvatarMode, or GlobalEndAvatarMode								**
*********************************************************************************************************************/
void CGame::LocalEndAvatarMode(int iWinnerSide, char * cAvatarMessenger) // 1= Aresden, 2 = Elvine
{ register int i;
	wsprintf(G_cTxt, "(!)Received LocalEndAvatar, messenger: %s (%d)", cAvatarMessenger,iWinnerSide);
	PutLogList(G_cTxt);
	if (m_bIsAvatarMode == FALSE) return;
	_CreateAvatarGUID(m_dwAvatarGUID, iWinnerSide); // logs the winner side

	m_bIsAvatarMode	= FALSE;
	m_iAvatarWinnerSide = iWinnerSide;
	ZeroMemory(m_cAvatarMessenger, sizeof(m_cAvatarMessenger));
	m_iAvatarMessenger = -1;

	for (i = 1; i < DEF_MAXCLIENTS; i++)
	if ((m_pClientList[i] != NULL) && (m_pClientList[i]->m_bIsInitComplete == TRUE)) 
	{	SendNotifyMsg(NULL, i, DEF_NOTIFY_AVATAR, (DWORD)5, 0, m_iAvatarWinnerSide
			, cAvatarMessenger, m_pClientList[i]->m_iWarContribution);
		m_pClientList[i]->m_iExpStock += m_pClientList[i]->m_iWarContribution;	
		wsprintf(G_cTxt, "Avatar Exp :       PC(%s) Got %d xp."
				, m_pClientList[i]->m_cCharName
				, m_pClientList[i]->m_iWarContribution );	
		PutLogList(G_cTxt);
		PutLogEventFileList(G_cTxt);
		m_pClientList[i]->m_iWarContribution = 0;
		m_pClientList[i]->m_iConstructionPoint = 0;
	}
	RemoveAvatarStructures();
	// Restore the map definition if necessary 	
	if (m_bMapModeEquilibriumChanged == TRUE) 
	{	m_bMapModeEquilibrium = TRUE;
		m_bMapModeEquilibriumChanged = FALSE;	
		if (   (m_iPLmapIndex != -1) && (m_pMapList[m_iPLmapIndex] != NULL)
			&& (m_pMapList[m_iPLmapIndex]->m_bChangedForCrusade == TRUE))
		{	__bReadMapCrusadeInfo(m_iPLmapIndex, FALSE);
	}	}
	// LOgs
	wsprintf(G_cTxt,"(_) Avatar Mode OFF.");
	PutLogList(G_cTxt);
	PutLogList(" ");
	PutLogEventFileList(G_cTxt);
	PutLogEventFileList(" ");
}

/*********************************************************************************************************************
** void CGame::CGame::CreateAvatarStructures()																		**	
** description	  :: Spwns the relic, compute and place Statues, place structures									**
** called		  :: Called by LocalStartAvatarMode																	**
*********************************************************************************************************************/
void CGame::CreateAvatarStructures()
{int i, z, tX, tY, iNamingValue;
 char cName[6], cNpcName[21], cNpcWayPoint[11];
 short sOwnerH; 	
 char cOwnerType;
 char  cItemName[21];
 class CItem * pItem;
	if (m_iPLmapIndex == -1) return;

	ZeroMemory(cName, sizeof(cName));
	ZeroMemory(cNpcName, sizeof(cNpcName));
	ZeroMemory(cNpcWayPoint, sizeof(cNpcWayPoint));

	//1 - Spawn the relic...
	tX = -1;
	tY = -1;		
	if ((m_iPLmapIndex != -1) && (m_pMapList[m_iPLmapIndex] != NULL))
	{	while (m_pMapList[m_iPLmapIndex]->bGetIsMoveAllowedTile(tX, tY) == FALSE)
		{	tX = rand()%(m_pMapList[m_iPLmapIndex]->m_sSizeX); // RAND_MAX
			tY = rand()%(m_pMapList[m_iPLmapIndex]->m_sSizeY);		
		}
		wsprintf(cItemName, "AvatarRelic"); //DEF_ITEMEFFECTTYPE_EVENT_ITEMDROP
		pItem = NULL;
		pItem = new class CItem;
		if (_bInitItemAttr(pItem, cItemName) == FALSE)
		{	delete pItem;
			m_pMapList[m_iPLmapIndex]->bSetItem(tX, tY, pItem);
			wsprintf(G_cTxt, "Avatar relic spawn failure");
			PutLogList(G_cTxt);
			PutItemLogFileList(G_cTxt);	
		}else
		{	pItem->m_sTouchEffectType   = DEF_ITET_ID;
			memcpy(&pItem->m_sItemSpecEffectValue1, &m_dwAvatarGUID, 4);	
			SYSTEMTIME SysTime;
			GetLocalTime(&SysTime);
			char cTemp[256];
			ZeroMemory(cTemp, sizeof(cTemp));
			wsprintf(cTemp, "%d%2d",  (short)SysTime.wMonth, (short)SysTime.wDay);
			pItem->m_sTouchEffectValue3 = atoi(cTemp);

			m_pMapList[m_iPLmapIndex]->bSetItem(tX, tY, pItem);
			wsprintf(G_cTxt, "Avatar relic spawned: %s  %s(%d %d)"
				, pItem->m_cName
				, m_pMapList[m_iPLmapIndex]->m_cName
				, tX
				, tY);
			PutLogList(G_cTxt);
			PutItemLogFileList(G_cTxt);
			// de pas montrer au gars qui sont déjà sur la carte
			/*SendEventToNearClient_TypeB(MSGID_EVENT_COMMON, DEF_COMMONTYPE_ITEMDROP, m_iPLmapIndex,
					tX, tY, pItem->m_sSprite, pItem->m_sSpriteFrame, pItem->m_cItemColor); */
	}	}
	
	// 2 - Search the 1st statue (far from relic)
	int iBestI = 0, iBestX = tX, iBestY = tY; 
	for (i = 0; i < DEF_MAX_STATUE_LOCATIONS; i++) 
	{	//wsprintf(G_cTxt, "Statue list[%d]->cStatueRank:%d x:%d, y:%d", i, m_stAvatarStatues[i].cStatueRank, m_stAvatarStatues[i].dX, m_stAvatarStatues[i].dY);
		//PutLogList(G_cTxt);				
		if ((m_stAvatarStatues[i].cStatueRank == -1) && (m_stAvatarStatues[i].dX != -1)) 
		{	if (  (abs(m_stAvatarStatues[i].dX - tX) + abs(m_stAvatarStatues[i].dY - tY)) 
				> (abs(iBestX - tX) + abs(iBestY - tY))) 
			{	iBestX = m_stAvatarStatues[i].dX;
				iBestY = m_stAvatarStatues[i].dY;
				iBestI = i;	
	}	}	}
	m_stAvatarStatues[iBestI].cType = 15; // Dragon
	m_stAvatarStatues[iBestI].cStatueRank = 1; // 1st statue

//wsprintf(G_cTxt, "Avatar 1st statue found: %d", iBestI);
//PutLogList(G_cTxt);

	// 3 - Search the next statues.
	i = iBestI;
	char cLastType = 15, cLastRank = 1;
	while (TRUE)
	{	i++;
		if (i >= DEF_MAX_STATUE_LOCATIONS) i = 1;
		if (m_stAvatarStatues[i].cStatueRank != -1) continue; // This statue is already used
		if (m_stAvatarStatues[i].dX == -1) continue; // This statue is not defined
		cLastType ++;
		cLastRank ++;
		m_stAvatarStatues[i].cType = cLastType; // Dragon
		m_stAvatarStatues[i].cStatueRank = cLastRank; // 1st statue
//wsprintf(G_cTxt, "Avatar next statue found: %d", i);
//PutLogList(G_cTxt);

		if (cLastRank >= 7) break;	
	}

	// 4 - Create Avatar structures...
	for (i = 0; i < DEF_MAX_STATUE_LOCATIONS; i++) 
	if (m_stAvatarStructures[i].cType != NULL) 
	{	for (z = 0; z < DEF_MAXMAPS; z++)
		{	if (   (m_pMapList[z] != NULL) // Mob
				&& (strcmp(m_pMapList[z]->m_cName, m_stAvatarStructures[i].cMapName) == 0)
				&& (m_stAvatarStructures[i].cMobSide >=0)) 
			{	iNamingValue = m_pMapList[z]->iGetEmptyNamingValue();
				if (iNamingValue == -1) 
				{	// No room for a new avatar structure
				}else // NPC
				{	wsprintf(cName, "XX%d", iNamingValue);
					cName[0] = '_';
					cName[1] = z+65;				
					switch (m_stAvatarStructures[i].cType) {
					case 36: // Arrow Guard Tower
						strcpy(cNpcName, "AGT-Elvine"); // side set later
						break;
					case 37: // Canon Guard Tower
						strcpy(cNpcName, "CGT-Elvine"); // side set later
						break;;
					case 39: // Detector
						strcpy(cNpcName, "DT-Elvine"); // side set later
						break;
					case 42: // Mana Stone
						strcpy(cNpcName, "ManaStone"); // side set later
						break;
					case 87: // CT-Aresden CrossBow Tower
						strcpy(cNpcName, "CT-Aresden"); // side set later
						break;
					case 89: // AGC-Aresden Ancient Great cannon
						strcpy(cNpcName, "AGC-Aresden");
						break;

					default: // Other npcs
						strcpy(cNpcName, m_pNpcConfigList[m_stAvatarStructures[i].cType]->m_cNpcName); 
						break;
					} // End of switch
					tX = (int)m_stAvatarStructures[i].dX;
					tY = (int)m_stAvatarStructures[i].dY;
					if (bCreateNewNpc(cNpcName, cName, m_pMapList[z]->m_cName, 0, 0, DEF_MOVETYPE_RANDOM, 
					             &tX, &tY, cNpcWayPoint, NULL, NULL, -1, FALSE) == FALSE) 
					{	m_pMapList[z]->SetNamingValueEmpty(iNamingValue);// Npc creation failed
					}else 
					{	m_pMapList[z]->SetStayAllowedFlag(tX, tY-1, FALSE); // Allow case behind structure
						m_pMapList[z]->GetOwner(&sOwnerH, &cOwnerType, tX, tY);
						if (   (m_pNpcList[sOwnerH] != NULL) && (cOwnerType == DEF_OWNERTYPE_NPC)
							&& (sOwnerH > 0) && (sOwnerH < DEF_MAXNPCS) ) 
						{	m_pNpcList[sOwnerH]->m_iBuildCount	= 0;							
							m_pNpcList[sOwnerH]->m_sAppr2		= 0;
							m_pNpcList[sOwnerH]->m_cSide		= m_stAvatarStructures[i].cMobSide;
							wsprintf(G_cTxt, "(!) Creating Avatar Structure(%s) at %s(%d, %d)", cNpcName, m_stAvatarStructures[i].cMapName, tX, tY);
							PutLogList(G_cTxt);
							PutLogEventFileList(G_cTxt);
	}	}	}	}	}	}	

	// 5 - Create the statues
	for (i = 0; i < DEF_MAX_STATUE_LOCATIONS; i++) 
	if ((m_stAvatarStatues[i].cStatueRank > 0) && (m_stAvatarStatues[i].cType > 14)) 
	{	if (m_pMapList[m_stAvatarStatues[i].cMapIndex] != NULL) 		
		{	iAddDynamicObjectList(NULL, NULL, m_stAvatarStatues[i].cType
				, m_stAvatarStatues[i].cMapIndex
				, (int)m_stAvatarStatues[i].dX
				, (int)m_stAvatarStatues[i].dY
				, NULL, 0);
	}	}

}

/*********************************************************************************************************************
**  void CGame::RemoveAvatarStructures ()																			**	
** description	  :: Delete all uneede Avatar event things															**
** called		  :: at the end of event, by LocalEndAvatarMode()													**
*********************************************************************************************************************/
void CGame::RemoveAvatarStructures ()
{register int i;
	DWORD dwTime = timeGetTime();
	for (i = 1; i < DEF_MAXDYNAMICOBJECTS; i++) 
	{ 	if (   (m_pDynamicObjectList[i] != NULL) && (m_pDynamicObjectList[i]->m_sType >14) )
		{	switch (m_pDynamicObjectList[i]->m_sType) {
			case DEF_DYNAMICOBJECT_STATUE1://		15 // Snoopy Avatar quest
			case DEF_DYNAMICOBJECT_STATUE2://		16 // Snoopy Avatar quest
			case DEF_DYNAMICOBJECT_STATUE3://		17 // Snoopy Avatar quest
			case DEF_DYNAMICOBJECT_STATUE4://		18 // Snoopy Avatar quest
			case DEF_DYNAMICOBJECT_STATUE5://		19 // Snoopy Avatar quest
			case DEF_DYNAMICOBJECT_STATUE6://		20 // Snoopy Avatar quest
			case DEF_DYNAMICOBJECT_STATUE7://		20 // Snoopy Avatar quest
				SendEventToNearClient_TypeB(MSGID_DYNAMICOBJECT, DEF_MSGTYPE_REJECT, m_pDynamicObjectList[i]->m_cMapIndex, m_pDynamicObjectList[i]->m_sX, m_pDynamicObjectList[i]->m_sY, m_pDynamicObjectList[i]->m_sType, i, NULL);
				m_pMapList[m_pDynamicObjectList[i]->m_cMapIndex]->SetDynamicObject(NULL, NULL, m_pDynamicObjectList[i]->m_sX, m_pDynamicObjectList[i]->m_sY, dwTime);
			break;
			delete m_pDynamicObjectList[i];
			m_pDynamicObjectList[i] = NULL;
	}	}	}
	// Then remove mobs
	for (i = 0 ; i < DEF_MAXNPCS; i++)
	if (m_pNpcList[i] != NULL) 
	{	switch (m_pNpcList[i]->m_sOriginalType) {
		case 36:
		case 37:
		case 39:
		case 42:
		case 87:
		case 89:
			DeleteNpc(i);
			break;
	}	}
}

/*********************************************************************************************************************
** void CGame::GlobalStartAvatarMode() 																				**	
** description	  :: Loads the avatar.cfg  																			**
** called		  :: on server start OnStartGameSignal()															**
*********************************************************************************************************************/

/*	for (i = 0; i < DEF_MAX_STATUE_LOCATIONS; i++) 
	{	ZeroMemory(m_stAvatarStatues[i].cMapName, sizeof(m_stAvatarStatues[i].cMapName));		
		m_stAvatarStatues[i].cMapIndex	= -1;	// MapIndex or -1 if not on server
		m_stAvatarStatues[i].cType		= NULL;	// DynamicObject type (15..21) or mob type
		m_stAvatarStatues[i].dX			= -1;	// 
		m_stAvatarStatues[i].dY			= -1;	// 
		m_stAvatarStatues[i].cStatueRank= -1;	// -1 if not defined, 0 if a mob		
		m_stAvatarStatues[i].cMobSide	= -1;	// -1 if absent (statue)
	}
	struct {
		char cMapName[11];		// Name in avatar.cfg
		char cMapIndex;			// MapIndex or -1 if not on server
		char cType;				// Structure type or DynamicObject type (15..21)
		int  dX, dY;			// Position
		char cStatueRank;		// -1 if not defined, 0 absent, else 1..6
		char cMobSide;			// -1 mean Avatar
	} m_stAvatarStatues[DEF_MAX_STATUE_LOCATIONS];		
	DWORD m_dwAvatarGUID;		// Unique event identifier
	DWORD m_dwAvatarStartTime;	// beginning time
	int   m_iAvatarWinnerSide;	// Side winning previous event or -1 during event
	BOOL  m_bIsAvatarMode;		// TRUE during event
	int   m_iPLmapIndex;		// 
	char  m_cAvatarMessenger[11]; // Name or character with the relic	
	int	  m_iAvatarMessenger;	// char id, if PL on this server.
*/


