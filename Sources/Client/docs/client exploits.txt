RequestCivilRight 0x0FC9420E 
¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯
> Packet editing, ça permet de bypasser le changement
> automatique de playmode au level 100

Ben non, c'est la demande pour devenir citoyen...
Le contenu du message envoyé n'est pas traité par le
serveur, en fait tu prens juste la nationalité si la
carte ou tu es actuellement. L'intérêt pourrait être
d'envoyer ce paquêt depuis ML, par exemple pour ce
retrouver faux Traveller niv20+.

En fait, j'ai du depuis des lutres corriger ce pb,
car j'ai un maire a Equilibrium....



	
RequestFullObjectData ( to see everyone )	
¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯
> là c'est si tu utilise un client perso, un genre
> de beholder hack en somme

Pas si sûr, mais ce genre de paquêts envoyés en boucle
crée du Mass lag. 
J'en ai fait l'expérience, avec l'ordre GM "/storm"...

En fait les persos invis sont complêtement envoyés
au client, et c'est ce dernier qui decide d'afficher en
translucide ou seulement les traces de course. C'est 
pourquoi le "Beholder hack" est si simple, et que virer
le BBNeck était stupide de la part de Siementec.

Il est bien plus dur de contrecarrer ça, car il y a de
vraies situations ou ce genre de pacquêts arrive en grand
nombre.

Par contre, t'ais-je dit que j'ai ajouté une protection
(certes sommaire) contre les attaques DOS?





GetMagicAbilityHandler ( 20% magic )
¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯
> Ca c'est quand tu va au wizard tower et qu'il te file
> +20%magic, il semblerait qu'en envoyant plusieurs fois
> la request en renvoyant des paquets on obtienne 100%

Je ne crois pas. Il ne file pas +20% mais te mêt a 20%!

Le contenu du message envoyé n'est pas traité par le
serveur, donc je vois mal un overflow ici.





GiveItemHandler ( give item to any1 on server )	
¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯
> Là je ne vois pas comment l'utiliser, en tout cas c'est
> en relation avec les give item des GM je pense

Je ne connais pas ce giveitem des GMs. Par contre, il est
vrai que la distance n'est vérifiée que côté client 
(+- 4 cases).

Je mêt un bloquage à 5 cases coté serveur. . .




MSGID_REQUEST_INITDATA ( Send before MSGID_REQUEST_INITPLAYER to crash server)
¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯
> Là tu ajoutes une variable BOOL genre bPlayer_init_sent dans la class
> CClient set sur FALSE par défaut, tu set la var à TRUE une fois le
> INITPLAYER effectué et tu ajoute juste une structure de controle sur
> bPlayer_init_sent avant de lancer l'action correspondante à INITDATA...

Oui, facile... Fait avec Warning serveur en rouge.




MSGID_REQUEST_NOSAVELOGOUT	
¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯
> Je ne vois pas trop ce que c'est, peut etre une sorte de logout hack
> (lance DeleteClient sans décompter les 10 secondes je pense...)

Je ne crois pas, c'est le client qui decompte les 10 secondes =(
Par contre imagine les dupes que ca permettrai de faire !
Suffit d'envoyer le paquêt vers le World, il va deco le perso
SANS le sauvegarder, et le gars a qui tu as filé l'item, va lui
se deco normalement = > dupe...

Par contre envoyer ce paquêt n'est pas si simple.
Il est sencé être envoyé par un gserver, donc la protection
anti-extasis pourrait être efficace...

Et bien, non, je viens de vérifier !
Si ds les sources LogServer, un check est fait sur ce paquêt pour
voir s'il vient bien d'un gserveur, je n'en ai pas trouvé trace
ds le wlog normal.

En conséqence il est très dur de trouver une parade face à cette
méthode de dupe qui reste fort délicate. (sauf si qqun crée un
outil pour ca...)
Faudrait changer le MSGID ds Wlog et gserver......




 	
Observer mode on InitPlayerData	
¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯
> Crash le serveur si on demande de passer en observer mode
> pendant la fonction... là je vois pas trop comment fixer ça
> a part d'une façon un peu similaire a celle expliquée plus haut.

Ici, c'est différent, RequestInitPlayerHandler(..) récupère du client
l'info "ObserverMode". Ce ne devrait se produire que si un GM en
observer mode change de serveur.
Je teste ca et le GM est visible sur le nouveau serveur (enfin je me voit)
mais pas de crash...

Par contre autant que je sache, la seule méthode pour demander a passer
en ObserverMode est la commande GM. Je ne connais pas de msg de requète
du client à ce sujêt...
Donc, je ne vois pas du tout ou est la possibilité de crash gserver...

Fix: ne pas traiter la valeur, ou mieux, vérifier si le nom du perso
est sur la liste des GMs.
(Je voudrais bien piger avant de coder un fix ici....)



	
Bwordmonitor shut up
¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯
#define MSGID_BWM_COMMAND_SHUTUP	0x19CC0F84
n'est pas utilisé par le client, pourtant, le gserver traite ce message...
D'ailleurs, elle semble buguée:
void CGame::_BWM_Command_Shutup(char *pData)
..
cp = (char *)(pData + 16); // étrange, logiquement ce serait +6, car ca ne 
                              traite que le nom du perso.

Il parait simple de simplement virer cette fonction, mais je ne voit pas
ce qui crasherai le gserveur, même si a cause du décalage, des données bidon
sont utilisées...



bwordmonitor register	
¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯
#define MSGID_BWM_INIT		0x19CC0F82	
Pareil, inutilisé par le client ou le Wlog.
Ca appelle la fonction:
void CGame::_BWM_Init(int iClientH, char *pData)

Encore une fois une fonction sans intérêt ni bug apparent.
Facile à virer...

Je me demande si il y a vraiment une faille ladedans, ou si c'est juste
une piste de recherche suite au post de KLKS


~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

 have found multiple ways to bufferoverflow the world/main/hg 
which means its possible to do a total takeover of the machine 

but sorry i'm not disclosing how to do it 

par....KLKS au sujêt de netgaylords.
Je ne connais pas et je pige pas vraiment ce qui cause tout cet émoi...


